<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>yWorks.yFilesNET.Algorithms</name>
  </assembly>
  <members>
    <member name="T:yWorks.Utils.Annotations.CanBeNullAttribute">
      <summary>
        <para>Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage</para>
      </summary>
      <remarks>
        <para>This attribute can be used by tools like Resharper to aid during coding and error analysis.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Utils.Annotations.NotNullAttribute">
      <summary>
        <para>Indicates that the value of marked element could never be <c>null</c></para>
      </summary>
      <remarks>
        <para>This attribute can be used by tools like Resharper to aid during coding and error analysis.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Utils.Annotations.ItemNotNullAttribute">
      <summary>
        <para>Indicates that a collection or an enumerable does not contain elements whose value is null.</para>
      </summary>
      <remarks>
        <para>This attribute can be used by tools like Resharper to aid during coding and error analysis.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Utils.Annotations.ItemCanBeNullAttribute">
      <summary>
        <para>Indicates that a collection or an enumerable can contain elements whose value is null.</para>
      </summary>
      <remarks>
        <para>This attribute can be used by tools like Resharper to aid during coding and error analysis.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.AbortHandler">
      <summary>
        <para>This class provides a means for early termination of graph algorithms.</para>
      </summary>
      <remarks>
        <para>Instances of this class may be attached to and retrieved from a graph and may receive requests for stopping and canceling an algorithm that is currently executed on the given graph.</para>
        <para>
          <h3>Client Code Usage</h3>
        </para>
        <para>An instance of this class can be attached to a graph using method <see cref="M:yWorks.Algorithms.AbortHandler.CreateForGraph(yWorks.Algorithms.Graph)" />. Using the handler's <see cref="M:yWorks.Algorithms.AbortHandler.Stop" /> and <see cref="M:yWorks.Algorithms.AbortHandler.Cancel" /> methods, it is possible to schedule requests for early termination. Algorithms can check for these requests and handle them appropriately.</para>
        <list type="bullet">
          <item>
            <term>
              <see cref="M:yWorks.Algorithms.AbortHandler.Stop" />
            </term>
            <description>The algorithm should terminate gracefully, delivering a consistent result. Although the termination will be early, it will usually not be immediate.</description>
          </item>
          <item>
            <term>
              <see cref="M:yWorks.Algorithms.AbortHandler.Cancel" />
            </term>
            <description>The algorithm should terminate immediately and all work done so far will be discarded.</description>
          </item>
        </list>
        <para>If a graph with an attached handler is processed by multiple algorithms (or multiple times by the same algorithm), the attached handler has to be <see cref="M:yWorks.Algorithms.AbortHandler.Reset" /> between algorithm runs. Otherwise, previous requests for early termination may lead to an undesired early termination of the next algorithm run.</para>
        <para>Methods <see cref="M:yWorks.Algorithms.AbortHandler.Stop" /> and <see cref="M:yWorks.Algorithms.AbortHandler.Cancel" /> are primarily meant for multi-threaded scenarios where the algorithm runs in a background thread and <see cref="M:yWorks.Algorithms.AbortHandler.Stop" />/<see cref="M:yWorks.Algorithms.AbortHandler.Cancel" /> are called from the main or UI thread. For pure single-threaded use cases, <see cref="P:yWorks.Algorithms.AbortHandler.StopDuration" /> and <see cref="P:yWorks.Algorithms.AbortHandler.CancelDuration" /> may be used for automatically stopping or cancelling the algorithm after a specified period of time has elapsed.</para>
        <para>
          <h3>Usage in Algorithms</h3>
        </para>
        <para>Algorithms have to retrieve an instance of this class from the graph that is processed using method <see cref="M:yWorks.Algorithms.AbortHandler.GetFromGraph(yWorks.Algorithms.Graph)" />. Then, the algorithm needs to query the retrieved instance of this class for stop or cancel requests using method <see cref="M:yWorks.Algorithms.AbortHandler.Check" />.</para>
        <para>Alternatively, convenience method <see cref="M:yWorks.Algorithms.AbortHandler.Check(yWorks.Algorithms.Graph)" /> for one-time checks is available. For performance critical code that checks repeatedly, it is recommended to follow the first approach, though.</para>
        <para>When handling a stop request, algorithms should ensure that the resulting graph is still in a consistent state.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Algorithms.AbortHandler.AbortHandlerDpKey">
      <summary>
        <para>A data provider key for attaching an AbortHandler instance to a graph.</para>
      </summary>
      <remarks>
        <para>Only instances of <see cref="T:yWorks.Algorithms.AbortHandler" /> should be assigned to this <see cref="T:yWorks.Algorithms.IDataProvider" />, otherwise a <see cref="T:System.InvalidCastException" /> will occur. Layout algorithms will use the attached handler to check for requests to cancel or stop the layout process.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Algorithms.AbortHandler" /> instance.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.AbortHandler.StopDuration" />
      <seealso cref="P:yWorks.Algorithms.AbortHandler.CancelDuration" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Reset" />
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.Stop">
      <summary>
        <para>Schedules a stop request.</para>
      </summary>
      <remarks>
        <para>Algorithms that detect stop requests should terminate gracefully and ensure that the processed graph remains in a consistent state.</para>
        <para>If a <see cref="M:yWorks.Algorithms.AbortHandler.Cancel" /> request has already been scheduled for this handler, the stop request is ignored. If a <see cref="M:yWorks.Algorithms.AbortHandler.Cancel" /> request is scheduled later on, the stop request is overridden.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Check" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Cancel" />
    </member>
    <member name="P:yWorks.Algorithms.AbortHandler.StopRequested">
      <summary>
        <para>Returns whether or not a stop request was scheduled explicitly with the <see cref="M:yWorks.Algorithms.AbortHandler.Stop" /> method.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.TimeToStop">
      <summary>
        <para>Determines the remaining time until an algorithm that <see cref="M:yWorks.Algorithms.AbortHandler.Check">checks</see> this handler is stopped automatically.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Algorithms.AbortHandler.StopDuration">stop duration</see> is less than or equal to zero, <c>-1</c> will be returned which means that the algorithm may run unrestricted.</para>
      </remarks>
      <returns>
        <para>the remaining time until the algorithm is stopped automatically or <c>-1</c> if the algorithm may run unrestricted</para>
      </returns>
      <seealso cref="P:yWorks.Algorithms.AbortHandler.StopDuration" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Reset" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Stop" />
    </member>
    <member name="P:yWorks.Algorithms.AbortHandler.StopDuration">
      <summary>
        <para>Gets or sets the duration an algorithm may run before being stopped automatically.</para>
      </summary>
      <remarks>
        <para>An algorithm is terminated gracefully, if the time in between <see cref="M:yWorks.Algorithms.AbortHandler.#ctor">creating</see> or <see cref="M:yWorks.Algorithms.AbortHandler.Reset">resetting</see> this handler and calling <see cref="M:yWorks.Algorithms.AbortHandler.Check" /> exceeds the stop duration.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the duration is negative</para>
      </exception>
      <value>
        <para>the duration</para>
      </value>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.TimeToStop" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Reset" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Stop" />
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.Cancel">
      <summary>
        <para>Schedules a cancel request.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Check" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Stop" />
    </member>
    <member name="P:yWorks.Algorithms.AbortHandler.CancelRequested">
      <summary>
        <para>Returns whether or not a cancel request was scheduled explicitly with the <see cref="M:yWorks.Algorithms.AbortHandler.Cancel" /> method.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.TimeToCancel">
      <summary>
        <para>Determines the remaining time (in milliseconds) until an algorithm that <see cref="M:yWorks.Algorithms.AbortHandler.Check">checks</see> this handler is cancelled automatically.</para>
      </summary>
      <returns>
        <para>the remaining time until the algorithm is cancelled automatically.</para>
      </returns>
      <seealso cref="P:yWorks.Algorithms.AbortHandler.CancelDuration" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Reset" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Cancel" />
    </member>
    <member name="P:yWorks.Algorithms.AbortHandler.CancelDuration">
      <summary>
        <para>Gets or sets the duration an algorithm may run before being cancelled automatically.</para>
      </summary>
      <remarks>
        <para>An algorithm is terminated immediately, if the time in between <see cref="M:yWorks.Algorithms.AbortHandler.#ctor">creating</see> or <see cref="M:yWorks.Algorithms.AbortHandler.Reset">resetting</see> this handler and calling <see cref="M:yWorks.Algorithms.AbortHandler.Check" /> exceeds the cancel duration.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the duration is negative</para>
      </exception>
      <value>
        <para>the duration (in milliseconds)</para>
      </value>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Reset" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Cancel" />
    </member>
    <member name="P:yWorks.Algorithms.AbortHandler.CheckFailed">
      <summary>
        <para>Gets whether or not methods <see cref="M:yWorks.Algorithms.AbortHandler.Check" /> or <see cref="M:yWorks.Algorithms.AbortHandler.Check(yWorks.Algorithms.Graph)" /> were called after a stop or cancel event.</para>
      </summary>
      <remarks>
        <para>More precisely, it returns <c>true</c> if one of the check methods either threw an <see cref="T:yWorks.Algorithms.AlgorithmAbortedException" /> or returned <c>true</c> to indicate that the calling algorithm should terminate gracefully. Otherwise, this method returns <c>false</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the check methods were called after a stop or cancel event, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Check" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Check(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.Check">
      <summary>
        <para>Determines whether or not an algorithm should terminate immediately.</para>
      </summary>
      <remarks>
        <para>This method returns <c>true</c> if the algorithm should terminate gracefully and ensures that the processed graph remains in a consistent state.</para>
      </remarks>
      <returns>
        <para>
          <c>true</c>, if the algorithm should terminate immediately, <c>false</c> otherwise</para>
      </returns>
      <exception cref="T:yWorks.Algorithms.AlgorithmAbortedException">
        <para>if the algorithm should terminate immediately</para>
      </exception>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Cancel" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Stop" />
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.Reset">
      <summary>
        <para>Resets the state of the <see cref="T:yWorks.Algorithms.AbortHandler">handler</see>.</para>
      </summary>
      <remarks>
        <para>Resetting the <see cref="T:yWorks.Algorithms.AbortHandler">handler</see> discards any previous stop or cancel requests. Moreover, the handler's internal timestamp that is used for determining whether or not an algorithm should be stopped or cancelled automatically is reset as well.</para>
        <para>This method should be called whenever a graph with an attached handler is processed an additional time to prevent previous requests for early termination to result in an undesired early termination of the next algorithm run.</para>
      </remarks>
      <seealso cref="P:yWorks.Algorithms.AbortHandler.CancelDuration" />
      <seealso cref="P:yWorks.Algorithms.AbortHandler.StopDuration" />
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.CreateForGraph(yWorks.Algorithms.Graph)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Algorithms.AbortHandler">handler</see> instance and attaches it to the given graph.</para>
      </summary>
      <remarks>
        <para>If the given graph has already an attached handler instance, this is the instance that will be returned and this method will not create a new <see cref="T:yWorks.Algorithms.AbortHandler" />.</para>
        <para>This method should be called by client code prior to starting a graph algorithm that may be terminated early.</para>
      </remarks>
      <param name="graph">
        <para>the graph to which the handler will be attached</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Algorithms.AbortHandler" /> instance for the given graph</para>
      </returns>
      <exception cref="T:System.ArgumentNullException">
        <para>if the given graph is <c>null</c>.</para>
      </exception>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.HasHandler(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.RemoveFromGraph(yWorks.Algorithms.Graph)">
      <summary>
        <para>Removes any attached <see cref="T:yWorks.Algorithms.AbortHandler" /> instance from the given graph.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>if the given graph is <c>null</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.GetFromGraph(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Algorithms.AbortHandler" /> instance for the given graph.</para>
      </summary>
      <remarks>
        <para>If <see cref="M:yWorks.Algorithms.AbortHandler.CreateForGraph(yWorks.Algorithms.Graph)" /> has been used for attaching a new handler to the given graph, this is the instance that will be returned. Otherwise, a non-functional instance is returned whose methods do nothing. Use <see cref="M:yWorks.Algorithms.AbortHandler.HasHandler(yWorks.Algorithms.Graph)" /> to check whether or not a handler has been already attached to the given graph.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.AbortHandler" /> for the given graph or a non-functional instance if no handler has been previously created</para>
      </returns>
      <exception cref="T:System.ArgumentNullException">
        <para>if the given graph is <c>null</c></para>
      </exception>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.CreateForGraph(yWorks.Algorithms.Graph)" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.HasHandler(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.CopyHandler(yWorks.Algorithms.Graph,yWorks.Algorithms.Graph)">
      <summary>
        <para>Attaches the <see cref="T:yWorks.Algorithms.AbortHandler" /> instance of the given source graph to the target graph as well.</para>
      </summary>
      <param name="source">
        <para>the graph whose handler is attached to the target graph</para>
      </param>
      <param name="target">
        <para>the graph to which the handler of the source graph is attached</para>
      </param>
      <exception cref="T:System.ArgumentNullException">
        <para>if the given source is <c>null</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.HasHandler(yWorks.Algorithms.Graph)">
      <summary>
        <para>Determines whether or not an <see cref="T:yWorks.Algorithms.AbortHandler" /> instance is attached to the given graph.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if a handler is attached to the given graph, <c>false</c> otherwise</para>
      </returns>
      <exception cref="T:System.ArgumentNullException">
        <para>if the given graph is <c>null</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.AbortHandler.Check(yWorks.Algorithms.Graph)">
      <summary>
        <para>Determines whether or not an algorithm should terminate immediately.</para>
      </summary>
      <remarks>
        <para>This method returns <c>true</c> if the algorithm should terminate gracefully and ensures that the processed graph remains in a consistent state.</para>
        <para>This convenience method is meant for one-time checks only. For performance critical code that needs to check repeatedly, it is recommended to retrieve the given graph's attached handler once and only call the handler's <see cref="M:yWorks.Algorithms.AbortHandler.Check" /> method repeatedly.</para>
      </remarks>
      <returns>
        <para>
          <c>true</c>, if the algorithm should stop immediately while still providing some valid result, <c>false</c> otherwise</para>
      </returns>
      <exception cref="T:yWorks.Algorithms.AlgorithmAbortedException">
        <para>if the algorithm should terminate immediately</para>
      </exception>
      <exception cref="T:System.ArgumentNullException">
        <para>if the given graph is <c>null</c></para>
      </exception>
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Check" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Cancel" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Stop" />
      <param name="graph" />
    </member>
    <member name="T:yWorks.Algorithms.AlgorithmAbortedException">
      <summary>
        <para>Exception thrown by an algorithm to indicate that an immediate termination request was detected.</para>
      </summary>
      <seealso cref="T:yWorks.Algorithms.AbortHandler" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Cancel" />
      <seealso cref="M:yWorks.Algorithms.AbortHandler.Check" />
    </member>
    <member name="M:yWorks.Algorithms.AlgorithmAbortedException.#ctor(System.String)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Algorithms.AlgorithmAbortedException" /> with the specified detail message.</para>
      </summary>
      <param name="msg">
        <para>the detail message</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.AlgorithmAbortedException.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Algorithms.AlgorithmAbortedException" /> with no detail message.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.Bfs">
      <summary>
        <para>This class provides services that center around breadth first search (BFS).</para>
      </summary>
      <remarks>
        <para>Breadth first search starts at a given set of nodes and explores the neighboring nodes first, before visiting the next level neighbors.</para>
        <para>A breadth first search run can be either directed or undirected. All methods require a list of nodes that are considered as the core nodes from which the breadth first search starts. These nodes can be identified either with a <see cref="T:yWorks.Algorithms.NodeList" /> or with a <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns <c>true</c> for core nodes and <c>false</c> for all other nodes. The output is given as an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes of a particular layer.</para>
        <para> Example for a BFS run. The marked node is the core node from which BFS starts while node labels indicate the resulting layers.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Returns the layers of nodes calculated by a breadth first search.</para>
      </summary>
      <remarks>
        <para>The first of these layers contains all nodes within the given <see cref="T:yWorks.Algorithms.NodeList" />. These nodes are the core nodes from which an undirected breadth first search to the other nodes starts.</para>
        <para>In the <c>i</c>-th layer are previously unassigned nodes that are connected to nodes in the <c>(i-1)</c>-th layer.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="coreNodes">
        <para>the list of core nodes from which the BFS starts</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes of a particular layer</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns the layers of nodes constructed by a breadth first search.</para>
      </summary>
      <remarks>
        <para>The first of these layers contains all nodes for which the given <see cref="T:yWorks.Algorithms.IDataProvider" /> returns <c>true</c>. These nodes are the core nodes from which an undirected breadth first search to the other nodes starts.</para>
        <para>In the <c>i</c>-th layer are previously unassigned nodes that are connected to nodes in the <c>(i-1)</c>-th layer.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="isCoreNode">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that contains the nodes from which the BFS starts; core nodes are marked with a <c>true</c> value</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes of a particular layer</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Returns the layers of nodes constructed by a breadth first search.</para>
      </summary>
      <remarks>
        <para>The first of these layers contains all nodes for which the given <see cref="T:yWorks.Algorithms.IDataProvider" /> returns <c>true</c>. These nodes are the core nodes from which an undirected breadth first search to the other nodes starts. The algorithm fills the provided <see cref="T:yWorks.Algorithms.INodeMap" /> with an integer indicating the layer of each node.</para>
        <para>In the <c>i</c>-th layer are previously unassigned nodes that are connected to nodes in the <c>(i-1)</c>-th layer.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="isCoreNode">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that contains the nodes from which the BFS starts; core nodes are marked with a <c>true</c> value</para>
      </param>
      <param name="layerIDMap">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the BFS execution and holds the zero-based index of the BFS layer to which each node belongs or <c>-1</c> if the node is not reachable</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes of a particular layer</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Returns the layers of nodes constructed by a breadth first search.</para>
      </summary>
      <remarks>
        <para>The first of these layers contains all nodes within the given <see cref="T:yWorks.Algorithms.NodeList" />. These nodes are the core nodes from which an undirected breadth first search to the other nodes starts. The algorithm fills the provided <see cref="T:yWorks.Algorithms.INodeMap" /> with an integer indicating the layer of each node.</para>
        <para>In the <c>i</c>-th layer are previously unassigned nodes that are connected to nodes in the <c>(i-1)</c>-th layer.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="coreNodes">
        <para>the list of core nodes from which the BFS starts</para>
      </param>
      <param name="layerIDMap">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the BFS execution and holds the zero-based index of the BFS layer to which each node belongs or <c>-1</c> if the node is not reachable</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes of a particular layer</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,System.Boolean,yWorks.Algorithms.INodeMap,System.Int32)">
      <summary>
        <para>Returns the layers of nodes constructed by a directed/undirected breadth first search where the maximum number of layers is restricted.</para>
      </summary>
      <remarks>
        <para>The first of these layers contains all nodes within the given <see cref="T:yWorks.Algorithms.NodeList" />. These nodes are the core nodes from which either a directed or undirected breadth first search to the other nodes starts. The algorithm fills the provided <see cref="T:yWorks.Algorithms.INodeMap" /> with an integer indicating the layer of each node.</para>
        <para>In the <c>i</c>-th layer are previously unassigned nodes that are connected to nodes in the <c>(i-1)</c>-th layer.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="coreNodes">
        <para>the list of core nodes from which the BFS starts</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered directed, <c>false</c> otherwise</para>
      </param>
      <param name="layerIDMap">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the BFS execution and holds the zero-based index of the BFS layer to which each node belongs or <c>-1</c> if the node is not reachable</para>
      </param>
      <param name="maxLayers">
        <para>the number of layers that will be returned or <c>0</c> if all layers are required</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes of a particular layer</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,yWorks.Algorithms.BfsDirection,yWorks.Algorithms.INodeMap,System.Int32)">
      <summary>
        <para>Returns the layers of nodes constructed by a directed/undirected breadth first search where the maximum number of layers is restricted.</para>
      </summary>
      <remarks>
        <para>The first of these layers contains all nodes within the given <see cref="T:yWorks.Algorithms.NodeList" />. These nodes are the core nodes from which a breadth first search to the other nodes starts. The algorithm fills the provided <see cref="T:yWorks.Algorithms.INodeMap" /> with an integer indicating the layer of each node.</para>
        <para>In the <c>i</c>-th layer are previously unassigned nodes that are connected to nodes in the <c>(i-1)</c>-th layer.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="coreNodes">
        <para>the list of core nodes</para>
      </param>
      <param name="direction">
        <para>one of the predefined direction specifiers</para>
      </param>
      <param name="layerIDMap">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the BFS execution and holds the zero-based index of the BFS layer to which each node belongs or <c>-1</c> if the node is not reachable</para>
      </param>
      <param name="maxLayers">
        <para>the number of layers that will be returned or <c>0</c> if all layers are required</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes of a particular layer</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given direction is not supported</para>
      </exception>
    </member>
    <member name="T:yWorks.Algorithms.Bipartitions">
      <summary>
        <para>This class provides methods to determine whether a graph is bipartite and to obtain the corresponding partitions.</para>
      </summary>
      <remarks>
        <para>A <b>bipartite</b> graph is a graph whose nodes can be partitioned into two sets such that each edges connects two nodes of different sets. In other words, there are no edges connecting nodes that belong to the same partition.</para>
        <para>The two sets/partitions are represented by two <see cref="T:System.Object" /> constants i.e., <see cref="F:yWorks.Algorithms.Bipartitions.Red" /> or <see cref="F:yWorks.Algorithms.Bipartitions.Blue" />.</para>
        <para> Example of a bipartite graph. Circular and rectangular nodes represent the two partitions.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Algorithms.Bipartitions.Red">
      <summary>
        <para>A constant for marking a node that belongs to the red partition.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.Bipartitions.Blue">
      <summary>
        <para>A constant for marking a node that belongs to the blue partition.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Bipartitions.IsBipartite(yWorks.Algorithms.Graph)">
      <summary>
        <para>Determines whether or not the given graph is bipartite.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is bipartite, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Bipartitions.GetBipartition(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Calculates a bipartition of the given graph, if one exists.</para>
      </summary>
      <remarks>
        <para>If the graph is bipartite, then for all nodes of the given graph either <see cref="F:yWorks.Algorithms.Bipartitions.Red" /> or <see cref="F:yWorks.Algorithms.Bipartitions.Blue" /> objects will be set in the given <see cref="T:yWorks.Algorithms.INodeMap" />, depending on the partition to which each node belongs.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="markMap">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the BFS execution and returns the partition (either <see cref="F:yWorks.Algorithms.Bipartitions.Red" /> or <see cref="F:yWorks.Algorithms.Bipartitions.Blue" />) to which each node belongs</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is bipartite, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Centrality">
      <summary>
        <para>This class provides methods to determine various centrality indices of nodes or edges of a graph.</para>
      </summary>
      <remarks>
        <para>Centrality indices serve to quantify an intuitive feeling that in most networks some nodes or edges are "more central" than others. The provided methods assign a double value to each node or edge of a graph that represents its centrality. The higher an assigned value, the more central the element is considered by the algorithm.</para>
        <para>Also, this class provides convenience methods that normalize the returned centrality values such that they lie within the interval <c>[0,1]</c>.</para>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>
            <b>Betweenness centrality</b> is a measure for how often a node/edge lies on a shortest path between each pair of nodes in the graph.</item>
          <item>
            <b>Closeness centrality</b> is the reciprocal of the sum of shortest path distances of a node to all other nodes in the graph.</item>
          <item>
            <b>Graph centrality</b> is the reciprocal of the maximum of all shortest path distances from a node to all other nodes in the graph.</item>
          <item>
            <b>Degree centrality</b> is the number of the incoming, outgoing or overall edges incident to a node (measures incoming, outgoing and overall degree).</item>
          <item>
            <b>Weight centrality</b> measures the weight associated with incoming, outgoing, or all edges of a node.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.NodeBetweenness(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Boolean,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Computes betweenness centrality for each node of a given graph.</para>
      </summary>
      <remarks>
        <para>
          <i>Betweenness centrality</i> is a measure for how often a node lies on a shortest path between each pair of nodes in the graph. Removing a central edge will cause many shortest paths to change.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="centrality">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (centrality) for each node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="edgeCosts">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a positive double value (cost) or <c>null</c> if the edges are of equal cost; for invalid input values the algorithm uses cost <c>1.0</c></para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.EdgeBetweenness(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap,System.Boolean,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Computes betweenness centrality for each edge of a given graph.</para>
      </summary>
      <remarks>
        <para>
          <i>Betweenness centrality</i> is a measure for how often an edge lies on a shortest path between each pair of nodes in the graph. Removing a central edge will cause many shortest paths to change.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="centrality">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution and returns a double value (centrality) for each edge</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="edgeCosts">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a positive double value (cost) or <c>null</c> if the edges are of equal cost; for invalid input values the algorithm uses cost <c>1.0</c></para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.NodeEdgeBetweenness(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IEdgeMap,System.Boolean,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Computes betweenness centrality for each node and edge of a given graph.</para>
      </summary>
      <remarks>
        <para>
          <i>Betweenness centrality</i> is a measure for how often a node/edge lies on a shortest path between each pair of nodes in the graph. Removing a central node/edge will cause many shortest paths to change.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="nodeCentrality">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (centrality) for each node</para>
      </param>
      <param name="edgeCentrality">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution and returns a double value (centrality) for each edge</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="edgeCosts">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a positive double value (cost) or <c>null</c> if the edges are of equal cost; for invalid input values the algorithm uses cost <c>1.0</c></para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.ClosenessCentrality(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Boolean,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Computes the closeness centrality for the nodes of a graph.</para>
      </summary>
      <remarks>
        <para>
          <i>Closeness centrality</i> is defined as the reciprocal of the sum of shortest path distances of a node to all other nodes in the graph. Therefore, a node with high closeness centrality has short distances to all other nodes of a graph. If the sum of the shortest path distances is <c>0</c>, the closeness of a node is set to <see cref="F:System.Double.PositiveInfinity" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="closeness">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (centrality) for each node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="edgeCosts">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a positive double value (cost) or <c>null</c> if the edges are of equal cost</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.GraphCentrality(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Boolean,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Computes the graph centrality for the nodes of a graph.</para>
      </summary>
      <remarks>
        <para>
          <i>Graph centrality</i> is defined as the reciprocal of the maximum of all shortest path distances from a node to all other nodes in the graph. Nodes with high graph centrality have short distances to all other nodes in the graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="centrality">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (centrality) for each node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="edgeCosts">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a positive double value (cost) or <c>null</c> if the edges are of equal cost</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.DegreeCentrality(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Boolean,System.Boolean)">
      <summary>
        <para>Computes the degree centrality for the nodes of a given graph.</para>
      </summary>
      <remarks>
        <para>
          <i>Degree centrality</i> is the number of the incoming, outgoing or overall edges incident to a node (measures incoming, outgoing and overall degree).</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="centrality">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (centrality) for each node</para>
      </param>
      <param name="considerInEdges">
        <para>
          <c>true</c> if the incoming edges should be considered, <c>false</c> otherwise</para>
      </param>
      <param name="considerOutEdges">
        <para>
          <c>true</c> if the outgoing edges should be considered, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.WeightCentrality(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Boolean,System.Boolean,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Computes the weight centrality for the nodes of a graph.</para>
      </summary>
      <remarks>
        <para>
          <i>Weight centrality</i> measures the weight associated with incoming, outgoing, or all edges of a node.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="centrality">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (centrality) for each node</para>
      </param>
      <param name="considerInEdges">
        <para>
          <c>true</c> if the incoming edges should be considered, <c>false</c> otherwise</para>
      </param>
      <param name="considerOutEdges">
        <para>
          <c>true</c> if the outgoing edges should be considered, <c>false</c> otherwise</para>
      </param>
      <param name="edgeWeights">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a positive double value (weight) or <c>null</c> if the edges are considered to have uniform weight of <c>1.0</c></para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.Normalize(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Normalizes the <c>double</c> values of a given <see cref="T:yWorks.Algorithms.INodeMap" /> by dividing each of them by the maximum of all values (maximum norm).</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="map">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value from <c>[0,1]</c> interval</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Centrality.Normalize(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Normalizes the <c>double</c> values of a given <see cref="T:yWorks.Algorithms.IEdgeMap" /> by dividing each of them by the maximum of all values (maximum norm).</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="map">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution and returns a double value from <c>[0,1]</c> interval</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Cycles">
      <summary>
        <para>This class is responsible for finding cycles within a graph that have certain properties.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>An edge path with vertices <c>v0, v1, v2, ... , vk</c> (with k &gt; 0 and (vi-1,vi), 0 &lt; i &lt;= k is edge of the given graph) is called <b>simple</b> if no vertex appears more than once.</item>
          <item>An edge path forms a <b>cycle</b> if <c>v0 = vk</c>.</item>
          <item>A cycle is called <b>simple</b> if no vertex appears more than once.</item>
          <item>A graph that contains no cycles is called <b>acyclic</b>.</item>
        </list>
        <para> Example of an acyclic directed graph (edge directions are considered)  Example of a graph containing a cycle. Marked edges form a directed cycle.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Cycles.FindCycleEdges(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Marks the edges of a given graph whose removal or reversal would make the graph acyclic while trying to minimize the cost associated with the marked edges.</para>
      </summary>
      <remarks>
        <para>This minimization is performed heuristically, since it is a well known hard problem to come up with an optimal solution.</para>
        <para>The costs are assigned using a <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds a non-negative double value for each edge.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="cycleEdges">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution and returns whether an edge is a detected cycle edge</para>
      </param>
      <param name="costDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds the non-negative <see cref="T:System.Double" /> reversal cost for each edge</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Cycles.FindCycleEdgesDFS(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Marks the edges of a given graph whose removal or reversal would make the graph acyclic based on a depth first search.</para>
      </summary>
      <remarks>
        <para>The number of marked cycle edges is expected to be slightly greater than when using <see cref="M:yWorks.Algorithms.Cycles.FindCycleEdges(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.IDataProvider)" />. The advantage of this method is that the result set is more stable when edges are added or removed over time.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="cycleEdges">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution and returns a boolean value indicating whether or not an edge is a detected cycle edge</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Cycles.FindCycle(yWorks.Algorithms.Graph,System.Boolean)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Algorithms.EdgeList" /> that contains the edges of a cycle found in the given graph.</para>
      </summary>
      <remarks>
        <para>The edges are returned in the order they appear in the detected cycle.</para>
        <para>If the returned cycle is empty, no cycle has been found in the given graph.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered directed, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges of a cycle or an empty <see cref="T:yWorks.Algorithms.EdgeList" /> if the graph is acyclic</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Cycles.FindAllCycleEdges(yWorks.Algorithms.Graph,System.Boolean)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Algorithms.EdgeList" /> that contains all the edges that are part of at least one directed or undirected simple cycle.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered directed, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> that contains all the edges that are part of at least one directed or undirected simple cycle</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Dart">
      <summary>
        <para>Represents a dart of a face of a <see cref="T:yWorks.Algorithms.PlanarEmbedding" />.</para>
      </summary>
      <remarks>
        <para>For each edge there exist two darts, one that represents the edge in its original direction (i.e., from source to target) and one that represents its reverse. Each dart is associated with a <see cref="P:yWorks.Algorithms.Dart.Face">face</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Dart.AssociatedEdge">
      <summary>
        <para>Gets the edge associated with this dart.</para>
      </summary>
      <value>
        <para>the edge associated with this dart</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Dart.Reversed">
      <summary>
        <para>Gets whether this dart represents the original edge or its reverse.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this dart represents the original edge, <c>false</c> if it represents its reverse</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Dart.OppositeDart">
      <summary>
        <para>Gets the opposite dart.</para>
      </summary>
      <remarks>
        <para>The opposite dart is associated with the same edge as this dart but with a different <see cref="P:yWorks.Algorithms.Dart.Reversed">direction</see>.</para>
      </remarks>
      <value>
        <para>the opposite dart</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Dart.Face">
      <summary>
        <para>Gets the face list associated with this dart.</para>
      </summary>
      <value>
        <para>the face list associated with this dart</para>
      </value>
    </member>
    <member name="T:yWorks.Algorithms.Dfs">
      <summary>
        <para>Framework class for implementing depth first search (DFS) based algorithms.</para>
      </summary>
      <remarks>
        <para>A depth first search starts from a specified node and traverses the neighbors within a branch as deeply as possible (i.e., without visiting any vertex twice) before backtracking.</para>
        <para>A depth first search traversal induces a DFS forest that may consist of more than one DFS tree. Based on these trees, the edges are divided into four categories (see example):</para>
        <list type="bullet">
          <item>
            <b>Tree Edges:</b> The edges of the DFS forest.</item>
          <item>
            <b>Back edges:</b> Non-tree edges that connect nodes with their ancestors in the DFS tree. Self-loops are also considered as back edges.</item>
          <item>
            <b>Forward edges:</b> Edges that connect nodes of the DFS tree to one of their descendants.</item>
          <item>
            <b>Cross edges:</b> All other edges.</item>
        </list>
        <para>During a DFS run each node of the graph can be in one of the following states:</para>
        <list type="bullet">
          <item>
            <b>Undiscovered:</b> A node that has not been visited yet.</item>
          <item>
            <b>Discovered but not finished:</b> A node that has been already visited, but has not been completed yet, i.e. it is still part of an active path of the DFS tree.</item>
          <item>
            <b>Finished:</b> A node that has been completed, i.e. it has been visited before and is not part of an active path of the DFS tree anymore.</item>
        </list>
        <para>Graph algorithms, which are based on a depth first search, can extend this class and override appropriate callback methods provided by this class.</para>
        <para> Example of a DFS traversal. Node labels indicate the order in which nodes are visited. Solid edges are the edges of the DFS tree while dashed edges represent back, forward and cross edges.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Algorithms.Dfs.stateMap">
      <summary>
        <para>A <see cref="T:yWorks.Algorithms.INodeMap" /> that holds for each <see cref="T:yWorks.Algorithms.Node" /> an <see cref="T:System.Object" /> indicating the current state of the given node as it is visited by this algorithm.</para>
      </summary>
      <remarks>
        <para>Each node will be assigned one of the <see cref="F:yWorks.Algorithms.Dfs.White">WHITE</see>, <see cref="F:yWorks.Algorithms.Dfs.Gray">GRAY</see> or <see cref="F:yWorks.Algorithms.Dfs.Black">BLACK</see> objects that describe the state of the nodes.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Algorithms.Dfs.White">
      <summary>
        <para>A constant indicating a node has not been visited yet.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.Dfs.Gray">
      <summary>
        <para>A constant indicating a node has already been visited, but has not been completed yet.</para>
      </summary>
      <remarks>
        <para>Such a node is still part of an active path of the DFS tree.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Algorithms.Dfs.Black">
      <summary>
        <para>A constant indicating a node has been completed.</para>
      </summary>
      <remarks>
        <para>Such a node has been visited before and is no longer part of an active path of the DFS tree.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Algorithms.Dfs" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Dfs.DirectedMode">
      <summary>
        <para>Sets whether or not to interpret the edges of the graph as directed.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the edges are considered as directed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Dfs.LookFurtherMode">
      <summary>
        <para>Sets whether or not to continue the depth first search after all nodes reachable from the first node have been visited.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the depth first search should continue, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.Start(yWorks.Algorithms.Graph)">
      <summary>
        <para>Starts a depth first search on the given graph.</para>
      </summary>
      <remarks>
        <para>The first node of the graph will be visited first.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.Start(yWorks.Algorithms.Graph,yWorks.Algorithms.Node)">
      <summary>
        <para>Starts a depth first search from a given <see cref="T:yWorks.Algorithms.Node" /> of the input graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="start">
        <para>the given start node</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.PreVisit(yWorks.Algorithms.Node,System.Int32)">
      <summary>
        <para>Callback method that will be invoked whenever a formerly unvisited node gets visited for the first time.</para>
      </summary>
      <remarks>
        <para>By default, this method does nothing. It may be overridden to support custom implementations.</para>
      </remarks>
      <param name="node">
        <para>the given node</para>
      </param>
      <param name="dfsNumber">
        <para>the DFS number of the given node</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.PostVisit(yWorks.Algorithms.Node,System.Int32,System.Int32)">
      <summary>
        <para>Callback method that will be invoked whenever a node visit has been completed.</para>
      </summary>
      <remarks>
        <para>By default, this method does nothing. It may be overridden to support custom implementations.</para>
      </remarks>
      <param name="node">
        <para>the given node</para>
      </param>
      <param name="dfsNumber">
        <para>the DFS number of the given node</para>
      </param>
      <param name="compNumber">
        <para>the completion number of the given node</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.PreTraverse(yWorks.Algorithms.Edge,yWorks.Algorithms.Node,System.Boolean)">
      <summary>
        <para>Callback method that will be invoked if the given edge will be considered the first (and only) time during the DFS.</para>
      </summary>
      <remarks>
        <para>By default, this method does nothing. It may be overridden to support custom implementations.</para>
      </remarks>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <param name="node">
        <para>the node to be visited next only if <c>treeEdge == true</c></para>
      </param>
      <param name="treeEdge">
        <para>
          <c>true</c> if the <c>node</c> will be visited, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.PostTraverse(yWorks.Algorithms.Edge,yWorks.Algorithms.Node)">
      <summary>
        <para>Callback method that will be invoked after the DFS has returned from the given node.</para>
      </summary>
      <remarks>
        <para>By default, this method does nothing. It may be overridden to support custom implementations.</para>
      </remarks>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <param name="node">
        <para>the node that has been reached via the given edge</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.LookFurther(yWorks.Algorithms.Node)">
      <summary>
        <para>Callback method that will be invoked whenever DFS continues its search at a new root node.</para>
      </summary>
      <remarks>
        <para>By default, this method does nothing. It may be overridden to support custom implementations.</para>
      </remarks>
      <param name="v">
        <para>the new root node</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Dfs.Cancel">
      <summary>
        <para>Cancels the depth first search.</para>
      </summary>
      <remarks>
        <para>It may be overridden to support custom implementations.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.DpKeyBase`1">
      <summary>
        <para>This is the base class of all look-up keys that are used to register <see cref="T:yWorks.Algorithms.IDataProvider" /> with a <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <typeparam name="TValue">
        <para>The type of the values that are returned by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this class.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Algorithms.DpKeyBase`1.#ctor(System.Type,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Algorithms.DpKeyBase`1" /> class.</para>
      </summary>
      <param name="declaringType">
        <para>Type that declares this key.</para>
      </param>
      <param name="name">
        <para>The name of this key.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.DpKeyBase`1.DeclaringType">
      <summary>
        <para>Gets the type that declares this key.</para>
      </summary>
      <value>
        <para>The type that declares this key.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.DpKeyBase`1.Name">
      <summary>
        <para>Gets the name of this key.</para>
      </summary>
      <value>
        <para>The name of this key.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.DpKeyBase`1.Equals(yWorks.Algorithms.DpKeyBase{`0})">
      <summary>
        <para>Returns whether this key is equal to the specified <paramref name="other" />.</para>
      </summary>
      <param name="other">
        <para>The other key to compare with this instance.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified key is equal to this instance; otherwise, <c>false</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.DpKeyBase`1.Equals(System.Object)">
      <summary>
        <para>Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.</para>
      </summary>
      <param name="obj">
        <para>The <see cref="T:System.Object" /> to compare with this instance.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.DpKeyBase`1.GetHashCode">
      <summary>
        <para>Returns a hash code for this instance.</para>
      </summary>
      <returns>
        <para>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.EdgeDpKey`1">
      <summary>
        <para>This class is used as look-up key for registering <see cref="T:yWorks.Algorithms.IDataProvider" /> for <see cref="T:yWorks.Algorithms.Edge" />s with a <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <typeparam name="TValue">
        <para>The type of the values that are returned by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this class.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Algorithms.EdgeDpKey`1.#ctor(System.Type,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Algorithms.EdgeDpKey`1" /> class.</para>
      </summary>
      <param name="declaringType">
        <para>Type that declares this key.</para>
      </param>
      <param name="name">
        <para>The name of this key.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.GraphDpKey`1">
      <summary>
        <para>This class is used as look-up key for registering <see cref="T:yWorks.Algorithms.IDataProvider" /> for the <see cref="T:yWorks.Algorithms.Graph" /> itself with a graph.</para>
      </summary>
      <typeparam name="TValue">
        <para>The type of the values that are returned by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this class.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Algorithms.GraphDpKey`1.#ctor(System.Type,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Algorithms.GraphDpKey`1" /> class.</para>
      </summary>
      <param name="declaringType">
        <para>Type that declares this key.</para>
      </param>
      <param name="name">
        <para>The name of this key.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.GraphObjectDpKey`1">
      <summary>
        <para>This class is used as look-up key for registering <see cref="T:yWorks.Algorithms.IDataProvider" /> for <see cref="T:yWorks.Algorithms.GraphObject" />s with a <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <typeparam name="TValue">
        <para>The type of the values that are returned by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this class.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Algorithms.GraphObjectDpKey`1.#ctor(System.Type,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Algorithms.GraphObjectDpKey`1" /> class.</para>
      </summary>
      <param name="declaringType">
        <para>Type that declares this key.</para>
      </param>
      <param name="name">
        <para>The name of this key.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.IEdgeLabelLayoutDpKey`1">
      <summary>
        <para>This class is used as look-up key for registering <see cref="T:yWorks.Algorithms.IDataProvider" /> for <see cref="T:yWorks.Layout.IEdgeLabelLayout" />s with a <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <typeparam name="TValue">
        <para>The type of the values that are returned by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this class.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Algorithms.IEdgeLabelLayoutDpKey`1.#ctor(System.Type,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Algorithms.IEdgeLabelLayoutDpKey`1" /> class.</para>
      </summary>
      <param name="declaringType">
        <para>Type that declares this key.</para>
      </param>
      <param name="name">
        <para>The name of this key.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.INodeLabelLayoutDpKey`1">
      <summary>
        <para>This class is used as look-up key for registering <see cref="T:yWorks.Algorithms.IDataProvider" /> for <see cref="T:yWorks.Layout.INodeLabelLayout" />s with a <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <typeparam name="TValue">
        <para>The type of the values that are returned by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this class.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Algorithms.INodeLabelLayoutDpKey`1.#ctor(System.Type,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Algorithms.INodeLabelLayoutDpKey`1" /> class.</para>
      </summary>
      <param name="declaringType">
        <para>Type that declares this key.</para>
      </param>
      <param name="name">
        <para>The name of this key.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.ILabelLayoutDpKey`1">
      <summary>
        <para>This class is used as look-up key for registering <see cref="T:yWorks.Algorithms.IDataProvider" /> for <see cref="T:yWorks.Layout.ILabelLayout" />s with a <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <typeparam name="TValue">
        <para>The type of the values that are returned by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this class.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Algorithms.ILabelLayoutDpKey`1.#ctor(System.Type,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Algorithms.ILabelLayoutDpKey`1" /> class.</para>
      </summary>
      <param name="declaringType">
        <para>Type that declares this key.</para>
      </param>
      <param name="name">
        <para>The name of this key.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.NodeDpKey`1">
      <summary>
        <para>This class is used as look-up key for registering <see cref="T:yWorks.Algorithms.IDataProvider" /> for <see cref="T:yWorks.Algorithms.Node" />s with a <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <typeparam name="TValue">
        <para>The type of the values that are returned by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this class.</para>
      </typeparam>
    </member>
    <member name="M:yWorks.Algorithms.NodeDpKey`1.#ctor(System.Type,System.String)">
      <summary>
        <para>Initializes a new instance of the <see cref="T:yWorks.Algorithms.NodeDpKey`1" /> class.</para>
      </summary>
      <param name="declaringType">
        <para>Type that declares this key.</para>
      </param>
      <param name="name">
        <para>The name of this key.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Edge">
      <summary>
        <para>Represents an edge, i.e., a directed connection between two nodes (represented by instances of class <see cref="T:yWorks.Algorithms.Node" />) in the directed graph data type <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <remarks>
        <para>
          <br /> The <i>directed</i> stems from the fact that an edge has a distinct source node and a distinct target node. Using pair notation, an edge would be written as (<i>&lt;source node&gt;</i>, <i>&lt;target node&gt;</i>).</para>
        <para>Most notably, an edge provides access to its source node (<see cref="P:yWorks.Algorithms.Edge.Source" />) and its target node (<see cref="P:yWorks.Algorithms.Edge.Target" />). Note that an edge can have the same node as its source and target. Such an edge is then called "self-loop" and method <see cref="P:yWorks.Algorithms.Edge.SelfLoop" /> yields <c>true</c>.</para>
        <para>
          <b>Important:</b> Class Graph is the single authority for any structural changes to the graph data type. Specifically, this means that there is no way to create or delete a node or an edge without using an actual Graph instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Edge.#ctor(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion,yWorks.Algorithms.GraphElementInsertion)">
      <summary>
        <para>Creates a new edge that belongs to the given graph.</para>
      </summary>
      <remarks>
        <para>The new edge <c>e</c> has source node <c>v</c> and target node <c>w</c>. <br /> <br /> Edge <c>e</c> is inserted in such a way that an iteration over the edges at node <c>v</c> returns <c>e</c></para>
        <list type="bullet">
          <item>after <c>e1</c>, if <c>d1 == AFTER</c></item>
          <item>before <c>e1</c>, if <c>d1 == BEFORE</c>,</item>
        </list>
        <para>and an iteration over the edges at <c>w</c> returns <c>e</c></para>
        <list type="bullet">
          <item>after <c>e2</c>, if <c>d2 == AFTER</c></item>
          <item>before <c>e2</c>, if <c>d2 == BEFORE</c>.</item>
        </list>
      </remarks>
      <param name="v">
        <para>The source node of the edge.</para>
      </param>
      <param name="e1">
        <para>An edge with source node <c>v</c>.</para>
      </param>
      <param name="w">
        <para>The target node of the edge.</para>
      </param>
      <param name="e2">
        <para>An edge with target node <c>w</c>.</para>
      </param>
      <param name="d1">
        <para>One of the object insertion specifiers <see cref="F:yWorks.Algorithms.GraphElementInsertion.Before" /> or <see cref="F:yWorks.Algorithms.GraphElementInsertion.After" />.</para>
      </param>
      <param name="d2">
        <para>One of the object insertion specifiers <see cref="F:yWorks.Algorithms.GraphElementInsertion.Before" /> or <see cref="F:yWorks.Algorithms.GraphElementInsertion.After" />.</para>
      </param>
      <param name="g" />
    </member>
    <member name="M:yWorks.Algorithms.Edge.CreateCopy(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a copy of this edge that will be inserted into the given graph connecting the given source and target nodes.</para>
      </summary>
      <param name="g">
        <para>The graph the created edge will belong to.</para>
      </param>
      <param name="v">
        <para>The source node of the created edge.</para>
      </param>
      <param name="w">
        <para>The target node of the created edge.</para>
      </param>
      <returns>
        <para>The newly created Edge object.</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.Edge.Graph">
      <summary>
        <para>Gets the graph this edge belongs to.</para>
      </summary>
      <remarks>
        <para>If the edge does not belong to a graph, because it was removed or hidden from it, this method returns <c>null</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Edge.Index">
      <summary>
        <para>Gets the index of this edge within its graph G.</para>
      </summary>
      <remarks>
        <para>Edge indices represent the ordering of standard edge iteration on G. The value of an index is <c> &gt;= 0</c> and <c> &lt; G.edgeCount()</c>.</para>
        <para>Note that indices are subject to change whenever the sequence of edges in a graph is modified by either removing, hiding, reinserting, or unhiding an edge, or by explicitly changing its position in the sequence.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Graph.RemoveEdge(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Algorithms.Graph.ReInsertEdge(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Algorithms.Graph.MoveToFirst(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Algorithms.Graph.MoveToLast(yWorks.Algorithms.Edge)" />
    </member>
    <member name="P:yWorks.Algorithms.Edge.Source">
      <summary>
        <para>Gets the source node connected to this edge.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.Edge.Target" />
    </member>
    <member name="P:yWorks.Algorithms.Edge.Target">
      <summary>
        <para>Gets the target node connected to this edge.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.Edge.Source" />
    </member>
    <member name="M:yWorks.Algorithms.Edge.Opposite(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the node at the opposite edge end with respect to the given node.</para>
      </summary>
      <remarks>
        <para>Note that self-loops have the same node at both edge ends.</para>
      </remarks>
      <param name="v" />
    </member>
    <member name="P:yWorks.Algorithms.Edge.SelfLoop">
      <summary>
        <para>Gets <c>true</c> if and only if this edge is a self-loop.</para>
      </summary>
      <remarks>
        <para>An edge is called a self-loop, if it is adjacent to only one node, i.e., source node and target node are the same.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Edge.ToString">
      <summary>
        <para>Returns a String representation of this edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Edge.OnReinsert">
      <summary>
        <para>Callback method that is invoked from a graph just before this edge will be reinserted into that graph.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Edge.NextOutEdge">
      <summary>
        <para>Gets the successor of this edge in the list of outgoing edges at its source node.</para>
      </summary>
      <remarks>
        <para>If this edge is the last outgoing edge at its source node, then <c>null</c> is returned.</para>
      </remarks>
      <seealso cref="P:yWorks.Algorithms.Edge.PrevOutEdge" />
      <seealso cref="P:yWorks.Algorithms.Edge.NextInEdge" />
    </member>
    <member name="P:yWorks.Algorithms.Edge.NextInEdge">
      <summary>
        <para>Gets the successor of this edge in the list of incoming edges at its target node.</para>
      </summary>
      <remarks>
        <para>If this edge is the last incoming edge at its target node, then <c>null</c> is returned.</para>
      </remarks>
      <seealso cref="P:yWorks.Algorithms.Edge.PrevInEdge" />
      <seealso cref="P:yWorks.Algorithms.Edge.NextOutEdge" />
    </member>
    <member name="P:yWorks.Algorithms.Edge.PrevOutEdge">
      <summary>
        <para>Gets the predecessor of this edge in the list of outgoing edges at its source node.</para>
      </summary>
      <remarks>
        <para>If this edge is the first outgoing edge at its source node, then <c>null</c> is returned.</para>
      </remarks>
      <seealso cref="P:yWorks.Algorithms.Edge.NextOutEdge" />
      <seealso cref="P:yWorks.Algorithms.Edge.PrevInEdge" />
    </member>
    <member name="P:yWorks.Algorithms.Edge.PrevInEdge">
      <summary>
        <para>Gets the predecessor of this edge in the list of incoming edges at its target node.</para>
      </summary>
      <remarks>
        <para>If this edge is the first incoming edge at its target node, then <c>null</c> is returned.</para>
      </remarks>
      <seealso cref="P:yWorks.Algorithms.Edge.NextInEdge" />
      <seealso cref="P:yWorks.Algorithms.Edge.PrevOutEdge" />
    </member>
    <member name="T:yWorks.Algorithms.EdgeList">
      <summary>
        <para>Specialized list implementation for instances of type <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.#ctor">
      <summary>
        <para>Creates an empty edge list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.#ctor(yWorks.Algorithms.Edge[])">
      <summary>
        <para>Creates a list that is initialized with the edges provided by the given array of edges.</para>
      </summary>
      <param name="a" />
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.#ctor(yWorks.Algorithms.IEdgeCursor)">
      <summary>
        <para>Creates a list that is initialized with the edges provided by the given EdgeCursor object.</para>
      </summary>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.#ctor(yWorks.Algorithms.IEdgeCursor,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Creates a list that is initialized with those edges from the given EdgeCursor object for which the given data provider returns <c>true</c> upon calling its <see cref="M:yWorks.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see> method.</para>
      </summary>
      <param name="ec">
        <para>An edge cursor providing edges that should be added to this list.</para>
      </param>
      <param name="predicate">
        <para>A data provider that acts as a inclusion predicate for each edge accessible by the given edge cursor.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.#ctor(yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates a list that is initialized with a single edge provided.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.#ctor(yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Creates a list that is initialized with an EdgeList.</para>
      </summary>
      <param name="edgeList" />
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.Edges">
      <summary>
        <para>Returns an edge cursor for this edge list.</para>
      </summary>
      <returns>
        <para>An edge cursor granting access to the edges within this list.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.FirstEdge">
      <summary>
        <para>Returns the first edge in this list, or <c>null</c> when the list is empty.</para>
      </summary>
      <returns>
        <para>The first edge in the list.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.LastEdge">
      <summary>
        <para>Returns the last edge in this list, or <c>null</c> when the list is empty.</para>
      </summary>
      <returns>
        <para>The last edge in the list.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.PopEdge">
      <summary>
        <para>Removes the first edge from this list and returns it.</para>
      </summary>
      <returns>
        <para>The first edge from the list.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.ToEdgeArray">
      <summary>
        <para>Returns an edge array containing all elements of this list in the canonical order.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.EdgeList.GetEnumerator">
      <summary>
        <para>Returns an enumerator for this collection.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.BfsDirection">
      <seealso cref="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,yWorks.Algorithms.BfsDirection,yWorks.Algorithms.INodeMap,System.Int32)" />
    </member>
    <member name="F:yWorks.Algorithms.BfsDirection.Predecessor">
      <summary>
        <para>An edge direction specifier for incoming edges.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,yWorks.Algorithms.BfsDirection,yWorks.Algorithms.INodeMap,System.Int32)" />
    </member>
    <member name="F:yWorks.Algorithms.BfsDirection.Successor">
      <summary>
        <para>An edge direction specifier for outgoing edges.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,yWorks.Algorithms.BfsDirection,yWorks.Algorithms.INodeMap,System.Int32)" />
    </member>
    <member name="F:yWorks.Algorithms.BfsDirection.Both">
      <summary>
        <para>An edge direction specifier for both incoming and outgoing edges.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Bfs.GetLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,yWorks.Algorithms.BfsDirection,yWorks.Algorithms.INodeMap,System.Int32)" />
    </member>
    <member name="T:yWorks.Algorithms.GraphElementInsertion">
      <summary>
        <para>Object insertion specifier.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Edge.#ctor(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion,yWorks.Algorithms.GraphElementInsertion)" />
      <seealso cref="M:yWorks.Algorithms.Graph.ChangeEdge(yWorks.Algorithms.Edge,yWorks.Algorithms.Edge,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion,yWorks.Algorithms.GraphElementInsertion)" />
      <seealso cref="M:yWorks.Algorithms.Graph.ChangeEdge(yWorks.Algorithms.Edge,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion)" />
      <seealso cref="M:yWorks.Algorithms.Graph.CreateEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion,yWorks.Algorithms.GraphElementInsertion)" />
    </member>
    <member name="F:yWorks.Algorithms.GraphElementInsertion.Before">
      <summary>
        <para>Object insertion specifier. An object gets inserted before another one.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphElementInsertion.After">
      <summary>
        <para>Object insertion specifier. An object gets inserted after another one.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.GraphEventType">
      <seealso cref="M:yWorks.Algorithms.GraphEvent.#ctor(yWorks.Algorithms.Graph,yWorks.Algorithms.GraphEventType,System.Object)" />
      <seealso cref="P:yWorks.Algorithms.GraphEvent.Type" />
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.NodeCreation">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately after a node has been created. The data of the event is the newly created node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.EdgeCreation">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately after an edge has been created. The data of the event is the newly created edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.PreNodeRemoval">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately before a node will be removed from the graph. The data of the event is the node to be removed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.PostNodeRemoval">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately after a node has been removed from the graph. The data of the event is the removed node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.PreEdgeRemoval">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately before an edge will be removed from the graph. The data of the event is the edge to be removed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.PostEdgeRemoval">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately after an edge has been removed from the graph. The data of the event is the removed edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.NodeReinsertion">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately after a node has been reinserted into the graph. The data of the event is the reinserted node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.EdgeReinsertion">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately after an edge has been reinserted into the graph. The data of the event is the reinserted edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.PreEdgeChange">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately before the end points of an edge will be changed. The data of the event is the edge to be redefined.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.PostEdgeChange">
      <summary>
        <para>Type constant that identifies an event that gets fired immediately after the end points of an edge have been changed. The data of the event is the redefined edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.SubgraphInsertion">
      <summary>
        <para>Type constant that identifies an event that gets fired after a subgraph of a graph G has been moved to the emitting graph. The data of the event is a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes that induce the moved subgraph.</para>
        <para>This event gets fired just after the <see cref="F:yWorks.Algorithms.GraphEventType.SubgraphRemoval" /> event got fired on the subgraph's original graph G. Note that at the time the event gets fired, the nodes from the node list are already part of the emitting graph.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.SubgraphRemoval">
      <summary>
        <para>Type constant that identifies an event that gets fired after a subgraph of the emitting graph has been moved to a graph G. The data of the event is a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes that induce the moved subgraph.</para>
        <para>This event gets fired just before the <see cref="F:yWorks.Algorithms.GraphEventType.SubgraphInsertion" /> event will be fired on the subgraph's new graph G. Note that at the time the event gets fired, the nodes from the node list are already part of graph G.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.PreEvent">
      <summary>
        <para>Type constant that signals the start of a some logically coherent event sequence. If specified, the data of this event is its ID.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.GraphEventType.PostEvent">
      <summary>
        <para>Type constant that signals the end of a some logically coherent event sequence. If specified, the data of this event is its ID.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.DistanceMetric">
      <seealso cref="M:yWorks.Algorithms.Groups.KMeansClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.DistanceMetric,System.Int32,System.Int32,yWorks.Algorithms.Geometry.YPoint[])" />
    </member>
    <member name="F:yWorks.Algorithms.DistanceMetric.Euclidean">
      <summary>
        <para>A specifier for euclidean distance metric.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Groups.KMeansClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.DistanceMetric,System.Int32,System.Int32,yWorks.Algorithms.Geometry.YPoint[])" />
    </member>
    <member name="F:yWorks.Algorithms.DistanceMetric.EuclideanSquared">
      <summary>
        <para>A specifier for euclidean squared distance metric.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Groups.KMeansClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.DistanceMetric,System.Int32,System.Int32,yWorks.Algorithms.Geometry.YPoint[])" />
    </member>
    <member name="F:yWorks.Algorithms.DistanceMetric.Manhattan">
      <summary>
        <para>A specifier for Manhattan distance metric.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Groups.KMeansClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.DistanceMetric,System.Int32,System.Int32,yWorks.Algorithms.Geometry.YPoint[])" />
    </member>
    <member name="F:yWorks.Algorithms.DistanceMetric.Chebychev">
      <summary>
        <para>A specifier for Chebychev distance metric.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Groups.KMeansClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.DistanceMetric,System.Int32,System.Int32,yWorks.Algorithms.Geometry.YPoint[])" />
    </member>
    <member name="T:yWorks.Algorithms.Linkage">
      <summary>
        <para>A specifier for single-linkage clustering.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,System.Int32,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage,System.Double)" />
    </member>
    <member name="F:yWorks.Algorithms.Linkage.Single">
      <summary>
        <para>A specifier for single-linkage clustering.</para>
        <para>At the beginning, each element belongs to its own cluster. At each step of the clustering algorithm the two most "similar" clusters are merged together until all nodes belong to the same cluster.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,System.Int32,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage,System.Double)" />
    </member>
    <member name="F:yWorks.Algorithms.Linkage.Complete">
      <summary>
        <para>A specifier for complete-linkage clustering.</para>
        <para>At the beginning, each element belongs to its own cluster. At each step of the clustering algorithm the two most "dissimilar" clusters are merged and the distance equals to the distance of those two nodes that are farthest away from each other. The algorithm continues until all nodes belong to the same cluster.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,System.Int32,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage,System.Double)" />
    </member>
    <member name="F:yWorks.Algorithms.Linkage.Average">
      <summary>
        <para>A specifier for average-linkage clustering.</para>
        <para>At the beginning, each element belongs to its own cluster. At each step of the clustering algorithm the two most "similar" clusters are combined and the distance between them is defined as the average all distances between the nodes that belong to the two clusters that are combined. The algorithm continues until all nodes belong to the same cluster.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,System.Int32,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage,System.Double)" />
    </member>
    <member name="T:yWorks.Algorithms.Geometry.AffineLine">
      <summary>
        <para>This class represents a line in the 2D-dimensional affine space.</para>
      </summary>
      <remarks>
        <para>The line is defined by the equation ax + by + c = 0</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.AffineLine.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Creates an affine line which is defined by a point and a vector.</para>
      </summary>
      <param name="p1" />
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.AffineLine.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Creates an affine line which is defined by two points.</para>
      </summary>
      <param name="p1" />
      <param name="p2" />
    </member>
    <member name="P:yWorks.Algorithms.Geometry.AffineLine.A">
      <summary>
        <para>Gets a from ax+by+c = 0</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.AffineLine.B">
      <summary>
        <para>Gets b from ax+by+c = 0</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.AffineLine.C">
      <summary>
        <para>Gets c from ax+by+c = 0</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.AffineLine.ToString">
      <summary>
        <para>Returns the equation of the line as String</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.AffineLine.GetXProjection(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Projects an point on the line in direction of the X-axis.</para>
      </summary>
      <param name="p" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.AffineLine.GetYProjection(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Projects an point on the line in direction of the Y-axis.</para>
      </summary>
      <param name="p" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.AffineLine.GetCrossing(yWorks.Algorithms.Geometry.AffineLine,yWorks.Algorithms.Geometry.AffineLine)">
      <summary>
        <para>Returns the crossing of two lines.</para>
      </summary>
      <remarks>
        <para>If the lines are parallel, <c>null</c> is returned.</para>
      </remarks>
      <param name="l1" />
      <param name="l2" />
    </member>
    <member name="T:yWorks.Algorithms.Geometry.BorderLine">
      <summary>
        <para>This class can be used to easily model an orthogonal border line or sky-line.</para>
      </summary>
      <remarks>
        <para>It provides methods for measuring the distance between different BorderLine instances, merging multiple instances, modifying and efficiently moving them around.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.#ctor(System.Double)">
      <summary>
        <para>Creates a new BorderLine with the given value from -Double.MAX_VALUE to Double.MAX_VALUE.</para>
      </summary>
      <param name="value">
        <para>the value of the segment</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.#ctor(System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new BorderLine from a single segment.</para>
      </summary>
      <param name="min">
        <para>the beginning of this borderline</para>
      </param>
      <param name="max">
        <para>the ending of this borderline</para>
      </param>
      <param name="value">
        <para>the value of the segment</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new BorderLine from a single segment.</para>
      </summary>
      <param name="min">
        <para>the beginning of this borderline</para>
      </param>
      <param name="max">
        <para>the ending of this borderline</para>
      </param>
      <param name="valueAtMin">
        <para>the value of the segment at the beginning of this borderline</para>
      </param>
      <param name="valueAtMax">
        <para>the value of the segment at the ending of this borderline</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.CreateCopy(System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a copy of this borderline.</para>
      </summary>
      <remarks>
        <para>Optionally negates the values or offsets.</para>
      </remarks>
      <param name="negateValues">
        <para>whether the values are negated</para>
      </param>
      <param name="negateOffsets">
        <para>whether the offsets are negated</para>
      </param>
      <returns>
        <para>the copy of the borderline</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.SetMinValue(System.Double,System.Double,System.Double)">
      <summary>
        <para>Assures that all values in the given interval are less or equal than the given value.</para>
      </summary>
      <param name="min">
        <para>the lower end of the interval</para>
      </param>
      <param name="max">
        <para>the upper end of the interval</para>
      </param>
      <param name="value">
        <para>the greatest possible value for the interval</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.SetMaxValue(System.Double,System.Double,System.Double)">
      <summary>
        <para>Assures that all values in the given interval are greater or equal than the given value.</para>
      </summary>
      <param name="min">
        <para>the lower end of the interval</para>
      </param>
      <param name="max">
        <para>the upper end of the interval</para>
      </param>
      <param name="value">
        <para>the smallest possible value for the interval</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.AdoptValues(yWorks.Algorithms.Geometry.BorderLine)">
      <summary>
        <para>Convenience method that copies the actual data from the given argument to this instance.</para>
      </summary>
      <param name="other">
        <para>the argument to retrieve the values from</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.SetValue(System.Double,System.Double,System.Double)">
      <summary>
        <para>Sets a specific interval described by <c>min</c> and <c>max</c> to a given value.</para>
      </summary>
      <param name="min">
        <para>the left side of the interval.</para>
      </param>
      <param name="max">
        <para>the right side of the interval.</para>
      </param>
      <param name="value">
        <para>the value for the whole interval.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.SetSloped(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Sets a specific interval to a slope starting at a given value.</para>
      </summary>
      <param name="min">
        <para>the left side of the interval.</para>
      </param>
      <param name="max">
        <para>the right side of the interval.</para>
      </param>
      <param name="value">
        <para>the value at <c>min</c> where the slope starts.</para>
      </param>
      <param name="slope">
        <para>the slope of the segment in the given interval.</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if <c>min</c> is greater than <c>max</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.AddValueOffset(System.Double)">
      <summary>
        <para>Adds the given offset to the current values of the whole borderline.</para>
      </summary>
      <remarks>
        <para>This method has complexity O(1).</para>
      </remarks>
      <param name="delta">
        <para>the delta to add to the values</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.AddOffset(System.Double)">
      <summary>
        <para>Adds the given offset to the segments' positions.</para>
      </summary>
      <remarks>
        <para>This method has complexity O(1).</para>
      </remarks>
      <param name="delta">
        <para>the delta to add to the positions</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.BorderLine.Min">
      <summary>
        <para>Gets the smallest position of this borderline</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.BorderLine.Max">
      <summary>
        <para>Gets the greatest position of this borderline</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.BorderLine.MinValue">
      <summary>
        <para>Gets the minimum value that is set on this borderline</para>
      </summary>
      <value>
        <para>the value</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.BorderLine.MaxValue">
      <summary>
        <para>Gets the maximum value that is set on this borderline</para>
      </summary>
      <value>
        <para>the value</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetValueAt(System.Double)">
      <summary>
        <para>Returns the value that is set on this borderline at the specified position.</para>
      </summary>
      <param name="pos">
        <para>the position</para>
      </param>
      <returns>
        <para>the value</para>
      </returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <para>if the position is outside of the borderline.</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetValueAt(yWorks.Algorithms.ListCell,System.Double)">
      <summary>
        <para>Returns the value that is set on this borderline at the specified position.</para>
      </summary>
      <remarks>
        <para>The position must lie within the range of the segment that is stored in <c>cell</c>.</para>
      </remarks>
      <param name="cell">
        <para>The list cell containing the segment whose value shall be returned.</para>
      </param>
      <param name="pos">
        <para>the position</para>
      </param>
      <returns>
        <para>the value</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if <c>pos</c> is outside the segment's range that is stored in <c>cell</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetValueAt(yWorks.Algorithms.Geometry.BorderLine.Segment,System.Double)">
      <summary>
        <para>Returns the value that is set on this borderline at the specified position.</para>
      </summary>
      <remarks>
        <para>The position must lie within the range of the segment.</para>
      </remarks>
      <param name="segment">
        <para>The segment whose value shall be returned.</para>
      </param>
      <param name="pos">
        <para>the position where the value will be retrieved.</para>
      </param>
      <returns>
        <para>the value</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if <c>pos</c> is outside the segment's range.</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.CreateMax(yWorks.Algorithms.Geometry.BorderLine)">
      <summary>
        <para>Merges this borderline with the given borderline using the "maximum" policy.</para>
      </summary>
      <remarks>
        <para>That means the resulting borderline will have greater value of both borderline on each position. If you imagine each borderline as a the upper border of a plane, the resulting borderline will be the upper border of the merged planes.</para>
      </remarks>
      <param name="other">
        <para>the other borderline</para>
      </param>
      <returns>
        <para>a new borderline that is the result of the merge</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.CreateMin(yWorks.Algorithms.Geometry.BorderLine)">
      <summary>
        <para>Merges this borderline with the given borderline using the "minimum" policy.</para>
      </summary>
      <remarks>
        <para>That means the resulting borderline will have smaller value of both borderline on each position. If you imagine each borderline as a the lower border of a plane, the resulting borderline will be the lower border of the merged planes.</para>
      </remarks>
      <param name="other">
        <para>the other borderline</para>
      </param>
      <returns>
        <para>a new borderline that is the result of the merge</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.MergeWithMax(yWorks.Algorithms.Geometry.BorderLine)">
      <summary>
        <para>Merges this borderline with the given borderline using the "maximum" policy.</para>
      </summary>
      <param name="other">
        <para>the other borderline</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.MergeWithMin(yWorks.Algorithms.Geometry.BorderLine)">
      <summary>
        <para>Merges this borderline with the given borderline using the "minimum" policy.</para>
      </summary>
      <param name="other">
        <para>the other borderline</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetValue(yWorks.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
        <para>Returns the value of the minimum of the given segment.</para>
      </summary>
      <remarks>
        <para>If the segment's slope is 0, it's the value of the whole segment. In case the slope differs from 0, it's the value of the start of the slope.</para>
      </remarks>
      <param name="s">
        <para>the segment</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetMin(yWorks.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
        <para>Returns the minimum position of the given segment.</para>
      </summary>
      <param name="s">
        <para>the segment</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetSlope(yWorks.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
        <para>Returns the slope of the given segment.</para>
      </summary>
      <param name="s">
        <para>the segment</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetSegmentAt(System.Double)">
      <summary>
        <para>Returns the segment at the given position.</para>
      </summary>
      <param name="pos">
        <para>the position</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetMax(yWorks.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
        <para>Returns the maximum position of the given segment.</para>
      </summary>
      <param name="s">
        <para>the segment</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.FirstSegment">
      <summary>
        <para>Returns the first segment or <c>null</c> if there is no such segment.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.LastSegment">
      <summary>
        <para>Returns the last segment or <c>null</c> if there is no such segment.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.Prev(yWorks.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
        <para>Returns the previous segment or <c>null</c> if there is no such segment.</para>
      </summary>
      <param name="s" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.Next(yWorks.Algorithms.Geometry.BorderLine.Segment)">
      <summary>
        <para>Returns the next segment or <c>null</c> if there is no such segment.</para>
      </summary>
      <param name="s" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetMaxValue(System.Double,System.Double)">
      <summary>
        <para>Calculates the maximum value in the interval from-&gt;to.</para>
      </summary>
      <param name="from" />
      <param name="to" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetMinValue(System.Double,System.Double)">
      <summary>
        <para>Calculates the minimum value in the interval from-&gt;to.</para>
      </summary>
      <param name="from" />
      <param name="to" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.GetDistanceTo(yWorks.Algorithms.Geometry.BorderLine)">
      <summary>
        <para>Calculates the minimal distance between this borderline and the other one.</para>
      </summary>
      <remarks>
        <para>The other one is treated as if the values were all greater.</para>
      </remarks>
      <param name="greater" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.ToString">
      <summary>
        <para>Returns a lengthy String representation of this borderline.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.Grow(System.Double,System.Double,System.Boolean)">
      <summary>
        <para>Grows this BorderLine horizontally, so that the <see cref="M:yWorks.Algorithms.Geometry.BorderLine.GetValueAt(yWorks.Algorithms.Geometry.BorderLine.Segment,System.Double)">values</see> of the BorderLine stay the same however their <see cref="M:yWorks.Algorithms.Geometry.BorderLine.GetMin(yWorks.Algorithms.Geometry.BorderLine.Segment)">start</see> and <see cref="M:yWorks.Algorithms.Geometry.BorderLine.GetMax(yWorks.Algorithms.Geometry.BorderLine.Segment)">end</see> points are moved in the direction of <c>toMin</c> and <c>toMax</c>.</para>
      </summary>
      <remarks>
        <para>This is useful for scenarios where a BorderLine is needed that consists of an enlarged border.</para>
        <para>Note that this method normalizes the segments, i.e., it transforms each segment with slope != 0 to a segment with slope == 0.</para>
      </remarks>
      <param name="toMin">
        <para>the delta by which the border should be extended towards -Infinity</para>
      </param>
      <param name="toMax">
        <para>the delta by which the border should be extended towards +Infinity</para>
      </param>
      <param name="positive">
        <para>whether the BorderLine should be interpreted to point in positive direction. This influences the direction into which a segment's border is extended.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.BorderLine.Segment">
      <summary>
        <para>The handle of a segment of a borderline.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.Segment.GetValueAt(System.Double)">
      <summary>
        <para>Returns the segment's value at the given position.</para>
      </summary>
      <remarks>
        <para>Note: In case the position lies outside the segments range, the calculated value might be invalid. As the segment is not aware of any offsets the position also must not include any offsets.</para>
      </remarks>
      <param name="position">
        <para>the position the value is retrieved for.</para>
      </param>
      <returns>
        <para>the segment's value at the given position.</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.BorderLine.Segment.End">
      <summary>
        <para>Gets the end of this segment.</para>
      </summary>
      <value>
        <para>the end of this segment.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.Segment.Prev">
      <summary>
        <para>Returns the previous segment or <c>null</c> if there is no such segment.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.Segment.Next">
      <summary>
        <para>Returns the next segment or <c>null</c> if there is no such segment.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.BorderLine.Segment.ToString" />
    <member name="T:yWorks.Algorithms.Geometry.Geom">
      <summary>
        <para>This class provides useful geometric primitives and advanced geometric algorithms.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.Orientation(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Returns the orientation of point <c>r</c> relative to the directed line from point <c>p</c> to point <c>q</c>.</para>
      </summary>
      <remarks>
        <para>The given tuple of points is said to have positive orientation if <c>p</c> and <c>q</c> are distinct and <c>r</c> lies to the left of the oriented line passing through <c>p</c> and <c>q</c> and oriented from <c>p</c> to <c>q</c>.</para>
        <para>The tuple is said to have negative orientation if <c>p</c> and <c>q</c> are distinct and <c>r</c> lies to the right of the line, and the tuple is said to have orientation zero if the three points are collinear.</para>
      </remarks>
      <returns>
        <para>
          <b>+1</b> in the case of positive orientation, <b>-1</b> in the case of negative orientation and <b>0</b> in the case of zero orientation.</para>
      </returns>
      <param name="p" />
      <param name="q" />
      <param name="r" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.Orientation(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Same as <see cref="M:yWorks.Algorithms.Geometry.Geom.Orientation(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)" /> with double values as arguments.</para>
      </summary>
      <param name="px" />
      <param name="py" />
      <param name="qx" />
      <param name="qy" />
      <param name="rx" />
      <param name="ry" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.LeftTurn(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Same as <see cref="M:yWorks.Algorithms.Geometry.Geom.Orientation(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">orientation(p,q,r) &gt; 0</see></para>
      </summary>
      <param name="p" />
      <param name="q" />
      <param name="r" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.RightTurn(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Same as <see cref="M:yWorks.Algorithms.Geometry.Geom.Orientation(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">orientation(p,q,r) &lt; 0</see></para>
      </summary>
      <param name="p" />
      <param name="q" />
      <param name="r" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.Collinear(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Returns <c>true</c> iff the given points are collinear, i.e.</para>
      </summary>
      <remarks>
        <para>all three points lie on a common line.</para>
        <para>Same as <see cref="M:yWorks.Algorithms.Geometry.Geom.Orientation(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">orientation(p,q,r) == 0</see></para>
      </remarks>
      <param name="p" />
      <param name="q" />
      <param name="r" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.SideOfCircle(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Returns +1 if point <c>d</c> lies left of the directed circle through points <c>a</c>, <c>b</c>, and <c>c</c>, 0 if <c>a,b,c</c> and <c>d</c> are cocircular, and -1 otherwise.</para>
      </summary>
      <param name="a" />
      <param name="b" />
      <param name="c" />
      <param name="d" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.CalcConvexHull(yWorks.Algorithms.YList)">
      <summary>
        <para>Calculates the convex hull for a set of points.</para>
      </summary>
      <param name="points">
        <para>a list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" /> objects</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" /> objects that constitute the convex hull of the given points. The list contains points in counter clockwise order around the hull. The first point is the one with the smallest <c>x</c> coordinate. If two such points exist then of these points the one with the smallest <c>y</c> coordinate is chosen as the first one.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.ToRadians(System.Double)">
      <summary>
        <para>Converts the given degree value from angular to radian.</para>
      </summary>
      <param name="angdeg" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.ToDegrees(System.Double)">
      <summary>
        <para>Converts the given degree value from radian to angular</para>
      </summary>
      <param name="angrad" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.CalcIntersection(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YVector,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Calculates the intersection point of two affine lines.</para>
      </summary>
      <remarks>
        <para>Each line is given by a point and a direction vector.</para>
      </remarks>
      <param name="p1">
        <para>origin point of the first line.</para>
      </param>
      <param name="d1">
        <para>direction vector of the first line.</para>
      </param>
      <param name="p2">
        <para>origin point of the second line.</para>
      </param>
      <param name="d2">
        <para>direction vector of the second line.</para>
      </param>
      <returns>
        <para>the intersection point of the specified lines or <c>null</c> if there is no intersection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.CalcIntersection(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Calculates the intersection point of two <b>affine</b> lines.</para>
      </summary>
      <remarks>
        <para>Each line is given by two points.</para>
      </remarks>
      <param name="p1">
        <para>one point on the first line.</para>
      </param>
      <param name="p2">
        <para>another point on the first line.</para>
      </param>
      <param name="p3">
        <para>one point on the second line.</para>
      </param>
      <param name="p4">
        <para>another point on the second line.</para>
      </param>
      <returns>
        <para>the intersection point of the specified lines or <c>null</c> if there is no intersection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.CalcIntersection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Calculates the intersection point of two <b>affine</b> lines.</para>
      </summary>
      <remarks>
        <para>Each line is given by the coordinates of two points.</para>
      </remarks>
      <param name="x1">
        <para>x-coordinate of one point on the first line.</para>
      </param>
      <param name="y1">
        <para>y-coordinate of one point on the first line.</para>
      </param>
      <param name="x2">
        <para>x-coordinate of another point on the first line.</para>
      </param>
      <param name="y2">
        <para>y-coordinate of another point on the first line.</para>
      </param>
      <param name="x3">
        <para>x-coordinate of one point on the second line.</para>
      </param>
      <param name="y3">
        <para>y-coordinate of one point on the second line.</para>
      </param>
      <param name="x4">
        <para>x-coordinate of another point on the second line.</para>
      </param>
      <param name="y4">
        <para>y-coordinate of another point on the second line.</para>
      </param>
      <returns>
        <para>the intersection point of the specified lines or <c>null</c> if there is no intersection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.LinesIntersect(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Returns whether the two lines defined by the given coordinates intersect or not.</para>
      </summary>
      <param name="x1" />
      <param name="y1" />
      <param name="x2" />
      <param name="y2" />
      <param name="x3" />
      <param name="y3" />
      <param name="x4" />
      <param name="y4" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.Projection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Determines the projection of the point <c>p</c> onto the line segment <c>[l1, l2]</c>.</para>
      </summary>
      <remarks>
        <para>The resulting point is</para>
        <list type="bullet">
          <item>the orthogonal projection of <c>p</c> onto the line through <c>l1</c> and <c>l2</c>, iff the projection lies on the line segment <c>[l1, l2]</c></item>
          <item>the end point of the line segment <c>[l1, l2]</c> that is closest to <c>p</c>, otherwise</item>
        </list>
      </remarks>
      <param name="pointX">
        <para>the x coordinate of p</para>
      </param>
      <param name="pointY">
        <para>the y coordinate of p</para>
      </param>
      <param name="lineX1">
        <para>the x coordinate of l1</para>
      </param>
      <param name="lineY1">
        <para>the y coordinate of l1</para>
      </param>
      <param name="lineX2">
        <para>the x coordinate of l2</para>
      </param>
      <param name="lineY2">
        <para>the y coordinate of l2</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.DistanceToLineSegment(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Determines the distance of the point <c>p</c> to the line segment <c>[l1, l2]</c>.</para>
      </summary>
      <param name="pointX">
        <para>the x coordinate of p</para>
      </param>
      <param name="pointY">
        <para>the y coordinate of p</para>
      </param>
      <param name="lineX1">
        <para>the x coordinate of l1</para>
      </param>
      <param name="lineY1">
        <para>the y coordinate of l1</para>
      </param>
      <param name="lineX2">
        <para>the x coordinate of l2</para>
      </param>
      <param name="lineY2">
        <para>the y coordinate of l2</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.CalcUnion(yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Unions the pair of source <c>Rectangle2D</c> objects and puts the result into the specified destination <c>Rectangle2D</c> object.</para>
      </summary>
      <remarks>
        <para>If one of the source rectangles has negative width or height, it is excluded from the union. If both source rectangles have negative width or height, the destination rectangle will become a copy of <c>r1</c>. One of the source rectangles can also be the destination to avoid creating a third Rectangle2D object, but in this case the original points of this source rectangle will be overwritten by this method. If the destination is <c>null</c>, a new <c>Rectangle2D</c> is created.</para>
      </remarks>
      <param name="r1">
        <para>the first of a pair of <c>Rectangle2D</c> objects to be combined with each other</para>
      </param>
      <param name="r2">
        <para>the second of a pair of <c>Rectangle2D</c> objects to be combined with each other</para>
      </param>
      <param name="dest">
        <para>the <c>Rectangle2D</c> that holds the results of the union of <c>r1</c> and <c>r2</c></para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Geom.CalcIntersection(yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Intersects the pair of specified source <c>Rectangle2D</c> objects and puts the result into the specified destination <c>Rectangle2D</c> object.</para>
      </summary>
      <remarks>
        <para>If one or both of the source rectangles have negative width or height, the resulting rectangle will be located at (0,0) with a width and height of -1. One of the source rectangles can also be the destination to avoid creating a third Rectangle2D object, but in this case the original points of this source rectangle will be overwritten by this method.</para>
      </remarks>
      <param name="r1">
        <para>the first of a pair of <c>Rectangle2D</c> objects to be intersected with each other</para>
      </param>
      <param name="r2">
        <para>the second of a pair of <c>Rectangle2D</c> objects to be intersected with each other</para>
      </param>
      <param name="dest">
        <para>the <c>Rectangle2D</c> that holds the results of the intersection of <c>r1</c> and <c>r2</c></para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.ILineSegmentCursor">
      <summary>
        <para>This is an interface for a sequence of instances of LineSegment.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.ILineSegmentCursor.LineSegment">
      <summary>
        <para>Gets the instance of LineSegment the cursor is currently pointing on.</para>
      </summary>
      <value>
        <para>an instance of LineSegment</para>
      </value>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.IPlaneObject">
      <summary>
        <para>This interface describes a 2-dimensional object which has a finite bounding box.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.IPlaneObject.BoundingBox">
      <summary>
        <para>Gets the smallest Rectangle which contains the object.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.IPointCursor">
      <summary>
        <para>This is an interface for a sequence of instances of YPoint.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.IPointCursor.Point">
      <summary>
        <para>Gets the instance of YPoint the cursor is currently pointing on.</para>
      </summary>
      <value>
        <para>an instance of YPoint</para>
      </value>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.Insets">
      <summary>
        <para>Double-precision immutable insets representation.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.Geometry.Insets.top">
      <summary>
        <para>The inset from the top.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.Geometry.Insets.left">
      <summary>
        <para>The inset from the left.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.Geometry.Insets.bottom">
      <summary>
        <para>The inset from the bottom.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.Geometry.Insets.right">
      <summary>
        <para>The inset from the right.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Insets.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new instance with the given values</para>
      </summary>
      <param name="top">
        <para>The new top inset value</para>
      </param>
      <param name="left">
        <para>The new left inset value</para>
      </param>
      <param name="bottom">
        <para>The new bottom inset value</para>
      </param>
      <param name="right">
        <para>The new right inset value</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Insets.GetHashCode" />
    <member name="M:yWorks.Algorithms.Geometry.Insets.Equals(System.Object)">
      <summary>
        <para>Returns whether this insets object and <c>o</c> are equal.</para>
      </summary>
      <remarks>
        <para>Two insets are considered equal if the have the same values for each side.</para>
      </remarks>
      <param name="o">
        <para>The object to test for equality</para>
      </param>
      <returns>
        <para>
          <c>true</c> if both objects are equal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Insets.Clone" />
    <member name="M:yWorks.Algorithms.Geometry.Insets.ToString" />
    <member name="T:yWorks.Algorithms.Geometry.IntersectionAlgorithm">
      <summary>
        <para>This class calculates the intersection of rectangles in the plane with the help of a sweep-line algorithm.</para>
      </summary>
      <remarks>
        <para>
          <br /> The complexity is <c>O(n log n + s)</c> where <c>n</c> is the number of rectangles and <c>s</c> the number of intersections.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.IntersectionAlgorithm.Intersect(yWorks.Algorithms.YList,yWorks.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler)">
      <summary>
        <para>Calculates the intersections of rectangles in the plane.</para>
      </summary>
      <remarks>
        <para>Every found intersection is reported to an <c>IntersectionHandler</c>. Rectangles with negative size are completely ignored by this implementation (i.e. never generate intersections)</para>
      </remarks>
      <param name="objects">
        <para>a list of <c>PlaneObject</c> objects.</para>
      </param>
      <param name="iHandler">
        <para>intersections are reported to this class.</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler">
      <summary>
        <para>An instance of this interface handles intersections found by the <c>IntersectionAlgorithm</c>,</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.IntersectionAlgorithm.IIntersectionHandler.CheckIntersection(System.Object,System.Object)">
      <summary>
        <para>This method is called at every intersection.</para>
      </summary>
      <param name="a" />
      <param name="b" />
    </member>
    <member name="T:yWorks.Algorithms.Geometry.LineSegment">
      <summary>
        <para>This class represents a line segment in the plane.</para>
      </summary>
      <remarks>
        <para>A line segment is defined by its two end points.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Returns a new LineSegment.</para>
      </summary>
      <param name="p1">
        <para>the first end point of the line segment.</para>
      </param>
      <param name="p2">
        <para>the second end point of the line segment.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.IsVertical">
      <summary>
        <para>Gets if this segment is considered vertical, i.e.</para>
      </summary>
      <remarks>
        <para>the x values of the end point differ less then 0.00000001</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this segment is considered vertical, <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.IsVerticalSegment(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Determines if the given points define a vertical line segment.</para>
      </summary>
      <remarks>
        <para>This methods allows for x-coordinate differences of up to 1e-8.</para>
      </remarks>
      <returns>
        <para>
          <c>true</c> if the given points define a vertical line segment; <c>false</c> otherwise.</para>
      </returns>
      <param name="p1" />
      <param name="p2" />
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.IsHorizontal">
      <summary>
        <para>Gets if the interval is horizontal.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the interval is horizontal, <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.IsHorizontalSegment(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Determines if the given points define a horizontal line segment.</para>
      </summary>
      <remarks>
        <para>This methods allows for y-coordinate differences of up to 1e-8.</para>
      </remarks>
      <returns>
        <para>
          <c>true</c> if the given points define a horizontal line segment; <c>false</c> otherwise.</para>
      </returns>
      <param name="p1" />
      <param name="p2" />
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.FirstEndPoint">
      <summary>
        <para>Gets the first end point of the line segment.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.SecondEndPoint">
      <summary>
        <para>Gets the second end point of the line segment.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.IsInYIntervall(System.Double)">
      <summary>
        <para>Returns if the projection on the Y axis of the line segment covers a certain point on the Y Axis.</para>
      </summary>
      <param name="y" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.IsInXIntervall(System.Double)">
      <summary>
        <para>Returns if the projection on the X axis of the line segment covers a certain point on the X Axis.</para>
      </summary>
      <param name="x" />
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.XOffset">
      <summary>
        <para>Gets the y value of the line on x coordinate 0.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.Slope">
      <summary>
        <para>Gets the slope of the line segment.</para>
      </summary>
      <value>
        <para>the slope of the line segment.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.Length">
      <summary>
        <para>Returns the length of the line segment, this is the value of the Euclidean norm.</para>
      </summary>
      <returns>
        <para>an value &gt; 0.</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.BoundingBox">
      <summary>
        <para>Gets the smallest Rectangle which contains the object.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.Intersects(yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Checks whether the line segment intersects a box.</para>
      </summary>
      <param name="box">
        <para>A rectangle.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the line segments intersects the box, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.Contains(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Checks whether a given point lies on this line segment.</para>
      </summary>
      <param name="point">
        <para>an arbitrary point.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the line segments intersects the box, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.Intersects(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Checks whether the line segment intersects a point.</para>
      </summary>
      <param name="p">
        <para>a point</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the line segments intersects the given point, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.BoxIntersectsSegment(yWorks.Algorithms.Geometry.YRectangle,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Checks whether a line segment intersects a box.</para>
      </summary>
      <param name="box">
        <para>A rectangle.</para>
      </param>
      <param name="s">
        <para>first end point of the line segment.</para>
      </param>
      <param name="t">
        <para>second end point of the line segment.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the line segments intersects the box, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.BoxIntersectsSegment(yWorks.Algorithms.Geometry.YRectangle,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Checks whether a line segment intersects a box.</para>
      </summary>
      <remarks>
        <para>Implemented using the Cohen-Sutherland algorithm.</para>
      </remarks>
      <param name="box">
        <para>A rectangle</para>
      </param>
      <param name="x1">
        <para>x-coordinate of the first end point of the line segment</para>
      </param>
      <param name="y1">
        <para>y-coordinate of the first end point of the line segment</para>
      </param>
      <param name="x2">
        <para>x-coordinate of the second end point of the line segment</para>
      </param>
      <param name="y2">
        <para>y-coordinate of the second end point of the line segment</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the line segment intersects the box, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.BoxIntersectsSegment(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Checks whether a line segment intersects a paraxial box.</para>
      </summary>
      <remarks>
        <para>Implemented using the Cohen-Sutherland algorithm.</para>
      </remarks>
      <param name="boxX1">
        <para>x-coordinate of the upper left corner of the box</para>
      </param>
      <param name="boxY1">
        <para>y-coordinate of the upper left corner of the box</para>
      </param>
      <param name="boxX2">
        <para>x-coordinate of the lower right corner of the box</para>
      </param>
      <param name="boxY2">
        <para>y-coordinate of the lower right corner of the box</para>
      </param>
      <param name="sX1">
        <para>x-coordinate of the first end point of the line segment</para>
      </param>
      <param name="sY1">
        <para>y-coordinate of the first end point of the line segment</para>
      </param>
      <param name="sX2">
        <para>x-coordinate of the second end point of the line segment</para>
      </param>
      <param name="sY2">
        <para>y-coordinate of the second end point of the line segment</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the line segment intersects the box, <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.GetIntersection(yWorks.Algorithms.Geometry.LineSegment,yWorks.Algorithms.Geometry.LineSegment)">
      <summary>
        <para>Returns intersection point between the two line segments, if there is one or <c>null</c> if the two line segments do not intersect.</para>
      </summary>
      <param name="s1">
        <para>first line segment</para>
      </param>
      <param name="s2">
        <para>second line segment</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.ToYVector">
      <summary>
        <para>Returns the vector pointing from the first end point to the second end point of the line segment.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.ToAffineLine">
      <summary>
        <para>Returns the affine line defined by the end points of the line segment.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.DeltaX">
      <summary>
        <para>Gets the distance from start to end point in x-coordinates.</para>
      </summary>
      <value>
        <para>the distance from start to end point in x-coordinates.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.LineSegment.DeltaY">
      <summary>
        <para>Gets the distance from start to end point in y-coordinates.</para>
      </summary>
      <value>
        <para>the distance from start to end point in y-coordinates.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.LineSegment.ToString">
      <summary>
        <para>String representation of the line.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.Point2D">
      <summary>
        <para>Represents a two-dimensional point located at <c>(x, y)</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.#ctor">
      <summary>
        <para>Creates a new instance that is located at <c>(0, 0)</c></para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new instance at the given location.</para>
      </summary>
      <param name="x">
        <para>The x coordinate of the new point</para>
      </param>
      <param name="y">
        <para>The x coordinate of the new point</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.SetLocation(System.Double,System.Double)">
      <summary>
        <para>Sets the location of this point to the given coordinates.</para>
      </summary>
      <param name="x">
        <para>the new x coordinate</para>
      </param>
      <param name="y">
        <para>the new y coordinate</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Point2D.Location">
      <summary>
        <para>Sets the location of this point to the same values as for the given point.</para>
      </summary>
      <value>
        <para>point whose coordinates are used</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.ToString" />
    <member name="M:yWorks.Algorithms.Geometry.Point2D.DistanceSq(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Calculates the squared distance between two points, given as their coordinates.</para>
      </summary>
      <param name="x1">
        <para>The x coordinate of the first point.</para>
      </param>
      <param name="y1">
        <para>The y coordinate of the first point.</para>
      </param>
      <param name="x2">
        <para>The x coordinate of the second point.</para>
      </param>
      <param name="y2">
        <para>The y coordinate of the second point.</para>
      </param>
      <returns>
        <para>the squared distance between two points, given as their coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.Distance(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Calculates the distance between two points, given as their coordinates.</para>
      </summary>
      <param name="x1">
        <para>The x coordinate of the first point.</para>
      </param>
      <param name="y1">
        <para>The y coordinate of the first point.</para>
      </param>
      <param name="x2">
        <para>The x coordinate of the second point.</para>
      </param>
      <param name="y2">
        <para>The y coordinate of the second point.</para>
      </param>
      <returns>
        <para>the distance between two points, given as their coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.DistanceSq(System.Double,System.Double)">
      <summary>
        <para>Calculates the squared distance between this points and another one, given as its coordinates.</para>
      </summary>
      <param name="px">
        <para>The x coordinate of the second point.</para>
      </param>
      <param name="py">
        <para>The y coordinate of the second point.</para>
      </param>
      <returns>
        <para>the squared distance between this points and another one, given as its coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.DistanceSq(yWorks.Algorithms.Geometry.Point2D)">
      <summary>
        <para>Calculates the squared distance between this points and another one.</para>
      </summary>
      <param name="p">
        <para>The second point.</para>
      </param>
      <returns>
        <para>the squared distance between this points and another one.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.Distance(System.Double,System.Double)">
      <summary>
        <para>Calculates the distance between this points and another one, given as its coordinates.</para>
      </summary>
      <param name="px">
        <para>The x coordinate of the second point.</para>
      </param>
      <param name="py">
        <para>The y coordinate of the second point.</para>
      </param>
      <returns>
        <para>the distance between this points and another one, given as its coordinates.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.Distance(yWorks.Algorithms.Geometry.Point2D)">
      <summary>
        <para>Calculates the distance between this points and another one.</para>
      </summary>
      <param name="p">
        <para>The second point.</para>
      </param>
      <returns>
        <para>the distance between this points and another one.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.GetHashCode" />
    <member name="M:yWorks.Algorithms.Geometry.Point2D.Equals(System.Object)">
      <summary>
        <para>Returns whether this point and <c>obj</c> are equal.</para>
      </summary>
      <remarks>
        <para>Two points are considered equal if the have the same location.</para>
      </remarks>
      <param name="obj">
        <para>The object to test for equality</para>
      </param>
      <returns>
        <para>
          <c>true</c> if both objects are equal.</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Point2D.X">
      <summary>
        <para>Gets the x coordinate of this point.</para>
      </summary>
      <value>
        <para>the x coordinate of this point.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Point2D.Y">
      <summary>
        <para>Gets the y coordinate of this point.</para>
      </summary>
      <value>
        <para>the y coordinate of this point.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Point2D.Clone">
      <summary>
        <para>Creates a new instance of this class that has the same values as this objects.</para>
      </summary>
      <returns>
        <para>a new instance of this class that has the same values as this objects.</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.Rectangle2D">
      <summary>
        <para>Represents a two-dimensional rectangle of size <c>(width x height)</c>, located at the point <c>(x, y)</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.#ctor">
      <summary>
        <para>Creates a new rectangle of size <c>(0 x 0)</c> at the location <c>(0, 0)</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new rectangle of the specified size at the specified location.</para>
      </summary>
      <param name="x">
        <para>the x-coordinate of the upper left corner of the created rectangle.</para>
      </param>
      <param name="y">
        <para>the y-coordinate of the upper left corner of the created rectangle.</para>
      </param>
      <param name="width">
        <para>the width of the created rectangle.</para>
      </param>
      <param name="height">
        <para>the height of the created rectangle.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.Frame">
      <summary>
        <para>Gets or sets the outer bounds of this rectangle in double coordinates.</para>
      </summary>
      <value>
        <para>a new double-precision rectangle which represents the outer bounds of this rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.SetFrameFromDiagonal(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Sets the outer bounds of this rectangle based on the end points of one of its diagonals.</para>
      </summary>
      <param name="x1">
        <para>the x-coordinate of the first end point of a diagonal.</para>
      </param>
      <param name="y1">
        <para>the y-coordinate of the first end point of a diagonal.</para>
      </param>
      <param name="x2">
        <para>the x-coordinate of the other end point of a diagonal.</para>
      </param>
      <param name="y2">
        <para>the y-coordinate of the other end point of a diagonal.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.SetFrameFromDiagonal(yWorks.Algorithms.Geometry.Point2D,yWorks.Algorithms.Geometry.Point2D)">
      <summary>
        <para>Sets the outer bounds of this rectangle based on the end points of one of its diagonals.</para>
      </summary>
      <param name="p1">
        <para>the first end point of a diagonal.</para>
      </param>
      <param name="p2">
        <para>the other end point of a diagonal.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.SetFrameFromCenter(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Sets the outer bounds of this rectangle based on the specified new center and corner.</para>
      </summary>
      <param name="centerX">
        <para>the x-coordinate of the new center of this rectangle.</para>
      </param>
      <param name="centerY">
        <para>the y-coordinate of the new center of this rectangle.</para>
      </param>
      <param name="cornerX">
        <para>the x-coordinate of any new corner of this rectangle.</para>
      </param>
      <param name="cornerY">
        <para>the y-coordinate of any new corner of this rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.SetFrameFromCenter(yWorks.Algorithms.Geometry.Point2D,yWorks.Algorithms.Geometry.Point2D)">
      <summary>
        <para>Sets the outer bounds of this rectangle based on the specified new center and corner.</para>
      </summary>
      <param name="center">
        <para>the new center of this rectangle.</para>
      </param>
      <param name="corner">
        <para>any new corner of this rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.SetFrame(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Sets the outer bounds of this rectangle based on the specified location and size.</para>
      </summary>
      <param name="x">
        <para>the new x-coordinate of the upper left corner.</para>
      </param>
      <param name="y">
        <para>the new y-coordinate of the upper left corner.</para>
      </param>
      <param name="width">
        <para>the new width.</para>
      </param>
      <param name="height">
        <para>the new height.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.Rect">
      <summary>
        <para>Sets the location and size of this rectangle to be similar to the specified rectangle.</para>
      </summary>
      <value>
        <para>a rectangle that specifies the new location and size of this rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.SetRect(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Sets the location and size of this rectangle to the specified values.</para>
      </summary>
      <param name="x">
        <para>the new x-coordinate of the upper left corner.</para>
      </param>
      <param name="y">
        <para>the new y-coordinate of the upper left corner.</para>
      </param>
      <param name="width">
        <para>the new width.</para>
      </param>
      <param name="height">
        <para>the new height.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.CreateIntersection(yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Calculates the intersection of this rectangle with the given rectangle and returns the result as new rectangle.</para>
      </summary>
      <param name="r">
        <para>a rectangle to intersect with this rectangle.</para>
      </param>
      <returns>
        <para>a new rectangle that represents the calculated intersection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.CreateUnion(yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Calculates the union of this rectangle with the given rectangle and returns the result as new rectangle.</para>
      </summary>
      <param name="r">
        <para>a rectangle to union with this rectangle.</para>
      </param>
      <returns>
        <para>a new rectangle that represents the calculated union.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Intersect(yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Calculates the intersection of the first and second specified rectangle and sets the resulting location and size to the third rectangle.</para>
      </summary>
      <param name="src1">
        <para>the first rectangle to intersect.</para>
      </param>
      <param name="src2">
        <para>the second rectangle to intersect.</para>
      </param>
      <param name="dst">
        <para>the rectangle to which the result is set.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Union(yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Calculates the union of the first and second specified rectangle and sets the resulting location and size to the third rectangle.</para>
      </summary>
      <param name="src1">
        <para>the first rectangle to union.</para>
      </param>
      <param name="src2">
        <para>the second rectangle to union.</para>
      </param>
      <param name="dst">
        <para>the rectangle to which the result is set.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.IntersectsLine(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Checks if the line segment specified by the given coordinates intersects this rectangle.</para>
      </summary>
      <param name="x1">
        <para>the x-coordinate of the first end point of the line.</para>
      </param>
      <param name="y1">
        <para>the y-coordinate of the first end point of the line.</para>
      </param>
      <param name="x2">
        <para>the x-coordinate of the other end point of the line.</para>
      </param>
      <param name="y2">
        <para>the y-coordinate of the other end point of the line.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified line intersects this rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Contains(System.Double,System.Double)">
      <summary>
        <para>Checks if the point specified by the given coordinates is contained in this rectangle.</para>
      </summary>
      <param name="x">
        <para>the x-coordinate of the point.</para>
      </param>
      <param name="y">
        <para>the y-coordinate of the point.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the specified point is contained in this rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Intersects(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Checks whether this rectangle and the second specified rectangle intersect.</para>
      </summary>
      <param name="x">
        <para>the x coordinate of the second rectangle.</para>
      </param>
      <param name="y">
        <para>the y coordinate of the second rectangle.</para>
      </param>
      <param name="width">
        <para>the width coordinate of the second rectangle.</para>
      </param>
      <param name="height">
        <para>the height coordinate of the second rectangle.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if both rectangles intersect</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Contains(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Checks whether this rectangle completely contains the second specified rectangle.</para>
      </summary>
      <param name="x">
        <para>the x coordinate of the second rectangle.</para>
      </param>
      <param name="y">
        <para>the y coordinate of the second rectangle.</para>
      </param>
      <param name="width">
        <para>the width coordinate of the second rectangle.</para>
      </param>
      <param name="height">
        <para>the height coordinate of the second rectangle.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this rectangle contains the second one</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Add(System.Double,System.Double)">
      <summary>
        <para>Adds a point, specified by its coordinates, to this rectangle.</para>
      </summary>
      <remarks>
        <para>The rectangle will be grown if necessary. Note that for points that would lie on the right or bottom border of the rectangle, <see cref="M:yWorks.Algorithms.Geometry.Rectangle2D.Contains(System.Double,System.Double)" /> will still return <c>false</c> for the added point.</para>
      </remarks>
      <param name="px">
        <para>the x coordinate of the point to add</para>
      </param>
      <param name="py">
        <para>the y coordinate of the point to add</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Add(yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Adds a rectangle to this rectangle.</para>
      </summary>
      <remarks>
        <para>The rectangle will be grown to the union of both rectangles</para>
      </remarks>
      <param name="r">
        <para>the rectangle to add</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.GetHashCode" />
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Equals(System.Object)">
      <summary>
        <para>Returns whether this rectangle and <c>obj</c> are equal.</para>
      </summary>
      <remarks>
        <para>Two rectangles are considered equal if the have the same location and size.</para>
      </remarks>
      <param name="obj">
        <para>The object to test for equality</para>
      </param>
      <returns>
        <para>
          <c>true</c> if both objects are equal.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Contains(yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Checks whether this rectangle completely contains the second specified rectangle.</para>
      </summary>
      <param name="rect">
        <para>the rectangle to check for containment</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this rectangle contains the second one</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Intersects(yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Checks whether this rectangle and the second specified rectangle intersect.</para>
      </summary>
      <param name="rect">
        <para>the rectangle to check for intersection</para>
      </param>
      <returns>
        <para>
          <c>true</c> if both rectangles intersect</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.X">
      <summary>
        <para>Gets the x coordinate of the upper left corner.</para>
      </summary>
      <value>
        <para>the x coordinate of the upper left corner.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.Y">
      <summary>
        <para>Gets the y coordinate of the upper left corner.</para>
      </summary>
      <value>
        <para>the y coordinate of the upper left corner.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.Width">
      <summary>
        <para>Gets the width of this rectangle.</para>
      </summary>
      <value>
        <para>the width.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.Height">
      <summary>
        <para>Gets the height of this rectangle.</para>
      </summary>
      <value>
        <para>the height.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.Empty">
      <summary>
        <para>Gets whether this instance is empty, i.e.</para>
      </summary>
      <remarks>
        <para>covers no area.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> iff this rectangle is empty.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.MinX">
      <summary>
        <para>Gets the smallest x coordinate of this rectangle.</para>
      </summary>
      <value>
        <para>the smallest x coordinate of this rectangle.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.MinY">
      <summary>
        <para>Gets the smallest y coordinate of this rectangle.</para>
      </summary>
      <value>
        <para>the smallest y coordinate of this rectangle.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.MaxX">
      <summary>
        <para>Gets the largest x coordinate of this rectangle.</para>
      </summary>
      <value>
        <para>the largest x coordinate of this rectangle.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.MaxY">
      <summary>
        <para>Gets the largest y coordinate of this rectangle.</para>
      </summary>
      <value>
        <para>the largest y coordinate of this rectangle.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.CenterX">
      <summary>
        <para>Gets the x coordinate of the center point of this rectangle.</para>
      </summary>
      <value>
        <para>the x coordinate of the center point of this rectangle.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.CenterY">
      <summary>
        <para>Gets the y coordinate of the center point of this rectangle.</para>
      </summary>
      <value>
        <para>the y coordinate of the center point of this rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.ToString" />
    <member name="P:yWorks.Algorithms.Geometry.Rectangle2D.Bounds2D">
      <summary>
        <para>Gets the bounds of this instance in double precision.</para>
      </summary>
      <value>
        <para>the bounds of this instance in double precision.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Rectangle2D.Clone">
      <summary>
        <para>Creates a new instance of this class that has the same values as this objects.</para>
      </summary>
      <returns>
        <para>a new instance of this class that has the same values as this objects.</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.Triangulator">
      <summary>
        <para>This class provides algorithms for the triangulation of point sets in the plane.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Triangulator.TriangulatePoints(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Computes a triangulation of the given points.</para>
      </summary>
      <remarks>
        <para>The calculated triangulation is represented by an embedded graph, i.e. to each edge there exists a reverse edge and the outedges around each node are in embedded order. The returned edge and the (optional) reverseEdgeMap can be used to construct all faces of the plane graph and to determine its outer face.</para>
      </remarks>
      <param name="result">
        <para>a graph whose nodes represent the points that need to be triangulated.</para>
      </param>
      <param name="pointData">
        <para>must provide the location (YPoint) for each node in the given graph.</para>
      </param>
      <param name="reverseEdgeMap">
        <para>a node map that will contain for each edge its reverse edge. If this argument is <c>null</c> then no reverse edge information will be available.</para>
      </param>
      <returns>
        <para>an edge on the outer face of the result graph.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Triangulator.TriangulatePoints(yWorks.Algorithms.YList,yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Computes a triangulation of the given points.</para>
      </summary>
      <remarks>
        <para>The calculated triangulation is represented by an embedded graph, i.e. to each edge there exists a reverse edge and the outedges around each node are in embedded order. The returned edge and the (optional) reverseEdgeMap can be used to construct all faces of the plane graph and to determine its outer face.</para>
      </remarks>
      <param name="points">
        <para>the point set to be triangulated. The points must be provided as a YList of YPoints.</para>
      </param>
      <param name="result">
        <para>the resulting triangulation</para>
      </param>
      <param name="resultMap">
        <para>the node map that forms the link between a point and a node.</para>
      </param>
      <param name="reverseEdgeMap">
        <para>a node map that will contain for each edge its reverse edge. If this argument is <c>null</c> then no reverse edge information will be available.</para>
      </param>
      <returns>
        <para>an edge on the outer face of the result graph.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.Triangulator.CalcDelauneyTriangulation(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Computes a Delauney triangulation of the given points.</para>
      </summary>
      <remarks>
        <para>A Delauney triangulation is a triangulation such that none of the given points is inside the circumcircle of any of the calculated triangles.</para>
        <para>The calculated triangulation is represented by an embedded graph, i.e. to each edge there exists a reverse edge and the outedges around each node are in embedded order. The returned edge and the (optional) reverseEdgeMap can be used to construct all faces of the plane graph and to determine its outer face.</para>
      </remarks>
      <param name="result">
        <para>a graph whose nodes represent the points that need to be triangulated.</para>
      </param>
      <param name="pointData">
        <para>must provide the location (YPoint) for each node in the given graph.</para>
      </param>
      <param name="revMap">
        <para>a node map that will contain for each edge its reverse edge. If this argument is <c>null</c> then no reverse edge information will be available.</para>
      </param>
      <returns>
        <para>an edge on the outer face of the result graph.</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.YDimension">
      <summary>
        <para>This class represents the size of an object.</para>
      </summary>
      <remarks>
        <para>An instance of this class implements the immutable design pattern.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YDimension.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new YDimension2D object for given size.</para>
      </summary>
      <param name="width" />
      <param name="height" />
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YDimension.Width">
      <summary>
        <para>Gets the width of the dimension object.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YDimension.Height">
      <summary>
        <para>Gets the height of the dimension object.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YDimension.Equals(System.Object)">
      <summary>
        <para>Tests a dimension to equality to another dimension.</para>
      </summary>
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YDimension.GetHashCode" />
    <member name="M:yWorks.Algorithms.Geometry.YDimension.ToString">
      <summary>
        <para>Returns the size in the form: "W: width H: height"</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YDimension.CompareTo(System.Object)">
      <param name="o" />
    </member>
    <member name="T:yWorks.Algorithms.Geometry.YOrientedRectangle">
      <summary>
        <para>An oriented rectangle in 2D coordinate space with double precision coordinates.</para>
      </summary>
      <remarks>
        <para>The rectangle's <c>height</c> extends from its <em><see cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Anchor">anchor point</see></em> in the direction of its <em>up
 vector</em> (<see cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.UpX">ux</see>, <see cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.UpY">uy</see>). Its <c>width</c> extends from its <see cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Anchor">anchor point</see> in direction <c>(-uy, ux)</c> (i.e. perpendicular to the <em>up vector</em>). This means that an oriented rectangle with anchor point <c>(0, 0)</c> width <c>100</c>, height <c>10</c>, and up vector <c>(0, -1)</c> is a paraxial rectangle with upper left corner <c>(0, -10)</c> and lower right corner <c>(100, 0)</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.#ctor(yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Creates a new instance using the provided rectangle's values to initialize anchor and size.</para>
      </summary>
      <remarks>
        <para>The oriented rectangle's up vector will be <c>(0, -1)</c>.</para>
      </remarks>
      <param name="rect">
        <para>the provided rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.#ctor(yWorks.Algorithms.Geometry.YOrientedRectangle)">
      <summary>
        <para>Creates a new instance using the provided rectangle's values to initialize anchor, size, and up vector.</para>
      </summary>
      <param name="rect">
        <para>the provided rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YDimension)">
      <summary>
        <para>Creates a new instance using the provided values to initialize the anchor and size.</para>
      </summary>
      <remarks>
        <para>The oriented rectangle's up vector will be <c>(0, -1)</c>.</para>
      </remarks>
      <param name="anchor">
        <para>The provider for the dynamic anchor of this instance.</para>
      </param>
      <param name="size">
        <para>The provider for the dynamic size of this instance.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YDimension,yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Creates a new instance using the provided values to initialize anchor, size, and up vector.</para>
      </summary>
      <param name="position">
        <para>The provider for the dynamic anchor of this instance.</para>
      </param>
      <param name="size">
        <para>The provider for the dynamic size of this instance.</para>
      </param>
      <param name="upVector">
        <para>The up vector.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new instance using the provided values to initialize anchor and size.</para>
      </summary>
      <remarks>
        <para>The oriented rectangle's up vector will be <c>(0, -1)</c>.</para>
      </remarks>
      <param name="anchorX">
        <para>The x coordinate of the anchor of the oriented rectangle.</para>
      </param>
      <param name="anchorY">
        <para>The y coordinate of the anchor of the oriented rectangle.</para>
      </param>
      <param name="width">
        <para>The width of the rectangle.</para>
      </param>
      <param name="height">
        <para>The height of the rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new instance using the provided values to initialize anchor, size, and up vector.</para>
      </summary>
      <param name="anchorX">
        <para>The x coordinate of the anchor of the oriented rectangle.</para>
      </param>
      <param name="anchorY">
        <para>The y coordinate of the anchor of the oriented rectangle.</para>
      </param>
      <param name="width">
        <para>The width of the rectangle.</para>
      </param>
      <param name="height">
        <para>The height of the rectangle.</para>
      </param>
      <param name="upX">
        <para>The x component of the up vector.</para>
      </param>
      <param name="upY">
        <para>The y component of the up vector.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Empty">
      <summary>
        <para>Gets whether this instance has negative width or height.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Anchor">
      <summary>
        <para>Gets or sets the anchor of this oriented rectangle.</para>
      </summary>
      <value>
        <para>the new anchor point of this rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.SetAnchor(System.Double,System.Double)">
      <summary>
        <para>Sets the anchor of this rectangle.</para>
      </summary>
      <param name="x">
        <para>the new x-coordinate of the anchor point.</para>
      </param>
      <param name="y">
        <para>the new y-coordinate of the anchor point.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.AnchorX">
      <summary>
        <para>Gets the x-coordinate of this rectangle's anchor point.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.AnchorY">
      <summary>
        <para>Gets the y-coordinate of this rectangle's anchor point.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Size">
      <summary>
        <para>Gets or sets the size of this rectangle.</para>
      </summary>
      <value>
        <para>the size of this rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.SetSize(System.Double,System.Double)">
      <summary>
        <para>Sets the size of this rectangle.</para>
      </summary>
      <param name="width">
        <para>the new width.</para>
      </param>
      <param name="height">
        <para>the new height.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Width">
      <summary>
        <para>Gets the width of this rectangle.</para>
      </summary>
      <value>
        <para>the width of this rectangle.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Height">
      <summary>
        <para>Gets the height of this rectangle.</para>
      </summary>
      <value>
        <para>the height of this rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.SetUpVector(System.Double,System.Double)">
      <summary>
        <para>Sets the components of the up vector to the new values.</para>
      </summary>
      <param name="upX">
        <para>The x component of the normalized up vector.</para>
      </param>
      <param name="upY">
        <para>The y component of the normalized up vector.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.UpX">
      <summary>
        <para>Gets the x-component of this rectangle's up vector.</para>
      </summary>
      <value>
        <para>the x-component of this rectangle's up vector.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.UpY">
      <summary>
        <para>Gets the y-component of this rectangle's up vector.</para>
      </summary>
      <value>
        <para>the y-component of this rectangle's up vector.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Angle">
      <summary>
        <para>Gets or sets the angle (measured in radians) of this rectangle.</para>
      </summary>
      <remarks>
        <para>The angle of an oriented rectangle is the angle between the vector <c>(0, -1)</c> and the rectangle's up vector in counter clockwise order. An angle of 0 means the up vector points up in direction <c>(0, -1)</c>.</para>
      </remarks>
      <value>
        <para>the angle (measured in radians) of this rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.MoveBy(System.Double,System.Double)">
      <summary>
        <para>Moves this rectangle by applying the offset to the anchor.</para>
      </summary>
      <param name="dx">
        <para>The x offset to move the rectangle's position by.</para>
      </param>
      <param name="dy">
        <para>The y offset to move the rectangle's position by.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Center">
      <summary>
        <para>Gets or sets the current center of the oriented rectangle.</para>
      </summary>
      <value>
        <para>the current center of the rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.SetCenter(System.Double,System.Double)">
      <summary>
        <para>Sets the anchor of the OrientedRectangle so that the center of the rectangle coincides with the given coordinate pair.</para>
      </summary>
      <param name="cx">
        <para>The x coordinate of the center.</para>
      </param>
      <param name="cy">
        <para>The y coordinate of the center.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YOrientedRectangle.BoundingBox">
      <summary>
        <para>Calculates the paraxial bounding box of this oriented rectangle.</para>
      </summary>
      <value>
        <para>the paraxial bounding box of this oriented rectangle.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.Contains(System.Double,System.Double,System.Boolean)">
      <summary>
        <para>Determines whether or not the specified point lies inside this oriented rectangle.</para>
      </summary>
      <param name="x">
        <para>the x-coordinate of the point to check.</para>
      </param>
      <param name="y">
        <para>the y-coordinate of the point to check.</para>
      </param>
      <param name="closed">
        <para>if <c>true</c>, all points on the border of the rectangle are considered to be <em>contained</em>.</para>
      </param>
      <returns>
        <para>
          <c>true</c> iff the specified point lies inside; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.CalcPoints(yWorks.Algorithms.Geometry.YOrientedRectangle)">
      <summary>
        <para>Determines the four corner points of an oriented rectangle.</para>
      </summary>
      <param name="rect">
        <para>The rectangle to determine the bounds.</para>
      </param>
      <returns>
        <para>the array of corner points.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.CalcPointsInDouble(yWorks.Algorithms.Geometry.YOrientedRectangle)">
      <summary>
        <para>Determines the coordinates of the four corners of an oriented rectangle.</para>
      </summary>
      <param name="rect">
        <para>The rectangle to determine the bounds.</para>
      </param>
      <returns>
        <para>the array of coordinates of the corner points in which each even index has the x-coordinate and each odd index the y-coordinate</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.Intersects(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Algorithms.Geometry.YRectangle,System.Double)">
      <summary>
        <para>Determines whether a rectangle intersects an oriented rectangle, given an epsilon.</para>
      </summary>
      <param name="orientedRectangle">
        <para>The oriented rectangle to test.</para>
      </param>
      <param name="rectangle">
        <para>The rectangle to test.</para>
      </param>
      <param name="eps">
        <para>A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>Whether they have a non-empty intersection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.Contains(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Algorithms.Geometry.YPoint,System.Double)">
      <summary>
        <para>Determines whether the given oriented rectangle contains the provided point, using an epsilon value.</para>
      </summary>
      <param name="rect">
        <para>The rectangle.</para>
      </param>
      <param name="p">
        <para>The point to test.</para>
      </param>
      <param name="eps">
        <para>fuzziness range. A positive value allows for fuzzy hit testing. If a point lies outside the given rectangle, but its distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the point lies inside the rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.Contains(yWorks.Algorithms.Geometry.YOrientedRectangle,System.Double,System.Double,System.Double)">
      <summary>
        <para>Determines whether the given oriented rectangle contains the provided point, using an epsilon value.</para>
      </summary>
      <param name="rect">
        <para>The rectangle.</para>
      </param>
      <param name="x">
        <para>x-coordinate of the point to test.</para>
      </param>
      <param name="y">
        <para>y-coordinate of the point to test.</para>
      </param>
      <param name="eps">
        <para>fuzziness range. A positive value allows for fuzzy hit testing. If a point lies outside the given rectangle, but its distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the point lies inside the rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.Contains(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Algorithms.Geometry.YOrientedRectangle,System.Double)">
      <summary>
        <para>Determines whether the given rectangle r1 contains rectangle r2, using an epsilon value.</para>
      </summary>
      <param name="r1">
        <para>The first rectangle.</para>
      </param>
      <param name="r2">
        <para>The second rectangle.</para>
      </param>
      <param name="eps">
        <para>A positive value allows for fuzzy hit testing. If the point lies outside the given object but it's distance is less than or equal to that value, it will be considered a hit.</para>
      </param>
      <returns>
        <para>true iff the r1 contains r2.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.Intersects(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Algorithms.Geometry.LineSegment,System.Double)">
      <summary>
        <para>Determines whether or not the specified oriented rectangle and the specified line segment intersect.</para>
      </summary>
      <returns>
        <para>
          <c>true</c> if the rectangle and the segment intersect and <c>false</c> otherwise.</para>
      </returns>
      <param name="rect" />
      <param name="line" />
      <param name="eps" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.IntersectionPoint(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Algorithms.Geometry.LineSegment,System.Double)">
      <summary>
        <para>Determines an intersection point of the specified oriented rectangle and the specified line segment.</para>
      </summary>
      <remarks>
        <para>Note: there might be more than one intersection point. However this method only returns one intersection point or <c>null</c> if there is no intersection.</para>
      </remarks>
      <returns>
        <para>an intersection point of the specified oriented rectangle and the specified line segment or <c>null</c> if the rectangle and the segment do not intersect.</para>
      </returns>
      <param name="rect" />
      <param name="line" />
      <param name="eps" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.ToString" />
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.Equals(System.Object)">
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.GetHashCode" />
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.GetMovedInstance(System.Double,System.Double)">
      <summary>
        <para>Creates a new <c>OrientedRectangle</c> instance whose anchor point is moved by the specified distance values, but has the same width, height, and up vector as this rectangle.</para>
      </summary>
      <param name="dx">
        <para>the distance to move the anchor point in x-direction. A positive value means "move" to the right, a negative value means "move" to the left.</para>
      </param>
      <param name="dy">
        <para>the distance to move the anchor point in y-direction. A positive value means "move" downwards, a negative value means "move" upwards.</para>
      </param>
      <returns>
        <para>a new <c>OrientedRectangle</c> instance whose anchor point is moved by the specified distance values.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.GetResizedInstance(System.Double,System.Double)">
      <summary>
        <para>Creates a new <c>OrientedRectangle</c> instance that has the specified width and height, but has the same anchor point and up vector as this rectangle.</para>
      </summary>
      <param name="width">
        <para>the width of the new rectangle.</para>
      </param>
      <param name="height">
        <para>the height of the new rectangle.</para>
      </param>
      <returns>
        <para>a new <c>OrientedRectangle</c> instance that has the specified width and height.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YOrientedRectangle.AdoptValues(yWorks.Algorithms.Geometry.YOrientedRectangle)">
      <summary>
        <para>Copies the actual values from the given <c>OrientedRectangle</c> to this instance.</para>
      </summary>
      <param name="other">
        <para>the <c>OrientedRectangle</c> to retrieve the values from</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.YPoint">
      <summary>
        <para>This class represents a point in the plane with double coordinates.</para>
      </summary>
      <remarks>
        <para>This class implements the immutable design pattern.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Algorithms.Geometry.YPoint.Origin">
      <summary>
        <para>A YPoint constant with coordinates (0,0).</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.#ctor">
      <summary>
        <para>Creates a new YPoint at location (0,0)</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new YPoint object for a given position.</para>
      </summary>
      <param name="x">
        <para>the x coordinate of the point.</para>
      </param>
      <param name="y">
        <para>the y coordinate of the point.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YPoint.X">
      <summary>
        <para>Gets the x-coordinate of the point object.</para>
      </summary>
      <value>
        <para>the value of the x-coordinate.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YPoint.Y">
      <summary>
        <para>Gets the y-coordinate of the point object.</para>
      </summary>
      <value>
        <para>the value of the y-coordinate.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.DistanceTo(System.Double,System.Double)">
      <summary>
        <para>Returns the euclidean distance between this point and a given point.</para>
      </summary>
      <param name="x">
        <para>the x coordinate of an arbitrary point</para>
      </param>
      <param name="y">
        <para>the y coordinate of an arbitrary point</para>
      </param>
      <returns>
        <para>the Euclidean distance between this point and the point (x,y).</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.DistanceTo(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Returns the euclidean distance between this point and a given point.</para>
      </summary>
      <param name="p">
        <para>an arbitrary point</para>
      </param>
      <returns>
        <para>the Euclidean distance between this point and p.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.Distance(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Returns the euclidean distance between two points.</para>
      </summary>
      <param name="p1">
        <para>an arbitrary point</para>
      </param>
      <param name="p2">
        <para>an arbitrary point</para>
      </param>
      <returns>
        <para>the Euclidean distance between p1 and p2.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.Distance(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Returns the euclidean distance between two points.</para>
      </summary>
      <param name="x1">
        <para>x-coordinate of first point</para>
      </param>
      <param name="y1">
        <para>y-coordinate of first point</para>
      </param>
      <param name="x2">
        <para>x-coordinate of second point</para>
      </param>
      <param name="y2">
        <para>y-coordinate of second point</para>
      </param>
      <returns>
        <para>the euclidean distance between first and second point</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.Add(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Adds two points and returns the result.</para>
      </summary>
      <param name="p1">
        <para>an arbitrary instance of YPoint.</para>
      </param>
      <param name="p2">
        <para>an arbitrary instance of YPoint.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.Subtract(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Subtracts two points (p1 - p2) and returns the result.</para>
      </summary>
      <param name="p1">
        <para>an arbitrary instance of YPoint.</para>
      </param>
      <param name="p2">
        <para>an arbitrary instance of YPoint.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.MidPoint(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Returns a point that geometrically lies in in the middle of the line formed by the given points.</para>
      </summary>
      <param name="p1">
        <para>an arbitrary instance of YPoint.</para>
      </param>
      <param name="p2">
        <para>an arbitrary instance of YPoint.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.Swap(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Returns a copy of the given point with exchanged x- and y-coordinates.</para>
      </summary>
      <param name="p">
        <para>an arbitrary instance of YPoint.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.MoveBy(System.Double,System.Double)">
      <summary>
        <para>Returns the point, got by moving this point to another position.</para>
      </summary>
      <param name="x">
        <para>the value which is added on the x-coordinate of the point.</para>
      </param>
      <param name="y">
        <para>the value which is added on the y-coordinate of the point.</para>
      </param>
      <returns>
        <para>a new instance of YPoint which is the result of the moving operation.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.Equals(System.Object)">
      <summary>
        <para>Tests a point to equality to another point.</para>
      </summary>
      <remarks>
        <para>This test returns true if the <c>o</c> is also an instance of YPoint and has the same coordinates as the instance on which equals is invoked.</para>
      </remarks>
      <param name="o">
        <para>an arbitrary instance.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.GetHashCode" />
    <member name="M:yWorks.Algorithms.Geometry.YPoint.ToString">
      <summary>
        <para>Returns the coordinates of the point as string.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPoint.CompareTo(System.Object)">
      <summary>
        <para>Comparable implementation.</para>
      </summary>
      <remarks>
        <para>YPoints are ordered by ascending x-coordinates. If the x-coordinates of two points equal, then these points are ordered by ascending y-coordinates.</para>
      </remarks>
      <param name="o" />
    </member>
    <member name="T:yWorks.Algorithms.Geometry.YPointPath">
      <summary>
        <para>This class represents an ordered list of points in the plane.</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.Geometry.YPointPath.EmptyPath">
      <summary>
        <para>Defines a path with no points.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.#ctor">
      <summary>
        <para>Creates a new empty path.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.#ctor(System.Collections.Generic.IList{System.Object})">
      <summary>
        <para>Creates a new path from a list of points.</para>
      </summary>
      <param name="l">
        <para>a list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" /> instances.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.#ctor(yWorks.Algorithms.Geometry.YPoint[])">
      <summary>
        <para>Creates a new path from an array of points.</para>
      </summary>
      <param name="path" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.Cursor">
      <summary>
        <para>Get the points in the path.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.Points">
      <summary>
        <para>Get the points in the path.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YPointPath.First">
      <summary>
        <para>Gets the first point in the path.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YPointPath.Last">
      <summary>
        <para>Gets the last point in the path.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.ToList">
      <summary>
        <para>Get the points in the path as list.</para>
      </summary>
      <returns>
        <para>a list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" /> instances.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.ToArray">
      <summary>
        <para>Get the points in the list as array.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.CreateReverse">
      <summary>
        <para>Create a point path with reverse ordering of the points.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.Length">
      <summary>
        <para>Get the number of points in the path.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YPointPath.LineSegmentCount">
      <summary>
        <para>Gets the number of line segments in the path.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.LineSegments">
      <summary>
        <para>Get the points in the path.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.GetLineSegment(System.Int32)">
      <summary>
        <para>Returns a line segment in the path.</para>
      </summary>
      <param name="i" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.ToString" />
    <member name="M:yWorks.Algorithms.Geometry.YPointPath.CalculateLength">
      <summary>
        <para>Calculate the (geometric) length of the path.</para>
      </summary>
      <remarks>
        <para>The length of the path is the sum of lengths of all line segments making up the path.</para>
      </remarks>
      <returns>
        <para>the (geometric) length of the path</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Geometry.YRectangle">
      <summary>
        <para>This class defines a rectangle and provides utility methods for it.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.#ctor">
      <summary>
        <para>Creates a new rectangle with upper left corner (0,0) and size (0,0).</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YDimension)">
      <summary>
        <para>Creates a new rectangle with given upper left corner and size.</para>
      </summary>
      <param name="pos">
        <para>upper left corner of the rectangle.</para>
      </param>
      <param name="size">
        <para>size of the rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new rectangle with given upper left corner and size.</para>
      </summary>
      <param name="x">
        <para>x-coordinate of upper left corner of the rectangle.</para>
      </param>
      <param name="y">
        <para>y-coordinate of upper left corner of the rectangle.</para>
      </param>
      <param name="width">
        <para>width of the rectangle.</para>
      </param>
      <param name="height">
        <para>height of the rectangle.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.GetManhattanDistance(yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Returns the Manhattan distance to the passed rectangle.</para>
      </summary>
      <remarks>
        <para>If they overlap the distance is 0.</para>
      </remarks>
      <param name="other">
        <para>the second rectangle.</para>
      </param>
      <returns>
        <para>the distance to the given rectangle.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.GetEuclideanDistance(yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Returns the Euclidean distance to the passed rectangle.</para>
      </summary>
      <remarks>
        <para>If they overlap, the distance is 0.</para>
      </remarks>
      <param name="other">
        <para>the second rectangle.</para>
      </param>
      <returns>
        <para>the distance to the given rectangle.</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YRectangle.X">
      <summary>
        <para>Gets x-coordinate of upper left corner.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YRectangle.Y">
      <summary>
        <para>Gets y-coordinate of upper left corner.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YRectangle.Location">
      <summary>
        <para>Gets coordinates of upper left corner.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YRectangle.BoundingBox">
      <summary>
        <para>Gets this object.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double)">
      <summary>
        <para>Checks whether or not this <c>YRectangle</c> contains the given point.</para>
      </summary>
      <param name="x">
        <para>the x-coordinate of the point to check.</para>
      </param>
      <param name="y">
        <para>the x-coordinate of the point to check.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the point lies inside the rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
        <para>Determines whether the specified rectangle contains the specified point.</para>
      </summary>
      <param name="rx">
        <para>the x-coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="ry">
        <para>the y-coordinate of the upper left corner of the rectangle.</para>
      </param>
      <param name="rw">
        <para>the width of the rectangle.</para>
      </param>
      <param name="rh">
        <para>the height of the rectangle.</para>
      </param>
      <param name="x">
        <para>the x-coordinate of the point to check.</para>
      </param>
      <param name="y">
        <para>the x-coordinate of the point to check.</para>
      </param>
      <param name="closed">
        <para>if <c>true</c>, all points on the border of the rectangle are considered to be <em>contained</em>.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the point lies inside the rectangle; <c>false</c> otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.Contains(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Checks whether or not this <c>YRectangle</c> contains the given point.</para>
      </summary>
      <param name="p" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.Contains(yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Checks whether or not this <c>YRectangle</c> contains the given rectangle.</para>
      </summary>
      <param name="p" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.Contains(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Checks whether or not this <c>YRectangle</c> contains the rectangle defined by the given frame.</para>
      </summary>
      <param name="x" />
      <param name="y" />
      <param name="width" />
      <param name="height" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.Intersects(yWorks.Algorithms.Geometry.YRectangle,yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Returns whether or not the given rectangles intersect.</para>
      </summary>
      <param name="r1" />
      <param name="r2" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.ToString">
      <summary>
        <para>Returns a string representation of this rectangle</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.GetHashCode" />
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.Equals(System.Object)">
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YRectangle.CompareTo(System.Object)">
      <param name="o" />
    </member>
    <member name="T:yWorks.Algorithms.Geometry.YVector">
      <summary>
        <para>This class represents a vector in the 2-dimensional real vector space.</para>
      </summary>
      <remarks>
        <para>This vector is an ordered 2 tuple and is defined by two doubles.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new vector with given direction.</para>
      </summary>
      <param name="dx">
        <para>the first coordinate</para>
      </param>
      <param name="dy">
        <para>the second coordinate</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.#ctor(yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Creates a new vector which is a copy of another vector.</para>
      </summary>
      <param name="v">
        <para>the vector, whose values are copied.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Creates a new vector, whose direction is given by two points.</para>
      </summary>
      <remarks>
        <para>The vector is defined by <c>p1</c> - <c>p2</c>.</para>
      </remarks>
      <param name="p1">
        <para>The first point.</para>
      </param>
      <param name="p2">
        <para>The second point. If no point is spcified, <c>(0,0)</c> is used instead.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new vector, whose direction is given by two points.</para>
      </summary>
      <remarks>
        <para>The vector is defined by <c>(x1 - x2, y1 - y2)</c>.</para>
      </remarks>
      <param name="x1">
        <para>the X-coordinate of the first point.</para>
      </param>
      <param name="y1">
        <para>the Y-coordinate of the first point.</para>
      </param>
      <param name="x2">
        <para>the X-coordinate of the second point.</para>
      </param>
      <param name="y2">
        <para>the Y-coordinate of the second point.</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YVector.X">
      <summary>
        <para>Gets the first coordinate of the vector.</para>
      </summary>
      <value>
        <para>the X-coordinate of the vector.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Geometry.YVector.Y">
      <summary>
        <para>Gets the second coordinate of the vector.</para>
      </summary>
      <value>
        <para>the X-coordinate of the vector.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.Norm">
      <summary>
        <para>Assigns unit length to the vector.<br /></para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.Rotate(System.Double)">
      <summary>
        <para>Returns a new <c>YVector</c> instance that is obtained by rotating this vector by the given angle (measured in radians) in clockwise direction (with regards to screen coordinates).</para>
      </summary>
      <remarks>
        <para>Screen coordinates mean positive x-direction is from left to right and positive y-direction is from top to bottom.</para>
      </remarks>
      <param name="angle">
        <para>the angle of rotation in radians.</para>
      </param>
      <returns>
        <para>the rotated vector.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.Add(yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Adds a vector to this vector.</para>
      </summary>
      <param name="v">
        <para>the vector to add.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.Add(yWorks.Algorithms.Geometry.YVector,yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Adds two vectors and returns the result.</para>
      </summary>
      <param name="v">
        <para>first vector to sum.</para>
      </param>
      <param name="w">
        <para>second vector to sum.</para>
      </param>
      <returns>
        <para>v+w</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.Add(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Adds the vector to a point and returns the resulting point.</para>
      </summary>
      <param name="p">
        <para>a point.</para>
      </param>
      <param name="v">
        <para>the vector to add to the point.</para>
      </param>
      <returns>
        <para>p+v</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.Scale(System.Double)">
      <summary>
        <para>Scales the vector by an factor.</para>
      </summary>
      <param name="factor">
        <para>the scale factor, with which the length is multiplied.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.Length">
      <summary>
        <para>Returns the length of the vector, this is the value of the euclidean norm.</para>
      </summary>
      <returns>
        <para>a value &gt; 0.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.RightOf(yWorks.Algorithms.Geometry.YVector,yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Returns true if vector v1 is on the right side of v2.</para>
      </summary>
      <param name="v1" />
      <param name="v2" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.GetNormal(yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Returns this vector with unit length.</para>
      </summary>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.OrthoNormal(yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Returns the vector which is orthogonal to the given one and has unit length.</para>
      </summary>
      <param name="v">
        <para>a vector.</para>
      </param>
      <returns>
        <para>a vector which is orthogonal to v with unit length.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.ScalarProduct(yWorks.Algorithms.Geometry.YVector,yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Returns the value of the scalar product of two vectors.</para>
      </summary>
      <param name="v1">
        <para>the first vector.</para>
      </param>
      <param name="v2">
        <para>the second vector.</para>
      </param>
      <returns>
        <para>
          <c>v1.x * v2.x + v1.y * v2.y</c>
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.Angle(yWorks.Algorithms.Geometry.YVector,yWorks.Algorithms.Geometry.YVector)">
      <summary>
        <para>Returns the angle (measured in radians) between two vectors in clockwise order (with regards to screen coordinates) from v1 to v2.</para>
      </summary>
      <remarks>
        <para>Screen coordinates mean positive x-direction is from left to right and positive y-direction is from top to bottom.</para>
      </remarks>
      <param name="v1" />
      <param name="v2" />
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.AddAngle(System.Double,System.Double)">
      <summary>
        <para>Returns the result of the addition of two angles between <c>0</c> and <c>2*Pi</c>.</para>
      </summary>
      <remarks>
        <para>The result is calculated modulo <c>2*Pi</c>.</para>
      </remarks>
      <param name="a1">
        <para>a value in <c>[0,2Pi)</c>.</para>
      </param>
      <param name="a2">
        <para>a value in <c>[0,2Pi)</c>.</para>
      </param>
      <returns>
        <para>The sum of a1 and a2 modulo <c>2*Pi</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Geometry.YVector.ToString">
      <summary>
        <para>Returns a string representation of this vector.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.Graph">
      <summary>
        <para>This class implements a directed graph structure.</para>
      </summary>
      <remarks>
        <para>Basically, a directed graph consists of a set of objects called "nodes" (represented by instances of class <see cref="T:yWorks.Algorithms.Node" />) and a set of node pairs which are called "edges" (represented by instances of class <see cref="T:yWorks.Algorithms.Edge" />). <br /> The <i>directed</i> stems from the fact that all edges in the graph have direction, i.e., they have a distinct source node and a distinct target node. Using the aforementioned pair notation, an edge would be written as (<i>&lt;source node&gt;</i>, <i>&lt;target node&gt;</i>).</para>
        <para>Class Graph presents a proper data type that provides support for all essential operations like element creation, removal, access, and iteration. <br /> <b>Important:</b> Class Graph is the single authority for any structural changes to the graph data type. Specifically, this means that there is no way to create or delete a node or an edge without using an actual Graph instance.</para>
        <para>Furthermore, this class is also responsible for providing access to its elements. This is done by means of bidirectional cursors that present a read-only view on the node set (interface <see cref="T:yWorks.Algorithms.INodeCursor" />) and edge set (interface <see cref="T:yWorks.Algorithms.IEdgeCursor" />).</para>
        <para>Class Graph fires notification events that signal structural changes, like, e.g., creation, removal, reinsertion, or modification of graph elements. <br /> Classes that implement the <see cref="T:yWorks.Algorithms.IGraphListener" /> interface can be registered with this class using the <see cref="M:yWorks.Algorithms.Graph.AddGraphListener(yWorks.Algorithms.IGraphListener)">addGraphListener</see> method in order to receive such events.</para>
        <para>This class provides direct support for the notion of data accessors. It allows to register so-called data providers (implementations of interface <see cref="T:yWorks.Algorithms.IDataProvider" />) that hold arbitrary data which is associated to its nodes and/or edges. <br /> Also, it serves as a factory to create so-called maps (<see cref="T:yWorks.Algorithms.INodeMap" />, <see cref="T:yWorks.Algorithms.IEdgeMap" />) that can be utilized to bind arbitrary data to nodes and edges.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Graph.HasListeners">
      <summary>
        <para>Determines whether there are listeners registered with this instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Graph.#ctor">
      <summary>
        <para>Instantiates an empty Graph object.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Graph.#ctor(yWorks.Algorithms.Graph,yWorks.Algorithms.ICursor)">
      <summary>
        <para>Instantiates a new Graph object as a partial copy of the given graph.</para>
      </summary>
      <remarks>
        <para>Only the subgraph induced by the given cursor will be copied to the new Graph instance. If no cursor is specifed, the complete graph is copied. Values bound to the argument graph via node and edge keys are available in the new Graph instance with the keys registered with <c>graph</c>. Only references to these values are copied.</para>
        <para>The new Graph instance also inherits all graph listeners registered with the given graph.</para>
      </remarks>
      <param name="graph">
        <para>The graph to be (partially) copied.</para>
      </param>
      <param name="subNodes">
        <para>A cursor to iterate over the nodes that actually induce the subgraph to be copied.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.CreateCopy">
      <summary>
        <para>Creates a copy of this graph.</para>
      </summary>
      <remarks>
        <para>Invokes <see cref="M:yWorks.Algorithms.Graph.#ctor(yWorks.Algorithms.Graph,yWorks.Algorithms.ICursor)" />.</para>
      </remarks>
      <returns>
        <para>The newly created Graph object.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Graph.CreateNode">
      <summary>
        <para>Creates a new node in this graph and fires a corresponding notification event to inform registered listeners.</para>
      </summary>
      <returns>
        <para>The newly created Node object.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Graph.CreateEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a new edge in this graph and fires a corresponding notification event to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>The new edge has source node <c>v</c> and target node <c>w</c>, i.e., would be written as edge <c>e = (v, w)</c>.</para>
        <para>The edge is appended to the lists of incoming and outgoing edges at the source node and target node, respectively.</para>
      </remarks>
      <param name="v">
        <para>The source node of the edge.</para>
      </param>
      <param name="w">
        <para>The target node of the edge.</para>
      </param>
      <returns>
        <para>The newly created Edge object.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Graph.CreateEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion,yWorks.Algorithms.GraphElementInsertion)">
      <summary>
        <para>Creates a new edge in this graph to be ordered before or after a given edge and fires a corresponding notification event to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>The new edge <c>e</c> has source node <c>v</c> and target node <c>w</c>, i.e., would be written as edge <c>e = (v, w)</c>. <br /> <br /> Edge <c>e</c> is inserted in such a way that an iteration over the edges at node <c>v</c> returns <c>e</c></para>
        <list type="bullet">
          <item>after <c>e1</c>, if <c>d1 == AFTER</c></item>
          <item>before <c>e1</c>, if <c>d1 == BEFORE</c>,</item>
        </list>
        <para>and an iteration over the edges at <c>w</c> returns <c>e</c></para>
        <list type="bullet">
          <item>after <c>e2</c>, if <c>d2 == AFTER</c></item>
          <item>before <c>e2</c>, if <c>d2 == BEFORE</c>.</item>
        </list>
      </remarks>
      <param name="v">
        <para>The source node of the edge.</para>
      </param>
      <param name="e1">
        <para>An edge with source node <c>v</c>.</para>
      </param>
      <param name="w">
        <para>The target node of the edge.</para>
      </param>
      <param name="e2">
        <para>An edge with target node <c>w</c>.</para>
      </param>
      <param name="d1">
        <para>One of the object insertion specifiers <see cref="F:yWorks.Algorithms.GraphElementInsertion.Before" /> or <see cref="F:yWorks.Algorithms.GraphElementInsertion.After" />.</para>
      </param>
      <param name="d2">
        <para>One of the object insertion specifiers <see cref="F:yWorks.Algorithms.GraphElementInsertion.Before" /> or <see cref="F:yWorks.Algorithms.GraphElementInsertion.After" />.</para>
      </param>
      <returns>
        <para>The newly created Edge object.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Graph.RemoveNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Removes the given node from this graph.</para>
      </summary>
      <remarks>
        <para>All edges connecting to the given node are removed as well (preceding the actual node removal). Corresponding notification events are fired to inform registered listeners.</para>
        <para>The node will be deselected before it gets removed.</para>
      </remarks>
      <param name="v">
        <para>The node to be removed from this graph.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.RemoveEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Removes the given edge from this graph and fires a corresponding notification event to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>The edge will be deselected before it gets removed.</para>
      </remarks>
      <param name="e">
        <para>The edge to be removed.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.ReInsertNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Reinserts a formerly removed node into this graph and fires a corresponding notification event to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>The reinserted node is appended to the sequence of nodes in this graph, i.e., normally, its new position does not match the position before its removal.</para>
      </remarks>
      <param name="v">
        <para>The node to be reinserted.</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.Graph.RemoveNode(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.ReInsertEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Reinserts a formerly removed edge into this graph and fires a corresponding notification event to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>The reinserted edge is appended to the sequence of edges in this graph, i.e., normally, its new position does not match the position before its removal. The same holds for the edge's positions in the list of incoming and outgoing edges at its source node and target node, respectively.</para>
        <para>Note that reinserting an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed) causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.</para>
      </remarks>
      <param name="e">
        <para>The edge to be reinserted.</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.Graph.RemoveEdge(yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.ChangeEdge(yWorks.Algorithms.Edge,yWorks.Algorithms.Edge,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion,yWorks.Algorithms.GraphElementInsertion)">
      <summary>
        <para>Redefines an edge's end points and fires corresponding notification events to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>Edge <c>e</c> has source node <c>v := e1.source()</c> and target node <c>w := e2.target()</c>. <br /> <br /> Edge <c>e</c> is inserted in such a way that an iteration over the edges at <c>v</c> returns <c>e</c></para>
        <list type="bullet">
          <item>after <c>e1</c>, if <c>d1 == AFTER</c></item>
          <item>before <c>e1</c>, if <c>d1 == BEFORE</c>,</item>
        </list>
        <para>and an iteration over the edges at <c>w</c> returns <c>e</c></para>
        <list type="bullet">
          <item>after <c>e2</c>, if <c>d2 == AFTER</c></item>
          <item>before <c>e2</c>, if <c>d2 == BEFORE</c>.</item>
        </list>
      </remarks>
      <param name="e">
        <para>The edge to be changed.</para>
      </param>
      <param name="e1">
        <para>Reference edge for insertion at a new source node.</para>
      </param>
      <param name="e2">
        <para>Reference edge for insertion at a new target node.</para>
      </param>
      <param name="d1">
        <para>One of the object insertion specifiers <see cref="F:yWorks.Algorithms.GraphElementInsertion.Before" /> or <see cref="F:yWorks.Algorithms.GraphElementInsertion.After" />.</para>
      </param>
      <param name="d2">
        <para>One of the object insertion specifiers <see cref="F:yWorks.Algorithms.GraphElementInsertion.Before" /> or <see cref="F:yWorks.Algorithms.GraphElementInsertion.After" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.ChangeEdge(yWorks.Algorithms.Edge,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Algorithms.GraphElementInsertion)">
      <summary>
        <para>Redefines an edge's end points and fires corresponding notification events to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>Edge <c>e</c> has source node <c>v := sourceReference.source()</c> or <c>v := newSource</c>, if <c>sourceReference == null</c> and target node <c>w := targetReference.target()</c> or <c>w := newTarget</c>, if <c>targetReference == null</c>. <br /> <br /> Edge <c>e</c> is inserted in such a way that an iteration over the edges at <c>v</c> returns <c>e</c></para>
        <list type="bullet">
          <item>after <c>sourceReference</c>, if <c>sourceD == AFTER</c></item>
          <item>before <c>sourceReference</c>, if <c>sourceD == BEFORE</c>,</item>
        </list>
        <para>and an iteration over the edges at <c>w</c> returns <c>e</c></para>
        <list type="bullet">
          <item>after <c>targetReference</c>, if <c>targetD == AFTER</c></item>
          <item>before <c>targetReference</c>, if <c>targetD == BEFORE</c>.</item>
        </list>
      </remarks>
      <param name="e">
        <para>The edge to be changed.</para>
      </param>
      <param name="newSource">
        <para>The new source node.</para>
      </param>
      <param name="sourceReference">
        <para>Reference edge for insertion at the new source node.</para>
      </param>
      <param name="sourceD">
        <para>One of the object insertion specifiers <see cref="F:yWorks.Algorithms.GraphElementInsertion.Before" /> or <see cref="F:yWorks.Algorithms.GraphElementInsertion.After" />.</para>
      </param>
      <param name="newTarget">
        <para>The new target node.</para>
      </param>
      <param name="targetReference">
        <para>Reference edge for insertion at the new target node.</para>
      </param>
      <param name="targetD">
        <para>One of the object insertion specifiers <see cref="F:yWorks.Algorithms.GraphElementInsertion.Before" /> or <see cref="F:yWorks.Algorithms.GraphElementInsertion.After" />.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.ChangeEdge(yWorks.Algorithms.Edge,yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Redefines an edge's end points and fires corresponding notification events to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>The edge is appended to the lists of incoming and outgoing edges at the given source node and target node, respectively.</para>
      </remarks>
      <param name="e">
        <para>The edge to be changed.</para>
      </param>
      <param name="newSource">
        <para>The new source node of the given edge.</para>
      </param>
      <param name="newTarget">
        <para>The new target node of the given edge.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.ReverseEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Reverses the given edge and fires corresponding notification events to inform registered listeners.</para>
      </summary>
      <remarks>
        <para>This operation exchanges source and target node of the edge.</para>
      </remarks>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Edge)">
      <summary>
        <para>Hides the given edge from this graph.</para>
      </summary>
      <remarks>
        <para>Hiding an edge means to (temporarily) remove the edge from the graph.</para>
        <para>The only difference to a proper edge removal as performed by <see cref="M:yWorks.Algorithms.Graph.RemoveEdge(yWorks.Algorithms.Edge)" /> is that no <see cref="T:yWorks.Algorithms.GraphEvent" /> will be emitted that signals the structural change (i.e. the edge's removal).</para>
        <para>Generally, hiding should <i>only</i> be used in the sense of temporarily removing an object that will be reinserted shortly after.</para>
        <para>To reinsert a hidden edge use <see cref="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Edge)" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Node)" />
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Edge)">
      <summary>
        <para>Unhides the given edge in this graph.</para>
      </summary>
      <remarks>
        <para>Unhiding an edge means to reinsert an edge that was formerly hidden from this graph by a call to <see cref="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Edge)" />.</para>
        <para>The only difference to a proper edge reinsertion as performed by <see cref="M:yWorks.Algorithms.Graph.ReInsertEdge(yWorks.Algorithms.Edge)" /> is that no <see cref="T:yWorks.Algorithms.GraphEvent" /> will be emitted that signals the structural change (i.e. the edge's reinsertion).</para>
        <para>Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed) causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Node)" />
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Node)">
      <summary>
        <para>Hides the given node from this graph.</para>
      </summary>
      <remarks>
        <para>Hiding a node means to (temporarily) remove the node from the graph.</para>
        <para>The only difference to a proper node removal as performed by <see cref="M:yWorks.Algorithms.Graph.RemoveNode(yWorks.Algorithms.Node)" /> is that no <see cref="T:yWorks.Algorithms.GraphEvent" /> will be emitted that signals the structural change (i.e. the node's removal).</para>
        <para>Generally, hiding should <i>only</i> be used in the sense of temporarily removing an object that will be reinserted shortly after.</para>
        <para>To reinsert a hidden node use <see cref="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Node)" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Edge)" />
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Node)">
      <summary>
        <para>Unhides the given node in this graph.</para>
      </summary>
      <remarks>
        <para>Unhiding a node means to reinsert a node that was formerly hidden from this graph by a call to <see cref="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Node)" />.</para>
        <para>The only difference to a proper node reinsertion as performed by <see cref="M:yWorks.Algorithms.Graph.ReInsertNode(yWorks.Algorithms.Node)" /> is that no <see cref="T:yWorks.Algorithms.GraphEvent" /> will be emitted that signals the structural change (i.e. the node's reinsertion).</para>
      </remarks>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.MoveToLast(yWorks.Algorithms.Node)">
      <summary>
        <para>Moves the given node to the last position within the sequence of nodes in this graph.</para>
      </summary>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.MoveToFirst(yWorks.Algorithms.Node)">
      <summary>
        <para>Moves the given node to the first position within the sequence of nodes in this graph.</para>
      </summary>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.MoveToLast(yWorks.Algorithms.Edge)">
      <summary>
        <para>Moves the given edge to the last position within the sequence of edges in this graph.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.MoveToFirst(yWorks.Algorithms.Edge)">
      <summary>
        <para>Moves the given edge to the first position within the sequence of edges in this graph.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="P:yWorks.Algorithms.Graph.N">
      <summary>
        <para>Gets the number of nodes in this graph.</para>
      </summary>
      <remarks>
        <para>Same as <see cref="P:yWorks.Algorithms.Graph.NodeCount" />.</para>
      </remarks>
      <value>
        <para>the number of nodes in this graph.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Graph.NodeCount">
      <summary>
        <para>Gets the number of nodes in this graph.</para>
      </summary>
      <value>
        <para>the number of nodes in this graph.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Graph.E">
      <summary>
        <para>Gets the number of edges in this graph.</para>
      </summary>
      <remarks>
        <para>Same as <see cref="P:yWorks.Algorithms.Graph.EdgeCount" />.</para>
      </remarks>
      <value>
        <para>the number of edges in this graph.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Graph.EdgeCount">
      <summary>
        <para>Gets the number of edges in this graph.</para>
      </summary>
      <value>
        <para>the number of edges in this graph.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Graph.Empty">
      <summary>
        <para>Gets <c>true</c> if this graph contains no nodes.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this graph contains no nodes, otherwise <c>false</c>.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Graph.Clear">
      <summary>
        <para>Removes all nodes and edges from this graph and fires corresponding notification events to inform registered listeners.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Graph.Contains(yWorks.Algorithms.Node)">
      <summary>
        <para>Whether or not this graph contains the given node.</para>
      </summary>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.Contains(yWorks.Algorithms.Edge)">
      <summary>
        <para>Whether or not this graph contains the given edge.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.ContainsEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns whether or not this graph contains an edge that connects the given nodes.</para>
      </summary>
      <param name="source">
        <para>The source node.</para>
      </param>
      <param name="target">
        <para>The target node.</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.Node.GetEdgeTo(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Node.GetEdgeFrom(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Node.GetEdge(yWorks.Algorithms.Node)" />
    </member>
    <member name="P:yWorks.Algorithms.Graph.FirstNode">
      <summary>
        <para>Gets the first node in this graph.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Graph.FirstEdge">
      <summary>
        <para>Gets the first edge in this graph.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Graph.LastNode">
      <summary>
        <para>Gets the last node in this graph.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Graph.LastEdge">
      <summary>
        <para>Gets the last edge in this graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Graph.GetNodeArray">
      <summary>
        <para>Returns an array containing all nodes of this graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Graph.GetEdgeArray">
      <summary>
        <para>Returns an array containing all edges of this graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Graph.GetNodeCursor">
      <summary>
        <para>Provides access to the nodes of the graph.</para>
      </summary>
      <returns>
        <para>A NodeCursor to iterate over the nodes in the graph.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Graph.GetEdgeCursor">
      <summary>
        <para>Provides access to the edges of the graph.</para>
      </summary>
      <returns>
        <para>An EdgeCursor to iterate over the edges in the graph.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Graph.CreateGraph">
      <summary>
        <para>Creates an empty base object of the same type as this graph.</para>
      </summary>
      <remarks>
        <para>Subclasses should override this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Graph.SortEdges(System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Sorts the internally held list of edges.</para>
      </summary>
      <remarks>
        <para>If the given comparator is <c>null</c>, then the edges will not be sorted. This list determines the order of the edges as returned by <see cref="M:yWorks.Algorithms.Graph.GetEdgeCursor" />.</para>
      </remarks>
      <param name="comp">
        <para>The comparator used for the edges.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.SortNodes(System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Sorts the internally held list of nodes.</para>
      </summary>
      <remarks>
        <para>If the given comparator is <c>null</c>, then the nodes will not be sorted. This list determines the order of the nodes as returned by <see cref="M:yWorks.Algorithms.Graph.GetNodeCursor" />.</para>
      </remarks>
      <param name="comp">
        <para>The comparator used for the nodes.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.SortEdges(System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Sorts incoming and outgoing edges at each node of the graph.</para>
      </summary>
      <remarks>
        <para>If a given comparator is <c>null</c>, then the corresponding edges (i.e., incoming/outgoing) will not be sorted. This sorts the order of the edges as returned by <see cref="M:yWorks.Algorithms.Node.GetOutEdgeCursor(yWorks.Algorithms.Edge)" /> and <see cref="M:yWorks.Algorithms.Node.GetInEdgeCursor(yWorks.Algorithms.Edge)" /> respectively.</para>
      </remarks>
      <param name="inComp">
        <para>The comparator used for the incoming edges at each node.</para>
      </param>
      <param name="outComp">
        <para>The comparator used for the outgoing edges at each node.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Graph.CreateNodeMap">
      <summary>
        <para>Returns a newly created node map that is valid for the nodes in this graph.</para>
      </summary>
      <remarks>
        <para>The implementation returned by this method can be used for any node that is part of this Graph instance at any point of time, i.e., it is safe to modify the graph structure (add and remove nodes and edges) freely.</para>
        <para>The implementation returned uses <c>O(n)</c> memory at all times and provides true <c>O(1)</c> read and write access for each node.</para>
        <para>In order to release the resources held by this map, <see cref="M:yWorks.Algorithms.Graph.DisposeNodeMap(yWorks.Algorithms.INodeMap)" /> has to be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Graph.CreateEdgeMap">
      <summary>
        <para>Returns a newly created edge map that is valid for the edges in this graph.</para>
      </summary>
      <remarks>
        <para>The implementation returned by this method can be used for any edge that is part of this Graph instance at any point of time, i.e., it is safe to modify the graph structure (add and remove nodes and edges) freely.</para>
        <para>The implementation returned uses <c>O(m)</c> memory at all times and provides true <c>O(1)</c> read and write access for each edge.</para>
        <para>In order to release the resources held by this map, <see cref="M:yWorks.Algorithms.Graph.DisposeEdgeMap(yWorks.Algorithms.IEdgeMap)" /> has to be called.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Graph.DisposeNodeMap(yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Informs the graph that the given node map is no longer needed.</para>
      </summary>
      <remarks>
        <para>This method is used for NodeMap implementations that have been obtained using the <see cref="M:yWorks.Algorithms.Graph.CreateNodeMap" /> factory method.</para>
        <para>Calling this method will destroy the node map and associated resources can be freed. It is strongly recommended to dispose of all node maps that are not needed anymore using this method.</para>
      </remarks>
      <param name="map" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.DisposeEdgeMap(yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Informs the graph that the given edge map is no longer needed.</para>
      </summary>
      <remarks>
        <para>This method is used for EdgeMap implementations that have been obtained using the <see cref="M:yWorks.Algorithms.Graph.CreateEdgeMap" /> factory method.</para>
        <para>Calling this method will destroy the edge map and associated resources can be freed. It is strongly recommended to dispose of all edge maps that are not needed anymore using this method.</para>
      </remarks>
      <param name="map" />
    </member>
    <member name="P:yWorks.Algorithms.Graph.RegisteredNodeMaps">
      <summary>
        <para>Gets all node maps that have been created by this graph but have not yet been disposed.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Graph.CreateNodeMap" />
      <seealso cref="M:yWorks.Algorithms.Graph.DisposeNodeMap(yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="P:yWorks.Algorithms.Graph.RegisteredEdgeMaps">
      <summary>
        <para>Gets all edge maps that have been created by this graph but have not yet been disposed.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Graph.CreateEdgeMap" />
      <seealso cref="M:yWorks.Algorithms.Graph.DisposeEdgeMap(yWorks.Algorithms.IEdgeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.GetDataProvider(System.Object)">
      <summary>
        <para>Returns the data provider that is registered with the graph using the given look-up key.</para>
      </summary>
      <remarks>
        <para>The look-up domain of a returned data provider normally consists of either the nodes of the graph, or its edges, or both.</para>
      </remarks>
      <param name="providerKey" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.AddDataProvider(System.Object,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Registers the given data provider using the given look-up key.</para>
      </summary>
      <remarks>
        <para>If there is already a data provider registered with that key, then it will be overwritten with the new one.</para>
      </remarks>
      <param name="providerKey" />
      <param name="data" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.RemoveDataProvider(System.Object)">
      <summary>
        <para>Removes the data provider that is registered using the given look-up key.</para>
      </summary>
      <param name="providerKey" />
    </member>
    <member name="P:yWorks.Algorithms.Graph.DataProviderKeys">
      <summary>
        <para>Gets an array of all data provider look-up keys that are registered with this graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Graph.FirstOutEdge(yWorks.Algorithms.Node)">
      <summary>
        <para>Low-level iteration support for adjacent edges.</para>
      </summary>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Graph.PrintNodeSlotSize">
      <summary>
        <para>For internal debugging purposes only.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Graph.ToString">
      <summary>
        <para>Returns a String representation of this graph.</para>
      </summary>
      <remarks>
        <para>The result contains the String representations of all nodes followed by the String representations of all edges.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Graph.Nodes">
      <summary>
        <para>Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" /> for <see cref="T:yWorks.Algorithms.Node" />s that can be used to iterate over the nodes that are contained in this instance.</para>
      </summary>
      <remarks>
        <para>This is a live enumerable and will thus reflect the current state of the graph. Note that changes to the graph structure during the traversal should be carried out with great care.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Graph.Edges">
      <summary>
        <para>Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" /> for <see cref="T:yWorks.Algorithms.Edge" />s that can be used to iterate over the edges that are contained in this instance.</para>
      </summary>
      <remarks>
        <para>This is a live enumerable and will thus reflect the current state of the graph. Note that changes to the graph structure during the traversal should be carried out with great care.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.GraphChecker">
      <summary>
        <para>This class provides methods that check structural properties of a given graph.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>
            <b>Cycle:</b> An edge path with vertices <c>v0, v1, v2, ... , vk</c> forms a cycle if <c>v0 = vk</c> and consists of at least one edge.</item>
          <item>
            <b>Acyclic graph:</b> A graph that contains no directed cycle.</item>
          <item>
            <b>Cyclic graph:</b> A graph that contains a directed cycle.</item>
          <item>
            <b>Connected graph:</b> A graph in which there exists an undirected path of edges between every pair of nodes.</item>
          <item>
            <b>Strongly connected graph:</b> A graph in which there exists a directed path between each pair of nodes.</item>
          <item>
            <b>Biconnected graph:</b> A graph that has no cut vertex or articulation point (i.e., a node whose removal disconnects the graph).</item>
          <item>
            <b>Bipartite graph:</b> A graph whose nodes can be partitioned into two sets such that each edge connects two nodes of different sets.</item>
          <item>
            <b>Tree graph:</b> An acyclic graph, in which any pair of vertices is connected through a path. If one vertex of a tree is distinguished from the other vertices, then the tree is called <b>rooted tree</b>.</item>
          <item>
            <b>N-ary tree graph:</b> A directed rooted tree where each node has a maximum of <c>n</c> children.</item>
          <item>
            <b>Forest graph:</b> A graph whose connected components are trees.</item>
          <item>
            <b>Simple graph:</b> A graph that contains no self-loops and parallel edges.</item>
          <item>
            <b>Planar graph:</b> A graph that can be drawn on the plane without edge crossings.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsAcyclic(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given directed graph is acyclic.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>acyclic</i> if it contains no directed cycle.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is acyclic, <c>false</c>, otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsCyclic(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given directed graph is cyclic.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>cyclic</i> if it contains a directed cycle.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is cyclic, <c>false</c>, otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsPlanar(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given graph is planar.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>planar</i> if it can be drawn on the plane without edge crossings.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is planar, <c>false</c>, otherwise.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsConnected(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given graph is connected.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>connected</i> if there exists an undirected path of edges between every pair of nodes.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is connected, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsStronglyConnected(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given directed graph is strongly connected.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>strongly connected</i> if there exists a directed path between each pair of nodes.</para>
      </remarks>
      <param name="graph">
        <para>the given directed graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is strongly connected, <c>false</c>, otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsBiconnected(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given undirected graph is biconnected.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>biconnected</i> if it has no cut vertex or articulation point, i.e., no node whose removal disconnects the graph.</para>
      </remarks>
      <param name="graph">
        <para>the given undirected graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is biconnected, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsBipartite(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given undirected graph is bipartite.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>bipartite</i> if its nodes can be partitioned into two sets such that each edge connects two nodes of different sets.</para>
      </remarks>
      <param name="graph">
        <para>the given undirected graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is bipartite, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsNaryTree(yWorks.Algorithms.Graph,System.Int32)">
      <summary>
        <para>Checks whether or not the given graph is a directed rooted tree where each node has a maximum of <c>n</c> children.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is a directed rooted tree where each node has at most <c>n</c> children, <c>false</c> otherwise</para>
      </returns>
      <param name="n" />
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsRootedTree(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given directed graph is a directed rooted tree.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is a directed rooted tree, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsTree(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given graph is an undirected tree.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is an undirected tree, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsForest(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether the given graph is a forest.</para>
      </summary>
      <remarks>
        <para>A graph is a <i>forest</i> if its connected components are trees.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is a forest, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsSelfLoopFree(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given graph contains no self-loops.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph contains no self-loops, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsSimple(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given directed graph is simple.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>simple</i> if it contains no two distinct edges <c>e1, e2</c> where <c>e1.source() == e2.source() &amp;&amp; e1.target() == e2.target()</c>.</para>
      </remarks>
      <param name="graph">
        <para>the given directed graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is simple, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphChecker.IsMultipleEdgeFree(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given undirected graph contains no multiple edges.</para>
      </summary>
      <remarks>
        <para>More precisely, the method returns <c>true</c> if the graph contains no two distinct edges <c>e1, e2</c> that connect the same pairs of nodes in either direction.</para>
      </remarks>
      <param name="graph">
        <para>the given undirected graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph contains no multiple edges, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.GraphConnectivity">
      <summary>
        <para>This class provides algorithms for determining certain connectivity components within a graph.</para>
      </summary>
      <remarks>
        <para>It also provides convenience methods for working with these components.</para>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>
            <b>Connected graph:</b> A graph is called connected if there exists an undirected path of edges between every pair of nodes.</item>
          <item>
            <b>Strongly connected graph:</b> A graph is called strongly connected if there exists a directed path between each pair of nodes.</item>
          <item>
            <b>Biconnected graph:</b> A graph is called biconnected if it has no cut vertex or articulation point (i.e., a node whose removal disconnects the remaining graph).</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.Algorithms.Graph)">
      <summary>
        <para>Calculates the connected components of a given graph.</para>
      </summary>
      <remarks>
        <para>A graph <c>G</c> is called <i>connected</i> if there exists an undirected path of edges between every pair of nodes.</para>
        <para>The connected components of a graph are the maximal connected subgraphs of which the graph consists.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes that belong to the same connected component</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Calculates the connected components of a given graph and returns their number.</para>
      </summary>
      <remarks>
        <para>A graph <c>G</c> is called <i>connected</i> if there exists an undirected path of edges between every pair of nodes.</para>
        <para>The connected components of a graph are the maximal connected subgraphs of which the graph consists.</para>
      </remarks>
      <param name="compNum">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns the zero-based index of the connected component to which each node belongs</para>
      </param>
      <returns>
        <para>the number of connected components of the given graph</para>
      </returns>
      <param name="graph" />
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.MakeConnected(yWorks.Algorithms.Graph)">
      <summary>
        <para>Makes a graph connected by adding additional edges to the graph.</para>
      </summary>
      <remarks>
        <para>The number of edges that will be added equals the number of separate components of the original graph minus <c>1</c>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges added to the graph</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.ToNodeListArray(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Int32)">
      <summary>
        <para>Transforms the return values of method <see cref="M:yWorks.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)" /> to an array of <see cref="T:yWorks.Algorithms.NodeList" />s, like it is returned by <see cref="M:yWorks.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.Algorithms.Graph)" />.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="compNum">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns the zero-based index of the connected component to which each node belongs</para>
      </param>
      <param name="maxCompNum">
        <para>the maximum number of connected components</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes that belong to the same connected component</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.IsConnected(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given graph is connected.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>connected</i> if there exists an undirected path of edges between every pair of nodes.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is connected, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.Algorithms.Graph)">
      <summary>
        <para>Calculates the biconnected components of a given undirected graph.</para>
      </summary>
      <remarks>
        <para>The result is returned as an array of <see cref="T:yWorks.Algorithms.EdgeList" />s each containing all edges that belong to the same biconnected component.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.EdgeList" />s each containing all edges that belong to the same biconnected component</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Calculates the biconnected components and the articulation points of a given undirected graph and returns the number of biconnected components.</para>
      </summary>
      <remarks>
        <para>Articulation points are returned in the form of a <see cref="T:yWorks.Algorithms.INodeMap" /> that returns for each node a boolean value indicating whether or not it is an articulation point.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="compNum">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution and returns the zero-based index of the biconnected component to which each edge belongs or <c>-1</c> for self-loops</para>
      </param>
      <param name="aPoint">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a boolean value indicating whether or not a given node is an articulation point</para>
      </param>
      <returns>
        <para>the number of biconnected components</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.Algorithms.Graph)" />
      <seealso cref="M:yWorks.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.ToEdgeListArray(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap,System.Int32)">
      <summary>
        <para>Transforms the return values of <see cref="M:yWorks.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" /> to an array of <see cref="T:yWorks.Algorithms.EdgeList" />s, like it is returned by <see cref="M:yWorks.Algorithms.GraphConnectivity.BiconnectedComponents(yWorks.Algorithms.Graph)" />.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="compNum">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution and returns the zero-based index of the connected component to which each edge belongs</para>
      </param>
      <param name="maxCompNum">
        <para>the maximum number of biconnected components</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.EdgeList" />s each containing all edges that belong to the same biconnected component</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.MakeBiconnected(yWorks.Algorithms.Graph)">
      <summary>
        <para>Makes the given graph biconnected by inserting a minimum number of edges in the graph.</para>
      </summary>
      <remarks>
        <para>The given graph is considered to be undirected.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges added to the graph</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.IsBiconnected(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given undirected graph is biconnected.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>biconnected</i> if it has no cut vertex or articulation point, i.e., no node whose removal disconnects the graph.</para>
      </remarks>
      <param name="graph">
        <para>the given undirected graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is biconnected, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.Reachable(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Boolean[],System.Boolean[])">
      <summary>
        <para>Determines the set of nodes that are reachable from a given node when a set of edges that cannot be traversed is specified.</para>
      </summary>
      <remarks>
        <para>The result is based on a depth first search.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="start">
        <para>the node from which the search starts</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the edges should be traversed from source to target, <c>false</c> if edges can be traversed in both directions</para>
      </param>
      <param name="forbidden">
        <para>an array that holds for each <see cref="T:yWorks.Algorithms.Edge" /> a <see cref="T:System.Boolean" /> value indicating whether or not an edge can be traversed; an edge <c>e</c> is marked as forbidden if <c>forbidden[e.index()] == true</c></para>
      </param>
      <param name="reached">
        <para>an array that will be filled during the execution and returns for each <see cref="T:yWorks.Algorithms.Node" /> a <see cref="T:System.Boolean" /> value based on whether the node can be reached during the DFS; if a node <c>v</c> is reachable, then <c>reached[v.index()] = true</c></para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.GetSuccessors(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,System.Int32)">
      <summary>
        <para>Determines the direct or indirect successors of a given list of nodes.</para>
      </summary>
      <remarks>
        <list type="bullet">
          <item>A <i>direct</i> successor of a node is the target node of an outgoing edge connected to a node.</item>
          <item>An <i>indirect</i> successor of a node is a direct successor to another successor of a node.</item>
        </list>
        <para>The order of the returned nodes is determined by a breadth first search. No start node will be part of the resulting set.</para>
        <para>To obtain the result, an integer value should be given as input that limits the distance between a start node and a returned node. For all returned nodes there must be a path to a start node that has a length equal to or smaller than this distance.</para>
        <para>Setting the maximum distance to <c>1</c> will only yield the direct successors of all start nodes. On the other hand, setting the maximum distance to <c>graph.N()</c> or larger will yield all successors of all start nodes.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="startNodes">
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes from which the search starts</para>
      </param>
      <param name="maxDistance">
        <para>an integer value that limits the distance between a start node and a returned node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> that contains all direct and indirect successors of a node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.GetPredecessors(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,System.Int32)">
      <summary>
        <para>Determines the direct or indirect predecessors of a given list of nodes.</para>
      </summary>
      <remarks>
        <list type="bullet">
          <item>A <i>direct</i> predecessor of a node is the source node of an incoming edge connected to a node.</item>
          <item>An <i>indirect</i> predecessor of a node is a direct predecessor to another predecessor of a node.</item>
        </list>
        <para>The order of the returned nodes is determined by a breadth first search. No start node will be part of the resulting set.</para>
        <para>To obtain the result, an integer value should be given as input that limits the distance between a start node and a returned node. For all returned nodes there must be a path to a start node that has a length equal to or smaller than this distance.</para>
        <para>Setting the maximum distance to <c>1</c> will only yield the direct predecessors of all start nodes. On the other hand, setting the maximum distance to <c>graph.N()</c> or larger will yield all predecessors of all start nodes.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="startNodes">
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes from which the search starts</para>
      </param>
      <param name="maxDistance">
        <para>an integer value that limits the distance between a start node and a returned node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> that contains all direct and indirect predecessors of a node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.GetNeighbors(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,System.Int32)">
      <summary>
        <para>Determines the direct or indirect neighbors of a given set of nodes.</para>
      </summary>
      <remarks>
        <list type="bullet">
          <item>A <i>direct</i> neighbor of a node is directly connected by an edge to that node.</item>
          <item>An <i>indirect</i> neighbor of a node is directly connected to another direct or indirect neighbor of a node.</item>
        </list>
        <para>The order of the returned nodes is determined by a breadth first search. No start node will be part of the resulting set.</para>
        <para>To obtain the result, an integer value should be given as input that limits the distance between a start node and a returned node. For all returned nodes there must be a path to a start node that has a length equal to or smaller than this distance.</para>
        <para>Setting the maximum distance to <c>1</c> will only yield the direct neighbors of all start nodes. On the other hand, setting the maximum distance to <c>graph.N()</c> or larger will yield all neighbors of all start nodes.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> that contains all direct and indirect neighbors of a node</para>
      </returns>
      <param name="graph" />
      <param name="startNodes" />
      <param name="maxDistance" />
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.StronglyConnectedComponents(yWorks.Algorithms.Graph)">
      <summary>
        <para>Calculates the strongly connected components of a given graph.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>strongly connected</i> if there exists a directed path between each pair of nodes.</para>
        <para>The strongly connected components of a graph are the strongly connected subgraphs of which it consists.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains the nodes that belong to the same strongly connected component</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.GraphConnectivity.StronglyConnectedComponents(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.StronglyConnectedComponents(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Calculates the strongly connected components of a given graph and returns their number.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>strongly connected</i> if there exists a directed path between each pair of nodes.</para>
        <para>The strongly connected components of a graph are the strongly connected subgraphs of which it consists.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="compNum">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns the zero-based index of the connected component to which each node belongs</para>
      </param>
      <returns>
        <para>the number of strongly connected components of the given graph</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.GraphConnectivity.StronglyConnectedComponents(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Algorithms.GraphConnectivity.IsStronglyConnected(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given directed graph is strongly connected.</para>
      </summary>
      <remarks>
        <para>A graph is called <i>strongly connected</i> if there exists a directed path between each pair of nodes.</para>
      </remarks>
      <param name="graph">
        <para>the given directed graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is strongly connected, <c>false</c>, otherwise</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.GraphObject">
      <summary>
        <para>Common base type for both <see cref="T:yWorks.Algorithms.Node" /> and <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <remarks>
        <para>This type does not add public functionality to its base type.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.Groups">
      <summary>
        <para>This class provides methods for automatically partitioning nodes of a graph into groups.</para>
      </summary>
      <remarks>
        <para>Partitions can be defined using edge betweenness centrality, biconnectivity, k-means clustering or hierarchical clustering.</para>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>
            <b>Betweenness centrality</b> is a measure for how often a node lies on a shortest path between each pair of nodes in the graph.</item>
          <item>
            <b>Biconnected graph</b> is a graph that has no cut vertex or articulation point (i.e., a node whose removal disconnects the graph).</item>
          <item>
            <b>K-means clustering algorithm</b> partitions the nodes of a graph into <c>k</c>-clusters based on their positions on the plane and a given distance metric.</item>
          <item>
            <b>Hierarchical clustering</b> creates a hierarchy of clusters in a bottom-to-top approach based on some distance metric and linkage.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Groups.EdgeBetweennessClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Boolean,System.Int32,System.Int32,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Partitions the graph into groups using <i>edge betweenness centrality</i>.</para>
      </summary>
      <remarks>
        <para>In each iteration the edge with the highest betweenness centrality is removed from the graph. The method stops, if there are no more edges to remove. The clustering with the best quality reached during the process will be returned.</para>
        <para>The method requires the maximum number of groups that will be returned. The smaller this value is, the faster the overall computation time. The upper bound on the number of groups is <c>graph.N()</c>. Also, the number of returned groups is never smaller than the number of connected components of the graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="clusterIDs">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns an integer value (cluster ID) for each node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="minGroupCount">
        <para>the minimum number of groups that will be returned</para>
      </param>
      <param name="maxGroupCount">
        <para>the maximum number of groups that will be returned</para>
      </param>
      <param name="edgeCosts">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds a positive <see cref="T:System.Double" /> cost or <c>null</c> if the edges of the graph are considered to be of equal cost</para>
      </param>
      <returns>
        <para>the resulting number of different groups</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if <c>minGroupCount &gt; maxGroupCount</c> or <c>minGroupCount &gt; graph.N()</c> or <c>maxGroupCount &lt;= 0</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Groups.EdgeBetweennessClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Double,System.Int32,System.Int32,System.Boolean)">
      <summary>
        <para>Partitions the graph into groups using <i>edge betweenness clustering</i> proposed by Girvan and Newman.</para>
      </summary>
      <remarks>
        <para>In each iteration the edge with the highest betweenness centrality is removed from the graph. The method stops, if there are no more edges to remove or if the requested maximum number of groups is found. The clustering with the best quality reached during the process is returned.</para>
        <para>The algorithm includes several heuristic speed-up techniques available through the quality/time ratio. For the highest quality setting, it is used almost unmodified. The fast betweenness approximation of Brandes and Pich (<i>Centrality Estimation in Large Networks</i>) is employed for values around <c>0.5</c>. Typically, this results in a tiny decrease in quality but a large speed-up and is the recommended setting. To achieve the lowest running time, a local betweenness calculation is used (Gregory: <i>Local Betweenness for Finding Communities in Networks</i>).</para>
        <para>The method requires the maximum number of groups that will be returned. The smaller this value is, the faster the overall computation time. The upper bound on the number of groups is <c>graph.N()</c>. Also, the number of returned groups is never smaller than the number of connected components of the graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="clusterIDs">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns an integer value (cluster ID) for each node</para>
      </param>
      <param name="qualityTimeRatio">
        <para>a value between <c>0.0</c> (low quality, fast) and <c>1.0</c> (high quality, slow); the recommended value is <c>0.5</c></para>
      </param>
      <param name="minGroupCount">
        <para>the minimum number of groups that will be returned</para>
      </param>
      <param name="maxGroupCount">
        <para>the maximum number of groups that will be returned</para>
      </param>
      <param name="refine">
        <para>
          <c>true</c> if the algorithm refines the current grouping, <c>false</c> if the algorithm discards the current grouping</para>
      </param>
      <returns>
        <para>the resulting number of different groups</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if <c>minGroupCount &gt; maxGroupCount</c> or <c>minGroupCount &gt; graph.N()</c> or <c>maxGroupCount &lt;= 0</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Groups.BiconnectedComponentGrouping(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>This method partitions the graph by analyzing its <i>biconnected components</i>.</para>
      </summary>
      <remarks>
        <para>Nodes will be grouped such that the nodes within each group are biconnected. Nodes that belong to multiple biconnected components will be assigned to exactly one of these components.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="groupIDs">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns an integer value (cluster ID) for each node</para>
      </param>
      <returns>
        <para>the resulting number of different groups</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)">
      <summary>
        <para>Partitions the graph into clusters based on hierarchical clustering.</para>
      </summary>
      <remarks>
        <para>The clustering is performed using the agglomerative strategy i.e., a bottom-up approach according to which at the beginning each node belongs to its own cluster. At each step pairs of clusters are merged while moving up to the hierarchy. The dissimilarity between clusters is determined based on the given linkage and the given node distances metric. The algorithm continues until all nodes belong to the same cluster.</para>
        <para>The result is returned as a <see cref="T:yWorks.Algorithms.Groups.Dendrogram" /> object which represents the result of the clustering algorithm as a binary tree structure. It can easily be traversed by starting from the <see cref="P:yWorks.Algorithms.Groups.Dendrogram.Root">root node</see> and moving on to nodes of the next level via method <see cref="M:yWorks.Algorithms.Groups.Dendrogram.GetChildren(yWorks.Algorithms.Node)" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="distances">
        <para>a given <see cref="T:yWorks.Algorithms.Groups.INodeDistanceProvider" /> object that determines the distance between any two nodes</para>
      </param>
      <param name="linkage">
        <para>one of the predefined linkage values</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Groups.Dendrogram" /> which represents the result of the clustering as a binary tree</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown linkage is given</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage,System.Double)">
      <summary>
        <para>Partitions the graph into clusters based on hierarchical clustering, while the dendrogram is cut based on a given cut-off value.</para>
      </summary>
      <remarks>
        <para>The clustering is performed using the agglomerative strategy i.e., a bottom-up approach according to which at the beginning each node belongs to its own cluster. At each step pairs of clusters are merged while moving up to the hierarchy. The dissimilarity between clusters is determined based on the given linkage and the given node distances. The algorithm continues until all nodes belong to the same cluster.</para>
        <para>The result will be given based on the given cut-off value that is used for cutting the hierarchical tree at a point such that the dissimilarity values of the nodes that remain at the dendrogram are less than this value.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="clusterIDs">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns an integer value (cluster ID) for each node</para>
      </param>
      <param name="distances">
        <para>a given <see cref="T:yWorks.Algorithms.Groups.INodeDistanceProvider" /> object that determines the distance between any two nodes</para>
      </param>
      <param name="linkage">
        <para>one of the predefined linkage values</para>
      </param>
      <param name="cutOff">
        <para>the cut-off value that determines where to cut the hierarchic tree into clusters</para>
      </param>
      <returns>
        <para>the resulting number of clusters</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown linkage is used</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,System.Int32,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)">
      <summary>
        <para>Partitions the graph into clusters based on hierarchical clustering, while the dendrogram is cut based on a given maximum number of clusters.</para>
      </summary>
      <remarks>
        <para>The clustering is performed using the agglomerative strategy i.e., a bottom-up approach according to which at the beginning each node belongs to its own cluster. At each step pairs of clusters are merged while moving up to the hierarchy. The dissimilarity between clusters is determined based on the given linkage and the given node distances. The algorithm continues until all nodes belong to the same cluster.</para>
        <para>The result will be given based on the given maximum number of clusters value that is used for cutting the hierarchical tree at a point such that the number of remaining clusters equals to this value.</para>
        <para>The maximum number of clusters needs to be greater than zero and less than the number of the nodes of the graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="maxCluster">
        <para>the maximum number of clusters that determines where to cut the hierarchic tree into clusters</para>
      </param>
      <param name="clusterIDs">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns an integer value (cluster ID) for each node</para>
      </param>
      <param name="distances">
        <para>a given <see cref="T:yWorks.Algorithms.Groups.INodeDistanceProvider" /> object that determines the distance between any two graph nodes</para>
      </param>
      <param name="linkage">
        <para>one of the predefined linkage values</para>
      </param>
      <returns>
        <para>the resulting number of clusters</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown linkage is given or if the maximum number of clusters is less than or equal to zero or greater than the number of nodes of the graph</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Groups.KMeansClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.DistanceMetric,System.Int32,System.Int32,yWorks.Algorithms.Geometry.YPoint[])">
      <summary>
        <para>Partitions the graph into clusters using k-means clustering algorithm.</para>
      </summary>
      <remarks>
        <para>The nodes of the graph will be partitioned in <c>k</c> clusters based on their positions such that their distance from the cluster's mean (centroid) is minimized.</para>
        <para>The distance can be defined using diverse metrics as euclidean distance, euclidean-squared distance, manhattan distance or chebychev distance.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="clusterIDs">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns an integer value (cluster ID) for each node</para>
      </param>
      <param name="nodePositions">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds a <see cref="T:yWorks.Algorithms.Geometry.YPoint">point</see> representing the current position of each node in the graph</para>
      </param>
      <param name="distanceMetric">
        <para>one of the predefined distance metrics</para>
      </param>
      <param name="k">
        <para>the number of clusters</para>
      </param>
      <param name="iterations">
        <para>the maximum number of iterations performed by the algorithm for convergence</para>
      </param>
      <param name="centroids">
        <para>the initial centroids</para>
      </param>
      <returns>
        <para>the number of resulting (non-empty) clusters</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given distance metric is not supported</para>
      </exception>
    </member>
    <member name="T:yWorks.Algorithms.Groups.Dendrogram">
      <summary>
        <para>This class provides the result of hierarchical clustering algorithms by means of a binary tree structure.</para>
      </summary>
      <remarks>
        <para>The dendrogram is created using the agglomerative strategy (i.e., a bottom-up approach) based on the following steps:</para>
        <list type="bullet">
          <item>At the beginning (i.e., at level <c>0</c>), each node belongs to its own cluster. At this point, each node of the original graph (the one that will be clustered) is mapped to one of the dendrogram nodes that represent a leaf node (i.e., a node with no children).</item>
          <item>At each step, pairs of clusters are merged while moving up to the hierarchy. In this case, a new dendrogram node is created and the corresponding dissimilarity value between the two merged clusters can be obtained using <see cref="M:yWorks.Algorithms.Groups.Dendrogram.GetDissimilarityValue(yWorks.Algorithms.Node)" />. The dissimilarity values are monotone increasing starting from zero which corresponds to the leaf nodes of the dendrogram.</item>
          <item>The algorithm continues until all nodes belong to the same cluster. At this point, the root of the dendrogram is reached and can be obtained using method <see cref="P:yWorks.Algorithms.Groups.Dendrogram.Root" />.</item>
        </list>
        <para>The dendrogram is a binary tree that is directed from the root to the leaves. This means that one can iterate the dendrogram starting with the <see cref="P:yWorks.Algorithms.Groups.Dendrogram.Root">root node</see>, moving on to its <see cref="M:yWorks.Algorithms.Groups.Dendrogram.GetChildren(yWorks.Algorithms.Node)">children</see>, then moving on to their children and so on.</para>
        <para>From each node of the dendrogram, it is possible to retrieve the set of nodes of the original graph that belong to this dendrogram node using <see cref="M:yWorks.Algorithms.Groups.Dendrogram.GetClusterNodes(yWorks.Algorithms.Node)" />. This method returns an array of <see cref="T:yWorks.Algorithms.NodeList" />s that contain the nodes of all clusters that are merged when this dendrogram node was created. For example, say that clusters <c>C1 = {v1, v2}</c> and <c>C2 = {v3, v4}</c> are merged, where <c>{v1, v2, v3, v4}</c> are nodes of the original graph. Say that dendrogram node <c>u</c> is created by this merging. Then, the cluster nodes of <c>u</c> will be returned as two <see cref="T:yWorks.Algorithms.NodeList" />s where the first contains nodes <c>v1, v2</c> and the second <c>v3, v4</c>.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,System.Int32,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage,System.Double)" />
    </member>
    <member name="P:yWorks.Algorithms.Groups.Dendrogram.Root">
      <summary>
        <para>Gets the root node of the dendrogram.</para>
      </summary>
      <remarks>
        <para>A dendrogram traversal can be implemented by starting from this node, then moving on to its children using method <see cref="M:yWorks.Algorithms.Groups.Dendrogram.GetChildren(yWorks.Algorithms.Node)" />, and so on.</para>
      </remarks>
      <value>
        <para>the root node of the dendrogram</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Groups.Dendrogram.GetChildren(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns a <see cref="T:yWorks.Algorithms.NodeList" /> that contains the child nodes of the given parent node.</para>
      </summary>
      <remarks>
        <para>If the given node is a <see cref="M:yWorks.Algorithms.Groups.Dendrogram.IsLeaf(yWorks.Algorithms.Node)">leaf</see> node, the returned list will be empty.</para>
      </remarks>
      <param name="parent">
        <para>the parent node for which to retrieve the child nodes</para>
      </param>
      <returns>
        <para>the list of child nodes of the given parent node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Groups.Dendrogram.GetLevel(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the level of the given node of the dendrogram.</para>
      </summary>
      <param name="node">
        <para>the given dendrogram node</para>
      </param>
      <returns>
        <para>the level of the given dendrogram node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Groups.Dendrogram.GetNodeAtLevel(System.Int32)">
      <summary>
        <para>Returns the node of the dendrogram that belongs to the given level index.</para>
      </summary>
      <remarks>
        <para>If the given level index is greater than the <see cref="P:yWorks.Algorithms.Groups.Dendrogram.LevelCount">number of levels</see>, then this method will return <c>null</c>.</para>
      </remarks>
      <param name="level">
        <para>the given level index</para>
      </param>
      <returns>
        <para>the node of the dendrogram that belongs to the given level index or <c>null</c> if there exists no level with the given index.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given level is negative or greater than the <see cref="P:yWorks.Algorithms.Groups.Dendrogram.NodeCount">node count</see> minus one.</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.Groups.Dendrogram.GetOriginalNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the node of original graph that is mapped with the given leaf node of the dendrogram.</para>
      </summary>
      <param name="node">
        <para>the given leaf node</para>
      </param>
      <returns>
        <para>the node of original graph that is mapped with the given leaf node or <c>null</c> if the given node is an inner dendrogram node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Groups.Dendrogram.GetDissimilarityValue(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the dissimilarity value associated with the given node of the dendrogram.</para>
      </summary>
      <param name="node">
        <para>the given dendrogram node</para>
      </param>
      <returns>
        <para>the dissimilarity value associated with the given dendrogram node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Groups.Dendrogram.GetClusterNodes(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns an array of <see cref="T:yWorks.Algorithms.NodeList" />s that contain the nodes of the original graph that are associated with the given dendrogram node.</para>
      </summary>
      <remarks>
        <para>Each such <see cref="T:yWorks.Algorithms.NodeList" /> represents nodes that belong to the same cluster. For example, say that clusters <c>C1 = {v1, v2}</c> and <c>C2 = {v3, v4}</c> are merged, where <c>{v1, v2, v3, v4}</c> are nodes of the original graph. Say that dendrogram node <c>u</c> is created by this merging. Then, the cluster nodes of <c>u</c> will be returned as two <see cref="T:yWorks.Algorithms.NodeList" />s where the first contains nodes <c>v1, v2</c> and the second <c>v3, v4</c>.</para>
      </remarks>
      <param name="node">
        <para>the given dendrogram node</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s that contain the nodes of the original graph that are associated with the given dendrogram node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Groups.Dendrogram.IsLeaf(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns whether or not the given dendrogram node is a leaf node.</para>
      </summary>
      <remarks>
        <para>A leaf node has no further children and represents a node of the original graph. The original node can be retrieved via <see cref="M:yWorks.Algorithms.Groups.Dendrogram.GetOriginalNode(yWorks.Algorithms.Node)" />.</para>
      </remarks>
      <param name="node">
        <para>a dendrogram node</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given node is a leaf node, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.Groups.Dendrogram.NodeCount">
      <summary>
        <para>Gets the number of nodes in this dendrogram.</para>
      </summary>
      <value>
        <para>the number of nodes in this dendrogram</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.Groups.Dendrogram.LevelCount">
      <summary>
        <para>Gets the number of levels this dendrogram has.</para>
      </summary>
      <value>
        <para>the number of levels of this dendrogram</para>
      </value>
    </member>
    <member name="T:yWorks.Algorithms.Groups.INodeDistanceProvider">
      <summary>
        <para>An interface that determines the distance between two nodes of a graph.</para>
      </summary>
      <remarks>
        <para>It is used by the hierarchical clustering algorithm in order to determine the distance between any two nodes of a graph.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,System.Int32,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage,System.Double)" />
      <seealso cref="M:yWorks.Algorithms.Groups.HierarchicalClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.Groups.INodeDistanceProvider,yWorks.Algorithms.Linkage)" />
    </member>
    <member name="M:yWorks.Algorithms.Groups.INodeDistanceProvider.GetDistance(yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the distance between two given nodes of a graph.</para>
      </summary>
      <remarks>
        <para>Implementations of this method have to guarantee that the returned value is greater or equal to zero. Furthermore, the distances between two nodes have to be symmetric, i.e., the distance between node <c>n1</c> and <c>n2</c> is equal to the distance between node <c>n2</c> and <c>n1</c>.</para>
      </remarks>
      <param name="n1">
        <para>the first node</para>
      </param>
      <param name="n2">
        <para>the second node</para>
      </param>
      <returns>
        <para>the distance between the two given nodes</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.ICursor">
      <summary>
        <para>A general interface for iterating over a collection of objects.</para>
      </summary>
      <remarks>
        <para>It can be regarded as a read-only view of such a collection.</para>
        <para>A YCursor acts like a movable pointer on the elements of a collection. The pointer can be moved forward and backward and the element currently pointed on can be accessed. The removal of elements can only be performed on the provider of the cursor, not on the cursor itself. (That's why the cursor presents a read-only view.)</para>
        <para>Implementations of this interface do not need to support operations marked "optional."</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.ICursor.Ok">
      <summary>
        <para>Gets <c>true</c> if the current cursor position is valid.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.ICursor.Next">
      <summary>
        <para>Moves this cursor one position forward.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.ICursor.Prev">
      <summary>
        <para>Moves this cursor one position backward (optional).</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.ICursor.ToFirst">
      <summary>
        <para>Moves this cursor to the first valid cursor position (optional).</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.ICursor.ToLast">
      <summary>
        <para>Moves this cursor to the last valid cursor position (optional).</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.ICursor.Current">
      <summary>
        <para>Gets the object currently pointed on.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.ICursor.Size">
      <summary>
        <para>Gets the number of elements that can be accessed with this cursor.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.IDataAcceptor">
      <summary>
        <para>A general interface for setting data.</para>
      </summary>
      <remarks>
        <para>A data acceptor associates data with data holders. It constitutes a write-only view on particular data.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.IDataAcceptor.Set(System.Object,System.Object)">
      <summary>
        <para>Sets an object value associated with the given data holder.</para>
      </summary>
      <remarks>
        <para>This method may throw an UnsupportedOperationException.</para>
      </remarks>
      <param name="dataHolder" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.IDataAcceptor.SetInt(System.Object,System.Int32)">
      <summary>
        <para>Sets an integer value associated with the given data holder.</para>
      </summary>
      <remarks>
        <para>This method may throw an UnsupportedOperationException.</para>
      </remarks>
      <param name="dataHolder" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.IDataAcceptor.SetDouble(System.Object,System.Double)">
      <summary>
        <para>Sets a double value associated with the given data holder.</para>
      </summary>
      <remarks>
        <para>This method may throw an UnsupportedOperationException.</para>
      </remarks>
      <param name="dataHolder" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.IDataAcceptor.SetBool(System.Object,System.Boolean)">
      <summary>
        <para>Sets a boolean value associated with the given data holder.</para>
      </summary>
      <remarks>
        <para>This method may throw an UnsupportedOperationException.</para>
      </remarks>
      <param name="dataHolder" />
      <param name="value" />
    </member>
    <member name="T:yWorks.Algorithms.IDataMap">
      <summary>
        <para>Interface that combines the <see cref="T:yWorks.Algorithms.IDataProvider" /> and <see cref="T:yWorks.Algorithms.IDataAcceptor" /> interfaces.</para>
      </summary>
      <remarks>
        <para>This interface does not declare any additional methods.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.IDataProvider">
      <summary>
        <para>A general interface for data provision.</para>
      </summary>
      <remarks>
        <para>A data provider grants access to data associated with one or more data holders. It constitutes a read-only view on particular data.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.IDataProvider.Get(System.Object)">
      <summary>
        <para>Returns an object value associated with the given data holder.</para>
      </summary>
      <remarks>
        <para>This method may throw an UnsupportedOperationException.</para>
      </remarks>
      <param name="dataHolder" />
    </member>
    <member name="M:yWorks.Algorithms.IDataProvider.GetInt(System.Object)">
      <summary>
        <para>Returns an integer value associated with the given data holder.</para>
      </summary>
      <remarks>
        <para>This method may throw an UnsupportedOperationException.</para>
      </remarks>
      <param name="dataHolder" />
    </member>
    <member name="M:yWorks.Algorithms.IDataProvider.GetDouble(System.Object)">
      <summary>
        <para>Returns a double value associated with the given data holder.</para>
      </summary>
      <remarks>
        <para>This method may throw an UnsupportedOperationException.</para>
      </remarks>
      <param name="dataHolder" />
    </member>
    <member name="M:yWorks.Algorithms.IDataProvider.GetBool(System.Object)">
      <summary>
        <para>Returns a boolean value associated with the given data holder.</para>
      </summary>
      <remarks>
        <para>This method may throw an UnsupportedOperationException.</para>
      </remarks>
      <param name="dataHolder" />
    </member>
    <member name="T:yWorks.Algorithms.IEdgeCursor">
      <summary>
        <para>A cursor interface for iterating over edges.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.IEdgeCursor.Edge">
      <summary>
        <para>Gets the edge at the current location of the cursor.</para>
      </summary>
      <remarks>
        <para>This method is the typed variant of <see cref="P:yWorks.Algorithms.ICursor.Current" />.</para>
      </remarks>
      <value>
        <para>The edge currently pointed to by this cursor.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.IEdgeCursor.CyclicNext">
      <summary>
        <para>Moves the cursor to the cyclic next element of the underlying sequence.</para>
      </summary>
      <remarks>
        <para>This is the next element if available, else it is the first element.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.IEdgeCursor.CyclicPrev">
      <summary>
        <para>Moves the cursor to the cyclic previous element of the underlying sequence.</para>
      </summary>
      <remarks>
        <para>This is the previous element if available, else it is the last element.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.IEdgeMap">
      <summary>
        <para>Provides access to data associated with an edge.</para>
      </summary>
      <remarks>
        <para>An edge map can be considered as a map that allows only edges as keys. Edge keys of an edge map must belong to the same graph.</para>
        <para>There are data access methods defined for the most common typed values as well.</para>
        <para>The edge values are initialized with Java(TM) default values (null, 0, 0.0, false) upon initialization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.IEdgeMap.Set(System.Object,System.Object)">
      <summary>
        <para>Associates the given value to the given edge.</para>
      </summary>
      <param name="edge" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.IEdgeMap.Get(System.Object)">
      <summary>
        <para>Returns the value bound to the given edge.</para>
      </summary>
      <param name="edge" />
    </member>
    <member name="M:yWorks.Algorithms.IEdgeMap.SetBool(System.Object,System.Boolean)">
      <summary>
        <para>Associates the given boolean value to the given edge.</para>
      </summary>
      <param name="edge" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.IEdgeMap.GetBool(System.Object)">
      <summary>
        <para>Returns the boolean value bound to the given edge.</para>
      </summary>
      <param name="edge" />
    </member>
    <member name="M:yWorks.Algorithms.IEdgeMap.SetDouble(System.Object,System.Double)">
      <summary>
        <para>Associates the given double value to the given edge.</para>
      </summary>
      <param name="edge" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.IEdgeMap.GetDouble(System.Object)">
      <summary>
        <para>Returns the double value bound to the given edge.</para>
      </summary>
      <param name="edge" />
    </member>
    <member name="M:yWorks.Algorithms.IEdgeMap.SetInt(System.Object,System.Int32)">
      <summary>
        <para>Associates the given integer value to the given edge.</para>
      </summary>
      <param name="edge" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.IEdgeMap.GetInt(System.Object)">
      <summary>
        <para>Returns the integer value bound to the given edge.</para>
      </summary>
      <param name="edge" />
    </member>
    <member name="T:yWorks.Algorithms.INodeCursor">
      <summary>
        <para>A cursor interface for iterating over nodes.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.INodeCursor.Node">
      <summary>
        <para>Gets the node at the current location of the cursor.</para>
      </summary>
      <remarks>
        <para>This method is the typed variant of <see cref="P:yWorks.Algorithms.ICursor.Current" />.</para>
      </remarks>
      <value>
        <para>The node currently pointed to by this cursor.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.INodeCursor.CyclicNext">
      <summary>
        <para>Moves the cursor to the cyclic next element of the underlying sequence.</para>
      </summary>
      <remarks>
        <para>This is the next element if available, else it is the first element.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.INodeCursor.CyclicPrev">
      <summary>
        <para>Moves the cursor to the cyclic previous element of the underlying sequence.</para>
      </summary>
      <remarks>
        <para>This is the previous element if available, else it is the last element.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.INodeMap">
      <summary>
        <para>Provides access to data associated with a node.</para>
      </summary>
      <remarks>
        <para>A node map can be considered as a map that allows only nodes as keys. Node keys of a node map must belong to the same graph.</para>
        <para>There are data access methods defined for the most common typed values as well.</para>
        <para>The node values are initialized with Java(TM) default values (null, 0, 0.0, false) upon initialization.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.INodeMap.Set(System.Object,System.Object)">
      <summary>
        <para>Associates the given value to the given node.</para>
      </summary>
      <param name="node" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.INodeMap.Get(System.Object)">
      <summary>
        <para>Returns the value bound to the given node.</para>
      </summary>
      <param name="node" />
    </member>
    <member name="M:yWorks.Algorithms.INodeMap.SetBool(System.Object,System.Boolean)">
      <summary>
        <para>Associates the given boolean value to the given node.</para>
      </summary>
      <param name="node" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.INodeMap.GetBool(System.Object)">
      <summary>
        <para>Returns the boolean value bound to the given node.</para>
      </summary>
      <param name="key" />
    </member>
    <member name="M:yWorks.Algorithms.INodeMap.SetDouble(System.Object,System.Double)">
      <summary>
        <para>Associates the given double value to the given node.</para>
      </summary>
      <param name="node" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.INodeMap.GetDouble(System.Object)">
      <summary>
        <para>Returns the double value bound to the given node.</para>
      </summary>
      <param name="node" />
    </member>
    <member name="M:yWorks.Algorithms.INodeMap.SetInt(System.Object,System.Int32)">
      <summary>
        <para>Associates the given integer value to the given node.</para>
      </summary>
      <param name="node" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.INodeMap.GetInt(System.Object)">
      <summary>
        <para>Returns the integer value bound to the given node.</para>
      </summary>
      <param name="node" />
    </member>
    <member name="T:yWorks.Algorithms.INodeSequencer">
      <summary>
        <para>This is a generic interface for classes that provide an ordering for the nodes of a graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.INodeSequencer.Nodes(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns a cursor that grants access to <b>all</b> nodes of the given graph in some order.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.INodeCursor" /> that grants access to all nodes of a graph</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.IndependentSets">
      <summary>
        <para>This class provides methods for calculating independent sets.</para>
      </summary>
      <remarks>
        <para>An <b>independent set</b> is a set of nodes in a graph, in which no two nodes are adjacent.</para>
        <para> Circular nodes represent one of the independent sets of the given graph</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.IndependentSets.GetIndependentSets(yWorks.Algorithms.Graph)">
      <summary>
        <para>Partitions the set of nodes of the given graph into independent sets.</para>
      </summary>
      <remarks>
        <para>The method iteratively calls method <see cref="M:yWorks.Algorithms.IndependentSets.GetIndependentSet(yWorks.Algorithms.Graph)" />.</para>
      </remarks>
      <param name="conflictGraph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains an independent set of nodes</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.IndependentSets.GetIndependentSet(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Algorithms.IndependentSets.GetIndependentSet(yWorks.Algorithms.Graph)">
      <summary>
        <para>Calculates an independent set for a given graph.</para>
      </summary>
      <remarks>
        <para>A greedy heuristic is applied which tries to find a large independent set.</para>
      </remarks>
      <param name="conflictGraph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing an independent set of nodes</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.IndependentSets.GetIndependentSet(yWorks.Algorithms.Graph)" />
    </member>
    <member name="T:yWorks.Algorithms.InvalidGraphStructureException">
      <summary>
        <para>Exception thrown when a graph-structural precondition is violated.</para>
      </summary>
      <remarks>
        <para>Some graph algorithms make only sense on specially structured graphs, like, e.g., trees, DAGs (short for directed acyclic graph), or planar graphs. Methods that detect graph-structural mismatch will throw this exception then.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.InvalidGraphStructureException.#ctor(System.String)">
      <summary>
        <para>Constructs a WrongGraphStructure exception with the specified message.</para>
      </summary>
      <param name="msg" />
    </member>
    <member name="T:yWorks.Algorithms.ListCell">
      <summary>
        <para>Represents a so-called "cell" or "link" of the doubly linked list implementation <see cref="T:yWorks.Algorithms.YList" />.</para>
      </summary>
      <remarks>
        <para>It may be used to perform fast access and remove operations on that type of list.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.ListCell.Succ">
      <summary>
        <para>Returns the successor cell of this cell.</para>
      </summary>
      <remarks>
        <para>If there is no successor, then <c>null</c> is returned.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.ListCell.Pred">
      <summary>
        <para>Returns the predecessor cell of this cell.</para>
      </summary>
      <remarks>
        <para>If there is no predecessor, then <c>null</c> is returned.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.ListCell.Info">
      <summary>
        <para>Gets or sets the element stored in this cell.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.NetworkFlows">
      <summary>
        <para>This class provides sophisticated algorithms for solving classical network flow problems.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>
            <term>
              <b>Maximum flow problem:</b>
            </term>
            <description>Given a directed graph in which each edge has a capacity and given a source node <c>s</c> and a sink node <c>t</c>, find a flow of maximum value from <c>s</c> to <c>t</c>.</description>
          </item>
          <item>
            <term>
              <b>Minimum cut problem:</b>
            </term>
            <description>Given a directed graph in which each edge has a capacity and given a source node <c>s</c> and a sink node <c>t</c>, find an <c>s-t</c> cut of minimum capacity (i.e., a set of edges of minimum capacity whose removal would disconnect <c>t</c> from <c>s</c>).</description>
          </item>
          <item>
            <term>
              <b>Minimum cost flow problem:</b>
            </term>
            <description>Given a directed graph in which each edge has a cost and a capacity and each node has a supply or demand, find a flow of minimum total cost that satisfies the edge capacities and the node balances.</description>
          </item>
          <item>
            <term>
              <b>Minimum cost maximum flow problem:</b>
            </term>
            <description>Given a directed graph in which each edge has a cost and a capacity and given a source node <c>s</c> and a sink node <c>t</c>, find a flow of maximum value from <c>s</c> to <c>t</c> that has the minimum total cost.</description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Solves a minimum cost flow problem with a capacity scaling algorithm.</para>
      </summary>
      <remarks>
        <para>This algorithm is a variant of the successive shortest path algorithm (see Ahuja,Magnanti,Orlin: <i>Network flows</i>, Prentice Hall, 1993, pp.320-324). It has the pseudo-polynomial running time <c>O(m*log U*(m+n log n))</c> where <c>n</c> is the number of nodes in the network, <c>m</c> the number of edges and <c>U</c> the maximal edge capacity.</para>
        <para>Edges may have infinite capacity, which is denoted by the value <see cref="F:System.Int32.MaxValue" />.</para>
        <para>There are no restriction for the costs. In particular, they can also be negative.</para>
      </remarks>
      <param name="graph">
        <para>the given network</para>
      </param>
      <param name="lCapDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the integer lower bound for the capacity of each edge or <c>null</c> if no bound is specified</para>
      </param>
      <param name="uCapDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the integer upper bound for the capacity of each edge or <c>null</c> if no bound is specified</para>
      </param>
      <param name="cost0DP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) of each edge</para>
      </param>
      <param name="supplyDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the supply/demand of each node; supply is denoted by a positive value, demand by a negative value</para>
      </param>
      <param name="flowEM">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution with an integer flow for each edge</para>
      </param>
      <param name="dualsNM">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution with an integer value (dual value) for each node or <c>null</c> if no such values occur; dual values are also referred as potentials</para>
      </param>
      <returns>
        <para>the total cost of the flow</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
      <seealso cref="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Uses method <see cref="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" /> to solve a minimum cost flow problem.</para>
      </summary>
      <param name="graph">
        <para>the given network</para>
      </param>
      <param name="uCapDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the integer capacity of each edge or <c>null</c> if no bound is specified</para>
      </param>
      <param name="cost0DP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for each edge</para>
      </param>
      <param name="supplyDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the supply/demand of each node; supply is denoted by a positive value, demand by a negative value</para>
      </param>
      <param name="flowEM">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution with an integer flow for each edge</para>
      </param>
      <param name="dualsNM">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution with an integer value (dual value) for each node or <c>null</c> if no such values occur; dual values are also referred as potentials</para>
      </param>
      <returns>
        <para>the total cost of the flow</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
      <seealso cref="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Solves a minimum cost maximum flow problem.</para>
      </summary>
      <param name="graph">
        <para>the given network</para>
      </param>
      <param name="s">
        <para>the source node of the network</para>
      </param>
      <param name="t">
        <para>the sink node of the network</para>
      </param>
      <param name="uCapDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the integer capacity of each edge or <c>null</c> if no bound is specified</para>
      </param>
      <param name="cost0DP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for each edge</para>
      </param>
      <param name="flowEM">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution with an integer flow for each edge</para>
      </param>
      <param name="dualsNM">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution with an integer value (dual value) for each node or <c>null</c> if no such values occur; dual values are also referred as potentials</para>
      </param>
      <returns>
        <para>the total cost of the flow</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
      <seealso cref="M:yWorks.Algorithms.NetworkFlows.MinCostFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.NetworkFlows.CalcMaxFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Solves a maximum flow problem using the preflow-push method.</para>
      </summary>
      <remarks>
        <para>The implementation is based on</para>
        <list type="bullet">
          <item>Mehlhorn, Naeher: <i>LEDA: a platform for combinatorial and geometric computing</i>, Cambridge University Press, 2000, pp. 443-488.</item>
        </list>
        <para>The worst case running time is <c>O(mdeg * n^2 * m^(1/2))</c>, where <c>n</c> is the number of nodes in the network, <c>m</c> the number of edges and <c>mdeg</c> the maximal degree of any node.</para>
        <para>Edges may have infinite capacity, which is denoted by the value <see cref="F:System.Int32.MaxValue" />.</para>
      </remarks>
      <param name="graph">
        <para>the given network</para>
      </param>
      <param name="source">
        <para>the source node of the network</para>
      </param>
      <param name="sink">
        <para>the sink node of the network</para>
      </param>
      <param name="eCapDP">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that returns the integer capacity of each edge or <c>null</c> if no bound is specified</para>
      </param>
      <param name="flowEM">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution with an integer flow for each edge</para>
      </param>
      <returns>
        <para>the maximum flow value</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.NetworkFlows.CalcMaxFlowMinCut(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.NetworkFlows.CalcMaxFlowMinCut(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Solves a maximum flow problem using the preflow-push method but additionally marks all nodes that belong to the minimum cut set that is associated with the source of the network.</para>
      </summary>
      <param name="graph">
        <para>the given network</para>
      </param>
      <param name="source">
        <para>the source node of the network</para>
      </param>
      <param name="sink">
        <para>the sink node of the network</para>
      </param>
      <param name="eCapDP">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that returns the integer capacity of each edge or <c>null</c> if no bound is specified</para>
      </param>
      <param name="flowEM">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution with an integer flow for each edge</para>
      </param>
      <param name="sourceCutNM">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a boolean value indicating whether or not a node belongs to the cut set associated with the source of the network</para>
      </param>
      <returns>
        <para>the maximum flow value</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.NetworkFlows.CalcMaxFlow(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap)" />
    </member>
    <member name="T:yWorks.Algorithms.Node">
      <summary>
        <para>Represents a so-called node in the directed graph data type <see cref="T:yWorks.Algorithms.Graph" />.</para>
      </summary>
      <remarks>
        <para>Most notably, a node provides access to its adjacent edges (represented by instances of class <see cref="T:yWorks.Algorithms.Edge" />). These can be distinguished into the sets of incoming and outgoing edges.</para>
        <para>Iteration over all three sets of edges is provided by means of bidirectional cursors that present a read-only view of the respective set (<see cref="M:yWorks.Algorithms.Node.GetEdgeCursor" />, <see cref="M:yWorks.Algorithms.Node.GetInEdgeCursor(yWorks.Algorithms.Edge)" />, <see cref="M:yWorks.Algorithms.Node.GetOutEdgeCursor(yWorks.Algorithms.Edge)" />). Also supported is iteration over all nodes at opposite ends of either incoming edges or outgoing edges (<see cref="M:yWorks.Algorithms.Node.GetPredecessorCursor" />, <see cref="M:yWorks.Algorithms.Node.GetSuccessorCursor" />).</para>
        <para>The number of overall edges at a node is called its degree (<see cref="P:yWorks.Algorithms.Node.Degree" />), which is the sum of incoming and outgoing edges (<see cref="P:yWorks.Algorithms.Node.InDegree" />, <see cref="P:yWorks.Algorithms.Node.OutDegree" />).</para>
        <para>
          <b>Important:</b> Class Graph is the single authority for any structural changes to the graph data type. Specifically, this means that there is no way to create or delete a node or an edge without using an actual Graph instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Node.#ctor(yWorks.Algorithms.Graph)">
      <summary>
        <para>Instantiates a new Node object that will be part of the given graph.</para>
      </summary>
      <param name="g">
        <para>The graph that the created node will belong to.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Node.CreateCopy(yWorks.Algorithms.Graph)">
      <summary>
        <para>Creates a copy of this node that will be inserted into the given graph.</para>
      </summary>
      <param name="g">
        <para>The graph that the created node will belong to.</para>
      </param>
      <returns>
        <para>The newly created Node object.</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.Node.Degree">
      <summary>
        <para>Gets the overall number of incoming and outgoing edges at this node.</para>
      </summary>
      <remarks>
        <para>Note that self-loops are counted twice.</para>
      </remarks>
      <seealso cref="T:yWorks.Algorithms.Edge" />
      <seealso cref="P:yWorks.Algorithms.Node.InDegree" />
      <seealso cref="P:yWorks.Algorithms.Node.OutDegree" />
    </member>
    <member name="P:yWorks.Algorithms.Node.InDegree">
      <summary>
        <para>Gets the number of incoming edges at this node.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.Node.Degree" />
      <seealso cref="P:yWorks.Algorithms.Node.OutDegree" />
    </member>
    <member name="P:yWorks.Algorithms.Node.OutDegree">
      <summary>
        <para>Gets the number of outgoing edges at this node.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.Node.Degree" />
      <seealso cref="P:yWorks.Algorithms.Node.InDegree" />
    </member>
    <member name="P:yWorks.Algorithms.Node.Index">
      <summary>
        <para>Gets the index of this node within its graph G.</para>
      </summary>
      <remarks>
        <para>Node indices represent the ordering of standard node iteration on G. The value of an index is <c> &gt;= 0</c> and <c> &lt; G.nodeCount()</c>.</para>
        <para>Note that indices are subject to change whenever the sequence of nodes in a graph is modified by either removing, hiding, reinserting, or unhiding a node, or by explicitly changing its position in the sequence.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Graph.RemoveNode(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Graph.Hide(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Graph.ReInsertNode(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Graph.Unhide(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Graph.MoveToFirst(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Graph.MoveToLast(yWorks.Algorithms.Node)" />
    </member>
    <member name="P:yWorks.Algorithms.Node.Graph">
      <summary>
        <para>Gets the graph this node belongs to.</para>
      </summary>
      <remarks>
        <para>If the node does not belong to a graph, because it was removed or hidden from it, this method returns <c>null</c>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Node.FirstOutEdge">
      <summary>
        <para>Gets the first outgoing edge at this node, or <c>null</c> if it does not exist.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.Node.FirstInEdge" />
      <seealso cref="P:yWorks.Algorithms.Node.LastOutEdge" />
    </member>
    <member name="P:yWorks.Algorithms.Node.FirstInEdge">
      <summary>
        <para>Gets the first incoming edge at this node, or <c>null</c> if it does not exist.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.Node.FirstOutEdge" />
      <seealso cref="P:yWorks.Algorithms.Node.LastInEdge" />
    </member>
    <member name="P:yWorks.Algorithms.Node.LastOutEdge">
      <summary>
        <para>Gets the last outgoing edge at this node, or <c>null</c> if it does not exist.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.Node.FirstOutEdge" />
      <seealso cref="P:yWorks.Algorithms.Node.LastInEdge" />
    </member>
    <member name="P:yWorks.Algorithms.Node.LastInEdge">
      <summary>
        <para>Gets the last incoming edge at this node, or <c>null</c> if it does not exist.</para>
      </summary>
      <seealso cref="P:yWorks.Algorithms.Node.FirstInEdge" />
      <seealso cref="P:yWorks.Algorithms.Node.LastOutEdge" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetEdgeCursor">
      <summary>
        <para>Returns an edge cursor for all incoming and outgoing edges at this node.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Node.GetInEdgeCursor(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Algorithms.Node.GetOutEdgeCursor(yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetInEdgeCursor(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns an edge cursor for incoming edges at this node.</para>
      </summary>
      <remarks>
        <para>If an edge is specified, the cursor starts at the given edge, and the cyclic sequence order is the same as returned by <see cref="M:yWorks.Algorithms.Node.GetInEdgeCursor(yWorks.Algorithms.Edge)" />.</para>
      </remarks>
      <param name="startEdge">
        <para>The first edge being accessed by the returned cursor.</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.Node.GetOutEdgeCursor(yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetOutEdgeCursor(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns an edge cursor for outgoing edges at this node.</para>
      </summary>
      <remarks>
        <para>If an edge is specified, the cursor starts at the given edge, and the cyclic sequence order is the same as returned by <see cref="M:yWorks.Algorithms.Node.GetOutEdgeCursor(yWorks.Algorithms.Edge)" />.</para>
      </remarks>
      <param name="startEdge">
        <para>The first edge being accessed by the returned cursor.</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.Node.GetInEdgeCursor(yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetNeighborCursor">
      <summary>
        <para>Returns a node cursor for all neighbor nodes of this node.</para>
      </summary>
      <remarks>
        <para>Neighbor nodes are those at the opposite ends of both incoming and outgoing edges.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Node.GetPredecessorCursor" />
      <seealso cref="M:yWorks.Algorithms.Node.GetSuccessorCursor" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetPredecessorCursor">
      <summary>
        <para>Returns a node cursor for all predecessor nodes of this node.</para>
      </summary>
      <remarks>
        <para>Predecessor nodes are those at the opposite ends of incoming edges.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Node.GetSuccessorCursor" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetSuccessorCursor">
      <summary>
        <para>Returns a node cursor for all successor nodes of this node.</para>
      </summary>
      <remarks>
        <para>Successor nodes are those at the opposite ends of outgoing edges.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Node.GetPredecessorCursor" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetEdgeTo(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns an outgoing edge that connects this node with the given node, if such an edge exists.</para>
      </summary>
      <remarks>
        <para>Otherwise <c>null</c> is returned.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Node.GetEdge(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Node.GetEdgeFrom(yWorks.Algorithms.Node)" />
      <param name="target" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetEdgeFrom(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns an incoming edge that connects the given node with this node, if such an edge exists.</para>
      </summary>
      <remarks>
        <para>Otherwise <c>null</c> is returned.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Node.GetEdge(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Node.GetEdgeTo(yWorks.Algorithms.Node)" />
      <param name="source" />
    </member>
    <member name="M:yWorks.Algorithms.Node.GetEdge(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns an edge that connects this node with the given node, if such an edge exists.</para>
      </summary>
      <remarks>
        <para>Otherwise <c>null</c> is returned.</para>
        <para>Note that the first matching edge is returned, and that outgoing edges are tested prior to incoming edges.</para>
      </remarks>
      <seealso cref="M:yWorks.Algorithms.Node.GetEdgeFrom(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Algorithms.Node.GetEdgeTo(yWorks.Algorithms.Node)" />
      <param name="opposite" />
    </member>
    <member name="M:yWorks.Algorithms.Node.SortInEdges(System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Sorts incoming edges at this node according to the given comparator.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Node.SortOutEdges(System.Collections.Generic.IComparer{System.Object})" />
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.Node.SortOutEdges(System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Sorts outgoing edges at this node according to the given comparator.</para>
      </summary>
      <seealso cref="M:yWorks.Algorithms.Node.SortInEdges(System.Collections.Generic.IComparer{System.Object})" />
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.Node.ToString">
      <summary>
        <para>Returns a String representation of this node.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.Node.OutEdges">
      <summary>
        <para>Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" /> for <see cref="T:yWorks.Algorithms.Edge" />s that can be used to iterate over outgoing edges at this instance.</para>
      </summary>
      <remarks>
        <para>This is a live enumerable and will thus reflect the current state of the node's adjacency. Note that changes to the graph structure during the traversal should be carried out with great care. Note that self-loop edges are reported, too.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Node.InEdges">
      <summary>
        <para>Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" /> for <see cref="T:yWorks.Algorithms.Edge" />s that can be used to iterate over ingoing edges at this instance.</para>
      </summary>
      <remarks>
        <para>This is a live enumerable and will thus reflect the current state of the node's adjacency. Note that changes to the graph structure during the traversal should be carried out with great care. Note that self-loop edges are reported, too.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Node.Edges">
      <summary>
        <para>Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" /> for <see cref="T:yWorks.Algorithms.Edge" />s that can be used to iterate over the adjacent edges at this instance.</para>
      </summary>
      <remarks>
        <para>This is a live enumerable and will thus reflect the current state of the node's adjacency. Note that changes to the graph structure during the traversal should be carried out with great care. Note that self-loop edges are reported twice (as in edge and as out edge).</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Node.Successors">
      <summary>
        <para>Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" /> for <see cref="T:yWorks.Algorithms.Node" />s that can be used to iterate over the opposite sides of adjacent outgoing edges at this instance.</para>
      </summary>
      <remarks>
        <para>This is a live enumerable and will thus reflect the current state of the node's adjacency. Note that changes to the graph structure during the traversal should be carried out with great care. Note that for self-loop edges this node itself will be reported as a successor.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Node.Predecessors">
      <summary>
        <para>Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" /> for <see cref="T:yWorks.Algorithms.Node" />s that can be used to iterate over the opposite sides of adjacent incoming edges at this instance.</para>
      </summary>
      <remarks>
        <para>This is a live enumerable and will thus reflect the current state of the node's adjacency. Note that changes to the graph structure during the traversal should be carried out with great care. Note that for self-loop edges this node itself will be reported as a predecessor.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Algorithms.Node.Neighbors">
      <summary>
        <para>Yields a dynamic <see cref="T:System.Collections.Generic.IEnumerable`1" /> for <see cref="T:yWorks.Algorithms.Node" />s that can be used to iterate over the opposite sides of adjacent adjacent edges at this instance.</para>
      </summary>
      <remarks>
        <para>This is a live enumerable and will thus reflect the current state of the node's adjacency. Note that changes to the graph structure during the traversal should be carried out with great care. Note that for self-loop edges this node itself will be reported as a neighbor, twice.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.NodeList">
      <summary>
        <para>Specialized list implementation for instances of type <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.#ctor">
      <summary>
        <para>Creates an empty node list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.#ctor(yWorks.Algorithms.INodeCursor)">
      <summary>
        <para>Creates a list that is initialized with the nodes provided by the given NodeCursor object.</para>
      </summary>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.NodeList.#ctor(yWorks.Algorithms.INodeCursor,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Creates a list that is initialized with those nodes from the given NodeCursor object for which the given data provider returns <c>true</c> upon calling its <see cref="M:yWorks.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see> method.</para>
      </summary>
      <param name="nc">
        <para>A node cursor providing nodes that should be added to this list.</para>
      </param>
      <param name="predicate">
        <para>A data provider that acts as a inclusion predicate for each node accessible by the given node cursor.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.#ctor(yWorks.Algorithms.Node[])">
      <summary>
        <para>Creates a list that is initialized with the nodes provided by the given array of nodes.</para>
      </summary>
      <param name="a" />
    </member>
    <member name="M:yWorks.Algorithms.NodeList.#ctor(yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a list that is initialized with a single node provided.</para>
      </summary>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.NodeList.#ctor(yWorks.Algorithms.NodeList)">
      <summary>
        <para>Creates a list that is initialized with the entries of the given list.</para>
      </summary>
      <param name="list">
        <para>the values are added to the new list</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.Nodes">
      <summary>
        <para>Returns a node cursor for this node list.</para>
      </summary>
      <returns>
        <para>A node cursor granting access to the nodes within this list.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.FirstNode">
      <summary>
        <para>Returns the first node in this list, or <c>null</c> when the list is empty.</para>
      </summary>
      <returns>
        <para>The first node in the list.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.LastNode">
      <summary>
        <para>Returns the last node in this list, or <c>null</c> when the list is empty.</para>
      </summary>
      <returns>
        <para>The last node in the list.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.PopNode">
      <summary>
        <para>Removes the first node from this list and returns it.</para>
      </summary>
      <returns>
        <para>The first node from the list.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.ToNodeArray">
      <summary>
        <para>Returns a node array containing all elements of this list in the canonical order.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.NodeList.GetEnumerator">
      <summary>
        <para>Returns an enumerator for this collection.</para>
      </summary>
    </member>
    <member name="T:yWorks.Algorithms.NodeOrders">
      <summary>
        <para>This class provides algorithms that order the nodes of a graph using specific criteria.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>
            <b>A topological ordering</b> of the nodes of a directed graph is a linear ordering of the nodes such that for each directed edge <c>(u,v)</c>, node <c>u</c> lies before <c>v</c> in the ordering.</item>
          <item>A <b>DFS completion ordering</b> of the nodes of a graph is a node ordering identical to the order of node completion events in a <see cref="T:yWorks.Algorithms.Dfs">depth first search</see>.</item>
          <item>An <b>st-ordering</b> <c>(v_1,v_2,....,v_n)</c> of a biconnected graph is a node ordering which guarantees that:</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.Topological(yWorks.Algorithms.Graph,System.Int32[])">
      <summary>
        <para>Assigns a topological ordering to the nodes of a directed acyclic graph.</para>
      </summary>
      <remarks>
        <para>A topological ordering of the nodes of a directed graph is a linear ordering of the nodes such that for each directed edge <c>(u,v)</c>, node <c>u</c> lies before <c>v</c> in the ordering.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="order">
        <para>an array of <see cref="T:System.Int32" />s that will be filled during the execution and returns for each <see cref="T:yWorks.Algorithms.Node" /> <c>v</c>, its zero-based index within the calculated ordering, i.e., <c>order[v.index()] == 5</c> means that <c>v</c> is the <c>6</c>-th node within the ordering</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph is acyclic, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.NodeOrders.Topological(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.Topological(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns a topological ordering of the nodes of a directed acyclic graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes of the graph in the order they appear in the topological ordering</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the graph is cyclic</para>
      </exception>
      <seealso cref="M:yWorks.Algorithms.NodeOrders.Topological(yWorks.Algorithms.Graph,System.Int32[])" />
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.DfsCompletion(yWorks.Algorithms.Graph,System.Int32[])">
      <summary>
        <para>Calculates an ordering of the nodes identical to the order of node completion events in a depth first search.</para>
      </summary>
      <remarks>
        <para>This ordering is a reversed topological ordering in case the input graph is acyclic.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="order">
        <para>an array of <see cref="T:System.Int32" />s that returns for each <see cref="T:yWorks.Algorithms.Node" /> <c>v</c>, its zero-based index within the calculated ordering, i.e., <c>order[v.index()] == 5</c> means that <c>v</c> is the <c>6</c>-th node within the ordering</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.NodeOrders.Topological(yWorks.Algorithms.Graph,System.Int32[])" />
      <seealso cref="M:yWorks.Algorithms.NodeOrders.DfsCompletion(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.DfsCompletion(yWorks.Algorithms.Graph)">
      <summary>
        <para>Calculates an ordering of the nodes identical to the order of node completion events in a depth first search.</para>
      </summary>
      <remarks>
        <para>Like <see cref="M:yWorks.Algorithms.NodeOrders.DfsCompletion(yWorks.Algorithms.Graph,System.Int32[])" /> but the result is returned as a <see cref="T:yWorks.Algorithms.NodeList" />.</para>
        <para>This ordering is a reversed topological ordering in case the input graph is acyclic.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes of the graph in the order identical to the order of node completion events in a depth first search</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.NodeOrders.Topological(yWorks.Algorithms.Graph,System.Int32[])" />
      <seealso cref="M:yWorks.Algorithms.NodeOrders.DfsCompletion(yWorks.Algorithms.Graph,System.Int32[])" />
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.St(yWorks.Algorithms.Graph,System.Int32[],yWorks.Algorithms.Edge)">
      <summary>
        <para>Assigns an <c>st</c>-ordering to the nodes of a biconnected graph given the edge between source node <c>s</c> and sink node <c>t</c>.</para>
      </summary>
      <remarks>
        <para>An <b><c>st</c>-ordering</b> <c>(v_1,v_2,....,v_n)</c> of a biconnected graph is a node ordering which guarantees that:</para>
        <list type="bullet">
          <item>Source node <c>s</c> and sink node <c>t</c> are connected by an edge.</item>
          <item>For each node <c>v_i</c> in the ordering other than <c>s</c> or <c>t</c>, there are neighbors <c>v_j</c> and <c>v_k</c> with <c>j &lt; i</c> and <c>k &gt; i</c>.</item>
        </list>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="stOrder">
        <para>an array of <see cref="T:System.Int32" />s that will be filled during the execution and returns for each <see cref="T:yWorks.Algorithms.Node" /> <c>v</c>, its zero-based index within the calculated ordering, i.e., <c>stOrder[v.index()] == 5</c> means that <c>v</c> is the <c>6</c>-th node within the ordering</para>
      </param>
      <param name="stEdge">
        <para>an <see cref="T:yWorks.Algorithms.Edge" /> that connects source node <c>s</c> and sink node <c>t</c></para>
      </param>
      <seealso cref="M:yWorks.Algorithms.NodeOrders.St(yWorks.Algorithms.Graph)" />
      <seealso cref="M:yWorks.Algorithms.NodeOrders.St(yWorks.Algorithms.Graph,System.Int32[],yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.St(yWorks.Algorithms.Graph)">
      <summary>
        <para>Assigns an <c>st</c>-ordering to the nodes of a biconnected graph.</para>
      </summary>
      <remarks>
        <para>Like <see cref="M:yWorks.Algorithms.NodeOrders.St(yWorks.Algorithms.Graph,System.Int32[],yWorks.Algorithms.Edge)" /> but the result is returned as a <see cref="T:yWorks.Algorithms.NodeList" />.</para>
        <para>An <b><c>st</c>-ordering</b> <c>(v_1,v_2,....,v_n)</c> of a biconnected graph is a node ordering which guarantees that:</para>
        <list type="bullet">
          <item>Source node <c>s</c> and sink node <c>t</c> are connected by an edge.</item>
          <item>For each node <c>v_i</c> in the ordering other than <c>s</c> or <c>t</c>, there are neighbors <c>v_j</c> and <c>v_k</c> with <c>j &lt; i</c> and <c>k &gt; i</c>.</item>
        </list>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes of the graph in the order defined by the <c>st</c>-ordering</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.NodeOrders.St(yWorks.Algorithms.Graph,System.Int32[],yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.ToNodeList(yWorks.Algorithms.Graph,System.Int32[])">
      <summary>
        <para>Converts an array-based result returned by a method of this class to a <see cref="T:yWorks.Algorithms.NodeList" /> that contains all nodes in the order provided by the given array.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="order">
        <para>an array of <see cref="T:System.Int32" />s that will be filled during the execution and returns for each <see cref="T:yWorks.Algorithms.Node" /> <c>v</c>, its zero-based index within the calculated ordering, i.e., <c>order[v.index()] == 5</c> means that <c>v</c> is the <c>6</c>-th node within the ordering</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes of the graph in the order provided by the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.ToNodeMap(yWorks.Algorithms.Graph,System.Int32[],yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Copies an array-based result returned by a method of this class to a <see cref="T:yWorks.Algorithms.INodeMap" /> that will provide values of basic type <c>int</c>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="order">
        <para>an array of <see cref="T:System.Int32" />s that returns for each <see cref="T:yWorks.Algorithms.Node" /> <c>v</c>, its zero-based index within the calculated ordering, i.e., <c>order[v.index()] == 5</c> means that <c>v</c> is the <c>6</c>-th node within the ordering</para>
      </param>
      <param name="result">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution with the zero-based index of each node within the calculated ordering</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.NodeOrders.ToNodeMap(yWorks.Algorithms.NodeList,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Copies a <see cref="T:yWorks.Algorithms.NodeList" />-based result returned by a method of this class to a <see cref="T:yWorks.Algorithms.INodeMap" /> that will provide values of basic type <c>int</c>.</para>
      </summary>
      <param name="order">
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes of the graph in the appropriate order</para>
      </param>
      <param name="result">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution with the zero-based index of each node within the calculated ordering</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Paths">
      <summary>
        <para>This class provides methods for finding paths within a graph that have certain properties.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>A <b>path</b> of length <c>k</c> from node <c>u</c> to node <c>v</c> in a graph is a sequence <c>v0, v1, v2, ... , vk</c> of nodes such that <c>u = v0, v = vk</c> and <c>(vi-1, vi)</c> in <c>E</c>, for each <c>i = 1, 2, .. , k</c>.</item>
          <item>A path is called <b>simple</b> if no node appears twice.</item>
          <item>A <b>chain</b> is a path of maximum length in which each internal node has degree <c>2</c>.</item>
          <item>The <b>longest path problem</b> is the problem of finding a simple path of maximum length in a given graph. The longest path problem is <c>NP</c>-hard for undirected graphs, but can be solved in linear time for directed acyclic graphs.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindPath(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges of a path from the given start node to the given end node, if such a path exists.</para>
      </summary>
      <remarks>
        <para>The edges are returned in the order that they appear in the found path. If the returned path is empty, no path between the given nodes was found.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="startNode">
        <para>the first node of the path</para>
      </param>
      <param name="endNode">
        <para>the last node of the path</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the path should be directed, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the path edges between the start node and the end node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindLongPath(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges of an undirected simple path within the given graph.</para>
      </summary>
      <remarks>
        <para>The edges are returned in the order that they appear in the found path.</para>
        <para>A heuristic is used for finding a path that is long. It is not guaranteed, though, that the returned path is actually the longest path within the given graph, since that is a well known hard problem.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges of an undirected simple path</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindLongestPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Calculates the longest path from a given node to all other node in a given directed acyclic graph.</para>
      </summary>
      <param name="graph">
        <para>a directed acyclic graph</para>
      </param>
      <param name="startNode">
        <para>the node for which the distances are calculated</para>
      </param>
      <param name="dist">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that returns the distance (i.e. weight) of type double for each edge</para>
      </param>
      <param name="maxDist">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and holds the maximum distance between the given node and all other nodes</para>
      </param>
      <param name="predicate">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that returns a boolean value indicating whether or not an edge should be considered during the path search</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindLongestPath(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns the longest directed path in a given acyclic weighted graph.</para>
      </summary>
      <remarks>
        <para>All edges of the graph have an integral length associated with them. The longest path is defined as one of all directed paths within the graph for which the edge lengths of all contained edges sum up to a maximum.</para>
      </remarks>
      <param name="graph">
        <para>a directed acyclic graph</para>
      </param>
      <param name="edgeLength">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the non-negative integer length of each edge</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges of the longest directed path</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Paths.ConstructNodePath(yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Constructs a <see cref="T:yWorks.Algorithms.NodeList">path of nodes</see> from a given <see cref="T:yWorks.Algorithms.EdgeList">path of edges</see>.</para>
      </summary>
      <remarks>
        <para>The returned node path has length <c>path.size()+1</c>, if the given path is not empty. Otherwise, the returned path will be empty. The <c>i</c>-th node in the returned path will be either source or target node of the <c>i</c>-th edge in the given path.</para>
      </remarks>
      <param name="path">
        <para>the given <see cref="T:yWorks.Algorithms.EdgeList">path of edges</see></para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList">path of nodes</see> from the given <see cref="T:yWorks.Algorithms.EdgeList">path of edges</see></para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindPath(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Returns whether or not a directed path from a start node to another node in an acyclic graph exists.</para>
      </summary>
      <param name="graph">
        <para>an acyclic graph which contains the two nodes</para>
      </param>
      <param name="topSort">
        <para>a <see cref="T:yWorks.Algorithms.NodeList">list</see> of nodes sorted in topological order</para>
      </param>
      <param name="predicate">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that returns a boolean value indicating whether or not an edge should be considered during the path search</para>
      </param>
      <returns>
        <para>
          <c>true</c> if a directed path from a start node to another node exists, <c>false</c> otherwise</para>
      </returns>
      <param name="startNode" />
      <param name="endNode" />
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindAllPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Finds all edges that belong to a directed path from a <c>start</c> node to an <c>end</c> node.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="startNode">
        <para>the given start node</para>
      </param>
      <param name="endNode">
        <para>the given end node</para>
      </param>
      <param name="pathEdges">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution with a boolean value indicating whether or not an edge belongs to a path connecting the two given nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindAllChains(yWorks.Algorithms.Graph,System.Boolean)">
      <summary>
        <para>Returns all chains present in the given graph.</para>
      </summary>
      <remarks>
        <para>A chain is a path of maximum length in which each internal node has degree <c>2</c>.</para>
        <para>The internal nodes on directed chains all have in-degree <c>1</c> and out-degree <c>1</c>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the chain should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.EdgeList" />s each of which contains the edges (at least two) that make up a chain</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.Paths.ConstructNodePath(yWorks.Algorithms.EdgeList)" />
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindAllPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean)">
      <summary>
        <para>Returns all simple directed or undirected paths that connect a <c>start</c> node with an <c>end</c> node.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="startNode">
        <para>the given start node</para>
      </param>
      <param name="endNode">
        <para>the given end node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the path should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.EdgeList" />s each of which represents a path between the start and end node</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindAllPathsCursor(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean)">
      <summary>
        <para>A variant of <see cref="M:yWorks.Algorithms.Paths.FindAllPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean)" />, which returns all simple directed or undirected paths between two given nodes as a special cursor that calculates the next path in the sequence, only when needed.</para>
      </summary>
      <remarks>
        <para>The returned cursor only supports the operation <see cref="P:yWorks.Algorithms.ICursor.Ok" />, <see cref="P:yWorks.Algorithms.ICursor.Current" />, <see cref="P:yWorks.Algorithms.ICursor.Size" /> and <see cref="M:yWorks.Algorithms.ICursor.Next" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="startNode">
        <para>the given start node</para>
      </param>
      <param name="endNode">
        <para>the given end node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the path should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.ICursor" /> that calculates the next path in the sequence</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Paths.FindAllPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Predicate{yWorks.Algorithms.EdgeList})">
      <summary>
        <para>A variant of <see cref="M:yWorks.Algorithms.Paths.FindAllPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean)" /> which returns all simple directed or undirected paths between two given nodes and, additionally, allows to specify a filter for the paths to be returned.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="startNode">
        <para>the given start node</para>
      </param>
      <param name="endNode">
        <para>the given end node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the path should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="filter">
        <para>a <see cref="T:System.Predicate`1" /> that accepts or rejects a found <see cref="T:yWorks.Algorithms.EdgeList" /> and adds it to the result</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.EdgeList" />s each of which represents a path between the start and end node.</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.PlanarEmbedding">
      <summary>
        <para>Represents an embedding of a planar graph.</para>
      </summary>
      <remarks>
        <para>A planar embedding is represented by a <see cref="P:yWorks.Algorithms.PlanarEmbedding.Faces">list of faces</see>. Each face is represented by a list of <see cref="T:yWorks.Algorithms.Dart">darts</see> which describe the border of the face.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.PlanarEmbedding.#ctor(yWorks.Algorithms.Graph)">
      <summary>
        <para>Creates a new embedding for the specified planar graph.</para>
      </summary>
      <param name="graph">
        <para>a planar graph</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the specified graph is not planar</para>
      </exception>
    </member>
    <member name="P:yWorks.Algorithms.PlanarEmbedding.Faces">
      <summary>
        <para>Gets a <see cref="T:System.Collections.Generic.IList`1" /> of face lists.</para>
      </summary>
      <remarks>
        <para>More precisely, each entry of this list is another list that contains all <see cref="T:yWorks.Algorithms.Dart">darts</see> of a face.</para>
      </remarks>
      <value>
        <para>a <see cref="T:System.Collections.Generic.IList`1" /> of face lists.</para>
      </value>
    </member>
    <member name="P:yWorks.Algorithms.PlanarEmbedding.OuterFace">
      <summary>
        <para>Gets the <see cref="T:System.Collections.Generic.IList`1" /> that represents the outer face.</para>
      </summary>
      <value>
        <para>the <see cref="T:System.Collections.Generic.IList`1" /> that represents the outer face</para>
      </value>
      <seealso cref="P:yWorks.Algorithms.PlanarEmbedding.Faces" />
    </member>
    <member name="M:yWorks.Algorithms.PlanarEmbedding.GetOutgoingDarts(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IList`1" /> containing the (cyclic ordered) outgoing darts of the specified node.</para>
      </summary>
      <param name="node">
        <para>a node</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IList`1" /> containing the (cyclic ordered) outgoing darts</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.PlanarEmbedding.GetDarts(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the two darts associated with the given edge.</para>
      </summary>
      <param name="edge">
        <para>an edge</para>
      </param>
      <returns>
        <para>the two darts associated with the given edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.PlanarEmbedding.GetCyclicNext(yWorks.Algorithms.Dart)">
      <summary>
        <para>Returns the cyclic next dart of the given dart.</para>
      </summary>
      <param name="dart">
        <para>a dart</para>
      </param>
      <returns>
        <para>the cyclic next dart of the given dart</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.PlanarEmbedding.GetCyclicPrevious(yWorks.Algorithms.Dart)">
      <summary>
        <para>Returns the cyclic previous dart of the given dart.</para>
      </summary>
      <param name="dart">
        <para>a dart</para>
      </param>
      <returns>
        <para>the cyclic previous dart of the given dart</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.PlanarEmbedding.IsPlanar(yWorks.Algorithms.Graph)">
      <summary>
        <para>Return whether or not the given graph is planar.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given graph is planar, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.RankAssignments">
      <summary>
        <para>This class provides algorithms for solving the rank assignment problem.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3> Let <c>G=(V,E)</c> be a directed acyclic graph. Let <c>length(e)</c> denote the minimum length and <c>weight(e)</c> the weight of an edge <c>e</c>.</para>
        <para>The <b>rank assignment problem</b> is the problem of finding integer values <c>rank(v)</c> for all <c>v</c> in <c>V</c>, such that:</para>
        <list type="bullet">
          <item>
            <c>rank(v) - rank(w) &gt;= length(v,w)</c>, for all <c>(v,w)</c> in <c>E</c> and,</item>
          <item>the sum <c>(weight(v,w) * (rank(v) - rank(w)))</c> over all <c>(v,w)</c> in <c>E</c> is minimized.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.RankAssignments.Simplex(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,System.Int64)">
      <summary>
        <para>Solves the rank assignment problem using the simplex method given a maximum time duration for the algorithm.</para>
      </summary>
      <remarks>
        <para>This method assigns a minimum rank to the nodes in a acyclic graph.</para>
        <para>Although its time complexity has not been proven polynomial, in practice it takes few iterations and runs quickly.</para>
        <para>The algorithm is based on:</para>
        <list type="bullet">
          <item>E.R. Gansner et al., <i>A Technique for Drawing Directed Graphs</i>, IEEE Transactions on Software Engineering, Vol.19, No.3, March 1993.</item>
        </list>
        <para>Minimum edge length and weights should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="layer">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns the zero-based ranking index for each node</para>
      </param>
      <param name="w">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an integer value (weight) of each edge</para>
      </param>
      <param name="minLength">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an integer value (minimum length) of each edge</para>
      </param>
      <param name="maximalDuration">
        <para>a preferred time limit for the algorithm (in milliseconds)</para>
      </param>
      <returns>
        <para>the number of layers</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.RankAssignments.Simplex(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,System.Int64)" />
      <seealso cref="M:yWorks.Algorithms.RankAssignments.Simplex(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.Node,System.Boolean,System.Int64)" />
    </member>
    <member name="M:yWorks.Algorithms.RankAssignments.Simplex(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.Node,System.Boolean,System.Int64)">
      <summary>
        <para>Similar to <see cref="M:yWorks.Algorithms.RankAssignments.Simplex(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,System.Int64)" /> but, additionally, it is possible to provide a valid initial tree solution for the problem.</para>
      </summary>
      <remarks>
        <para>Minimum edge length and weights should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="layer">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns the zero-based ranking index for each node</para>
      </param>
      <param name="w">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an integer value (weight) of each edge</para>
      </param>
      <param name="minLength">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an integer value (minimum length) of each edge</para>
      </param>
      <param name="tree">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that returns a boolean value indicating whether or not an edge is a tree edge</para>
      </param>
      <param name="_root">
        <para>the given root node of the tree solution</para>
      </param>
      <param name="validRanking">
        <para>
          <c>true</c> if the argument <c>layer</c> contains a valid ranking, <c>false</c> otherwise</para>
      </param>
      <param name="maximalDuration">
        <para>a preferred time limit for the algorithm (in milliseconds)</para>
      </param>
      <returns>
        <para>the number of layers</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.RankAssignments.Simplex(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,System.Int64)" />
      <seealso cref="M:yWorks.Algorithms.RankAssignments.Simplex(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.Node,System.Boolean,System.Int64)" />
    </member>
    <member name="M:yWorks.Algorithms.RankAssignments.Simple(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IEdgeMap,System.Int64)">
      <summary>
        <para>This method quickly calculates a tight tree given a maximum time duration for the algorithm.</para>
      </summary>
      <remarks>
        <para>The algorithm is using a highly optimized version of Gansner's algorithm:</para>
        <list type="bullet">
          <item>E.R. Gansner et al., <i>A Technique for Drawing Directed Graphs</i>, IEEE Transactions on Software Engineering, Vol.19, No.3, March 1993.</item>
        </list>
        <para>Minimum edge length and weights should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph in which all the edges have directions, such that <c>rank[source] &lt; rank[target]</c> and <c>rank[target] - rank[source] &gt;= minlength[edge]</c></para>
      </param>
      <param name="rank">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns the integer ranking of each node</para>
      </param>
      <param name="minLength">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that returns an integer value (minimum/tight length) of each edge</para>
      </param>
      <param name="maximalDuration">
        <para>a preferred time limit for the algorithm (in milliseconds)</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.RankAssignments.Simple(yWorks.Algorithms.Graph,System.Int32[],System.Int32[],System.Int64)" />
    </member>
    <member name="M:yWorks.Algorithms.RankAssignments.Simple(yWorks.Algorithms.Graph,System.Int32[],System.Int32[],System.Int64)">
      <summary>
        <para>Like <see cref="M:yWorks.Algorithms.RankAssignments.Simple(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IEdgeMap,System.Int64)" />, but arrays are used instead of <see cref="T:yWorks.Algorithms.INodeMap" />s and <see cref="T:yWorks.Algorithms.IEdgeMap" />s.</para>
      </summary>
      <remarks>
        <para>Minimum edge length and weights should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph in which all the edges have directions, such that <c>rank[source] &lt; rank[target]</c> and <c>rank[target] - rank[source] &gt;= minlength[edge]</c></para>
      </param>
      <param name="rank">
        <para>an array that will be filled with the ranking <c>r</c> of each node <c>v</c> such that <c>rank[v.index] == r</c></para>
      </param>
      <param name="minLength">
        <para>an array holding a non-negative value <c>len</c> of each edge <c>e</c> such that <c>minLength[e.index] == len</c></para>
      </param>
      <param name="maximalDuration">
        <para>a preferred time limit for the algorithm (in milliseconds)</para>
      </param>
      <returns>
        <para>the number of layers</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.RankAssignments.Simple(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.IEdgeMap,System.Int64)" />
    </member>
    <member name="T:yWorks.Algorithms.ShortestPaths">
      <summary>
        <para>This class provides diverse algorithms and helper methods for solving the shortest path problem on weighted graphs.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3> Given a weighted directed/undirected graph:</para>
        <list type="bullet">
          <item>The <b>shortest path problem</b> is the problem of finding a shortest path between <b>a source node <c>s</c>
 and a target node <c>t</c></b> such that the sum of the edge costs is minimized.</item>
          <item>The <b>k-shortest path problem</b> is the problem of finding <b><c>k</c> shortest paths</b> between <b>a source
 node <c>s</c> and a target node <c>t</c></b> such that the sum of the edge costs is minimized.</item>
          <item>The <b>single-source shortest path problem</b> is the problem of finding shortest paths from <b>a source node
 <c>s</c> to all</b> other nodes such that the sum of the edge costs is minimized.</item>
          <item>The <b>single-source single-sink shortest path problem</b> is the problem of finding shortest paths from <b>a source node <c>s</c> to a target node <c>t</c></b> such that the sum of the edge costs is minimized.</item>
          <item>The <b>all-pairs shortest path problem</b> is the problem of finding shortest paths between <b>every pair of
 nodes</b> such that the sum of the edge costs is minimized.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.Uniform(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])">
      <summary>
        <para>Solves the single-source shortest path problem for arbitrary graphs in which each edge has a <b>uniform cost of
 <c>1.0</c></b>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the node from which the shortest path search starts</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="dist">
        <para>an array of values that will be filled during the execution and returns the shortest distance from node <c>s</c> to all other nodes. The distance from <c>s</c> to <c>v</c> is <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>, then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.</para>
      </param>
      <param name="pred">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s that will be filled during the execution and returns for each node <c>t</c> the shortest path edge <c>pred[t.index()]</c> which is the last edge on the shortest path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there is no shortest path from <c>s</c> to <c>t</c>, then <c>pred[t.index()] == null</c>.</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.Uniform(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.INodeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Like <see cref="M:yWorks.Algorithms.ShortestPaths.Uniform(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])" /> but uses <see cref="T:yWorks.Algorithms.INodeMap" />s instead of arrays.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the node from which the shortest path search starts</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="dist">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (shortest distance) from node <c>s</c> to all other nodes or <see cref="F:System.Double.PositiveInfinity" /> if no such paths exist</para>
      </param>
      <param name="pred">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns for each node <c>t</c> the last edge on the shortest path from <c>s</c> to <c>t</c> or <c>null</c> if <c>t == s</c> or no shortest path from <c>s</c> to <c>t</c> exists</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.Uniform(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.Acyclic(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Double[],System.Double[],yWorks.Algorithms.Edge[])">
      <summary>
        <para>Solves the single-source shortest path problem for <b>acyclic</b> directed graphs.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with an arbitrary double value that represents the cost of that edge.</para>
        <para>This method yields the shortest distance from a given node <c>s</c> to all other nodes.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the node from which the shortest path search starts</para>
      </param>
      <param name="cost">
        <para>an array of double values that returns the costs for traversing each edge; edge <c>e</c> has cost <c>cost[e.index()]</c></para>
      </param>
      <param name="dist">
        <para>an array of values that will be filled during the execution and returns the shortest distance from node <c>s</c> to all other nodes. The distance from <c>s</c> to <c>v</c> is <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>, then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.</para>
      </param>
      <param name="pred">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s that will be filled during the execution and returns for each node <c>t</c> the shortest path edge <c>pred[t.index()]</c> which is the last edge on the shortest path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there is no shortest path from <c>s</c> to <c>t</c>, then <c>pred[t.index()] == null</c>.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the input graph is acyclic, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.Acyclic(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Double[],System.Double[],yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.Acyclic(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap,yWorks.Algorithms.INodeMap)">
      <summary />
      <remarks>
        <para>Each edge is associated with an arbitrary double value that represents the cost of that edge.</para>
        <para>This method yields the shortest distance from a given node <c>s</c> to all other nodes.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the node from which the shortest path search starts</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the double value (cost) for traversing each edge</para>
      </param>
      <param name="dist">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (shortest distance) from node <c>s</c> to all other nodes or <see cref="F:System.Double.PositiveInfinity" /> if no such paths exist</para>
      </param>
      <param name="pred">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns for each node <c>t</c> the last edge on the shortest path from <c>s</c> to <c>t</c> or <c>null</c> if <c>t == s</c> or no shortest path from <c>s</c> to <c>t</c> exists</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the input graph is acyclic, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.Acyclic(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Double[],System.Double[],yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.Dijkstra(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.Algorithms.Edge[])">
      <summary>
        <para>Solves the single-source shortest path problem for arbitrary graphs.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.</para>
        <para>This method yields the shortest distance from a given node <c>s</c> to all other nodes.</para>
        <para>The costs should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the node from which the shortest path search starts</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>an array of double values that returns the costs for traversing each edge; edge <c>e</c> has cost <c>cost[e.index()]</c></para>
      </param>
      <param name="dist">
        <para>an array of values that will be filled during the execution and returns the shortest distance from node <c>s</c> to all other nodes. The distance from <c>s</c> to <c>v</c> is <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>, then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.</para>
      </param>
      <param name="pred">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s that will be filled during the execution and returns for each node <c>t</c> the shortest path edge <c>pred[t.index()]</c> which is the last edge on the shortest path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there is no shortest path from <c>s</c> to <c>t</c>, then <c>pred[t.index()] == null</c>.</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.Dijkstra(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.Dijkstra(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Solves the single-source shortest path problem for arbitrary graphs.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.</para>
        <para>This method yields the shortest distance from a given node <c>s</c> to all other nodes.</para>
        <para>The costs should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the node from which the shortest path search starts</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the double value (cost) for traversing each edge</para>
      </param>
      <param name="dist">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (shortest distance) from node <c>s</c> to all other nodes or <see cref="F:System.Double.PositiveInfinity" /> if no such paths exist</para>
      </param>
      <param name="pred">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns for each node <c>t</c> the last edge on the shortest path from <c>s</c> to <c>t</c> or <c>null</c> if <c>t == s</c> or no shortest path from <c>s</c> to <c>t</c> exists</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.Dijkstra(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])">
      <summary>
        <para>This method solves the single-source single-sink shortest path problem for arbitrary graphs.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.</para>
        <para>This method returns the shortest distance from node <c>s</c> to node <c>t</c>. It also returns information to construct the actual path between these two nodes.</para>
        <para>The costs should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the source node</para>
      </param>
      <param name="t">
        <para>the sink node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>an array of double values that returns the costs for traversing each edge; edge <c>e</c> has cost <c>cost[e.index()]</c></para>
      </param>
      <param name="pred">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s that will be filled during the execution and returns for each node <c>t</c> the shortest path edge <c>pred[t.index()]</c> which is the last edge on the shortest path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there is no shortest path from <c>s</c> to <c>t</c>, then <c>pred[t.index()] == null</c>.</para>
      </param>
      <returns>
        <para>the distance between <c>s</c>and <c>t</c> if a path between these two nodes exists or <c>Double.POSITIVE_INFINITY</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider)" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap)" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[])">
      <summary>
        <para>Similar to <see cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])" /> but instead of returning the shortest distance between the source and sink the actual shortest edge path between these nodes will be returned.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.</para>
        <para>If the returned path is empty, then there is no path between the nodes.</para>
        <para>The costs should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the source node</para>
      </param>
      <param name="t">
        <para>the sink node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>an array of double values that returns the costs for traversing each edge; edge <c>e</c> has cost <c>cost[e.index()]</c></para>
      </param>
      <returns>
        <para>a shortest <see cref="T:yWorks.Algorithms.EdgeList">path of edges</see> between source and sink</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider)" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Similar to <see cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap)" /> but instead of returning the shortest distance between the source and sink the actual shortest edge path between these nodes will be returned.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.</para>
        <para>If the returned path is empty, then there is no path between the nodes.</para>
        <para>The costs should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the source node</para>
      </param>
      <param name="t">
        <para>the sink node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the double value (cost) for traversing each edge</para>
      </param>
      <returns>
        <para>a shortest <see cref="T:yWorks.Algorithms.EdgeList">path of edges</see> between source and sink</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap)" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Like <see cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])" /> but uses <see cref="T:yWorks.Algorithms.INodeMap" />s and <see cref="T:yWorks.Algorithms.IDataProvider" />s instead of arrays.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with a <b>non-negative</b> double value that represents the cost of the edge.</para>
        <para>The costs should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the source node</para>
      </param>
      <param name="t">
        <para>the sink node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the double value (cost) for traversing each edge</para>
      </param>
      <param name="pred">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns for each node <c>t</c> the last edge on the shortest path from <c>s</c> to <c>t</c> or <c>null</c> if <c>t == s</c> or no shortest path from <c>s</c> to <c>t</c> exists</para>
      </param>
      <returns>
        <para>a shortest <see cref="T:yWorks.Algorithms.EdgeList">path of edges</see> between source and sink</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[],yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider)" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSourceSingleSink(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,System.Double[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.BellmanFord(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.Algorithms.Edge[])">
      <summary>
        <para>Solves the single-source shortest path problem for arbitrary graphs.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with an arbitrary double value that represents the cost of this edge.</para>
        <para>In case the given weighted graph contains no <b>negative cost cycles</b>, this method will yield the shortest distance from a given node <c>s</c> to all other nodes. If, on the other hand, the given graph contains negative-cost cycles, this method will yield no reasonable result which will be indicated by the return value <c>false</c>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the node from which the shortest path search starts</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>an array of double values that returns the costs for traversing each edge; edge <c>e</c> has cost <c>cost[e.index()]</c></para>
      </param>
      <param name="dist">
        <para>an array of values that will be filled during the execution and returns the shortest distance from node <c>s</c> to all other nodes. The distance from <c>s</c> to <c>v</c> is <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>, then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.</para>
      </param>
      <param name="pred">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s that will be filled during the execution and returns for each node <c>t</c> the shortest path edge <c>pred[t.index()]</c> which is the last edge on the shortest path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there is no shortest path from <c>s</c> to <c>t</c>, then <c>pred[t.index()] == null</c>.</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.BellmanFord(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.BellmanFord(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Solves the single-source shortest path problem for arbitrary graphs.</para>
      </summary>
      <remarks>
        <para>Each edge is associated with an arbitrary double value that represents the cost of this edge.</para>
        <para>In case the given weighted graph contains no <b>negative-cost cycles</b>, this method will yield the shortest distance from a given node <c>s</c> to all other nodes. If, on the other hand, the given graph contains negative-cost cycles, this method will yield no reasonable result which will be indicated by the return value <c>false</c>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the source node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the double value (cost) for traversing each edge</para>
      </param>
      <param name="dist">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (shortest distance) from node <c>s</c> to all other nodes or <see cref="F:System.Double.PositiveInfinity" /> if no such paths exist</para>
      </param>
      <param name="pred">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns for each node <c>t</c> the last edge on the shortest path from <c>s</c> to <c>t</c> or <c>null</c> if <c>t == s</c> or no shortest path from <c>s</c> to <c>t</c> exists</para>
      </param>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.BellmanFord(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.SingleSource(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.Algorithms.Edge[])">
      <summary>
        <para>This method solves the single-source shortest path problem for arbitrary graphs.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the node from which the shortest path search starts</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>an array of double values that returns the costs for traversing each edge; edge <c>e</c> has cost <c>cost[e.index()]</c></para>
      </param>
      <param name="dist">
        <para>an array of values that will be filled during the execution and returns the shortest distance from node <c>s</c> to all other nodes. The distance from <c>s</c> to <c>v</c> is <c>dist[v.index()]</c>. If there is no path from <c>s</c> to <c>v</c>, then <c>dist[v.index()] == Double.POSITIVE_INFINITY</c>.</para>
      </param>
      <param name="pred">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s that will be filled during the execution and returns for each node <c>t</c> the shortest path edge <c>pred[t.index()]</c> which is the last edge on the shortest path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there is no shortest path from <c>s</c> to <c>t</c>, then <c>pred[t.index()] == null</c>.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the weighted graph does not contain a negative-cost cycle, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSource(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.SingleSource(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.INodeMap,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>This method solves the single-source shortest path problem for arbitrary graphs.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="s">
        <para>the source node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the double value (cost) for traversing each edge</para>
      </param>
      <param name="dist">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns a double value (shortest distance) from node <c>s</c> to all other nodes or <see cref="F:System.Double.PositiveInfinity" /> if no such paths exist</para>
      </param>
      <param name="pred">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns for each node <c>t</c> the last edge on the shortest path from <c>s</c> to <c>t</c> or <c>null</c> if <c>t == s</c> or no shortest path from <c>s</c> to <c>t</c> exists</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the weighted graph does not contain a negative-cost cycle, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.SingleSource(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,System.Double[],System.Double[],yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.AllPairs(yWorks.Algorithms.Graph,System.Boolean,System.Double[],System.Double[][])">
      <summary>
        <para>This method solves the all-pairs shortest path problem for graphs with arbitrary edge costs.</para>
      </summary>
      <remarks>
        <para>If the given graph contains a negative-cost cycle, then <c>false</c> is returned and the values returned in <c>dist</c> are left unspecified.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="cost">
        <para>an array of double values that returns the costs for traversing each edge; edge <c>e</c> has cost <c>cost[e.index()]</c></para>
      </param>
      <param name="dist">
        <para>an array of values that will be filled during the execution and returns the shortest path distances from all pairs of nodes <c>s</c> and <c>t</c> in the graph. The distance from <c>s</c> to <c>t</c> is <c>dist[s.index()][t.index()]</c>. If there is no path from <c>s</c> to <c>t</c>, then <c>dist[s.index()][t.index()] == Double.POSITIVE_INFINITY</c>.</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given graph does not contain a negative-cost cycle, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.FindShortestUniformPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Marks all edges that belong to a shortest path from <c>start</c> node to <c>target</c> node.</para>
      </summary>
      <remarks>
        <para>This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="start">
        <para>the start node</para>
      </param>
      <param name="end">
        <para>the target node</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="pathMap">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be filled during the execution and returns a boolean value indicating whether or not the edge belongs to a shortest path connecting the two nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.KShortestPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Int32)">
      <summary>
        <para>This method finds the <c>k</c> shortest paths connecting a pair of nodes in a directed graph with non-negative edge costs.</para>
      </summary>
      <remarks>
        <para>The result will be returned as a list of <see cref="T:yWorks.Algorithms.EdgeList" /> objects.</para>
        <para>The cost should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="costDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for traversing each edge</para>
      </param>
      <param name="start">
        <para>the given start node</para>
      </param>
      <param name="end">
        <para>the given target node</para>
      </param>
      <param name="k">
        <para>a non-negative integer value</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.YList">list</see> of <see cref="T:yWorks.Algorithms.EdgeList" /> objects each of which represents a path from <c>start</c> node to <c>target</c> node. The <c>i</c>-th path in the list contains the <c>i</c>-th shortest path between the <c>start</c> and <c>target</c> node.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.KShortestPathsCursor(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Int32)">
      <summary>
        <para>A variant of <see cref="M:yWorks.Algorithms.ShortestPaths.KShortestPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Int32)" /> that returns the result as a special cursor that calculates the next path in the sequence only when needed.</para>
      </summary>
      <remarks>
        <para>The returned cursor only supports the operation <see cref="P:yWorks.Algorithms.ICursor.Ok" />, <see cref="P:yWorks.Algorithms.ICursor.Current" /> and <see cref="M:yWorks.Algorithms.ICursor.Next" />.</para>
        <para>The cost should be non-negative.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="costDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for traversing each edge</para>
      </param>
      <param name="start">
        <para>the given start node</para>
      </param>
      <param name="end">
        <para>the given target node</para>
      </param>
      <param name="k">
        <para>a non-negative integer value</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.ICursor">cursor</see> that calculates the next path in the sequence only when needed</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.UniformCost(yWorks.Algorithms.Graph)">
      <summary>
        <para>Convenience method that returns an array containing uniform edge costs of <c>1.0</c> for each edge of the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>an array that contains uniform edge costs of value <c>1.0</c> (i.e., for each edge <c>e: cost[e.index()] == 1.0</c>)</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])">
      <summary>
        <para>Convenience method that constructs an explicit <see cref="T:yWorks.Algorithms.NodeList">path of nodes</see> from the result returned by one of the shortest paths methods defined in this class.</para>
      </summary>
      <remarks>
        <para>If there is no path from node <c>s</c> to <c>t</c>, then an empty list is returned.</para>
      </remarks>
      <param name="s">
        <para>the start node of the shortest path which must be the same start node that was specified when <c>pred</c> was calculated</para>
      </param>
      <param name="t">
        <para>the target node of the path</para>
      </param>
      <param name="pred">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s that will be filled during the execution and returns for each node <c>t</c> the shortest path edge <c>pred[t.index()]</c> which is the last edge on the shortest path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there is no shortest path from <c>s</c> to <c>t</c>, then <c>pred[t.index()] == null</c>.</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList">list</see> containing the nodes on the shortest path from <c>s</c> to <c>t</c> in the correct order</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Like <see cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" /> but the path edges are given by a <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </summary>
      <remarks>
        <para>If there is no path from node <c>s</c> to <c>t</c>, then an empty list is returned.</para>
      </remarks>
      <param name="s">
        <para>the start node of the shortest path which must be the same start node that was specified when <c>pred</c> was calculated</para>
      </param>
      <param name="t">
        <para>the target node of the path</para>
      </param>
      <param name="pred">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns for each node <c>t</c> the last edge on the shortest path from <c>s</c> to <c>t</c> or <c>null</c> if <c>t == s</c> or no shortest path from <c>s</c> to <c>t</c> exists</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList">list</see> containing the nodes on the shortest path from <c>s</c> to <c>t</c> in the correct order</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructNodePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])">
      <summary>
        <para>Convenience method that constructs an explicit <see cref="T:yWorks.Algorithms.EdgeList">path of edges</see> from the result returned by one of the shortest paths methods defined in this class.</para>
      </summary>
      <remarks>
        <para>If there is no path from node <c>s</c> to <c>t</c>, then an empty list is returned.</para>
      </remarks>
      <param name="s">
        <para>the start node of the shortest path which must be the same start node that was specified when <c>pred</c> was calculated</para>
      </param>
      <param name="t">
        <para>the target node of the path</para>
      </param>
      <param name="pred">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s that will be filled during the execution and returns for each node <c>t</c> the shortest path edge <c>pred[t.index()]</c> which is the last edge on the shortest path from <c>s</c> to <c>t</c>. If <c>t == s</c> or if there is no shortest path from <c>s</c> to <c>t</c>, then <c>pred[t.index()] == null</c>.</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> containing the edges on the shortest path from <c>s</c> to <c>t</c> in the correct order</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Like <see cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" /> but the path edges are given by a <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </summary>
      <remarks>
        <para>If there is no path from node <c>s</c> to <c>t</c>, then an empty list is returned.</para>
      </remarks>
      <param name="s">
        <para>the start node of the shortest path which must be the same start node that was specified when <c>pred</c> was calculated</para>
      </param>
      <param name="t">
        <para>the target node of the path</para>
      </param>
      <param name="pred">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution and returns for each node <c>t</c> the last edge on the shortest path from <c>s</c> to <c>t</c> or <c>null</c> if <c>t == s</c> or no shortest path from <c>s</c> to <c>t</c> exists</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> containing the edges on the shortest path from <c>s</c> to <c>t</c> in the correct order</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.ShortestPaths.ConstructEdgePath(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge[])" />
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.FindShortestUniformPaths(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,System.Boolean,System.Int32,yWorks.Algorithms.EdgeList,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Finds all nodes and edges that belong to a shortest path from a <c>start</c> node to a set of target nodes in the graph not farther away than a given distance.</para>
      </summary>
      <remarks>
        <para>This method assumes that each edge of the input graph has a <b>cost of 1.0</b>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="start">
        <para>the start node</para>
      </param>
      <param name="targetMap">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a boolean value indicating whether or not a node belongs to the set of target nodes</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="maxLength">
        <para>the maximum edge length of the shortest paths</para>
      </param>
      <param name="pathEdges">
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> that will be filled during the execution and returns the edges on the shortest path from <c>s</c> to <c>t</c> in the correct order</para>
      </param>
      <param name="pathNodes">
        <para>a <see cref="T:yWorks.Algorithms.NodeList">list</see> that will be filled during the execution and returns the nodes on the shortest path from <c>s</c> to <c>t</c> in the correct order</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.ShortestPaths.ShortestPair(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns two edge-disjoint paths in a non-negatively weighted directed graph, such that both paths connect nodes <c>s</c> and <c>t</c> and have minimum total length.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="source">
        <para>the source node of the shortest pair</para>
      </param>
      <param name="target">
        <para>the target node of the shortest pair</para>
      </param>
      <param name="directed">
        <para>
          <c>true</c> if the graph should be considered as directed, <c>false</c> otherwise</para>
      </param>
      <param name="costDP">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for traversing each edge</para>
      </param>
      <returns>
        <para>a two-dimensional array of <see cref="T:yWorks.Algorithms.EdgeList" />s holding the resulting edge-disjoint paths or <c>null</c> if no such edge-disjoint paths exist</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Sorting">
      <summary>
        <para>This class provides methods for efficiently sorting graph elements in graph structures.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Sorting.SortNodesByDegree(yWorks.Algorithms.Graph)">
      <summary>
        <para>Sorts the nodes of a given graph by degree in ascending order.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.Node" />s sorted by degree in ascending order</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Sorting.SortNodesByIntKey(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Sorts the nodes of a given graph by an integer key associated with each node through a <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </summary>
      <remarks>
        <para>The nodes are sorted in ascending order.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="keys">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the keys based on which the nodes will be sorted</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.Node" />s sorted by an integer key in ascending order</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.SpanningTrees">
      <summary>
        <para>This class provides (minimum) spanning tree algorithms for graphs.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>A <b>spanning tree</b> of an undirected connected graph is a subset of its edges that induce a tree that connects all nodes of the graph.</item>
          <item>A <b>minimum spanning tree</b> of a weighted connected graph is a spanning tree whose edges have minimum overall cost among all spanning trees of that graph.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.SpanningTrees.Minimum(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Calculates a minimum spanning tree for the given graph.</para>
      </summary>
      <remarks>
        <para>Currently, the result is obtained by calling <see cref="M:yWorks.Algorithms.SpanningTrees.Prim(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for each edge</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> containing the edges that form the minimum spanning tree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.SpanningTrees.Kruskal(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Calculates a minimum spanning tree for the given graph.</para>
      </summary>
      <remarks>
        <para>The implementation is based on an algorithm originally published in:</para>
        <list type="bullet">
          <item>J.B. Kruskal. On the shortest spanning subtree of a graph and the traveling salesman problem. <i>Proceedings of the American Mathematical Society</i>, pages 48-50, 1956.</item>
        </list>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for each edge</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> containing the edges that form the minimum spanning tree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.SpanningTrees.Prim(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Calculates a minimum spanning tree for the given graph.</para>
      </summary>
      <remarks>
        <para>The implementation is based on an algorithm originally published in:</para>
        <list type="bullet">
          <item>R.C. Prim. Shortest connection networks and some generalizations. <i>Bell System Technical Journal</i>, 36:1389-1401, 1957.</item>
        </list>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="cost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for each edge</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> containing the edges that form the minimum spanning tree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.SpanningTrees.Uniform(yWorks.Algorithms.Graph)">
      <summary>
        <para>Calculates a spanning tree for the given graph in which each edge has a uniform cost of <c>1.0</c>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> containing the edges that form the minimum spanning tree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.SpanningTrees.Cost(yWorks.Algorithms.EdgeList,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns the overall cost of a previously calculated minimum spanning tree.</para>
      </summary>
      <param name="treeEdges">
        <para>the given <see cref="T:yWorks.Algorithms.EdgeList">list</see> of edges that form a minimum spanning tree</para>
      </param>
      <param name="edgeCost">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a double value (cost) for each tree edge</para>
      </param>
      <returns>
        <para>the overall cost of the tree edges</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Transitivity">
      <summary>
        <para>This class provides algorithms to compute reachability information for directed, acyclic graphs.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>
            <b>Reflexive, transitive closure:</b> Let <c>G = (V,E)</c> be a directed acyclic graph. The <b>reflexive, transitive closure</b> of <c>G</c> is a graph which contains edge <c>(v,w)</c> only if there exists a path from <c>v</c> to <c>w</c> in <c>G</c>.</item>
          <item>
            <b>Transitive reduction:</b> Let <c>G = (V,E)</c> be a directed acyclic graph. The <b>transitive reduction</b> of <c>G</c> is a graph which contains edge <c>(v,w)</c> only if there exists no path from <c>v</c> to <c>w</c> in <c>G</c> of length <c>2</c> or more.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Transitivity.TransitiveClosure(yWorks.Algorithms.Graph,yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Calculates the transitive closure for a directed acyclic graph.</para>
      </summary>
      <remarks>
        <para>Given a <c>G = (V,E)</c> be a directed acyclic graph. The <i>reflexive, transitive closure</i> of <c>G</c> is a graph which contains edge <c>(v,w)</c> only if there exists a path from <c>v</c> to <c>w</c> in <c>G</c>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph to which this method will add transitive edges, if necessary</para>
      </param>
      <param name="addedEdges">
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> that will be filled during the execution and contains the edges that have been added to the graph by this method</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Transitivity.TransitiveReduction(yWorks.Algorithms.Graph,yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Calculates the transitive reduction for a directed acyclic graph.</para>
      </summary>
      <remarks>
        <para>The transitive edges in the graph will be removed by this method.</para>
        <para>Given <c>G = (V,E)</c> be a directed acyclic graph. The <i>transitive reduction</i> of <c>G</c> is a graph which contains edge <c>(v,w)</c> only if there exists no path from <c>v</c> to <c>w</c> in <c>G</c> of length <c>2</c> or more.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="transitiveEdges">
        <para>a <see cref="T:yWorks.Algorithms.EdgeList">list</see> that will be filled during the execution and contains all transitive edges of the given graph; removal of these edges will yield the transitive reduction of the graph</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Trees">
      <summary>
        <para>This class provides diverse algorithms and services for tree-structured graphs or subgraphs.</para>
      </summary>
      <remarks>
        <para>
          <h3>Definitions</h3>
        </para>
        <list type="bullet">
          <item>
            <b>Tree:</b> An acyclic graph, in which any pair of vertices (nodes) is connected through a path. If one vertex of a tree is distinguished from the other vertices, then this vertex is called the <b>root</b> and the tree is called a <b>rooted tree</b>.</item>
          <item>
            <b>Directed rooted tree:</b> A rooted tree where edges are directed from the root to the leaves.</item>
          <item>
            <b>Depth:</b> The depth of a vertex in a rooted tree is the number of edges of the unique path between this vertex and the root.</item>
          <item>
            <b>Parent:</b> In a rooted tree a vertex <c>v</c> is called parent of a vertex <c>w</c> if <c>v</c> and <c>w</c> are adjacent (i.e. connected by an edge) and the unique path between <c>w</c> and the root contains <c>v</c>. Note that each vertex except the root has exactly one parent.</item>
          <item>
            <b>Children:</b> In a rooted tree a vertex <c>w</c> is called child of a vertex <c>v</c> if <c>v</c> is the parent of <c>w</c>. A vertex may have several children.</item>
          <item>
            <b>N-ary tree:</b> A directed rooted tree where each node has a maximum of <c>n</c> children.</item>
          <item>
            <b>Forest:</b> A graph whose connected components are trees.</item>
          <item>
            <b>Leaf:</b> A leaf <c>v</c> is a node with out-degree (i.e., the number of edges having <c>v</c> as a target) zero if the input is a directed rooted tree, and a node with degree (i.e., the number of edges incident to <c>v</c>) one, otherwise.</item>
          <item>
            <b>Subtree:</b> A subtree of a tree <c>T</c> is a subgraph of <c>T</c> which is also a tree.</item>
          <item>
            <b>Nearest or Lowest or Least common ancestor:</b> The nearest common ancestor of two nodes <c>u</c> and <c>v</c> in a tree graph is the shared ancestor of <c>u</c> and <c>v</c> that is located farthest from the root.</item>
          <item>
            <b>Eccentricity:</b> The eccentricity of a tree node is the maximum distance to any other node.</item>
          <item>
            <b>Center node:</b> The center of a tree is the set of nodes that have minimal eccentricity.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetTreeEdges(yWorks.Algorithms.Graph,yWorks.Algorithms.NodeList[])">
      <summary>
        <para>Returns an array of <see cref="T:yWorks.Algorithms.EdgeList" /> objects each containing edges that belong to a maximal directed subtree of the given graph.</para>
      </summary>
      <remarks>
        <para>This method can also be applied to the result obtained by <see cref="M:yWorks.Algorithms.Trees.GetUndirectedTreeNodes(yWorks.Algorithms.Graph)" />. In this case, the subtrees are considered to be undirected.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="treeNodes">
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" />s previously calculated by <see cref="M:yWorks.Algorithms.Trees.GetTreeNodes(yWorks.Algorithms.Graph)" /></para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.EdgeList" /> objects each containing edges that belong to a maximal subtree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetTreeNodes(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns an array of <see cref="T:yWorks.Algorithms.NodeList" /> objects each containing nodes that belong to a maximal directed subtree of the given graph.</para>
      </summary>
      <remarks>
        <para>For each list of tree nodes, the first node element is the root of a tree. On each such root, all outgoing edges connect to nodes in the subtree and each in-degree of the root is at least two.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" /> objects each containing nodes that belong to a maximal directed subtree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetUndirectedTreeNodes(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns an array of <see cref="T:yWorks.Algorithms.NodeList" /> objects each containing nodes that belong to a maximal undirected subtree of the given graph.</para>
      </summary>
      <remarks>
        <para>For each list of tree nodes, the first node is the only node of the subtree that may be incident to non-tree edges.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.NodeList" /> objects each containing nodes that belong to a maximal undirected subtree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.IsNaryTree(yWorks.Algorithms.Graph,System.Int32)">
      <summary>
        <para>Checks whether or not the given graph is a directed rooted tree in which each node has a maximum of <c>n</c> children.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="n">
        <para>the allowed maximum of children</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given graph is a n-ary tree, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.IsRootedTree(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given graph is a directed rooted tree.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given graph is a directed rooted tree, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.IsTree(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given graph is an undirected tree.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given graph is an undirected tree, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.IsForest(yWorks.Algorithms.Graph)">
      <summary>
        <para>Checks whether or not the given graph is a forest, that is, a graph whose connected components are directed rooted trees.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given graph is a forest, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.IsForest(yWorks.Algorithms.Graph,System.Boolean)">
      <summary>
        <para>Checks whether or not the given graph is a forest.</para>
      </summary>
      <remarks>
        <para>If <c>directedRootedTree == true</c>, each component has to be a directed rooted tree. Otherwise, each component has to be an undirected tree.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="directedRootedTree">
        <para>
          <c>true</c> if the algorithm should check for directed rooted trees, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given graph is a forest, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetLeafNodes(yWorks.Algorithms.Graph,System.Boolean)">
      <summary>
        <para>Returns all leaf nodes of the given tree.</para>
      </summary>
      <remarks>
        <para>A leaf node is a node with <c>outdegree == 0</c> if the input is a directed rooted tree, and a node with <c>degree == 1</c>, otherwise.</para>
      </remarks>
      <param name="tree">
        <para>the given tree</para>
      </param>
      <param name="directedRootedTree">
        <para>
          <c>true</c> if the algorithm should consider the tree as directed, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> that contains all leaf nodes of the given tree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetCenterRoot(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns the center node of an undirected tree.</para>
      </summary>
      <remarks>
        <para>The center node has the property of inducing a minimum depth tree when being used as the root of that tree.</para>
      </remarks>
      <param name="tree">
        <para>the given undirected tree</para>
      </param>
      <returns>
        <para>the center node of the given undirected tree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetRoot(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns a possible root for the given (undirected) tree.</para>
      </summary>
      <remarks>
        <para>More precisely:</para>
        <list type="bullet">
          <item>If the input is a directed rooted tree or reversed directed rooted tree, it returns the corresponding root node.</item>
          <item>If the input is a tree, the method returns a maximum weight center node as defined in <see cref="M:yWorks.Algorithms.Trees.GetWeightedCenterNode(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)" />.</item>
          <item>If the input is not a tree, a node with <c>indegree == 0</c> (or <c>outdegree == 0</c>) is returned.</item>
        </list>
      </remarks>
      <param name="tree">
        <para>the given tree</para>
      </param>
      <returns>
        <para>a possible root for the given tree</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetWeightedCenterNode(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Finds a node used by the greatest number of all (undirected) paths interconnecting all nodes with each other.</para>
      </summary>
      <remarks>
        <para>The number of paths per node are stored in the given <see cref="T:yWorks.Algorithms.INodeMap" />.</para>
      </remarks>
      <param name="tree">
        <para>the given tree</para>
      </param>
      <param name="intWeight">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that holds the number of paths per node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Node" /> used by the greatest number of all undirected paths</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.DirectTree(yWorks.Algorithms.Graph,yWorks.Algorithms.Node)">
      <summary>
        <para>Converts the given tree to a directed rooted tree with the given node as root element by reversing some edges.</para>
      </summary>
      <remarks>
        <para>A list of all reversed edges will be returned by this method.</para>
      </remarks>
      <param name="tree">
        <para>the given tree</para>
      </param>
      <param name="root">
        <para>the given root element</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the reversed edges</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetNearestCommonAncestor(yWorks.Algorithms.Graph,yWorks.Algorithms.Node,System.Boolean,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Returns the nearest common ancestor of a subset of nodes within a directed rooted tree.</para>
      </summary>
      <remarks>
        <para>It is not part of the given subset.</para>
      </remarks>
      <param name="tree">
        <para>the given directed rooted tree</para>
      </param>
      <param name="root">
        <para>the root of the tree</para>
      </param>
      <param name="rootedDownward">
        <para>
          <c>true</c> if the tree is directed from the root to the leaves, <c>false</c> otherwise</para>
      </param>
      <param name="nodes">
        <para>the subset of nodes</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Algorithms.Node">nearest common ancestor</see> of the given subset of nodes</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetSubTreeDepths(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Returns the depths of each subtree of a rooted directed tree.</para>
      </summary>
      <param name="tree">
        <para>a rooted directed tree graph</para>
      </param>
      <param name="subtreeDepthMap">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution with the depth of the subtree rooted at each node</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Trees.GetSubTreeSizes(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Returns the size (number of nodes) of each subtree of a rooted directed tree.</para>
      </summary>
      <param name="tree">
        <para>a rooted directed tree graph</para>
      </param>
      <param name="subtreeSizeMap">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled during the execution with the size of the subtree rooted at each node</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Util.Comparers">
      <summary>
        <para>This class provides access to some Comparator instances that are commonly used in yFiles.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.CreateIntDataSourceComparer(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares objects of type <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <remarks>
        <para>Two edges are compared by comparing their source nodes. Each source node <c>e.source()</c> in turn is compared by the int value provided by the given data provider: <c>dp.getInt(e.source())</c>.</para>
      </remarks>
      <param name="dp">
        <para>a data provider that must return an int value for the source node of each edge being compared.</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares edges.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.CreateIntDataTargetComparer(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares objects of type <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <remarks>
        <para>Two edges are compared by comparing their target nodes. Each target node <c>e.target()</c> in turn is compared by the int value provided by the given data provider: <c>dp.getInt(e.target())</c>.</para>
      </remarks>
      <param name="dp">
        <para>a data provider that must return an int value for the target node of each edge being compared.</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares edges.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.CreateDoubleDataSourceComparer(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares objects of type <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <remarks>
        <para>Two edges are compared by comparing their source nodes. Each source node <c>e.source()</c> in turn is compared by the double value provided by the given data provider: <c>dp.getDouble(e.source())</c>.</para>
      </remarks>
      <param name="dp">
        <para>a data provider that must return a double value for the source node of each edge being compared.</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares edges.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.CreateDoubleDataTargetComparer(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares objects of type <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <remarks>
        <para>Two edges are compared by comparing their target nodes. Each target node <c>e.target()</c> in turn is compared by the double value provided by the given data provider: <c>dp.getDouble(e.target())</c>.</para>
      </remarks>
      <param name="dp">
        <para>a data provider that must return a double value for the target node of each edge being compared.</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares edges.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.CreateIntDataComparer(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares objects of arbitrary type.</para>
      </summary>
      <remarks>
        <para>Two objects are compared by comparing the int value the given data provider returns for each of these objects.</para>
      </remarks>
      <param name="dp">
        <para>a data provider that must return an int value for each object that is being compared by this comparator.</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares arbitrary objects.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.CreateDoubleDataComparer(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares objects of arbitrary type.</para>
      </summary>
      <remarks>
        <para>Two objects are compared by comparing the double value the given data provider returns for each of these objects.</para>
      </remarks>
      <param name="dp">
        <para>a data provider that must return a double value for each object that is being compared by this comparator.</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares arbitrary objects.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.CreateComparableComparer">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares to Objects of type Comparable.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.CreateComparableDataComparer(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares objects of arbitrary type.</para>
      </summary>
      <remarks>
        <para>Two objects are compared by comparing the <see cref="T:System.IComparable" /> instances the given data provider returns for each of these objects.</para>
      </remarks>
      <param name="dp">
        <para>a data provider that must return a <see cref="T:System.IComparable" /> for each object that is being compared by this comparator.</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares arbitrary objects.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Comparers.Compare(System.Double,System.Double)">
      <summary>
        <para>Compares the specified floating point numbers.</para>
      </summary>
      <remarks>
        <para>Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.</para>
        <para>
          <b>Warning:</b> This method does <b>not</b> handle <c>NaN</c>! If you need <c>NaN</c>-safe comparison, use <see cref="M:System.Double.CompareTo(System.Double)" /> instead.</para>
      </remarks>
      <param name="d1">
        <para>the first number to compare.</para>
      </param>
      <param name="d2">
        <para>the second number to compare.</para>
      </param>
      <returns>
        <para>a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.</para>
      </returns>
      <seealso cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)" />
    </member>
    <member name="T:yWorks.Algorithms.Util.Cursors">
      <summary>
        <para>Provides utility methods for working with <see cref="T:yWorks.Algorithms.ICursor">cursors</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.Cursors.ToArray(yWorks.Algorithms.ICursor,System.Object[])">
      <summary>
        <para>Creates or fills an array with the values provided by the cursor</para>
      </summary>
      <param name="cursor">
        <para>the cursor</para>
      </param>
      <param name="dest">
        <para>the array to fill with the values or <c>null</c> if the method should create the array itself</para>
      </param>
      <returns>
        <para>dest or a newly created array filled with the values from cursor</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Cursors.CreateCursor``1(System.Collections.Generic.ICollection{``0})">
      <summary>
        <para>Creates a cursor view of the given collection.</para>
      </summary>
      <remarks>
        <para>Creates an ICursor view of the given collection.</para>
        <para>Note that the returned cursor does not support the <see cref="M:yWorks.Algorithms.ICursor.Prev">prev</see> and <see cref="M:yWorks.Algorithms.ICursor.ToLast">toLast</see> operations.</para>
      </remarks>
      <param name="c">
        <para>The collection.</para>
      </param>
      <returns>
        <para>The cursor view of the given collection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Cursors.CreateEdgeCursor``1(System.Collections.Generic.ICollection{``0})">
      <summary>
        <para>Creates a cursor view of the given collection.</para>
      </summary>
      <remarks>
        <para>Note that the returned cursor does not support the operations <see cref="M:yWorks.Algorithms.ICursor.Prev">prev</see>, <see cref="M:yWorks.Algorithms.ICursor.ToLast">toLast</see>, and <see cref="M:yWorks.Algorithms.IEdgeCursor.CyclicPrev" />.</para>
      </remarks>
      <param name="c">
        <para>The collection.</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.IEdgeCursor" /> view of the given collection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Cursors.CreateNodeCursor``1(System.Collections.Generic.ICollection{``0})">
      <summary>
        <para>Creates a cursor view of the given collection.</para>
      </summary>
      <remarks>
        <para>Note that the returned cursor does not support the operations <see cref="M:yWorks.Algorithms.ICursor.Prev">prev</see>, <see cref="M:yWorks.Algorithms.ICursor.ToLast">toLast</see>, and <see cref="M:yWorks.Algorithms.INodeCursor.CyclicPrev" />.</para>
      </remarks>
      <param name="c">
        <para>The collection.</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Algorithms.INodeCursor" /> view of the given collection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Cursors.Concatenate(yWorks.Algorithms.ICursor,yWorks.Algorithms.ICursor)">
      <summary>
        <para>Creates a new cursor that provides a logical view on the concatenation of the two given cursors.</para>
      </summary>
      <param name="c1">
        <para>- first concatenation argument</para>
      </param>
      <param name="c2">
        <para>- second concatenation argument</para>
      </param>
    </member>
    <member name="T:yWorks.Algorithms.Util.DataProviderAdapter">
      <summary>
        <para>An abstract adapter class for providing data.</para>
      </summary>
      <remarks>
        <para>The data provision methods in this class throw a <see cref="T:System.NotSupportedException" /> and <see cref="M:yWorks.Algorithms.Util.DataProviderAdapter.Defined(System.Object)" /> always returns <c>false</c>.</para>
        <para>This class exists as a convenience for creating data provider objects.</para>
        <para>Extend this class to provide either typed or untyped data for a certain lookup domain.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviderAdapter.Get(System.Object)">
      <summary>
        <para>Subclasses may override this method to provide access to object values.</para>
      </summary>
      <exception cref="T:System.NotSupportedException">
        <para>unless overwritten.</para>
      </exception>
      <param name="dataHolder" />
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviderAdapter.GetInt(System.Object)">
      <summary>
        <para>Subclasses may override this method to provide access to integer values.</para>
      </summary>
      <exception cref="T:System.NotSupportedException">
        <para>unless overwritten.</para>
      </exception>
      <param name="dataHolder" />
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviderAdapter.GetDouble(System.Object)">
      <summary>
        <para>Subclasses may override this method to provide access to double values.</para>
      </summary>
      <exception cref="T:System.NotSupportedException">
        <para>unless overwritten.</para>
      </exception>
      <param name="dataHolder" />
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviderAdapter.GetBool(System.Object)">
      <summary>
        <para>Subclasses may override this method to provide access to boolean values.</para>
      </summary>
      <exception cref="T:System.NotSupportedException">
        <para>unless overwritten.</para>
      </exception>
      <param name="dataHolder" />
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviderAdapter.Defined(System.Object)">
      <summary>
        <para>Returns <c>false</c> for all data holders.</para>
      </summary>
      <remarks>
        <para>Subclasses should override this method to make clear for which data holders there is a value accessible via this data provider.</para>
      </remarks>
      <returns>
        <para>
          <c>false</c>.</para>
      </returns>
      <param name="dataHolder" />
    </member>
    <member name="T:yWorks.Algorithms.Util.DataProviders">
      <summary>
        <para>This class provides convenience and transformation services for DataProviders.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Double[])">
      <summary>
        <para>Returns a DataProvider view of a double array defined for edges.</para>
      </summary>
      <remarks>
        <para>The double value <c>data[edge.index()]</c> will be returned by the data provider upon the method call <c>getDouble(edge)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Int32[])">
      <summary>
        <para>Returns a DataProvider view of an int array defined for edges.</para>
      </summary>
      <remarks>
        <para>The int value <c>data[edge.index()]</c> will be returned by the data provider upon the method call <c>getInt(edge)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Boolean[])">
      <summary>
        <para>Returns a DataProvider view of a boolean array defined for edges.</para>
      </summary>
      <remarks>
        <para>The boolean value <c>data[edge.index()]</c> will be returned by the data provider upon the method call <c>getBool(edge)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Object[])">
      <summary>
        <para>Returns a DataProvider view of an Object array defined for edges.</para>
      </summary>
      <remarks>
        <para>The Object value <c>data[edge.index()]</c> will be returned by the data provider upon the method call <c>get(edge)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateEdgeDataProvider(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
        <para>Returns a DataProvider view of a double, int, boolean and Object array defined for edges.</para>
      </summary>
      <remarks>
        <para>The double value <c>doubleData[edge.index()]</c> will be returned by the data provider upon the method call <c>getDouble(edge)</c>.</para>
        <para>The int value <c>intData[edge.index()]</c> will be returned by the data provider upon the method call <c>getInt(edge)</c>.</para>
        <para>The boolean value <c>boolData[edge.index()]</c> will be returned by the data provider upon the method call <c>getBool(edge)</c>.</para>
        <para>The Object value <c>objectData[edge.index()]</c> will be returned by the data provider upon the method call <c>get(edge)</c>.</para>
      </remarks>
      <param name="doubleData">
        <para>double data for each edge of a static graph</para>
      </param>
      <param name="intData">
        <para>int data for each edge of a static graph</para>
      </param>
      <param name="boolData">
        <para>boolean data for each edge of a static graph</para>
      </param>
      <param name="objectData">
        <para>Object data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given arrays</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Double[])">
      <summary>
        <para>Returns a DataProvider view of a double array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The double value <c>data[node.index()]</c> will be returned by the data provider upon the method call <c>getDouble(node)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each node of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Int32[])">
      <summary>
        <para>Returns a DataProvider view of an int array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The int value <c>data[node.index()]</c> will be returned by the data provider upon the method call <c>getInt(node)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each node of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Boolean[])">
      <summary>
        <para>Returns a DataProvider view of a boolean array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The boolean value <c>data[node.index()]</c> will be returned by the data provider upon the method call <c>getBool(node)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each node of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Object[])">
      <summary>
        <para>Returns a DataProvider view of an Object array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The Object value <c>data[node.index()]</c> will be returned by the data provider upon the method call <c>get(node)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each node of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateNodeDataProvider(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
        <para>Returns a DataProvider view of a double, int, boolean and Object array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The double value <c>doubleData[node.index()]</c> will be returned by the data provider upon the method call <c>getDouble(node)</c>.</para>
        <para>The int value <c>intData[node.index()]</c> will be returned by the data provider upon the method call <c>getInt(node)</c>.</para>
        <para>The boolean value <c>boolData[node.index()]</c> will be returned by the data provider upon the method call <c>getBool(node)</c>.</para>
        <para>The Object value <c>objectData[node.index()]</c> will be returned by the data provider upon the method call <c>get(node)</c>.</para>
      </remarks>
      <param name="doubleData">
        <para>double data for each node of a static graph</para>
      </param>
      <param name="intData">
        <para>int data for each node of a static graph</para>
      </param>
      <param name="boolData">
        <para>boolean data for each node of a static graph</para>
      </param>
      <param name="objectData">
        <para>Object data for each node of a static graph</para>
      </param>
      <returns>
        <para>a data provider view of the given arrays</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateConstantDataProvider(System.Object)">
      <summary>
        <para>Returns a DataProvider that returns the given value for each key.</para>
      </summary>
      <param name="data">
        <para>constant Object data returned by the created data provider.</para>
      </param>
      <returns>
        <para>a data provider view of a single value.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateSourceDataProvider(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a DataProvider for edges that return the data provider values bound to their source nodes.</para>
      </summary>
      <param name="nodeData" />
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateTargetDataProvider(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a DataProvider for edges that return the data provider values bound to their target nodes.</para>
      </summary>
      <param name="nodeData" />
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.CreateNegatedDataProvider(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Returns a DataProvider that returns the negated boolean values provided by another data provider.</para>
      </summary>
      <param name="data" />
    </member>
    <member name="T:yWorks.Algorithms.Util.DataProviders.DataProviderOverlayManager">
      <summary>
        <para>This helper class can be used to overlay DataProviders registered at a graph with another DataProvider.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.DataProviderOverlayManager.#ctor(yWorks.Algorithms.Graph)">
      <summary>
        <para>Creates a data provider overlay for the given graph instance.</para>
      </summary>
      <param name="graph" />
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.DataProviderOverlayManager.AddDataProvider(System.Object,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Adds the given DataProvider under the given key to the graph.</para>
      </summary>
      <remarks>
        <para>Stores the previously set DataProvider instance so it can be restored at a later time using method {<see cref="M:yWorks.Algorithms.Util.DataProviders.DataProviderOverlayManager.RestoreOriginalDataProviders" />.</para>
      </remarks>
      <param name="dataProviderKey" />
      <param name="newDataProvider" />
    </member>
    <member name="M:yWorks.Algorithms.Util.DataProviders.DataProviderOverlayManager.RestoreOriginalDataProviders">
      <summary>
        <para>Restores all DataProvider bindings that have been changed using {<see cref="M:yWorks.Algorithms.Util.DataProviders.DataProviderOverlayManager.AddDataProvider(System.Object,yWorks.Algorithms.IDataProvider)" />.</para>
      </summary>
      <remarks>
        <para>Calling this method resets the state its state.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Algorithms.Util.GraphPartitionManager">
      <summary>
        <para>Provides functionality to hide and unhide partitions of nodes and their adjacent edges of a graph temporarily for algorithmic operations.</para>
      </summary>
      <remarks>
        <para>This class can be used to temporarily hide away certain elements of a graph and to unhide that parts at a later time again. Instances of this class keep track of graph elements that were hidden from a graph in order to make them visible again at a later time.</para>
        <para>Note that this class should not be used to hide elements from a Graph2D for pure hiding purposes. Since this class will by default prevent the graph instance from firing events, other code might cease to work correctly. Use this class for short term removal of nodes and edges, only.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.#ctor(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Instantiates a new GraphPartitionManager for the given graph.</para>
      </summary>
      <remarks>
        <para>All non-static hiding and unhiding methods will refer to the given graph.</para>
      </remarks>
      <param name="graph" />
      <param name="partitionId" />
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.InitPartitions(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Initializes internal data structures using the new DataProvider.</para>
      </summary>
      <remarks>
        <para>This method must also be called whenever the content of the given DataProvider changes.</para>
      </remarks>
      <param name="partitionId">
        <para>the data provider that holds the partitionIds for all elements.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.HidePartition(System.Object)">
      <summary>
        <para>Hides nodes and adjacent edges that have the given partitionId associated.</para>
      </summary>
      <param name="partitionId">
        <para>the id</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.UnhidePartition(System.Object)">
      <summary>
        <para>Unhides nodes that have the given partitionId associated.</para>
      </summary>
      <param name="partitionId">
        <para>the id</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.DisplayPartition(System.Object)">
      <summary>
        <para>Assures that only nodes are visible in the graph that are associated with the given partitionId.</para>
      </summary>
      <param name="partitionId">
        <para>the partitionId for the nodes that will be made visible</para>
      </param>
    </member>
    <member name="P:yWorks.Algorithms.Util.GraphPartitionManager.FireGraphEventsEnabled">
      <summary>
        <para>Gets or sets whether or not this partition manager should fire graph events.</para>
      </summary>
      <remarks>
        <para>By default the partition manager does not fire graph events.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.HideAll">
      <summary>
        <para>Hides all nodes and edges from this graph.</para>
      </summary>
      <remarks>
        <para>The hidden elements will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.HideEdges">
      <summary>
        <para>Hides all edges from this graph.</para>
      </summary>
      <remarks>
        <para>The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.HideSelfLoops">
      <summary>
        <para>Hides all self-loop edges from this graph.</para>
      </summary>
      <remarks>
        <para>The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.SimplifyGraph">
      <summary>
        <para>Hides all self-loops and multiple edges from the graph.</para>
      </summary>
      <remarks>
        <para>The overall effect of this method is that the minimum number of edges are hidden from the graph such that it contains no self-loops and no multiple edges anymore. The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.HideMultipleEdges">
      <summary>
        <para>Hides multiple edges from the graph.</para>
      </summary>
      <remarks>
        <para>If there are multiple edges connecting two nodes then all but one (representative) of these edges will be hidden. The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.UnhideAll">
      <summary>
        <para>Unhides all formerly hidden elements in the graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.UnhideNodes">
      <summary>
        <para>Unhides all formerly hidden nodes in the graph.</para>
      </summary>
      <remarks>
        <para>Note that this method does not unhide hidden edges.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.UnhideEdges">
      <summary>
        <para>Unhides all formerly hidden edges in the graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Hide(yWorks.Algorithms.Node)">
      <summary>
        <para>Hides the given node and all it's adjacent edges from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden elements will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Hide(yWorks.Algorithms.Edge)">
      <summary>
        <para>Hides the given edge from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden edge will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Hide(yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Hides the given list of edges from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="el" />
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Hide(yWorks.Algorithms.NodeList)">
      <summary>
        <para>Hides the given list of nodes from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="nl" />
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Hide(yWorks.Algorithms.IEdgeCursor)">
      <summary>
        <para>Hides the given edges from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="ec" />
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Hide(yWorks.Algorithms.INodeCursor)">
      <summary>
        <para>Hides the given nodes from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="nc" />
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Hide(yWorks.Algorithms.ICursor)">
      <summary>
        <para>Hides the given elements from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="cursor" />
    </member>
    <member name="P:yWorks.Algorithms.Util.GraphPartitionManager.Graph">
      <summary>
        <para>Gets the <c>Graph</c> for which this partition manager was created.</para>
      </summary>
      <value>
        <para>the <c>Graph</c> for which this partition manager was created.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Unhide(yWorks.Algorithms.Edge)">
      <summary>
        <para>This method will be called whenever the partition manager is requested to unhide the given edge from the graph.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Util.GraphPartitionManager.Unhide(yWorks.Algorithms.Node)">
      <summary>
        <para>This method will be called whenever the partition manager is requested to unhide the given node from the graph.</para>
      </summary>
      <param name="v" />
    </member>
    <member name="T:yWorks.Algorithms.Util.LayoutGraphHider">
      <summary>
        <para>Provides functionality to hide and unhide nodes and edges of a graph temporarily for algorithmic operations.</para>
      </summary>
      <remarks>
        <para>This class can be used to temporarily hide away certain elements of a graph and to unhide that parts at a later time again. Instances of this class keep track of graph elements that were hidden from a graph in order to make them visible again at a later time.</para>
        <para>Note that this class should not be used to hide elements from a Graph2D for pure hiding purposes. Since this class will by default prevent the graph instance from firing events, other code might cease to work correctly. Use this class for short term removal of nodes and edges, only.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Algorithms.Util.LayoutGraphHider.hiddenEdges">
      <summary>
        <para>holds the list of the hidden edges in stack order</para>
      </summary>
    </member>
    <member name="F:yWorks.Algorithms.Util.LayoutGraphHider.hiddenNodes">
      <summary>
        <para>holds the list of the hidden nodes in stack order</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.#ctor(yWorks.Algorithms.Graph)">
      <summary>
        <para>Instantiates a new GraphHider for the given graph.</para>
      </summary>
      <remarks>
        <para>All non-static hiding and unhiding methods will refer to the given graph.</para>
      </remarks>
      <param name="g" />
    </member>
    <member name="P:yWorks.Algorithms.Util.LayoutGraphHider.FireGraphEvents">
      <summary>
        <para>Gets or sets whether or not this hider should fire graph events.</para>
      </summary>
      <remarks>
        <para>By default the hider does not fire graph events.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.HideAll">
      <summary>
        <para>Hides all nodes and edges from this graph.</para>
      </summary>
      <remarks>
        <para>The hidden elements will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.HideEdges">
      <summary>
        <para>Hides all edges from this graph.</para>
      </summary>
      <remarks>
        <para>The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.HideSelfLoops">
      <summary>
        <para>Hides all self-loop edges from this graph.</para>
      </summary>
      <remarks>
        <para>The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.SimplifyGraph">
      <summary>
        <para>Hides all self-loops and multiple edges from the graph.</para>
      </summary>
      <remarks>
        <para>The overall effect of this method is that the minimum number of edges are hidden from the graph such that it contains no self-loops and no multiple edges anymore. The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.HideMultipleEdges">
      <summary>
        <para>Hides multiple edges from the graph.</para>
      </summary>
      <remarks>
        <para>If there are multiple edges connecting two nodes then all but one (representative) of these edges will be hidden. The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.UnhideAll">
      <summary>
        <para>Unhides all formerly hidden elements in the graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.UnhideNodes">
      <summary>
        <para>Unhides all formerly hidden nodes in the graph.</para>
      </summary>
      <remarks>
        <para>Note that this method does not unhide hidden edges.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.UnhideEdges">
      <summary>
        <para>Unhides all formerly hidden edges in the graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Hide(yWorks.Algorithms.Node)">
      <summary>
        <para>Hides the given node and all it's adjacent edges from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden elements will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Hide(yWorks.Algorithms.Edge)">
      <summary>
        <para>Hides the given edge from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden edge will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Hide(yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Hides the given list of edges from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="el" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Hide(yWorks.Algorithms.NodeList)">
      <summary>
        <para>Hides the given list of nodes from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="nl" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Hide(yWorks.Algorithms.IEdgeCursor)">
      <summary>
        <para>Hides the given edges from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="ec" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Hide(yWorks.Algorithms.INodeCursor)">
      <summary>
        <para>Hides the given nodes from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="nc" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Hide(yWorks.Algorithms.ICursor)">
      <summary>
        <para>Hides the given elements from the graph.</para>
      </summary>
      <remarks>
        <para>The hidden nodes and adjacent edges will be stored so that they can be unhidden again at a later time.</para>
      </remarks>
      <param name="cursor" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.UnhideSubgraph(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeCursor)">
      <summary>
        <para>Unhides the subgraph induced by the given edges in the given graph.</para>
      </summary>
      <remarks>
        <para>The induced subgraph defined by the given edges consists of the given edges and all nodes that are either source or target of at least one of the given edges.</para>
        <para>Parts of the subgraph that are already contained in the given graph will not be unhidden and pose no problem to this method.</para>
      </remarks>
      <param name="graph" />
      <param name="ec" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.HideSubgraph(yWorks.Algorithms.Graph,yWorks.Algorithms.IEdgeCursor)">
      <summary>
        <para>Hides the subgraph induced by the given edges from the given graph.</para>
      </summary>
      <remarks>
        <para>The induced subgraph defined by the given edges consists of the given edges and all nodes that are solely connected to the rest of the graph by the given edges.</para>
      </remarks>
      <param name="graph" />
      <param name="ec" />
    </member>
    <member name="P:yWorks.Algorithms.Util.LayoutGraphHider.Graph">
      <summary>
        <para>Gets the <c>Graph</c> for which this <c>GraphHider</c> was created.</para>
      </summary>
      <value>
        <para>the <c>Graph</c> for which this <c>GraphHider</c> was created.</para>
      </value>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Unhide(yWorks.Algorithms.Edge)">
      <summary>
        <para>This method will be called whenever the hider is requested to unhide the given edge from the graph.</para>
      </summary>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.UnhideEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Unhides the given edge.</para>
      </summary>
      <remarks>
        <para>Also updates <see cref="F:yWorks.Algorithms.Util.LayoutGraphHider.hiddenEdges" />.</para>
        <para>Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed) causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.</para>
      </remarks>
      <param name="e">
        <para>the edge that will be unhidden</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.UnhideEdges(yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Unhides the given edges.</para>
      </summary>
      <remarks>
        <para>Also updates <see cref="F:yWorks.Algorithms.Util.LayoutGraphHider.hiddenEdges" />.</para>
        <para>Note that unhiding an edge whose source/target is not in the graph (e.g., because it's currently hidden/removed) causes an exception. Hence, in such cases, you first have to unhide/reinsert the corresponding endpoints.</para>
      </remarks>
      <param name="edges">
        <para>the edges that will be unhidden</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.UnhideNodes(yWorks.Algorithms.NodeList,System.Boolean)">
      <summary>
        <para>Unhides the given nodes and if requested its adjacent edges.</para>
      </summary>
      <remarks>
        <para>Also updates <see cref="F:yWorks.Algorithms.Util.LayoutGraphHider.hiddenNodes" /> and <see cref="F:yWorks.Algorithms.Util.LayoutGraphHider.hiddenEdges" />.</para>
      </remarks>
      <param name="nodes">
        <para>the nodes that will be unhidden</para>
      </param>
      <param name="unhideAdjacentEdges">
        <para>whether of not to unhide previously hidden edges connected at the given nodes whose other end point is not hidden, i.e. it is part of the graph.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.UnhideNode(yWorks.Algorithms.Node,System.Boolean)">
      <summary>
        <para>Unhides the given node and if requested its adjacent edges.</para>
      </summary>
      <remarks>
        <para>Also updates <see cref="F:yWorks.Algorithms.Util.LayoutGraphHider.hiddenNodes" /> and <see cref="F:yWorks.Algorithms.Util.LayoutGraphHider.hiddenEdges" />.</para>
      </remarks>
      <param name="v">
        <para>the node that will be unhidden</para>
      </param>
      <param name="unhideAdjacentEdges">
        <para>whether of not to unhide previously hidden edges connected at <c>v</c> whose other end point is not hidden, i.e. it is part of the graph.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.Unhide(yWorks.Algorithms.Node)">
      <summary>
        <para>This method will be called whenever the hider is requested to unhide the given node from the graph.</para>
      </summary>
      <param name="v" />
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.GetHiddenNodeCursor">
      <summary>
        <para>The nodes that are currently hidden</para>
      </summary>
      <returns>
        <para>a cursor of the currently hidden nodes</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.LayoutGraphHider.GetHiddenEdgeCursor">
      <summary>
        <para>The edges that are currently hidden</para>
      </summary>
      <returns>
        <para>a cursor of the currently hidden edges</para>
      </returns>
    </member>
    <member name="T:yWorks.Algorithms.Util.Maps">
      <summary>
        <para>This class provides convenience and transformation services for Node- and EdgeMaps.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateHashMap``2(System.Collections.Generic.ICollection{System.Collections.Generic.KeyValuePair{``0,``1}})">
      <summary>
        <para>Factory method that creates a <see cref="T:System.Collections.Generic.IDictionary`2" /> that is a special hash map implementation mainly used by the layout algorithms.</para>
      </summary>
      <param name="entries">
        <para>The items to optionally populate the set with initially.</para>
      </param>
      <returns>
        <para>A new instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateHashSet``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
        <para>Factory method that creates an <see cref="T:System.Collections.Generic.ICollection`1" /> implementation with set semantics that is a special hash map based implementation mainly used by the layout algorithms.</para>
      </summary>
      <param name="items">
        <para>The items to optionally populate the set with initially.</para>
      </param>
      <returns>
        <para>A new instance.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexNodeMap(System.Double[])">
      <summary>
        <para>Returns a NodeMap view of a double array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The double value <c>data[node.index()]</c> will be accessed by the NodeMap upon the method calls <c>getDouble(node)</c> and <c>setDouble(node,value)</c>.</para>
        <para>
          <b>Warning!</b> The indices of the accessed nodes must not change during the use of this NodeMap.</para>
      </remarks>
      <param name="data">
        <para>array data for each node of a static graph</para>
      </param>
      <returns>
        <para>a NodeMap view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexNodeMap(System.Int32[])">
      <summary>
        <para>Returns a NodeMap view of an int array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The int value <c>data[node.index()]</c> will be accessed by the NodeMap upon the method calls <c>getInt(node)</c> and <c>setInt(node,value)</c>. <b>Warning!</b> The indices of the accessed nodes must not change during the use of this NodeMap.</para>
      </remarks>
      <param name="data">
        <para>array data for each node of a static graph</para>
      </param>
      <returns>
        <para>a NodeMap view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexNodeMap(System.Boolean[])">
      <summary>
        <para>Returns a NodeMap view of a boolean array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The boolean value <c>data[node.index()]</c> will be accessed by the NodeMap upon the method calls <c>getBool(node)</c> and <c>setBool(node,value)</c>.</para>
      </remarks>
      <param name="data">
        <para>array data for each node of a static graph</para>
      </param>
      <returns>
        <para>a NodeMap view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexNodeMap(System.Object[])">
      <summary>
        <para>Returns a NodeMap view of an Object array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The Object value <c>data[node.index()]</c> will be accessed by the NodeMap upon the method calls <c>get(node)</c> and <c>set(node,value)</c>. <b>Warning!</b> The indices of the accessed nodes must not change during the use of this NodeMap.</para>
      </remarks>
      <param name="data">
        <para>array data for each node of a static graph</para>
      </param>
      <returns>
        <para>a NodeMap view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexNodeMap(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
        <para>Returns a NodeMap view of a double, int, boolean and Object array defined for nodes.</para>
      </summary>
      <remarks>
        <para>The double value <c>doubleData[node.index()]</c> will be accessed by the NodeMap upon the method calls <c>getDouble(node)</c> and <c>setDouble(node,value)</c>.</para>
        <para>The int value <c>intData[node.index()]</c> will be accessed by the NodeMap upon the method calls <c>getInt(node)</c> and <c>setInt(node,value)</c>.</para>
        <para>The boolean value <c>boolData[node.index()]</c> will be accessed by the NodeMap upon the method calls <c>getBool(node)</c> and <c>setBool(node,value)</c>.</para>
        <para>The Object value <c>objectData[node.index()]</c> will be accessed by the NodeMap upon the method calls <c>get(node)</c> and <c>set(node,value)</c>.</para>
        <para>
          <b>Warning!</b> The indices of the accessed nodes must not change during the use of this NodeMap.</para>
      </remarks>
      <param name="doubleData">
        <para>double data for each node of a static graph</para>
      </param>
      <param name="intData">
        <para>int data for each node of a static graph</para>
      </param>
      <param name="boolData">
        <para>boolean data for each node of a static graph</para>
      </param>
      <param name="objectData">
        <para>Object data for each node of a static graph</para>
      </param>
      <returns>
        <para>a NodeMap view of the given arrays</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Double[])">
      <summary>
        <para>Returns a EdgeMap view of a double array defined for edges.</para>
      </summary>
      <remarks>
        <para>The double value <c>data[edge.index()]</c> will be accessed by the EdgeMap upon the method calls <c>getDouble(edge)</c> and <c>setDouble(edge,value)</c>.</para>
        <para>
          <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.</para>
      </remarks>
      <param name="data">
        <para>array data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a EdgeMap view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Int32[])">
      <summary>
        <para>Returns a EdgeMap view of an int array defined for edges.</para>
      </summary>
      <remarks>
        <para>The int value <c>data[edge.index()]</c> will be accessed by the EdgeMap upon the method calls <c>getInt(edge)</c> and <c>setInt(edge,value)</c>.</para>
        <para>
          <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.</para>
      </remarks>
      <param name="data">
        <para>array data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a EdgeMap view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Boolean[])">
      <summary>
        <para>Returns a EdgeMap view of a boolean array defined for edges.</para>
      </summary>
      <remarks>
        <para>The boolean value <c>data[edge.index()]</c> will be accessed by the EdgeMap upon the method calls <c>getBool(edge)</c> and <c>setBool(edge,value)</c>.</para>
        <para>
          <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.</para>
      </remarks>
      <param name="data">
        <para>array data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a EdgeMap view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Object[])">
      <summary>
        <para>Returns a EdgeMap view of an Object array defined for edges.</para>
      </summary>
      <remarks>
        <para>The Object value <c>data[edge.index()]</c> will be accessed by the EdgeMap upon the method calls <c>get(edge)</c> and <c>set(edge,value)</c>.</para>
        <para>
          <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.</para>
      </remarks>
      <param name="data">
        <para>array data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a EdgeMap view of the given array</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateIndexEdgeMap(System.Double[],System.Int32[],System.Boolean[],System.Object[])">
      <summary>
        <para>Returns a EdgeMap view of a double, int, boolean and Object array defined for edges.</para>
      </summary>
      <remarks>
        <para>The double value <c>doubleData[edge.index()]</c> will be accessed by the EdgeMap upon the method calls <c>getDouble(edge)</c> and <c>setDouble(edge,value)</c>.</para>
        <para>The int value <c>intData[edge.index()]</c> will be accessed by the EdgeMap upon the method calls <c>getInt(edge)</c> and <c>setInt(edge,value)</c>.</para>
        <para>The boolean value <c>boolData[edge.index()]</c> will be accessed by the EdgeMap upon the method calls <c>getBool(edge)</c> and <c>setBool(edge,value)</c>.</para>
        <para>The Object value <c>objectData[edge.index()]</c> will be accessed by the EdgeMap upon the method calls <c>get(edge)</c> and <c>set(edge,value)</c>.</para>
        <para>
          <b>Warning!</b> The indices of the accessed edges must not change during the use of this EdgeMap.</para>
      </remarks>
      <param name="doubleData">
        <para>double data for each edge of a static graph</para>
      </param>
      <param name="intData">
        <para>int data for each edge of a static graph</para>
      </param>
      <param name="boolData">
        <para>boolean data for each edge of a static graph</para>
      </param>
      <param name="objectData">
        <para>Object data for each edge of a static graph</para>
      </param>
      <returns>
        <para>a EdgeMap view of the given arrays</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateHashedNodeMap">
      <summary>
        <para>Creates a NodeMap that is based on hashing.</para>
      </summary>
      <remarks>
        <para>The preconditions specified in java.util.HashMap apply for the keys and values of this map.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateNodeMap(System.Collections.Generic.IDictionary{System.Object,System.Object})">
      <summary>
        <para>Create a NodeMap view of the given map.</para>
      </summary>
      <remarks>
        <para>Accessing basic value types is solved by storing the corresponding wrapper types Double, Integer and Boolean within the given Map.</para>
      </remarks>
      <param name="map" />
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateHashedEdgeMap">
      <summary>
        <para>Creates an EdgeMap that is based on hashing.</para>
      </summary>
      <remarks>
        <para>The preconditions specified in java.util.HashMap apply for the keys and values of this map.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateEdgeMap(System.Collections.Generic.IDictionary{System.Object,System.Object})">
      <summary>
        <para>Create an EdgeMap view of the given map.</para>
      </summary>
      <remarks>
        <para>Accessing basic value types is solved by storing the corresponding wrapper types Double, Integer and Boolean within the given Map.</para>
      </remarks>
      <param name="map" />
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateHashedDataMap">
      <summary>
        <para>Creates a DataMap that is based on hashing.</para>
      </summary>
      <remarks>
        <para>The preconditions specified in java.util.HashMap apply for the keys and values of this map.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.Util.Maps.CreateDataMap(System.Collections.Generic.IDictionary{System.Object,System.Object})">
      <summary>
        <para>Create a DataMap view of the given map.</para>
      </summary>
      <remarks>
        <para>Accessing basic value types is solved by storing the corresponding wrapper types Double, Integer and Boolean within the given Map.</para>
      </remarks>
      <param name="map" />
    </member>
    <member name="T:yWorks.Algorithms.YList">
      <summary>
        <para>An implementation of a doubly linked list that provides direct access to the cells that store the elements.</para>
      </summary>
      <remarks>
        <para>The cells are represented by class <see cref="T:yWorks.Algorithms.ListCell" />.</para>
        <para>This class supports fast access and removal operations, specifically, it is possible to remove an element in constant time (i.e. O(1)) given a reference to its list cell.</para>
        <para>Class YList supports iteration over the elements either by using the list cells directly (methods <see cref="P:yWorks.Algorithms.YList.FirstCell" />/<see cref="P:yWorks.Algorithms.YList.LastCell" /> together with <see cref="M:yWorks.Algorithms.YList.SuccCell(yWorks.Algorithms.ListCell)" />/<see cref="M:yWorks.Algorithms.YList.PredCell(yWorks.Algorithms.ListCell)" />, respectively) or by means of a cursor (<see cref="M:yWorks.Algorithms.YList.Cursor" />).</para>
        <para>Furthermore, YList offers its own <see cref="M:yWorks.Algorithms.YList.Sort" /> method. Note that this class also provides all relevant methods to use the list like a stack data type.</para>
        <para>This implementation permits <c>null</c> as values. It implements the <see cref="T:System.Collections.Generic.IList`1" /> interface but does not support the <see cref="M:yWorks.Algorithms.YList.SubList(System.Int32,System.Int32)" /> method. The implementation of this method will throw an <see cref="T:System.NotSupportedException" /> if invoked. The <see cref="M:yWorks.Algorithms.YList.Cursor" /> returned by instances of this class is not fail fast.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.YList.#ctor">
      <summary>
        <para>Creates an empty doubly linked list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
      <summary>
        <para>Creates a list that is initialized with the elements provided by the given Collection object.</para>
      </summary>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.#ctor(System.Collections.IEnumerator)">
      <summary>
        <para>Creates a list that is initialized with the elements provided by the given enumerator object.</para>
      </summary>
      <remarks>
        <para>Creates a list that is initialized with the elements provided by the given enumerator object.</para>
      </remarks>
      <param name="e" />
    </member>
    <member name="M:yWorks.Algorithms.YList.#ctor(yWorks.Algorithms.ICursor)">
      <summary>
        <para>Creates a list that is initialized with the elements provided by the given YCursor object.</para>
      </summary>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.#ctor(yWorks.Algorithms.ICursor,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Creates a list that is initialized with those elements from the given YCursor object for which the given data provider returns <c>true</c> upon calling its <see cref="M:yWorks.Algorithms.IDataProvider.GetBool(System.Object)">getBool</see> method.</para>
      </summary>
      <param name="c">
        <para>A cursor providing objects that should be added to this list.</para>
      </param>
      <param name="predicate">
        <para>A data provider that acts as a inclusion predicate for each object accessible by the given cursor.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.YList.#ctor(System.Object[])">
      <summary>
        <para>Creates a list that is initialized with the elements provided by the given array of objects.</para>
      </summary>
      <param name="a" />
    </member>
    <member name="M:yWorks.Algorithms.YList.AddFirst(System.Object)">
      <summary>
        <para>Inserts the given object at the head of this list.</para>
      </summary>
      <returns>
        <para>The newly created ListCell object that stores the given object.</para>
      </returns>
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.YList.AddLast(System.Object)">
      <summary>
        <para>Inserts the given object at the tail of this list.</para>
      </summary>
      <returns>
        <para>The newly created ListCell object that stores the given object.</para>
      </returns>
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.YList.AddLastCell(yWorks.Algorithms.ListCell)">
      <summary>
        <para>Adds a formerly removed ListCell object at the tail of this list.</para>
      </summary>
      <remarks>
        <para>
          <b>Attention:</b> If the ListCell object is still part of any list, then that list will be corrupted afterwards.</para>
      </remarks>
      <param name="cell">
        <para>A list cell which is not part of any list.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.YList.AddFirstCell(yWorks.Algorithms.ListCell)">
      <summary>
        <para>Adds a formerly removed ListCell object at the head of this list.</para>
      </summary>
      <remarks>
        <para>
          <b>Attention:</b> If the ListCell object is still part of any list, then that list will be corrupted afterwards.</para>
      </remarks>
      <param name="cell">
        <para>A list cell which is not part of any list.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.YList.Add(System.Object)">
      <summary>
        <para>Same as <see cref="M:yWorks.Algorithms.YList.AddLast(System.Object)" />.</para>
      </summary>
      <returns>
        <para>
          <c>true</c>
        </para>
      </returns>
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.YList.AddAll(System.Collections.Generic.ICollection{System.Object})">
      <summary>
        <para>Appends all elements provided by the given collection to this list.</para>
      </summary>
      <returns>
        <para>Whether there have been elements appended.</para>
      </returns>
      <param name="collection" />
    </member>
    <member name="M:yWorks.Algorithms.YList.AddAll(yWorks.Algorithms.ICursor)">
      <summary>
        <para>Appends all elements provided by the given cursor to this list.</para>
      </summary>
      <remarks>
        <para>The cursor will be moved from its given position to the end.</para>
        <para>Be aware that a statement like <c>aList.append(aList.cursor())</c> results in an infinite recursion.</para>
      </remarks>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.InsertBefore(System.Object,yWorks.Algorithms.ListCell)">
      <summary>
        <para>Inserts the given object into this list with respect to a given reference list cell.</para>
      </summary>
      <remarks>
        <para>The (newly created) list cell that stores the object is inserted right before the reference list cell <c>refCell</c>.</para>
        <para>If <c>refCell == null</c>, the given object is appended to the list.</para>
      </remarks>
      <param name="o">
        <para>The object to be inserted.</para>
      </param>
      <param name="refCell">
        <para>The list cell used to reference the position.</para>
      </param>
      <returns>
        <para>The newly created ListCell object that stores object <c>o</c>.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.YList.InsertCellBefore(yWorks.Algorithms.ListCell,yWorks.Algorithms.ListCell)">
      <summary>
        <para>Inserts a formerly removed ListCell object into this list with respect to a given reference list cell.</para>
      </summary>
      <remarks>
        <para>The ListCell object is inserted right before the reference list cell <c>refCell</c>.</para>
        <para>
          <b>Attention:</b> If the ListCell object is still part of any list, then that list will be corrupted afterwards.</para>
      </remarks>
      <param name="cellToInsert">
        <para>A list cell which is not part of any list.</para>
      </param>
      <param name="refCell">
        <para>The list cell used to reference the position.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.YList.InsertCellAfter(yWorks.Algorithms.ListCell,yWorks.Algorithms.ListCell)">
      <summary>
        <para>Inserts a formerly removed ListCell object into this list with respect to a given reference list cell.</para>
      </summary>
      <remarks>
        <para>The ListCell object is inserted right after the reference list cell <c>refCell</c>.</para>
        <para>
          <b>Attention:</b> If the ListCell object is still part of any list, then that list will be corrupted afterwards.</para>
      </remarks>
      <param name="cellToInsert">
        <para>A list cell which is not part of any list.</para>
      </param>
      <param name="refCell">
        <para>The list cell used to reference the position.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.YList.InsertAfter(System.Object,yWorks.Algorithms.ListCell)">
      <summary>
        <para>Inserts the given object into this list with respect to a given reference list cell.</para>
      </summary>
      <remarks>
        <para>The (newly created) list cell that stores the object is inserted right after the reference list cell <c>refCell</c>.</para>
        <para>If <c>refCell == null</c>, the given object is inserted at the head of the list.</para>
      </remarks>
      <param name="o">
        <para>The object to be inserted.</para>
      </param>
      <param name="refCell">
        <para>The list cell used to reference the position.</para>
      </param>
      <returns>
        <para>The newly created ListCell object that stores object <c>o</c>.</para>
      </returns>
    </member>
    <member name="P:yWorks.Algorithms.YList.Count">
      <summary>
        <para>Gets the number of elements in this list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.IsEmpty">
      <summary>
        <para>Checks whether this list contains elements.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.Clear">
      <summary>
        <para>Removes all elements from this list.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.YList.First">
      <summary>
        <para>Gets the first element of this list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.Pop">
      <summary>
        <para>Removes the first element from this list and returns it.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.Push(System.Object)">
      <summary>
        <para>Equivalent to <see cref="M:yWorks.Algorithms.YList.AddFirst(System.Object)" />.</para>
      </summary>
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.YList.Peek">
      <summary>
        <para>Equivalent to <see cref="P:yWorks.Algorithms.YList.First" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.YList.Last">
      <summary>
        <para>Gets the last element of this list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.PopLast">
      <summary>
        <para>Removes the last element from this list and returns it.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.ElementAt(System.Int32)">
      <summary>
        <para>Returns the i-th element of this list.</para>
      </summary>
      <param name="i" />
    </member>
    <member name="M:yWorks.Algorithms.YList.IndexOf(System.Object)">
      <summary>
        <para>Returns the zero-based index of the given element in this list.</para>
      </summary>
      <remarks>
        <para>If the given element is not in the list, -1 is returned.</para>
      </remarks>
      <param name="obj" />
    </member>
    <member name="P:yWorks.Algorithms.YList.FirstCell">
      <summary>
        <para>Gets the first cell of this list.</para>
      </summary>
    </member>
    <member name="P:yWorks.Algorithms.YList.LastCell">
      <summary>
        <para>Gets the last cell of this list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.SuccCell(yWorks.Algorithms.ListCell)">
      <summary>
        <para>Returns the successor cell of the given list cell.</para>
      </summary>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.PredCell(yWorks.Algorithms.ListCell)">
      <summary>
        <para>Returns the predecessor cell of the given list cell.</para>
      </summary>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.CyclicSucc(yWorks.Algorithms.ListCell)">
      <summary>
        <para>Returns the cyclic successor cell of the given list cell.</para>
      </summary>
      <remarks>
        <para>The first cell is returned as the cyclic successor of the last list cell.</para>
      </remarks>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.CyclicPred(yWorks.Algorithms.ListCell)">
      <summary>
        <para>Returns the cyclic predecessor cell of the given list cell.</para>
      </summary>
      <remarks>
        <para>The last cell is returned as the cyclic predecessor of the first list cell.</para>
      </remarks>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.GetInfo(yWorks.Algorithms.ListCell)">
      <summary>
        <para>Returns the element stored in the given list cell.</para>
      </summary>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.SetInfo(yWorks.Algorithms.ListCell,System.Object)">
      <summary>
        <para>Updates the element stored in the given list cell with the given object.</para>
      </summary>
      <param name="c" />
      <param name="value" />
    </member>
    <member name="M:yWorks.Algorithms.YList.Remove(System.Object)">
      <summary>
        <para>Removes the given object from this list.</para>
      </summary>
      <remarks>
        <para>Only the first element for which equality to <c>o</c> holds gets removed.</para>
      </remarks>
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.YList.RemoveAll(System.Collections.Generic.ICollection{System.Object})">
      <summary>
        <para>Removes the given collection of objects from this list.</para>
      </summary>
      <returns>
        <para>Whether there have been elements removed.</para>
      </returns>
      <param name="collection" />
    </member>
    <member name="M:yWorks.Algorithms.YList.RetainAll(System.Collections.Generic.ICollection{System.Object})">
      <summary>
        <para>Retains only those elements in this list which are contained in the given collection.</para>
      </summary>
      <returns>
        <para>Whether there have been elements removed.</para>
      </returns>
      <param name="collection" />
    </member>
    <member name="M:yWorks.Algorithms.YList.RemoveCell(yWorks.Algorithms.ListCell)">
      <summary>
        <para>Removes the given list cell, and hence the element stored in it, from this list.</para>
      </summary>
      <returns>
        <para>The element that is stored in the removed cell.</para>
      </returns>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.RemoveAt(yWorks.Algorithms.ICursor)">
      <summary>
        <para>Removes the element pointed to by the given YCursor object.</para>
      </summary>
      <returns>
        <para>The removed element.</para>
      </returns>
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.Cursor">
      <summary>
        <para>Returns a cursor for this list.</para>
      </summary>
      <remarks>
        <para>All cursor operations are supported. This cursor implementation is not fail-fast and continues to work if this list is modified during the traversal as long as the current ListCell the cursor points at is this in this list or has been removed from this list but has not been added to another instance since then.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.YList.Contains(System.Object)">
      <summary>
        <para>Whether or not this list contains the given element.</para>
      </summary>
      <remarks>
        <para>Equality of elements is defined by the <see cref="M:System.Object.Equals(System.Object)" /> method.</para>
      </remarks>
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.YList.ContainsAll(System.Collections.Generic.ICollection{System.Object})">
      <summary>
        <para>Whether or not this list contains all the elements in the given collection.</para>
      </summary>
      <remarks>
        <para>Equality of elements is defined by the <see cref="M:System.Object.Equals(System.Object)" /> method.</para>
      </remarks>
      <param name="collection" />
    </member>
    <member name="M:yWorks.Algorithms.YList.FindCell(System.Object)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Algorithms.ListCell" /> where object <c>o</c> is stored.</para>
      </summary>
      <remarks>
        <para>This operation returns <c>null</c>, if no such cell exists. Equality of elements is defined by the <see cref="M:System.Object.Equals(System.Object)" /> method. The first element in the list that matches that criteria is returned.</para>
      </remarks>
      <returns>
        <para>the ListCell that contains the element or <c>null</c> if no such ListCell was found</para>
      </returns>
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.YList.ToString">
      <summary>
        <para>Returns a string representation of this List.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.ToArray">
      <summary>
        <para>Returns an array representation of this list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.ToArray(System.Array)">
      <summary>
        <para>Returns an array containing all list elements in the correct order.</para>
      </summary>
      <remarks>
        <para>The runtime type of the returned array is that of the given array.</para>
        <para>If the list does not fit in the specified array, a new array is allocated with the runtime type of the specified array and the size of this list.</para>
        <para>If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to <c>null</c>. This is useful in determining the length of the list <i>only</i> if the caller knows that the list does not contain any <c>null</c> elements.</para>
      </remarks>
      <param name="a">
        <para>The array into which the elements of the list are to be stored, if it is big enough. Otherwise, a new array of the same runtime type is allocated for this purpose.</para>
      </param>
      <returns>
        <para>An array containing the elements of the list.</para>
      </returns>
      <exception cref="T:System.ArrayTypeMismatchException">
        <para>if the runtime type of the specified array <c>a</c> is not a supertype of the runtime type of every element in this list.</para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.YList.Reverse">
      <summary>
        <para>Reverses the sequence of elements in this list.</para>
      </summary>
    </member>
    <member name="M:yWorks.Algorithms.YList.Sort(System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Sorts the elements in this list according to the given comparator.</para>
      </summary>
      <remarks>
        <para>NOTE: The elements will be assigned to different list cells by this method.</para>
      </remarks>
      <param name="comp" />
    </member>
    <member name="M:yWorks.Algorithms.YList.Sort">
      <summary>
        <para>Sorts the elements in this list into ascending order, according to their natural ordering.</para>
      </summary>
      <remarks>
        <para>All elements must implement the <see cref="T:System.IComparable" /> interface. Furthermore, all elements in this list must be mutually comparable (that is, <c>e1.compareTo(e2)</c> must not throw a ClassCastException for any elements <c>e1</c> and <c>e2</c> in this list).</para>
        <para>NOTE: The elements will be assigned to different list cells by this method.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Algorithms.YList.Splice(yWorks.Algorithms.YList)">
      <summary>
        <para>Transfers the contents of the given list to the end of this list.</para>
      </summary>
      <remarks>
        <para>The given list will be empty after this operation.</para>
        <para>Note that this operation transfers the list cells of the given list to this list. No new list cells are created by this operation.</para>
      </remarks>
      <param name="list" />
    </member>
    <member name="M:yWorks.Algorithms.YList.AddAll(System.Int32,System.Collections.Generic.ICollection{System.Object})">
      <param name="index" />
      <param name="c" />
    </member>
    <member name="M:yWorks.Algorithms.YList.GetCell(System.Int32)">
      <summary>
        <para>Gets the cell at the given index.</para>
      </summary>
      <param name="index">
        <para>the zero-based index of the cell in this list.</para>
      </param>
      <returns>
        <para>The cell.</para>
      </returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <para>if the index is negative or greater or equal than the <see cref="P:yWorks.Algorithms.YList.Count" /></para>
      </exception>
    </member>
    <member name="M:yWorks.Algorithms.YList.LastIndexOf(System.Object)">
      <param name="o" />
    </member>
    <member name="M:yWorks.Algorithms.YList.Set(System.Int32,System.Object)">
      <param name="index" />
      <param name="element" />
    </member>
    <member name="M:yWorks.Algorithms.YList.Get(System.Int32)">
      <param name="index" />
    </member>
    <member name="M:yWorks.Algorithms.YList.Insert(System.Int32,System.Object)">
      <param name="index" />
      <param name="element" />
    </member>
    <member name="M:yWorks.Algorithms.YList.SubList(System.Int32,System.Int32)">
      <param name="fromIndex" />
      <param name="toIndex" />
    </member>
    <member name="M:yWorks.Algorithms.YList.Equals(System.Object)">
      <param name="other" />
    </member>
    <member name="M:yWorks.Algorithms.YList.GetHashCode" />
    <member name="M:yWorks.Algorithms.YList.CopyTo(System.Array,System.Int32)">
      <summary>
        <para>Copies the elements of this collection to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.</para>
      </summary>
      <param name="array">
        <para>The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from this collection. The <see cref="T:System.Array" /> must have zero-based indexing.</para>
      </param>
      <param name="index">
        <para>The zero-based index in <paramref name="array" /> at which copying begins.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.YList.GetEnumerator">
      <summary>
        <para>Returns an enumerator that iterates through this collection.</para>
      </summary>
      <returns>
        <para>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through this collection.</para>
      </returns>
    </member>
    <member name="M:yWorks.Algorithms.YList.CopyTo(System.Object[],System.Int32)">
      <summary>
        <para>Copies the elements of this collection to an array, starting at the specified array index.</para>
      </summary>
      <param name="array">
        <para>The one-dimensional array that is the destination of the elements copied from this collection.</para>
      </param>
      <param name="arrayIndex">
        <para>The zero-based index in <paramref name="array" /> at which copying begins.</para>
      </param>
    </member>
    <member name="M:yWorks.Algorithms.YList.RemoveAt(System.Int32)">
      <param name="index" />
    </member>
    <member name="P:yWorks.Algorithms.YList.Item(System.Int32)">
      <summary>
        <para>Gets or sets the element at the specified index.</para>
      </summary>
      <param name="index">
        <para>The zero-based index of the element to get or set.</para>
      </param>
      <returns>
        <para>The element at the specified index.</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.BendConverter">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.BendConverter" /> replaces edge bends with dummy nodes for the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>
          <h2>Concept</h2> Replacing the bends works in three steps:</para>
        <list type="number">
          <item>Replacing the bends and the edge segments between them with dummy nodes and edges</item>
          <item>Invoking the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see> on the altered graph</item>
          <item>Recreating the bends and removing all dummy elements</item>
        </list>
        <para>When the dummy elements have been inserted, edge information about <see cref="P:yWorks.Layout.BendConverter.AdoptPortConstraints">port constraints</see>, <see cref="P:yWorks.Layout.BendConverter.AdoptEdgeGroups">edge groups</see> and <see cref="P:yWorks.Layout.BendConverter.AdoptAffectedEdges">selection state</see> can be adopted from the original edges. That way, the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see> can access the mentioned information.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.BendConverter.DefaultAffectedEdgesDpKey">
      <summary>
        <para>A data provider key for specifying the set of edges for which this stage will replace bends.</para>
      </summary>
      <remarks>
        <para>Only the bends of the marked edges will be replaced with dummy nodes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.BendConverter.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.BendConverter" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.BendConverter.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.BendConverter" /> with the given <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>the core layout algorithm</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.BendConverter.#ctor(System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.BendConverter" /> instance with the given size as the width and height for the dummy nodes.</para>
      </summary>
      <param name="size">
        <para>the size for the dummy nodes</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given size is negative</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.BendConverter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Replaces all bends in the current <see cref="F:yWorks.Layout.BendConverter.DefaultAffectedEdgesDpKey">scope</see> with dummy nodes before invoking the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>After the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see> has finished, the edges between the dummy nodes are reconnected and the dummy nodes are replaced by bends again.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.BendConverter.Prepare(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Prepares the graph before calling the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>The bends of the edges belonging to the current scope are replaced by dummy nodes and the segments between those dummy nodes are replaced by dummy edges.</para>
        <para>Edge-specific information like <see cref="T:yWorks.Layout.PortConstraint" />s, edge groups or selection state can be applied to the dummy edges to keep this information for the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see>.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.BendConverter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before invoking the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see>. It may be overridden to extend the edge-specific information that should be adopted by the dummy edges.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.BendConverter.Restore(yWorks.Layout.LayoutGraph)" />
      <seealso cref="P:yWorks.Layout.BendConverter.AdoptAffectedEdges" />
      <seealso cref="P:yWorks.Layout.BendConverter.AdoptPortConstraints" />
      <seealso cref="P:yWorks.Layout.BendConverter.AdoptEdgeGroups" />
    </member>
    <member name="M:yWorks.Layout.BendConverter.Restore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Restores the structure of the graph after the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see> has finished.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.BendConverter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> after invoking the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see>. It may be overridden to clean up all additional information added in <see cref="M:yWorks.Layout.BendConverter.Prepare(yWorks.Layout.LayoutGraph)" />.</para>
      </remarks>
      <param name="graph">
        <para>the graph arranged by the <see cref="P:yWorks.Layout.BendConverter.CoreLayout">core layout algorithm</see></para>
      </param>
      <seealso cref="M:yWorks.Layout.BendConverter.Prepare(yWorks.Layout.LayoutGraph)" />
      <seealso cref="P:yWorks.Layout.BendConverter.AdoptAffectedEdges" />
      <seealso cref="P:yWorks.Layout.BendConverter.AdoptPortConstraints" />
      <seealso cref="P:yWorks.Layout.BendConverter.AdoptEdgeGroups" />
    </member>
    <member name="P:yWorks.Layout.BendConverter.CoreLayout">
      <summary>
        <para>Gets or sets the core layout algorithm that is wrapped by this <see cref="T:yWorks.Layout.ILayoutStage" />.</para>
      </summary>
      <value>
        <para>the core layout routine</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.BendConverter.AdoptEdgeGroups">
      <summary>
        <para>Gets or sets whether or not edge grouping information of the original edge should be adopted by its replacement edges.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if dummy edges get the edge grouping information from their corresponding originals, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="P:yWorks.Layout.BendConverter.AdoptPortConstraints">
      <summary>
        <para>Gets or sets whether or not the associated <see cref="T:yWorks.Layout.PortConstraint" />s of the original edge should be adopted by its replacement edges.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if dummy edges get the <see cref="T:yWorks.Layout.PortConstraint" />s of their corresponding originals, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
    </member>
    <member name="P:yWorks.Layout.BendConverter.AdoptAffectedEdges">
      <summary>
        <para>Gets or sets whether or not the selection state of the original edge should be adopted by its replacement edges.</para>
      </summary>
      <remarks>
        <para>The selection state is looked up in a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the key returned by <see cref="P:yWorks.Layout.BendConverter.AffectedEdgesDpKey" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if dummy edges get the selection state of their corresponding original edge, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.BendConverter.AffectedEdgesDpKey" />
    </member>
    <member name="M:yWorks.Layout.BendConverter.AddedPathForEdge(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Adds information to newly created dummy nodes.</para>
      </summary>
      <remarks>
        <para>This is a callback method that will be invoked after new elements for the given edge have been added to the given graph by <see cref="M:yWorks.Layout.BendConverter.Prepare(yWorks.Layout.LayoutGraph)" />. At this point, the original edge is still in the graph.</para>
        <para>The current implementation does nothing.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the edge whose bends were replaced by the given dummy nodes</para>
      </param>
      <param name="dummyNodes">
        <para>the dummy nodes representing the bends of the edge</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.BendConverter.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> which identifies edges as <em>selected</em>.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Layout.BendConverter.AdoptAffectedEdges">the selection is conserved</see>, the selection state described by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key is applied to the according dummy edges.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key</para>
      </value>
      <seealso cref="P:yWorks.Layout.BendConverter.AdoptAffectedEdges" />
    </member>
    <member name="T:yWorks.Layout.BufferedLayout">
      <summary>
        <para>A <see cref="T:yWorks.Layout.BufferedLayout" /> is a hull algorithm that invokes its <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> on a copy of the input graph.</para>
      </summary>
      <remarks>
        <para>After the layout process has finished, the calculated layout will be written back to the original graph.</para>
        <para>This class also provides the possibility to perform arbitrary layout algorithms merely on a graph interface plus associated graph layout. This comes in handy if an application has its own graph and only provides a graph interface adapter to the <em>yFiles</em> graph layout machinery.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.BufferedLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.BufferedLayout" /> instance using the given <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>the core layout routine</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.BufferedLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Applies the layout calculated by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> to the input graph.</para>
      </summary>
      <remarks>
        <para>The layout calculation is invoked on a copy of the given graph. Then, the calculated layout will be written back to the given graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Circular.CircularLayout">
      <summary>
        <para>This layout algorithm arranges graphs in a circular fashion.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The nodes are arranged in circles and stars which emphasize group and tree structures inside a graph. Circular layout algorithms find applications in many areas such as social networking, network management, WWW visualization, eCommerce, telecommunications.  Circular layout with default settings  Circular layout with <see cref="F:yWorks.Layout.Circular.LayoutStyle.SingleCycle" /> layout style <h2>Concept</h2> The layout algorithm performs three steps when calculating a circular arrangement for a graph:</para>
        <list type="number">
          <item>It searches for partitions in the input graph depending on connectivity and on the given <see cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle">layout style</see>. Considering each partition as a node, the resulting graph has a tree-like structure.</item>
          <item>The partitions are laid out as circles using the selected <see cref="P:yWorks.Layout.Circular.CircularLayout.PartitionStyle">partition style</see>.</item>
          <item>The algorithm delegates the layout calculation for the underlying tree (in which each node corresponds to a partition) to a specialized layout algorithm accessible by <see cref="P:yWorks.Layout.Circular.CircularLayout.SingleCycleLayout" /> or <see cref="P:yWorks.Layout.Circular.CircularLayout.BalloonLayout" />. The partitions are moved to their final location.</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>The layout algorithm places the nodes in circles that represent a partition. There are several ways to find partitions in the input graph. Which one is applied is defined using <see cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle" />.</para>
        <para>The nodes in a partition can either lie on or in the interior of a circle. The placement of the nodes affects the compactness of the layout and can be specified using <see cref="P:yWorks.Layout.Circular.CircularLayout.PartitionStyle" />.</para>
        <para>Since edges are routed as straight lines, they may overlap with nodes or node labels. To resolve these overlaps, an edge routing algorithm (e.g. <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" /> or <see cref="T:yWorks.Layout.Router.OrganicEdgeRouter" />) can be appended.</para>
        <para>This layout algorithm supports <see cref="P:yWorks.Layout.Circular.CircularLayout.EdgeBundling">edge bundling</see>. In order to bundle the edges, the nodes of the graph are clustered in groups. Edge bundling is supported only if <see cref="P:yWorks.Layout.Circular.CircularLayout.PartitionStyle">partition layout style</see> is set to <see cref="F:yWorks.Layout.Circular.PartitionStyle.Cycle" /> and <see cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle">layout style</see> is other than <see cref="F:yWorks.Layout.Circular.LayoutStyle.BccIsolated" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Circular.CircularLayout.CircleIdDpKey">
      <summary>
        <para>A data acceptor key for publishing the final circle information.</para>
      </summary>
      <remarks>
        <para>For each node, the ID of the circle on which it was placed will be stored.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Circular.CircularLayout.CustomGroupsDpKey">
      <summary>
        <para>A data provider key for defining custom node partitions.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> needs to provide a mapping from <see cref="T:yWorks.Algorithms.Node" />s to unique <see cref="T:System.Object" /> IDs for each group of nodes. These groups will form the circles in the layout.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Circular.LayoutStyle.CustomGroups" />
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the layout algorithm reserves space for node labels preventing possible overlaps.</para>
      </summary>
      <remarks>
        <para>Nodes get temporarily enlarged such that they contain their labels.</para>
        <para>This might result in layouts that need much space.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if labels are considered, <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.PlaceChildrenOnCommonRadius">
      <summary>
        <para>Gets or sets whether or not, in the underlying tree, the children of a tree node are placed on a common radius.</para>
      </summary>
      <remarks>
        <para>Disabling this feature may produce more compact layout results.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if a common radius is used, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.FromSketchMode">
      <summary>
        <para>Gets or sets whether or not to take the coordinates of the input diagram into account when arranging the nodes of the partitions and the partitions themselves.</para>
      </summary>
      <remarks>
        <para>If enabled:</para>
        <list type="bullet">
          <item>For complex partitions (those consisting of more than one node), the layout algorithm tries to keep peripheral nodes and maintain their circular order around the center of the disk/circle. Other partitions that connect to this node are moved accordingly, if possible.</item>
          <item>For multiple partitions that connect to the same node, the layout algorithm tries to keep their circular order around this node. This only works as expected for <see cref="F:yWorks.Layout.Circular.LayoutStyle.BccCompact" /> as layout style, since otherwise the underlying tree structure is not well defined.</item>
        </list>
      </remarks>
      <value>
        <para>
          <c>true</c> if the initial coordinates of the nodes are used, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Circular.CircularLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Circular.CircularLayout" /> instance with the default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.MaximumDeviationAngle">
      <summary>
        <para>Gets or sets the maximum deviation angle allowed for an edge.</para>
      </summary>
      <remarks>
        <para>The deviation angle for an edge is the difference between its optimal angle away from the parent cycle and its actual angle.</para>
      </remarks>
      <value>
        <para>the maximum deviation angle given in degrees</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle">
      <summary>
        <para>Gets or sets the global layout style for this layout algorithm.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown layout style is set</para>
      </exception>
      <value>
        <para>one of the predefined layout styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.SingleCycleLayout">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Circular.SingleCycleLayout" /> instance used for laying out nodes on a single cycle.</para>
      </summary>
      <remarks>
        <para>Configuring this layout algorithm only affects layouts with only one partition.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.Circular.SingleCycleLayout" /> instance that handles layouts with only one partition</para>
      </value>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle" />
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.BalloonLayout">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Tree.BalloonLayout" /> instance used for arranging multiple partitions.</para>
      </summary>
      <remarks>
        <para>Configuring this layout algorithm affects the arrangement of the partitions within the overall layout.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.Tree.BalloonLayout" /> instance that arranges the partitions</para>
      </value>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle" />
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.PartitionStyle">
      <summary>
        <para>Gets or sets the style for the arrangement of each partition.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown style is given</para>
      </exception>
      <value>
        <para>one of the predefined partition styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.ComponentLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for arranging the components of the graph is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that arranges the graph components is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.HideGroupsStageEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for hiding group nodes is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage used for hiding group nodes is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStage" />
      <seealso cref="T:yWorks.Layout.Grouping.HideGroupsStage" />
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.OrientationLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of the layout is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that modifies the orientation is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="P:yWorks.Layout.Circular.CircularLayout.EdgeBundling">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.EdgeBundling" /> instance that defines the settings of the edge bundling feature.</para>
      </summary>
      <remarks>
        <para>The specified <see cref="T:yWorks.Layout.EdgeBundling" /> defines global bundling properties. Settings for individual edges can be defined by assigning an <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> to an edge using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey" />.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.EdgeBundling" /> instance defining the edge bundling setup</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Circular.CircularLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Arranges the given graph in a circular fashion.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Circular.CircularLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates a circular layout for the given graph.</para>
      </summary>
      <remarks>
        <para>The given graph will not be copied during the layout process and the layout will be immediately applied to the given graph.</para>
        <para>This method is not side effect free in the sense that the order of edges or nodes in the input graph may change during the layout process.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Circular.LayoutStyle">
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Circular.LayoutStyle.BccCompact">
      <summary>
        <para>The specifier for a layout style where the nodes within a biconnected component of the input graph are treated as separate partitions.</para>
        <para>If a node belongs to more than one biconnected component, it will be assigned to the one that seems to be more suitable.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Circular.LayoutStyle.BccIsolated">
      <summary>
        <para>The specifier for a layout style where the nodes within a biconnected component of the input graph are treated as separate partitions.</para>
        <para>If a node belongs to more than one biconnected component, it will form an isolated partition and will be laid out in between of all its biconnected component cycles.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Circular.LayoutStyle.CustomGroups">
      <summary>
        <para>The specifier for a layout style where the user can specify groups that will form separate partitions. To define the groups, a <see cref="T:yWorks.Algorithms.IDataProvider" /> with key <see cref="F:yWorks.Layout.Circular.CircularLayout.CustomGroupsDpKey" /> must be registered.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Circular.LayoutStyle.SingleCycle">
      <summary>
        <para>The specifier for a layout style where all nodes of the input graph will be placed on or in the interior of a single cycle.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.LayoutStyle" />
    </member>
    <member name="T:yWorks.Layout.Circular.PartitionStyle">
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.PartitionStyle" />
    </member>
    <member name="F:yWorks.Layout.Circular.PartitionStyle.Cycle">
      <summary>
        <para>Specifier for a partition layout style where all nodes of a partition are placed on the boundary of a circle.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.PartitionStyle" />
    </member>
    <member name="F:yWorks.Layout.Circular.PartitionStyle.Disk">
      <summary>
        <para>Specifier for a partition style with a semi-compact layout for each partition.</para>
        <para>This style places nodes in the interior and on the border of a circle and arranges them in an organic manner, leading to a more compact layout. Only nodes with connections to other partitions are guaranteed to lie on the boundary of the resulting disk.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.PartitionStyle" />
    </member>
    <member name="F:yWorks.Layout.Circular.PartitionStyle.Organic">
      <summary>
        <para>Specifier for a partition style with a compact layout for each partition.</para>
        <para>This style creates an organic circular layout for each partition. Even nodes that connect to different partitions may be placed in the interior of the resulting disk.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.PartitionStyle" />
    </member>
    <member name="T:yWorks.Layout.Circular.SingleCycleLayout">
      <summary>
        <para>This layout algorithm places all nodes of a graph on a single cycle.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>All nodes of a graph are placed on one common circle, generating <em>circular layouts</em>. The edges are drawn as simple, straight lines. The resulting layouts look like a ring. Edges connecting nodes which are <em>not</em> next to each other on the ring are routed <em>inside</em> of the circle. If a graph contains many edges, the number of edge crossings inside the circle may be quite high.</para>
        <para>Single-cycle circular layouts are suitable for the visualization of networks such as ring networks or smaller social networks. They are also useful to layout cyclic subgraphs of a larger graph.</para>
        <para> An example of a single cycle layout <h2>Concept</h2> First, the nodes are sorted by applying either a custom or some default <see cref="T:yWorks.Algorithms.INodeSequencer" />. Then, all nodes are placed on a circle with an appropriate radius according to the calculated order. <h2>Features</h2></para>
        <para>The order in which the nodes are placed on the circle is a crucial aspect of this algorithm. By specifying a <see cref="T:yWorks.Algorithms.INodeSequencer" /> instance via <see cref="P:yWorks.Layout.Circular.SingleCycleLayout.NodeSequencer" />, the order can be customized.</para>
        <para>There are two options to determine the radius of the circle on which nodes are placed:</para>
        <list type="number">
          <item>The radius can be determined automatically. A specified <see cref="P:yWorks.Layout.Circular.SingleCycleLayout.MinimumRadius">minimum radius</see> will be obeyed when choosing the radius.</item>
          <item>The radius can be chosen manually. To do so, disable the <see cref="P:yWorks.Layout.Circular.SingleCycleLayout.AutomaticRadius">automatic radius selection</see> and specify the custom radius via <see cref="P:yWorks.Layout.Circular.SingleCycleLayout.FixedRadius" />.</item>
        </list>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.InitialAngle">
      <summary>
        <para>Gets or sets the angle that describes the location on the circle of the first node.</para>
      </summary>
      <remarks>
        <para>The angle is measured in radians and world coordinates, e.g., <c>0</c> means east, <c>Pi/2</c> means south.</para>
      </remarks>
      <value>
        <para>the angle for the placement of the first node in radians</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.FromSketchModeEnabled">
      <summary>
        <para>Gets or sets whether or not to consider the coordinates of the input diagram when arranging the graph.</para>
      </summary>
      <remarks>
        <para>If this feature is enabled, the original circular order of peripheral nodes around an estimated circle center will be preserved.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the initial coordinates of the nodes are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Circular.SingleCycleLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Circular.SingleCycleLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance between nodes that are next to each other on the circle.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum distance between nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.FixedRadius">
      <summary>
        <para>Gets or sets a fixed radius for the circle on which the nodes will be placed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given radius is negative</para>
      </exception>
      <value>
        <para>the fixed radius for the circle</para>
      </value>
      <seealso cref="P:yWorks.Layout.Circular.SingleCycleLayout.MinimumRadius" />
      <seealso cref="P:yWorks.Layout.Circular.SingleCycleLayout.AutomaticRadius" />
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.MinimumRadius">
      <summary>
        <para>Gets or sets the minimum radius for the circle on which the nodes are placed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum radius is negative</para>
      </exception>
      <value>
        <para>the minimum circle radius</para>
      </value>
      <seealso cref="P:yWorks.Layout.Circular.SingleCycleLayout.FixedRadius" />
      <seealso cref="P:yWorks.Layout.Circular.SingleCycleLayout.AutomaticRadius" />
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.AutomaticRadius">
      <summary>
        <para>Gets or sets whether or not the radius of the circle should be determined automatically.</para>
      </summary>
      <remarks>
        <para>If enabled, the radius will be chosen such that the distance between nodes which are next to each other on the circle is approximately the same as the <see cref="P:yWorks.Layout.Circular.SingleCycleLayout.MinimumNodeDistance">minimum node distance</see>.</para>
        <para>If this feature is disabled, the radius specified via <see cref="P:yWorks.Layout.Circular.SingleCycleLayout.FixedRadius" /> will be applied.</para>
      </remarks>
      <value>
        <para>
          <c>true</c>, if the radius of the circle is determined automatically, <c>false</c>, otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Circular.SingleCycleLayout.MinimumRadius" />
      <seealso cref="P:yWorks.Layout.Circular.SingleCycleLayout.FixedRadius" />
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.NodeSequencer">
      <summary>
        <para>Gets or sets the custom <see cref="T:yWorks.Algorithms.INodeSequencer" /> that will be used for determining the order of the nodes for the circle placement.</para>
      </summary>
      <value>
        <para>the sequencer for determining a node order for the circle placement</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.LastAppliedRadius">
      <summary>
        <para>Gets the radius that was applied to the last layout calculated by this algorithm.</para>
      </summary>
      <remarks>
        <para>This method is useful if one wants to know the actual radius of a layout calculated by this algorithm.</para>
      </remarks>
      <value>
        <para>the radius applied to the result of the last layout calculation</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.OrientationLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of the layout is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that modifies the orientation is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="P:yWorks.Layout.Circular.SingleCycleLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="M:yWorks.Layout.Circular.SingleCycleLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Arranges the nodes of the given graph such that they all lie on a common circle.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.ComponentLayout">
      <summary>
        <para>A <see cref="T:yWorks.Layout.ComponentLayout" /> arranges the connected components of a graph.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The components can be arranged using different <see cref="P:yWorks.Layout.ComponentLayout.Style">styles</see>. All styles except <see cref="F:yWorks.Layout.ComponentArrangementStyles.None" /> place the components without overlaps. </para>
        <para>Layout with orthogonal components using <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsCompact" /></para>
        <para>
          <h2>Concept</h2>
        </para>
        <para>
          <see cref="T:yWorks.Layout.ComponentLayout" /> is a <see cref="T:yWorks.Layout.ILayoutStage" /> that can wrap another <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see>. That way, it allows handling disconnected graphs for the wrapped <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
        <para>The following steps outline the concept of <see cref="T:yWorks.Layout.ComponentLayout" />:</para>
        <list type="number">
          <item>Determine the connected components of the graph</item>
          <item>Hide all graph components</item>
          <item>Apply the following steps to each component separately</item>
          <item>Unhide all graph components</item>
          <item>
            <see cref="P:yWorks.Layout.ComponentLayout.ComponentArrangement">Optionally arrange</see> the components</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>To arrange the subgraphs of the components, <see cref="T:yWorks.Layout.ComponentLayout" /> uses the specified <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. If there is no <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> specified, it will keep the locations in the subgraph and arrange the components as they are.</para>
        <para>Hierarchically grouped graphs are handled in a special way. The contents of a group node will always belong to the same component as the group node itself. To change that behavior <see cref="P:yWorks.Layout.ComponentLayout.ConsiderGrouping">grouping</see> can be disabled.</para>
        <para>By default, the components consist of the connected nodes in a graph. To choose custom subgraphs to form components, register a <see cref="T:yWorks.Algorithms.IDataProvider" /> with <see cref="F:yWorks.Layout.ComponentLayout.ComponentIdDpKey" /> and assign component IDs to the nodes.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.MultiStageLayout" />
    </member>
    <member name="F:yWorks.Layout.ComponentLayout.AffectedComponentsDpKey">
      <summary>
        <para>A data provider key for specifying which nodes should be arranged.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with this key, all components will be laid out by the core layout algorithm.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.ComponentLayout.ComponentIdDpKey">
      <summary>
        <para>A data provider key for specifying custom graph components.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.ComponentLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ComponentLayout" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algortihm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.ComponentLayout.PreferredSize">
      <summary>
        <para>Gets or sets the preferred size of the layout.</para>
      </summary>
      <remarks>
        <para>The layout size also defines the desired aspect ratio (width/height).</para>
        <para>The width and height need to be greater than zero.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified width or height is negative or zero.</para>
      </exception>
      <value>
        <para>the preferred size of the calculated graph layout</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.ComponentLayout.FindGraphComponents(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Determines which nodes belong to the same graph component.</para>
      </summary>
      <remarks>
        <para>This implementation uses the graph connectivity to sort the nodes into different components. Nodes that are not connected by a path will be in separate components.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.ComponentLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" />. It may be overridden to choose another approach to find components that will be passed to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. However, most of the layout algorithms cannot handle disconnected graphs. Also, edges between custom components will be ignored.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="compNumber">
        <para>a map that will be filled with the zero-based index of the component to which the node belongs</para>
      </param>
      <returns>
        <para>the number of connected components of this graph</para>
      </returns>
      <seealso cref="M:yWorks.Algorithms.GraphConnectivity.ConnectedComponents(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Layout.ComponentLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Delegates the layout calculation for each component separately to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and optionally arranges the components.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.ComponentLayout.CalculateBounds(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates the bounding box of a graph component including <see cref="T:yWorks.Layout.NodeHalo" />s.</para>
      </summary>
      <remarks>
        <para>This method will be invoked for each component of the graph. Depending on the state of property <see cref="P:yWorks.Layout.ComponentLayout.ConsiderLabels" />, the returned bounding box will also include node and edge labels. It may be overridden to extend the bounds to reserve space for other elements.</para>
      </remarks>
      <param name="graph">
        <para>the subgraph containing the nodes and edges of a component</para>
      </param>
      <returns>
        <para>the bounding box of the component</para>
      </returns>
      <seealso cref="P:yWorks.Layout.ComponentLayout.ConsiderLabels" />
    </member>
    <member name="P:yWorks.Layout.ComponentLayout.ConsiderLabels">
      <summary>
        <para>Gets or sets whether or not to take node and edge labels into account when calculating the bounding box of the graph components.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node and edge labels are taken into account when calculating the bounding box of the graph components, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Layout.ComponentLayout.CalculateBounds(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.ComponentLayout.ArrangeComponents(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[],yWorks.Algorithms.EdgeList[],yWorks.Algorithms.Geometry.YRectangle[],yWorks.Algorithms.Geometry.Rectangle2D[])">
      <summary>
        <para>Produces a component graph layout.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.ComponentLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> in case <see cref="P:yWorks.Layout.ComponentLayout.ComponentArrangement">component arrangement</see> is enabled. It moves the graph's components such that their bounding boxes do not overlap. Subclasses may want to override this method to introduce custom component arrangement styles.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="nodes">
        <para>the nodes of the components; the i-th list contains the nodes of the i-th component</para>
      </param>
      <param name="edges">
        <para>the edges of the components; the i-th list contains the edges of the i-th component</para>
      </param>
      <param name="bbox">
        <para>the bounds of the components; the i-th rectangle describes the bounding box of the i-th component</para>
      </param>
      <param name="boxes">
        <para>the extended bounds of the components; the i-th rectangle describes the bounding box of the i-th component extended by the spacing between components. The method arranges these boxes in such a way that they do not overlap. Then, the i-th graph component must be placed inside the i-th box</para>
      </param>
      <seealso cref="M:yWorks.Layout.ComponentLayout.ArrangeFields(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[],yWorks.Algorithms.EdgeList[],yWorks.Algorithms.Geometry.YRectangle[],yWorks.Algorithms.Geometry.Rectangle2D[],System.Boolean,System.Boolean,System.Boolean)" />
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,yWorks.Layout.RowAlignment)" />
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleMultiRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,System.Double,System.Boolean,yWorks.Layout.MultiRowConstraint,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="P:yWorks.Layout.ComponentLayout.ComponentArrangement">
      <summary>
        <para>Gets or sets whether or not the separately arranged components of the input graph should be arranged relative to each other.</para>
      </summary>
      <remarks>
        <para>If enabled, the components are arranged using a specific <see cref="P:yWorks.Layout.ComponentLayout.Style">style</see> without producing overlaps between components (except for <see cref="F:yWorks.Layout.ComponentArrangementStyles.None" />). Otherwise, the layout algorithm will keep the components at their location. Then, the components may overlap.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the components of the graph are arranged, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.ComponentLayout.SetOrigin(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList,yWorks.Algorithms.EdgeList,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Moves the subgraph containing the given nodes and edges to the specified origin.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.ComponentLayout.ArrangeComponents(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[],yWorks.Algorithms.EdgeList[],yWorks.Algorithms.Geometry.YRectangle[],yWorks.Algorithms.Geometry.Rectangle2D[])" /> and <see cref="M:yWorks.Layout.ComponentLayout.ArrangeFields(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[],yWorks.Algorithms.EdgeList[],yWorks.Algorithms.Geometry.YRectangle[],yWorks.Algorithms.Geometry.Rectangle2D[],System.Boolean,System.Boolean,System.Boolean)" /> to move the components to overlap-free positions.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="nodes">
        <para>the nodes in the moving subgraph</para>
      </param>
      <param name="edges">
        <para>the edges in the moving subgraph</para>
      </param>
      <param name="origin">
        <para>the new origin of the graph</para>
      </param>
      <param name="rectangle">
        <para>the current bounds of the subgraph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.ComponentLayout.GridSpacing">
      <summary>
        <para>Gets or sets the current grid spacing.</para>
      </summary>
      <remarks>
        <para>Components will be moved by multiples of this value, thus keeping their offset to the grid. That way, components or parts of them that were placed on a grid before, will stay on their original grid. The grid spacing also influences the distance between the components.</para>
        <para>The spacing needs to be a non-negative value. If the grid spacing is set to <c>0</c>, the grid won't be considered at all.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given spacing is negative</para>
      </exception>
      <value>
        <para>the grid spacing</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.ComponentLayout.ComponentSpacing">
      <summary>
        <para>Gets or sets the distance between the bounding boxes of the components.</para>
      </summary>
      <remarks>
        <para>The spacing needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the spacing is negative</para>
      </exception>
      <value>
        <para>the component spacing</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.ComponentLayout.ConsiderGrouping">
      <summary>
        <para>Gets or sets whether or not grouping information bound to the graph should be considered when determining the graph components.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the nesting structure of the graph is considered when determining the components, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.ComponentLayout.Style">
      <summary>
        <para>Gets or sets how the components are arranged.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified style is unknown</para>
      </exception>
      <value>
        <para>one of the valid style specifiers</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.ComponentLayout.ArrangeFields(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[],yWorks.Algorithms.EdgeList[],yWorks.Algorithms.Geometry.YRectangle[],yWorks.Algorithms.Geometry.Rectangle2D[],System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Arranges the bounding boxes of the components.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.ComponentLayout.ArrangeComponents(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[],yWorks.Algorithms.EdgeList[],yWorks.Algorithms.Geometry.YRectangle[],yWorks.Algorithms.Geometry.Rectangle2D[])" /> if the <see cref="P:yWorks.Layout.ComponentLayout.Style">style</see> is set to <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedRectangle" />, <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedCompactRectangle" />, <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedCircle" /> or <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedCompactCircle" />. It may be overridden to adjust the component arrangement strategy of the mentioned styles.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="nodes">
        <para>the nodes of the components; the i-th list contains the nodes of the i-th component</para>
      </param>
      <param name="edges">
        <para>the edges of the components; the i-th list contains the edges of the i-th component</para>
      </param>
      <param name="bbox">
        <para>the bounds of the components; the i-th rectangle describes the bounding box of the i-th component</para>
      </param>
      <param name="boxes">
        <para>the extended bounds of the components; the i-th rectangle describes the bounding box of the i-th component</para>
      </param>
      <param name="circular">
        <para>
          <c>true</c> if the arrangement should be circular, <c>false</c> if it should be rectangular</para>
      </param>
      <param name="fill">
        <para>
          <c>true</c> if it is allowed to place components in empty spaces <em>inside other
 components</em>, <c>false</c> otherwise</para>
      </param>
      <param name="fromSketch">
        <para>
          <c>true</c> if the initial coordinates should be considered, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.CompositeLayoutStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.CompositeLayoutStage" /> allows for combining multiple <see cref="T:yWorks.Layout.ILayoutStage" />s.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.ILayoutStage" />s are organized in a pipeline where additional <see cref="T:yWorks.Layout.ILayoutStage" />s can be <see cref="M:yWorks.Layout.CompositeLayoutStage.PrependStage(yWorks.Layout.ILayoutStage)">prepended</see> or <see cref="M:yWorks.Layout.CompositeLayoutStage.AppendStage(yWorks.Layout.ILayoutStage)">appended</see>.</para>
        <para>Each <see cref="T:yWorks.Layout.ILayoutStage" /> in the pipeline executes its pre-processing code before calling its successor <see cref="T:yWorks.Layout.ILayoutStage" />. Then, after all subsequent <see cref="T:yWorks.Layout.ILayoutStage" />s have finished, it will execute its post-processing code.</para>
        <para>Note that the pipeline only works when all <see cref="T:yWorks.Layout.ILayoutStage" />s call their core layout algorithm which is the next <see cref="T:yWorks.Layout.ILayoutStage" /> in the pipeline.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.CompositeLayoutStage.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.CompositeLayoutStage" /> instance with an empty pipeline.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.CompositeLayoutStage.#ctor(yWorks.Layout.ILayoutStage,yWorks.Layout.ILayoutStage)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.CompositeLayoutStage" /> instance with two <see cref="T:yWorks.Layout.ILayoutStage" />s in the pipeline.</para>
      </summary>
      <remarks>
        <para>The inner <see cref="T:yWorks.Layout.ILayoutStage" /> will be wrapped by the outer <see cref="T:yWorks.Layout.ILayoutStage" />.</para>
      </remarks>
      <param name="outerStage">
        <para>the wrapping <see cref="T:yWorks.Layout.ILayoutStage" /></para>
      </param>
      <param name="innerStage">
        <para>the wrapped <see cref="T:yWorks.Layout.ILayoutStage" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.CompositeLayoutStage.PrependStage(yWorks.Layout.ILayoutStage)">
      <summary>
        <para>Prepends a <see cref="T:yWorks.Layout.ILayoutStage" /> to the previously added <see cref="T:yWorks.Layout.ILayoutStage" />s.</para>
      </summary>
      <remarks>
        <para>The added <see cref="T:yWorks.Layout.ILayoutStage" /> will be invoked before any other <see cref="T:yWorks.Layout.ILayoutStage" />. Its pre-processing code will be executed before the already added <see cref="T:yWorks.Layout.ILayoutStage" />s' pre-processing code, while its post-processing code will be executed after the post-processing code of all the other <see cref="T:yWorks.Layout.ILayoutStage" />s.</para>
      </remarks>
      <param name="stage">
        <para>the stage to prepend</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.CompositeLayoutStage.LayoutStages">
      <summary>
        <para>Gets the complete pipeline of <see cref="T:yWorks.Layout.ILayoutStage" />s that were added to this <see cref="T:yWorks.Layout.CompositeLayoutStage" />.</para>
      </summary>
      <value>
        <para>a list of all <see cref="T:yWorks.Layout.ILayoutStage" />s in the pipeline</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.CompositeLayoutStage.AppendStage(yWorks.Layout.ILayoutStage)">
      <summary>
        <para>Appends a <see cref="T:yWorks.Layout.ILayoutStage" /> to the previously added <see cref="T:yWorks.Layout.ILayoutStage" />s.</para>
      </summary>
      <remarks>
        <para>The added <see cref="T:yWorks.Layout.ILayoutStage" /> will be invoked just before the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> will be invoked. Its pre-processing code will be executed after the already added <see cref="T:yWorks.Layout.ILayoutStage" />s' pre-processing code, while its post-processing code will be executed before the post-processing code of all the other <see cref="T:yWorks.Layout.ILayoutStage" />s.</para>
      </remarks>
      <param name="stage">
        <para>the stage to append</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.CompositeLayoutStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Executes the pipeline of <see cref="T:yWorks.Layout.ILayoutStage" /> and the core layout algorithm which apply the layout to the graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.CopiedLayoutGraph">
      <summary>
        <para>A <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> is a <see cref="T:yWorks.Layout.LayoutGraph" /> that serves as a <b>copy of another graph</b> with layout information.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> comes to use if a <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> should not run directly on the original graph. Using a copy, the calculated layout will not be applied to the original graph before the layout algorithm finished successfully. This can <em>prevent inconsistencies</em> in case something goes wrong during layout calculations.</para>
        <para>
          <h2>Concept</h2> <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> contains corresponding nodes and edges for each node and edge in the original graph and copies the labels of the original nodes and edges. It also delegates all <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with the original graph.</para>
        <para>To preserve the relations between the original elements and the copied elements in this graph, <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> updates mappings between those elements.</para>
        <para>If there are structural changes to the original graph, they can be transferred to this copied graph using <see cref="M:yWorks.Layout.CopiedLayoutGraph.SyncStructure" />. Then the copied graph will be altered, adding and removing elements, until it corresponds to the original again.</para>
        <para>Method <see cref="M:yWorks.Layout.CopiedLayoutGraph.CommitLayoutToOriginalGraph" /> will transfer updated layout information to the original graph. The original graph will stay unchanged until this method is called.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.BufferedLayout" />
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.#ctor(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> instance which is a copy of the given graph.</para>
      </summary>
      <param name="graph">
        <para>the original graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.CreateEdge(System.Object)">
      <summary>
        <para>Creates an edge in the copied graph that corresponds to the given original edge.</para>
      </summary>
      <remarks>
        <para>The edge will connect to the copies of the source and target of the original edge. All labels of the original edge will be also copied and assigned to this edge.</para>
        <para>The mappings are updated. Hence, it is possible to look up the newly created edge by using <see cref="M:yWorks.Layout.CopiedLayoutGraph.GetCopiedEdge(System.Object)" /> or the original edge by using <see cref="M:yWorks.Layout.CopiedLayoutGraph.GetOriginalEdge(yWorks.Algorithms.Edge)" />.</para>
        <para>This method can be used for keeping the <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> in sync with the original graph.</para>
      </remarks>
      <param name="originalEdge">
        <para>the original edge</para>
      </param>
      <returns>
        <para>the copy of the original edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.CreateNode(System.Object)">
      <summary>
        <para>Creates a node in the copied graph that corresponds to the given original node.</para>
      </summary>
      <remarks>
        <para>All labels of the original node will be copied and assigned to this node.</para>
        <para>The mappings are updated. Hence, it is possible to look up the newly created node by using <see cref="M:yWorks.Layout.CopiedLayoutGraph.GetCopiedNode(System.Object)" /> or the original node by using <see cref="M:yWorks.Layout.CopiedLayoutGraph.GetOriginalNode(yWorks.Algorithms.Node)" />.</para>
        <para>This method can be used for keeping the <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> in sync with the original graph.</para>
      </remarks>
      <param name="originalNode">
        <para>the original node</para>
      </param>
      <returns>
        <para>the copy of the original node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.SyncStructure">
      <summary>
        <para>Synchronizes the structure of the <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> with the actual structure of the underlying original graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetLayout(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the layout information for the given node of the copied graph.</para>
      </summary>
      <remarks>
        <para>If there is no layout information for this node, yet, a new implementation of <see cref="T:yWorks.Layout.INodeLayout" /> is returned.</para>
      </remarks>
      <param name="copiedNode">
        <para>the node</para>
      </param>
      <returns>
        <para>the layout information for the node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetLayout(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the layout information for the given edge of the copied graph.</para>
      </summary>
      <remarks>
        <para>If there is no layout information for this edge, yet, a new implementation of <see cref="T:yWorks.Layout.IEdgeLayout" /> is returned.</para>
      </remarks>
      <param name="copiedEdge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the layout information for the edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetLabelLayout(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the layout information for all labels associated with the given node of the copied graph.</para>
      </summary>
      <remarks>
        <para>If there is no layout information for a label, yet, a new implementation of <see cref="T:yWorks.Layout.INodeLabelLayout" /> is created.</para>
      </remarks>
      <param name="copiedNode">
        <para>the node</para>
      </param>
      <returns>
        <para>the label layout information for all labels of the given node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetLabelLayout(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the layout information for all labels associated with the given edge of the copied graph.</para>
      </summary>
      <remarks>
        <para>If there is no layout information for a label, yet, a new implementation of <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> is created.</para>
      </remarks>
      <param name="copiedEdge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the label layout information for all labels of the given edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetOwner(yWorks.Layout.INodeLabelLayout)">
      <summary>
        <para>Returns the edge of the copied graph to which the given <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> belongs.</para>
      </summary>
      <param name="labelLayout">
        <para>a label layout information of a node in the copied graph</para>
      </param>
      <returns>
        <para>the node that belongs to the given label layout</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetOwner(yWorks.Layout.IEdgeLabelLayout)">
      <summary>
        <para>Returns the edge of the copied graph to which the given <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> belongs.</para>
      </summary>
      <param name="labelLayout">
        <para>a label layout information of an edge in the copied graph</para>
      </param>
      <returns>
        <para>the edge that belongs to the given label layout</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.CommitLayoutToOriginalGraph">
      <summary>
        <para>Writes the current layout information of all elements of this copied graph to the original graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetOriginalNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the original node that corresponds to the given copied node.</para>
      </summary>
      <param name="copiedNode">
        <para>the node in this graph that is a copy of the returned node</para>
      </param>
      <returns>
        <para>the node in the original graph whose copy is the given node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetOriginalEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the original edge that corresponds to the given copied edge.</para>
      </summary>
      <param name="copiedEdge">
        <para>the edge in this graph that is a copy of the returned edge</para>
      </param>
      <returns>
        <para>the edge in the original graph whose copy is the given edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetCopiedNode(System.Object)">
      <summary>
        <para>Returns the copied node that corresponds to the given original node.</para>
      </summary>
      <param name="originalNode">
        <para>a node of the original graph whose copy resides in this graph</para>
      </param>
      <returns>
        <para>a node in this graph that is the copy of the given original node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.GetCopiedEdge(System.Object)">
      <summary>
        <para>Returns the copied edge that corresponds to the given original edge.</para>
      </summary>
      <param name="originalEdge">
        <para>an edge of the original graph whose copy resides in this graph</para>
      </param>
      <returns>
        <para>an edge in this graph that is the copy of the given original edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.CopiedLayoutGraph.CreateLabelFactory">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ILabelLayoutFactory" /> for this <see cref="T:yWorks.Layout.CopiedLayoutGraph" />.</para>
      </summary>
      <remarks>
        <para>Subclasses overriding this method must provide an instance that manages the mapping between copied and original <see cref="T:yWorks.Layout.ILabelLayout" />s.</para>
      </remarks>
      <returns>
        <para>the new label layout factory</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.CurveFittingLayoutStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.CurveFittingLayoutStage" /> fits a piecewise <em>cubic bezier curve</em> to given arbitrary edge paths.</para>
      </summary>
      <remarks>
        <para>
          <h2>Concept</h2>
        </para>
        <para>The <see cref="M:yWorks.Layout.LayoutGraph.GetPath(yWorks.Algorithms.Edge)">path</see> of an edge, i.e., its start and end point as well as the intermediate control points, are interpreted as the set of input points. A cubic bezier curve is then fitted to these points.</para>
        <para>After the fitting, the points of the processed edges can be interpreted as cubic bezier control points. Each four consecutive points form a bezier curve, where the first and last of the four points represent the start and end of the curve and the second and third point are the control points defining how the curve looks. The second and third point do not necessarily lie on the actual curve.</para>
        <para>There are two exceptions to the stated rules:</para>
        <list type="bullet">
          <item>If an input edge only consists of a source and a target point, it will be ignored by this stage.</item>
          <item>Self-loop edges with only one intermediate control point are also ignored. Note that self-loops with more control points are, however, handled by this stage.</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>The <see cref="P:yWorks.Layout.CurveFittingLayoutStage.MaximumError">maximum allowed error</see> for the fitting process can be selected to control how high the precision should be. A high allowed error means that the approximation process has a lot of freedom. Curves are only loosely bound to the original edge path. If this is not desired, e.g., because no new intersection with other graph elements should be introduced, then a rather low error value should be specified. The lower the error value, the larger the number of bend points of an approximated edge will be.</para>
        <para>It is possible to define the set of edges that should be processed by this layout stage. Therefore, only paths of a sub-set of edges can be changed. Use a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the specified <see cref="P:yWorks.Layout.CurveFittingLayoutStage.AffectedEdgesDpKey">selection key</see> to mark edges which should be part of the considered sub-set.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.CurveFittingLayoutStage.DefaultAffectedEdgesDpKey">
      <summary>
        <para>A data provider key for selecting edges for curve fitting.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.CurveFittingLayoutStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.CurveFittingLayoutStage" /> with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.CurveFittingLayoutStage.MaximumError">
      <summary>
        <para>Gets or sets the maximum allowed error for the fitting process.</para>
      </summary>
      <remarks>
        <para>The error is defined as the minimum distance between an original input control point (i.e. bend) of and edge and the fitted bezier curve.</para>
        <para>The maximum error must be greater than or equal to zero.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified maximum error is negative</para>
      </exception>
      <value>
        <para>the maximum allowed error for the fitting process</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.CurveFittingLayoutStage.StraightControlPointRatio">
      <summary>
        <para>Gets or sets the ratio that defines the distance between the intermediate control points and the end points of a cubic segment which actually represents a straight line, i.e., in case the four points are collinear.</para>
      </summary>
      <remarks>
        <list type="bullet">
          <item>
            <c>0.33</c> - the second and third control point are equally distributed between te first and fourth point.</item>
          <item>
            <c>0.0</c> - the first and second control point as well as the third and fourth point are equal.</item>
          <item>
            <c>0.5</c> - the second and third control point are equal and exactly the mid-point between the first and fourth point.</item>
        </list>
        <para>The control point ratio is defined to be within the interval <c>[0.0, 0.5]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified ratio is outside the interval <c>[0.0, 0.5]</c></para>
      </exception>
      <value>
        <para>the control point ratio for straight-line path segments</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.CurveFittingLayoutStage.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key to look up the selection state of the edges that defines whether or not an edge's path should be approximated by a bezier curve.</para>
      </summary>
      <remarks>
        <para>If there is a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the input graph with this key, then only marked edges are processed by this layout stage. Otherwise, all edges are processed.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Algorithms.IDataProvider" /> key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for edge selection</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.CurveFittingLayoutStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Changes the edge paths of selected edges of the given graph such that they represent piecewise cubic bezier curves which approximate the original points of the path.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.DefaultLayoutGraph">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.DefaultLayoutGraph" /> is a default implementation of <see cref="T:yWorks.Layout.LayoutGraph" /> which holds the complete layout information about the graph and its elements.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DefaultLayoutGraph.nodeLabelMap">
      <summary>
        <para>A <see cref="T:yWorks.Algorithms.INodeMap" /> associating <see cref="T:yWorks.Layout.INodeLabelLayout" />s with the nodes of this graph.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.Algorithms.Node,yWorks.Layout.INodeLabelLayout[])" />
    </member>
    <member name="F:yWorks.Layout.DefaultLayoutGraph.edgeLabelMap">
      <summary>
        <para>An <see cref="T:yWorks.Algorithms.IEdgeMap" /> associating <see cref="T:yWorks.Layout.IEdgeLabelLayout" />s with the edges of this graph.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLabelLayout[])" />
    </member>
    <member name="F:yWorks.Layout.DefaultLayoutGraph.nodeLabelFeatureMap">
      <summary>
        <para>A <see cref="T:System.Collections.Generic.IDictionary`2" /> associating the owner of a node label with the node label itself.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DefaultLayoutGraph.edgeLabelFeatureMap">
      <summary>
        <para>A <see cref="T:System.Collections.Generic.IDictionary`2" /> associating the owner of an edge label with the edge label itself.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.DefaultLayoutGraph" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.#ctor(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.DefaultLayoutGraph" /> instance which is a copy of the given graph.</para>
      </summary>
      <param name="argGraph">
        <para>the original graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.#ctor(yWorks.Layout.LayoutGraph,yWorks.Algorithms.ICursor)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.DefaultLayoutGraph" /> instance which is a copy of the given subgraph.</para>
      </summary>
      <param name="graph">
        <para>the original graph</para>
      </param>
      <param name="nodeSubset">
        <para>the nodes that induce a subgraph of the original graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.GetLayout(yWorks.Algorithms.Node)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.SetLayout(yWorks.Algorithms.Node,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Specifies the layout information for the given node.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the location and size of the node.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="layout">
        <para>the layout information for the node</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.SetLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLayout)">
      <summary>
        <para>Specifies the layout information for the given edge.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the locations of the control and end points of the edge.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="layout">
        <para>the layout information for the edge</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.GetLayout(yWorks.Algorithms.Edge)">
      <param name="edge" />
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.GetLabelLayout(yWorks.Algorithms.Node)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.Algorithms.Node,yWorks.Layout.INodeLabelLayout)">
      <summary>
        <para>Specifies the layout information for all associated labels of the given node in case there is only one label.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the location, size and orientation of the label.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="layout">
        <para>the layout information for the label of the node</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.Algorithms.Node,yWorks.Layout.INodeLabelLayout[])">
      <summary>
        <para>Specifies the layout information for all associated labels of the given node.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the location, size and orientation of the label.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="layout">
        <para>the layout information for the labels of the node</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.SetLabelLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLabelLayout[])">
      <summary>
        <para>Specifies the layout information for all associated labels of the given edge.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the location, size and orientation of the label.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="layout">
        <para>the layout information for the labels of the edge</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.GetLabelLayout(yWorks.Algorithms.Edge)">
      <param name="edge" />
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.GetOwner(yWorks.Layout.INodeLabelLayout)">
      <param name="labelLayout" />
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.GetOwner(yWorks.Layout.IEdgeLabelLayout)">
      <param name="labelLayout" />
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.CreateEdgeLayout">
      <summary>
        <para>Creates a new implementation of <see cref="T:yWorks.Layout.IEdgeLayout" />.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.DefaultLayoutGraph.GetLayout(yWorks.Algorithms.Edge)" /> if there is no layout information assigned to an edge, yet. It may be overridden to create custom <see cref="T:yWorks.Layout.IEdgeLayout" />s.</para>
      </remarks>
      <returns>
        <para>the layout of an edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.CreateNodeLayout">
      <summary>
        <para>Creates a new implementation of <see cref="T:yWorks.Layout.INodeLayout" />.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.DefaultLayoutGraph.GetLayout(yWorks.Algorithms.Node)" /> if there is no layout information assigned to a node, yet. It may be overridden to create custom <see cref="T:yWorks.Layout.INodeLayout" />s.</para>
      </remarks>
      <returns>
        <para>the layout of a node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.DefaultLayoutGraph.CreateLabelFactory" />
    <member name="T:yWorks.Layout.Direction">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Direction" /> provides four main directions and some methods to work with them.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Direction.Up">
      <summary>
        <para>Decodes the up direction.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Direction.Right">
      <summary>
        <para>Decodes the right direction.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Direction.Down">
      <summary>
        <para>Decodes the down direction.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Direction.Left">
      <summary>
        <para>Decodes the left direction.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Direction.TurnCW">
      <summary>
        <para>Gets the direction that follows this direction in clockwise order.</para>
      </summary>
      <remarks>
        <para>The new direction is turned <c>90</c> degrees in clockwise direction compared to this instance.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the current direction value is invalid</para>
      </exception>
      <value>
        <para>the turned direction</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Direction.TurnCCW">
      <summary>
        <para>Gets the direction that follows this direction in counterclockwise order.</para>
      </summary>
      <remarks>
        <para>The new direction is turned <c>90</c> degrees in counterclockwise direction compared to this instance.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the current direction value is invalid</para>
      </exception>
      <value>
        <para>the turned direction</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Direction.Mirror">
      <summary>
        <para>Gets the mirror direction.</para>
      </summary>
      <remarks>
        <para>The new direction is turned <c>180</c> degrees compared to this instance.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the current direction value is invalid</para>
      </exception>
      <value>
        <para>the mirrored direction</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Direction.Horizontal">
      <summary>
        <para>Gets whether or not this direction is horizontal (<see cref="F:yWorks.Layout.Direction.Right" /> or <see cref="F:yWorks.Layout.Direction.Left" />).</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this direction is horizontal, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Direction.Vertical">
      <summary>
        <para>Gets whether or not this direction is vertical (<see cref="F:yWorks.Layout.Direction.Up" /> or <see cref="F:yWorks.Layout.Direction.Down" />).</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this direction is vertical, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Direction.GetDirection">
      <summary>
        <para>Returns the direction encoded as an integer value.</para>
      </summary>
      <returns>
        <para>
          <c>0</c> for direction <see cref="F:yWorks.Layout.Direction.Up" />, <c>1</c> for <see cref="F:yWorks.Layout.Direction.Right" />, <c>2</c> for <see cref="F:yWorks.Layout.Direction.Down" />, and <c>3</c> for <see cref="F:yWorks.Layout.Direction.Left" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Direction.ToString">
      <summary>
        <para>Returns a string representation of the direction.</para>
      </summary>
      <returns>
        <para>^ for <see cref="F:yWorks.Layout.Direction.Up" />, &gt; for <see cref="F:yWorks.Layout.Direction.Right" />, v for <see cref="F:yWorks.Layout.Direction.Down" />, and &lt; for <see cref="F:yWorks.Layout.Direction.Left" />.</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the current direction value is invalid</para>
      </exception>
    </member>
    <member name="T:yWorks.Layout.DiscreteEdgeLabelLayoutModel">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.DiscreteEdgeLabelLayoutModel" /> describes the placement of rotated labels at some predefined positions along the edge.</para>
      </summary>
      <remarks>
        <para />
        <para>The predefined positions in this model</para>
        <para>It's possible to specify a distance value that controls the distance between label and edge.</para>
        <para>Furthermore, there's the possibility to mask out arbitrary edge label candidates. This can either be done by specifying predefined candidate masks or combining several label positions with a logical <c>or</c>-operation to a user-defined mask.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.DiscreteEdgeLabelLayoutModel" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.#ctor(yWorks.Layout.DiscreteEdgeLabelPositions)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.DiscreteEdgeLabelLayoutModel" /> using the given candidate mask.</para>
      </summary>
      <remarks>
        <para>The candidates mask can either describe multiple or single valid positions.</para>
      </remarks>
      <param name="candidateMask">
        <para>the position mask that defines the allowed positions for an edge label</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.DiscreteEdgeLabelLayoutModel.CandidateMask">
      <summary>
        <para>Gets the candidate mask which specifies the valid positions for edge labels.</para>
      </summary>
      <value>
        <para>the position mask that defines the allowed positions for an edge label</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.DiscreteEdgeLabelLayoutModel.PositionRelativeToSegment">
      <summary>
        <para>Gets or sets whether or not the label position mask should be interpreted relative to the edge segment.</para>
      </summary>
      <remarks>
        <para>If this option is disabled, the position mask is interpreted in a geometric sense.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the position mask is interpreted relative to the edge segment, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.DiscreteEdgeLabelLayoutModel.AutoRotationEnabled">
      <summary>
        <para>Gets or sets whether or not edge labels are automatically rotated according to the angle of the corresponding reference edge segment.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels are automatically rotated according to the angle of the corresponding reference edge segment, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.DiscreteEdgeLabelLayoutModel.AutoFlipping">
      <summary>
        <para>Gets or sets whether or not edge labels get flipped if they would be upside down in their current position.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels get flipped if they would be upside down in their current position, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.DiscreteEdgeLabelLayoutModel.Angle">
      <summary>
        <para>Gets or sets the angle (measured in radians) of the label model.</para>
      </summary>
      <remarks>
        <para>The angle is applied in clockwise direction.</para>
      </remarks>
      <value>
        <para>the angle of the label model</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.DiscreteEdgeLabelLayoutModel.Distance">
      <summary>
        <para>Gets or sets the distance between the label's bounding box and the edge path.</para>
      </summary>
      <remarks>
        <para>The distance must be a non-negative value.</para>
      </remarks>
      <value>
        <para>the distance between the edge and the associated label</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.DiscreteEdgeLabelLayoutModel.DefaultParameter">
      <summary>
        <para>Gets a model parameter that encodes the default position of this model's allowed edge label positions.</para>
      </summary>
      <remarks>
        <para>Default positions are (in descending order):</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Center" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.SourceCenter" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Tail" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.SourceTail" />
          </item>
        </list>
        <para>Descending order means that whenever two or more of the above default positions are part of the allowed positions, then the model parameter encodes the one that is listed first.</para>
      </remarks>
      <value>
        <para>the model parameter describing the default placement of the edge label</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">
      <param name="labelBounds" />
      <param name="edgeLayout" />
      <param name="sourceNode" />
      <param name="targetNode" />
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.CreatePositionParameter(System.Int32)">
      <summary>
        <para>Returns a model parameter that encodes the specified position.</para>
      </summary>
      <remarks>
        <para>This model parameter can be passed to <see cref="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" /> to determine the label's position.</para>
      </remarks>
      <param name="position">
        <para>one of the valid positions</para>
      </param>
      <returns>
        <para>a model parameter that encodes the specified position</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the specified position is unknown</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.GetPosition(System.Object)">
      <summary>
        <para>Returns the position specifier that is encoded by the given model parameter.</para>
      </summary>
      <param name="parameter">
        <para>the model parameter</para>
      </param>
      <returns>
        <para>the position specifier</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the specified model parameter is not valid for this model</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.IsParameterValid(System.Object)">
      <summary>
        <para>Checks whether or not the given model parameter encodes a valid edge label position for this model.</para>
      </summary>
      <remarks>
        <para>If the model parameter describes a position that is accepted by the candidate mask, this is a valid parameter.</para>
      </remarks>
      <param name="parameter">
        <para>the model parameter</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the label position described by the given model parameter is allowed, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)">
      <param name="labelSize" />
      <param name="edgeLayout" />
      <param name="sourceNode" />
      <param name="targetNode" />
      <param name="param" />
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.IEdgeLabelLayout,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">
      <param name="label" />
      <param name="edgeLayout" />
      <param name="sourceNode" />
      <param name="targetNode" />
    </member>
    <member name="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.DiscreteEdgeLabelPositions)">
      <summary>
        <para>Returns the oriented box of the label for the given label position.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" /> and <see cref="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.IEdgeLabelLayout,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)" /> to retrieve a valid position.</para>
      </remarks>
      <param name="labelSize">
        <para>the size of the label that should be placed</para>
      </param>
      <param name="edgeLayout">
        <para>the layout of the edge to which the label belongs</para>
      </param>
      <param name="sourceLayout">
        <para>the layout of the source node of the label-owning edge</para>
      </param>
      <param name="targetLayout">
        <para>the layout of the target node of the label-owning edge</para>
      </param>
      <param name="position">
        <para>the label position that is valid in this model</para>
      </param>
      <returns>
        <para>the oriented box of the label</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.DiscreteNodeLabelLayoutModel">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.DiscreteNodeLabelLayoutModel" /> allows placing labels at eight positions around a node and at nine positions inside the node.</para>
      </summary>
      <remarks>
        <para />
        <para>The predefined positions in this model</para>
        <para>It's possible to specify an insets value that controls the distance between label and node.</para>
        <para>Furthermore, there's the possibility to mask out arbitrary node label candidates. This can either be done by specifying predefined candidate masks or a combination of valid positions of this model using a logical <c>or</c>-operation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.DiscreteNodeLabelLayoutModel" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.#ctor(yWorks.Layout.DiscreteNodeLabelPositions,System.Double)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.DiscreteNodeLabelLayoutModel" /> using the given candidate mask and insets.</para>
      </summary>
      <remarks>
        <para>The specified mask can also describe a single position.</para>
      </remarks>
      <param name="candidateMask">
        <para>the position mask that defines the allowed positions for a node label</para>
      </param>
      <param name="inset">
        <para>the inset value that defines the internal label distance to the node's border</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.DiscreteNodeLabelLayoutModel.CandidateMask">
      <summary>
        <para>Gets the candidate mask which specifies the valid positions for node labels.</para>
      </summary>
      <value>
        <para>the position mask that defines the allowed positions for a node label</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.DiscreteNodeLabelLayoutModel.Distance">
      <summary>
        <para>Gets or sets the distance between the label's bounding box and the node.</para>
      </summary>
      <remarks>
        <para>The distance must be a non-negative value.</para>
      </remarks>
      <value>
        <para>the distance between the node and the associated label</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.DiscreteNodeLabelLayoutModel.DefaultParameter">
      <summary>
        <para>Gets a model parameter that encodes the default position of this model's allowed node label positions.</para>
      </summary>
      <remarks>
        <para>Default positions are (in descending order):</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Layout.DiscreteNodeLabelPositions.Center" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.DiscreteNodeLabelPositions.NorthEast" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.DiscreteNodeLabelPositions.North" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.DiscreteNodeLabelPositions.East" />
          </item>
        </list>
        <para>Descending order means that whenever two or more of the above default positions are part of the allowed positions, then the model parameter encodes the one that is listed first.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.IsParameterValid(System.Object)">
      <summary>
        <para>Checks whether or not the given model parameter encodes a valid node label position for this model.</para>
      </summary>
      <remarks>
        <para>If the model parameter describes a position that is accepted by the candidate mask, this is a valid parameter.</para>
      </remarks>
      <param name="parameter">
        <para>the model parameter</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the label position described by the given model parameter is allowed, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)">
      <param name="labelSize" />
      <param name="nodeLayout" />
      <param name="parameter" />
    </member>
    <member name="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.INodeLabelLayout,yWorks.Layout.INodeLayout)">
      <param name="labelLayout" />
      <param name="nodeLayout" />
    </member>
    <member name="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,yWorks.Layout.DiscreteNodeLabelPositions)">
      <summary>
        <para>Returns the oriented box of the label for the given label position.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)" /> and <see cref="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.INodeLabelLayout,yWorks.Layout.INodeLayout)" /> to retrieve a valid position.</para>
      </remarks>
      <param name="labelSize">
        <para>the size of the label that should be placed</para>
      </param>
      <param name="nodeLayout">
        <para>the layout of the node to which the label belongs</para>
      </param>
      <param name="position">
        <para>the label position that is valid in this model</para>
      </param>
      <returns>
        <para>the oriented box of the label</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.INodeLayout)">
      <param name="labelBounds" />
      <param name="nodeLayout" />
    </member>
    <member name="T:yWorks.Layout.EdgeBundleDescriptor">
      <summary>
        <para>An <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> defines the <see cref="T:yWorks.Layout.EdgeBundling">bundling</see> settings of an edge.</para>
      </summary>
      <remarks>
        <para>The defined settings will be considered by <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> which support edge bundling.</para>
        <para>Each <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> can either be specified for a single edge or shared by several edges. It is assigned to an edge by registering a <see cref="T:yWorks.Algorithms.IDataProvider" /> with key <see cref="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey" /> to the input graph.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.EdgeBundling" />
      <seealso cref="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.EdgeBundleDescriptor.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.EdgeBundleDescriptor.#ctor(yWorks.Layout.EdgeBundleDescriptor)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> representing a copy of the given other descriptor instance.</para>
      </summary>
      <param name="descriptor">
        <para>the descriptor to copy</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.EdgeBundleDescriptor.ConsiderDirection">
      <summary>
        <para>Gets or sets whether or not the direction of the edge associated to this descriptor should be considered.</para>
      </summary>
      <remarks>
        <para>During the bundling procedure, the edges are bundled based on their direction such that the incoming edges of a node are bundled separately from its outgoing edges. If the direction of edges adjacent to a node is not considered, then they are not bundled separately.</para>
        <para>If the direction of some edges is taken into consideration while the direction of some others (adjacent to the same node) is ignored, the undirected edges are also bundled separately. This is done to distinguish them from the incoming and outgoing edges of the particular node.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the direction of the edge is considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.EdgeBundleDescriptor.Bundled">
      <summary>
        <para>Gets or sets whether or not an edge associated to this descriptor should be bundled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if an edge associated to this descriptor is bundled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.EdgeBundleDescriptor.BezierFitting">
      <summary>
        <para>Gets or sets whether or not a bezier curve should be fit to an edge associated to this descriptor.</para>
      </summary>
      <remarks>
        <para>If disabled, the edges resemble B-splines where points of the path are actually curve points. Therefore, this representation requires a high number of bends to model curves.</para>
        <para>If this feature is enabled, a bezier curve is fitted to the start and end point as well as the intermediate control points of the edge. After the fitting, the points of the edge can be interpreted as cubic bezier control points. Each four consecutive points form a bezier curve, where the first and last of the four points represent the start and end of the curve and the second and third point are the control points defining how the curve looks. The second and third point do not necessarily lie on the actual curve.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if a bezier curve is fitted to an edge associated with this descriptor, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.EdgeBundling">
      <summary>
        <para>An <see cref="T:yWorks.Layout.EdgeBundling" /> instance defines if and how the edges of a graph should be bundled by a <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see>, given that the algorithm supports edge bundling.</para>
      </summary>
      <remarks>
        <para>Bundling together multiple edges means that their common parts are to some degree merged into a bundled part. At the source and target point, the edges are again clearly split. Edge bundling is useful to increase the readability of graph drawings with a high number of edges that connect a comparably small number of nodes. Without bundling, such drawings can often contain visual clutter and feature bad readability.</para>
        <para>The bundling <see cref="P:yWorks.Layout.EdgeBundling.BundlingStrength">strength</see> and <see cref="P:yWorks.Layout.EdgeBundling.BundlingQuality">quality</see> are global settings for the bundling process. On the other hand, each edge can get specific settings by assigning a <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> to it. A <see cref="T:yWorks.Algorithms.IDataProvider" /> can be registered with the input graph with key <see cref="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey" /> to assign descriptors to edges. This allows, for example, to define which edges should actually be bundled.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.EdgeBundleDescriptor" />
      <seealso cref="P:yWorks.Layout.Circular.CircularLayout.EdgeBundling" />
    </member>
    <member name="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey">
      <summary>
        <para>A data provider key for specifying individual bundling settings for edges.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> is mapped to an edge, the <see cref="P:yWorks.Layout.EdgeBundling.DefaultBundleDescriptor">default descriptor</see> is used by the layout algorithm to obtain the bundling setup of that edge.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.EdgeBundling.DefaultBundleDescriptor" />
    </member>
    <member name="M:yWorks.Layout.EdgeBundling.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.EdgeBundling" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.EdgeBundling.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.EdgeBundling" /> instance with the given <see cref="P:yWorks.Layout.EdgeBundling.BundlingStrength">bundling strength</see> and <see cref="P:yWorks.Layout.EdgeBundling.BundlingQuality">bundling quality</see>.</para>
      </summary>
      <param name="bundlingStrength">
        <para>the bundling strength from the interval <c>[0,1]</c></para>
      </param>
      <param name="bundlingQuality">
        <para>the bundling quality from the interval <c>[0,1]</c></para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given bundling strength or quality is not within <c>[0,1]</c></para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.EdgeBundling.BundlingQuality">
      <summary>
        <para>Gets or sets the desired quality of the calculated edge bundling.</para>
      </summary>
      <remarks>
        <para>Higher quality indicates that the bundling procedure uses more sophisticated methods to compute the actual bundles and the routing of the edges. This may lead to a significantly higher running time, especially for large graphs. On the other hand, a low quality indicates that run-time is more important than highly optimized bundling results, leading to, for example, more crossings between different bundles.</para>
        <para>The quality is defined to lie within <c>[0,1]</c>, where higher values stand for higher quality.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given quality value is not within <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a value between <c>0</c> (low quality, fast) and <c>1</c> (high quality, slow)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.EdgeBundling.BundlingStrength">
      <summary>
        <para>Gets or sets the strength of the edge bundling.</para>
      </summary>
      <remarks>
        <para>The strength controls how tightly the edges are bundled and influences the shape of the curves of bundled edges. Low values lead to only slightly bundled edges; results will mostly show individual node-to-node connectivity information. High values show the connectivity on a higher level, strongly bundling edges together and generating highly curved edge paths.</para>
        <para>The bundling strength is defined as a value from the interval <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given strength is less than <c>0</c> or greater than <c>1</c></para>
      </exception>
      <value>
        <para>the bundling strength between <c>0</c> (no bundling) and <c>1</c> (strongly bundled edges).</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.EdgeBundling.DefaultBundleDescriptor">
      <summary>
        <para>Gets or sets the default <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> used for all edges which do not have a specific descriptor assigned via a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey" />.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given descriptor is <c>null</c></para>
      </exception>
      <value>
        <para>the default descriptor responsible for edges with no specific descriptor</para>
      </value>
      <seealso cref="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey" />
    </member>
    <member name="T:yWorks.Layout.EdgeLabelCandidate">
      <summary>
        <para>An <see cref="T:yWorks.Layout.EdgeLabelCandidate" /> describes one valid placement for an edge label considering the label model.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelCandidate.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YDimension,System.Object,yWorks.Layout.IEdgeLabelLayout,System.Boolean)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.EdgeLabelCandidate" /> described by location, size, model parameter and internal flag.</para>
      </summary>
      <param name="pos">
        <para>the location of the upper left corner of the candidate</para>
      </param>
      <param name="size">
        <para>the size of the candidate</para>
      </param>
      <param name="param">
        <para>the parameters of the label model associated with this candidate</para>
      </param>
      <param name="owner">
        <para>the label associated with the candidate</para>
      </param>
      <param name="internal">
        <para>
          <c>true</c> if the candidate is allowed to overlap with its owner, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelCandidate.#ctor(yWorks.Algorithms.Geometry.YOrientedRectangle,System.Object,yWorks.Layout.IEdgeLabelLayout,System.Boolean)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.EdgeLabelCandidate" /> described by its box, model parameter and internal flag.</para>
      </summary>
      <param name="labelBox">
        <para>the box that specifies the candidate's size and position</para>
      </param>
      <param name="param">
        <para>the parameters of the label model associated with this candidate</para>
      </param>
      <param name="owner">
        <para>the label associated with the candidate</para>
      </param>
      <param name="internal">
        <para>
          <c>true</c> if the candidate is allowed to overlap with its owner, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.EdgeLabelOrientationSupport">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.EdgeLabelOrientationSupport" /> provides orientation and mirroring support for <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> with integrated edge labeling.</para>
      </summary>
      <remarks>
        <para>To calculate the position and orientation of edge labels whose placements are defined with the <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" />, the <see cref="T:yWorks.Layout.OrientationLayout" /> would need the direction of the associated edge. Since this direction is not available to the <see cref="T:yWorks.Layout.OrientationLayout" />, because it is a wrapper, the calculation must be done in the core layout algorithm itself with the help of the <see cref="T:yWorks.Layout.EdgeLabelOrientationSupport" />.</para>
        <para>Important: Since layout algorithms with integrated edge labeling cannot deal with ambiguous preferred placement descriptors (combinations of the same setting, e.g., source or target for the <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.PlaceAlongEdge" />), <see cref="M:yWorks.Layout.EdgeLabelOrientationSupport.PreProcessLabel(yWorks.Algorithms.Graph,yWorks.Layout.LabelLayoutData,yWorks.Layout.Direction)" /> removes combinations and replaces the original descriptor with a <em>non-ambiguous</em> one during the layout calculation.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.EdgeLabelOrientationSupport" /> instance.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.OrientationLayout.ConsiderEdgeLabels" />
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.ReplaceAmbiguousLabelDescriptors(yWorks.Algorithms.Graph)">
      <summary>
        <para>Replaces the <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" />s of all edge labels in the given graph with non-ambiguous descriptors.</para>
      </summary>
      <remarks>
        <para>The non-ambiguous descriptors are retrieved from the original descriptors. They describe only one of the possible placements.</para>
        <para>This method should be called by a layout algorithm at the beginning of the layout calculation to assure that the label's placement is handled consistently.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.ResetAmbiguousLabelDescriptors(yWorks.Algorithms.Graph)">
      <summary>
        <para>Restores the <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" />s of all edge labels in the given graph with their original descriptors.</para>
      </summary>
      <remarks>
        <para>This method should be called by a layout algorithm at the end of the layout calculation to assure that the original state of the graph is not corrupted.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.PreProcessLabel(yWorks.Algorithms.Graph,yWorks.Layout.LabelLayoutData,yWorks.Layout.Direction)">
      <summary>
        <para>Prepares the label for the core layout algorithm.</para>
      </summary>
      <remarks>
        <para>First, the <see cref="P:yWorks.Layout.LabelLayoutData.PreferredPlacementDescriptor">preferred placement</see> of the edge label is replaced by a non-ambiguous <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> that has only relative references. This descriptor is orientation independent and can be used in the core layout algorithm. Second, the method rotates the <see cref="P:yWorks.Layout.LabelLayoutData.Bounds">label box</see> in respect of its <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> and the direction of the segment to which it belongs. After that call, the core layout algorithm can use the geometry (<see cref="P:yWorks.Layout.LabelLayoutData.Width" /> and <see cref="P:yWorks.Layout.LabelLayoutData.Height" />) of the label to calculate its location.</para>
        <para>This method is called by the core layout algorithm with the integrated edge labeling for each edge label before the layout algorithm uses the geometry of labels. It should be called as soon as the direction of the segment the label belongs to is determined.</para>
      </remarks>
      <param name="graph">
        <para>the graph to get the orientation information from</para>
      </param>
      <param name="label">
        <para>the information about the edge label whose segment direction is determined</para>
      </param>
      <param name="segmentDirection">
        <para>the direction of the segment the edge label belongs to</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.CreateNonAmbiguous(yWorks.Layout.PreferredPlacementDescriptor)">
      <summary>
        <para>Creates and returns a non-ambiguous <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> of the given potentially ambiguous one.</para>
      </summary>
      <remarks>
        <para>The created descriptor will be one without any combinations of settings, e.g., source or target for the <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.PlaceAlongEdge" />.</para>
      </remarks>
      <param name="ambiguous">
        <para>an ambiguous <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /></para>
      </param>
      <returns>
        <para>a non-ambiguous version of the given ambiguous <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.PostProcessLabel(yWorks.Algorithms.Graph,yWorks.Layout.LabelLayoutData)">
      <summary>
        <para>Restores the original preferred placement and updates the label rotation according to the layout orientation.</para>
      </summary>
      <remarks>
        <para>The original <see cref="P:yWorks.Layout.LabelLayoutData.PreferredPlacementDescriptor" /> that has been replaced in <see cref="M:yWorks.Layout.EdgeLabelOrientationSupport.PreProcessLabel(yWorks.Algorithms.Graph,yWorks.Layout.LabelLayoutData,yWorks.Layout.Direction)" /> gets restored. Then it moves and rotates the <see cref="P:yWorks.Layout.LabelLayoutData.Bounds">label box</see> in respect of the orientation.</para>
        <para>This method is called by the core layout algorithm with the integrated edge labeling for each edge label after the location of the label is determined.</para>
      </remarks>
      <param name="graph">
        <para>the graph to get the orientation information from</para>
      </param>
      <param name="label">
        <para>the information about the edge label whose location is determined</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.GetOrientedDirection(yWorks.Layout.Direction,yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)">
      <summary>
        <para>Transforms a direction of the layout to the oriented layout direction.</para>
      </summary>
      <param name="direction">
        <para>direction in the layout</para>
      </param>
      <param name="orientation">
        <para>the orientation of the layout</para>
      </param>
      <param name="mirrorMask">
        <para>the mask to determine whether or not the orientation is mirrored</para>
      </param>
      <returns>
        <para>the direction in the oriented layout</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.IsOrientationMirrored(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)">
      <summary>
        <para>Returns whether or not the orientation is mirrored.</para>
      </summary>
      <param name="orientation">
        <para>the orientation of the layout</para>
      </param>
      <param name="mirrorMask">
        <para>the mask to determine whether or not the orientation is mirrored</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the orientation is mirrored, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.UpdateLabelOrientation(yWorks.Layout.LabelLayoutData,yWorks.Layout.Direction)">
      <summary>
        <para>Calculates and sets the up vector of an edge label considering the preferred placement of the label as well as the direction of the edge segment the label is attached to.</para>
      </summary>
      <param name="label">
        <para>the data that describes the label orientation and is used for setting the new up vector</para>
      </param>
      <param name="segmentDirection">
        <para>the direction the edge segment is pointing to</para>
      </param>
      <seealso cref="M:yWorks.Layout.EdgeLabelOrientationSupport.GetEdgeLabelUpVector(yWorks.Layout.PreferredPlacementDescriptor,yWorks.Layout.Direction)" />
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.GetEdgeLabelUpVector(yWorks.Layout.PreferredPlacementDescriptor,yWorks.Layout.Direction)">
      <summary>
        <para>Calculates the up vector of an edge label considering the preferred placement of the label as well as the direction of the edge segment the label is attached to.</para>
      </summary>
      <param name="descriptor">
        <para>the data describing the preferred label orientation</para>
      </param>
      <param name="segmentDirection">
        <para>the direction the edge segment is pointing to</para>
      </param>
      <returns>
        <para>the up vector for the edge label that considers the preferred placement of the label as well as the direction of the edge segment the label is attached to</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.GetLabelUpVector(System.Double)">
      <summary>
        <para>Calculates the up vector for a label whose right vector is rotated clockwise by the given angle.</para>
      </summary>
      <remarks>
        <para>The up vector starts in the lower-left corner of the label and points up. If the label is paraxial it is <c>(0, -1)</c>. The right vector starts at the same point and points right. In a paraxial label it is <c>(1, 0)</c>.</para>
      </remarks>
      <param name="rightVectorAngle">
        <para>the angle in radians the right vector is rotated by</para>
      </param>
      <returns>
        <para>the up vector for a label whose right vector is rotated clockwise by the given angle</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.EdgeLabelOrientationSupport.MarkPortLabelForFallbackPlacement(yWorks.Layout.LabelLayoutData)">
      <summary>
        <para>Marks the given port label for a non-port placement (fallback).</para>
      </summary>
      <remarks>
        <para>The given edge label's <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> will internally be changed such that its <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.PlaceAlongEdge">placement along edge</see> is either <see cref="F:yWorks.Layout.LabelPlacements.AtSource" /> or <see cref="F:yWorks.Layout.LabelPlacements.AtTarget" />.</para>
        <para>Algorithms that are executed after this call and before <see cref="M:yWorks.Layout.EdgeLabelOrientationSupport.ResetAmbiguousLabelDescriptors(yWorks.Algorithms.Graph)" /> will handle port labels like normal source or target labels.</para>
      </remarks>
      <param name="portLabel">
        <para>an edge label that had a <see cref="F:yWorks.Layout.LabelPlacements.AtSourcePort" /> or <see cref="F:yWorks.Layout.LabelPlacements.AtTargetPort" /> placement preference</para>
      </param>
      <exception cref="T:System.InvalidOperationException">
        <para>if <see cref="M:yWorks.Layout.EdgeLabelOrientationSupport.ReplaceAmbiguousLabelDescriptors(yWorks.Algorithms.Graph)" /> was never called for the graph containing the given label.</para>
      </exception>
      <seealso cref="F:yWorks.Layout.LabelPlacements.AtSourcePort" />
      <seealso cref="F:yWorks.Layout.LabelPlacements.AtTargetPort" />
    </member>
    <member name="T:yWorks.Layout.FixNodeLayoutStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.FixNodeLayoutStage" /> fixes the initial position of either a <em>single</em> node or the alignment of the bounding box of several nodes (but not the positions of the individual nodes).</para>
      </summary>
      <remarks>
        <para>The absolute coordinates of the <see cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)">fix point</see> are the same before and after invoking the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. However, the relative coordinates of the nodes are altered by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.FixNodeLayoutStage.FixedNodeDpKey">
      <summary>
        <para>A data provider key for determining the nodes that should be considered fixed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.FixNodeLayoutStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.FixNodeLayoutStage" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy">
      <summary>
        <para>Gets or sets the fix point calculation policy used in <see cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Algorithms.Geometry.Rectangle2D)" /> to determine which point in the corresponding rectangle should be considered fixed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified policy is unknown</para>
      </exception>
      <value>
        <para>one of the valid fix point calculation policies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.FixNodeLayoutStage.IncludingEdges">
      <summary>
        <para>Gets or sets whether or not subgraph edges are taken into account when calculating the bounding box of the fixed nodes.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if subgraph edges are taken into account, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)" />
    </member>
    <member name="P:yWorks.Layout.FixNodeLayoutStage.IncludingLabels">
      <summary>
        <para>Gets or sets whether or not label geometries are taken into account when calculating the bounding box of the fixed nodes.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if label geometries are taken into account, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)" />
    </member>
    <member name="M:yWorks.Layout.FixNodeLayoutStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Delegates to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and moves the fixed point back to its initial location.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Calculates the fix point for the specified nodes in the specified graph.</para>
      </summary>
      <remarks>
        <para>The default implementation calls <see cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)" /> and <see cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Algorithms.Geometry.Rectangle2D)" />.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.FixNodeLayoutStage.ApplyLayout(yWorks.Layout.LayoutGraph)" /> to determine the point that will have the same coordinates before and after invoking the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. It may be overridden to introduce a custom policy for retrieving the fix point.</para>
      </remarks>
      <param name="graph">
        <para>the graph associated with the specified nodes</para>
      </param>
      <param name="fixed">
        <para>the list of nodes for which a fix point has to be determined</para>
      </param>
      <returns>
        <para>the fix point for the specified nodes in the specified graph</para>
      </returns>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />
      <seealso cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)" />
      <seealso cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Algorithms.Geometry.Rectangle2D)" />
    </member>
    <member name="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Calculates the fix point of the specified rectangle according to the policy returned by <see cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />.</para>
      </summary>
      <remarks>
        <para>If the specified rectangle is <c>null</c> or the rectangle has negative <c>width</c> or negative <c>height</c> then <c>null</c> will be returned.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)" />. It may be overridden to introduce a custom policy for retrieving the fix point.</para>
      </remarks>
      <param name="bounds">
        <para>the rectangle for which to determine the fix point</para>
      </param>
      <returns>
        <para>the fix point of the specified rectangle or <c>null</c> if nothing should be fixed</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the current fix point policy is invalid</para>
      </exception>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />
    </member>
    <member name="M:yWorks.Layout.FixNodeLayoutStage.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Calculates the bounding box of the specified nodes.</para>
      </summary>
      <remarks>
        <para>The calculated bounds may contain <see cref="P:yWorks.Layout.FixNodeLayoutStage.IncludingEdges">edges</see> and/or <see cref="P:yWorks.Layout.FixNodeLayoutStage.IncludingLabels">labels</see>.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)" /> and may be overridden to customize the size of the bounds.</para>
      </remarks>
      <param name="graph">
        <para>the graph associated with the specified nodes</para>
      </param>
      <param name="fixed">
        <para>the list of nodes for which to determine the bounding box</para>
      </param>
      <returns>
        <para>the bounding box of the specified nodes</para>
      </returns>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.IncludingEdges" />
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.IncludingLabels" />
      <seealso cref="M:yWorks.Layout.FixNodeLayoutStage.CalculateFixPoint(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList)" />
    </member>
    <member name="T:yWorks.Layout.FixPortLocationStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.FixPortLocationStage" /> ensures that layout algorithms that cannot handle port constraints keep the ports of edges with strong <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
      </summary>
      <remarks>
        <para>Without this stage, the port locations get lost.</para>
        <para>For each edge with strong <see cref="T:yWorks.Layout.PortConstraint" />s, this stage simply stores the original port and restores it after applying the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. Therefore, it either replaces the source/target port by the original port or adds the original port to the edge path calculated by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> (see method <see cref="P:yWorks.Layout.FixPortLocationStage.KeepCalculatedPorts" />).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.FixPortLocationStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.FixPortLocationStage" /> with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.FixPortLocationStage.KeepCalculatedPorts">
      <summary>
        <para>Gets or sets whether or not the final edge routes should contain the ports calculated by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>If this option is disabled, this stage simply replaces the current source/target ports (calculated by the core layout algorithm) by the original ports (for strong ports only). Otherwise, the calculated ports are still contained in the edge paths.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the final edge route should contain the ports calculated by the core layout algorithm, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.FixPortLocationStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Restores the locations of strong <see cref="T:yWorks.Layout.PortConstraint" />s after invoking the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.FreeEdgeLabelLayoutModel">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.FreeEdgeLabelLayoutModel" /> allows placing edge labels at any location.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.FreeEdgeLabelLayoutModel.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.FreeEdgeLabelLayoutModel" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.FreeEdgeLabelLayoutModel.DefaultParameter">
      <summary>
        <para>Gets the model parameter that encodes the default position of <see cref="T:yWorks.Layout.FreeEdgeLabelLayoutModel" />.</para>
      </summary>
      <remarks>
        <para>The distance of the label to the edge's source point will be <c>20</c>. The angle between the line to the center of the label and the first segment is <c>20</c> radians. The label is not rotated.</para>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.FreeEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the corresponding label box.</para>
      </remarks>
      <value>
        <para>the model parameter describing the default placement of the edge label</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.FreeEdgeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Creates a model parameter that represents the given edge label position within this model.</para>
      </summary>
      <remarks>
        <para>The created model parameter represents the current location of the given label.</para>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.FreeEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the current label box.</para>
      </remarks>
      <param name="labelBounds">
        <para>the oriented box of the label the parameter represents</para>
      </param>
      <param name="edgeLayout">
        <para>the layout of the edge to which the label belongs</para>
      </param>
      <param name="sourceLayout">
        <para>the layout of the source node of the label-owning edge</para>
      </param>
      <param name="targetLayout">
        <para>the layout of the target node of the label-owning edge</para>
      </param>
      <returns>
        <para>the model parameter representing the given label location</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if one or more of the given bounds' values are invalid, i.e., <c>NaN</c></para>
      </exception>
      <seealso cref="M:yWorks.Layout.FreeEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" />
    </member>
    <member name="M:yWorks.Layout.FreeEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)">
      <param name="labelSize" />
      <param name="edgeLayout" />
      <param name="sourceNode" />
      <param name="targetNode" />
      <param name="param" />
    </member>
    <member name="M:yWorks.Layout.FreeEdgeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.IEdgeLabelLayout,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.EdgeLabelCandidate" /> that describes the current label position.</para>
      </summary>
      <param name="labelLayout">
        <para>the label for which candidates should be generated</para>
      </param>
      <param name="edgeLayout">
        <para>the layout of the edge to which the label belongs</para>
      </param>
      <param name="sourceLayout">
        <para>the layout of the source node of the label-owning edge</para>
      </param>
      <param name="targetLayout">
        <para>the layout of the target node of the label-owning edge</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.EdgeLabelCandidate" /> instances</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter">
      <summary>
        <para>This model parameter encodes a label position within <see cref="T:yWorks.Layout.FreeEdgeLabelLayoutModel" />.</para>
      </summary>
      <remarks>
        <para>It represents every possible location in relation to the source point of the edge. The radius describes the distance of the label center from the source point. There is an angle <c>theta</c> which defines the location on the circle with the given radius. It is the angle between the first segment of the underlying edge and the imaginary line to the center of the label. Finally, there is a second angle that describes the rotation of the label box.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)" />
      <seealso cref="P:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter.Angle" />
    </member>
    <member name="M:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter" /> with radius <c>50</c> and angle <c>0</c>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter.#ctor(System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter" /> with the given radius, angle and rotation angle.</para>
      </summary>
      <param name="radius">
        <para>the distance of the label from the source node of the underlying edge</para>
      </param>
      <param name="theta">
        <para>the angle in radians between the first segment of the underlying edge and the imaginary line to the center of the label</para>
      </param>
      <param name="angle">
        <para>the rotation angle of the label</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter.Angle">
      <summary>
        <para>Gets or sets the rotation angle of the label that is placed using this model parameter.</para>
      </summary>
      <value>
        <para>the rotation angle of the label</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter.Point">
      <summary>
        <para>Gets a point that represents the location of the label's center in relation to the source point of the edge.</para>
      </summary>
      <remarks>
        <para>The x-coordinate corresponds to the radius which describes the distance of the label to the source point. The y-coordinate corresponds to the angle between the first segment of the underlying edge and the imaginary line to the center of the label.</para>
      </remarks>
      <value>
        <para>the location of the label in relation to the edge's source point</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)">
      <summary>
        <para>Specifies a point that represents the location of the label's center in relation to the source point of the edge.</para>
      </summary>
      <remarks>
        <para>The x-coordinate corresponds to the radius which describes the distance of the label to the source point. The y-coordinate corresponds to the angle between the first segment of the underlying edge and the imaginary line to the center of the label.</para>
      </remarks>
      <param name="radius">
        <para>the distance to the source point</para>
      </param>
      <param name="theta">
        <para>the location on the radius</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.FreeEdgeLabelLayoutModel.ModelParameter.ToString">
      <summary>
        <para>Returns a <see cref="T:System.String" /> representation of this model parameter.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:System.String" /> contains the radius around the source node on which the label is placed and the angle that describes the location on said radius.</para>
      </remarks>
      <returns>
        <para>the <see cref="T:System.String" /> representation</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.FreeNodeLabelLayoutModel">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.FreeNodeLabelLayoutModel" /> allows placing node labels at any desired position.</para>
      </summary>
      <remarks>
        <para>The location of the label does not need to satisfy any constraints. The <see cref="M:yWorks.Layout.FreeNodeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.INodeLayout)">model parameter</see> describes a fixed offset between the upper-left corner of the node and the center of the label.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.FreeNodeLabelLayoutModel.#ctor">
      <summary>
        <para>Returns a new instance of <see cref="T:yWorks.Layout.FreeNodeLabelLayoutModel" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.FreeNodeLabelLayoutModel.DefaultParameter">
      <summary>
        <para>Gets a model parameter that encodes the default position of <see cref="T:yWorks.Layout.INodeLabelLayoutModel" />.</para>
      </summary>
      <remarks>
        <para>The node label's upper-left corner is placed <c>20</c> pixels to the left and <c>20</c> pixels above the node.</para>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.FreeNodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the corresponding label box.</para>
      </remarks>
      <value>
        <para>the model parameter describing the default placement of the node label</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.FreeNodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)">
      <param name="labelSize" />
      <param name="nodeLayout" />
      <param name="param" />
    </member>
    <member name="M:yWorks.Layout.FreeNodeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.INodeLabelLayout,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.NodeLabelCandidate" /> that describes the current label position.</para>
      </summary>
      <param name="labelLayout">
        <para>the label for which candidates should be generated</para>
      </param>
      <param name="nodeLayout">
        <para>the layout of the node to which the label belongs</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.NodeLabelCandidate" /> instances</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.FreeNodeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Creates a model parameter that represents the given node label position within this model.</para>
      </summary>
      <remarks>
        <para>The created model parameter represents the current location of the given label.</para>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.FreeNodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the current label box.</para>
      </remarks>
      <param name="labelBounds">
        <para>the bounds of the label the parameter represents</para>
      </param>
      <param name="nodeLayout">
        <para>the layout of the node to which the label belongs</para>
      </param>
      <returns>
        <para>the model parameter</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if one or more of the given bounds' values are invalid, i.e., <c>NaN</c></para>
      </exception>
      <seealso cref="M:yWorks.Layout.FreeNodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)" />
    </member>
    <member name="T:yWorks.Layout.FreeNodeLabelLayoutModel.ModelParameter">
      <summary>
        <para>The model parameter that encodes a label position within <see cref="T:yWorks.Layout.FreeNodeLabelLayoutModel" />.</para>
      </summary>
      <remarks>
        <para>It represents every possible location in relation to the node. The point describes the offset of the label's center to the upper-left corner of the node.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.FreeNodeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.FreeNodeLabelLayoutModel.ModelParameter.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.FreeNodeLabelLayoutModel.ModelParameter" />.</para>
      </summary>
      <remarks>
        <para>It has no offset, i.e., the upper-left corners of both node label and node are at the same location.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.FreeNodeLabelLayoutModel.ModelParameter.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.FreeNodeLabelLayoutModel.ModelParameter" /> with the given offset.</para>
      </summary>
      <param name="dx">
        <para>the horizontal offset</para>
      </param>
      <param name="dy">
        <para>the vertical offset</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.FreeNodeLabelLayoutModel.ModelParameter.Point">
      <summary>
        <para>Gets the offset of the label's center to the upper-left corner of the node.</para>
      </summary>
      <value>
        <para>the offset</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.FreeNodeLabelLayoutModel.ModelParameter.SetPoint(System.Double,System.Double)">
      <summary>
        <para>Specifies the offset of the label's center to the upper-left corner of the node.</para>
      </summary>
      <param name="dx">
        <para>the horizontal offset</para>
      </param>
      <param name="dy">
        <para>the vertical offset</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Genealogy.FamilyTreeLayout">
      <summary>
        <para>This layout algorithm arranges genealogical graphs (family trees).</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The family trees consist of nodes that represent individuals and nodes that represent families. Individuals are connected via these family nodes. The graph is arranged in layers that describe generations. </para>
        <para>Basic Family Tree</para>
        <para>
          <h2>Concept</h2>
        </para>
        <para>In order to determine whether a node represents an individual or a partnership, a <see cref="T:yWorks.Algorithms.IDataProvider" /> has to be registered with key <see cref="F:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyTypeDpKey" />. If this <see cref="T:yWorks.Algorithms.IDataProvider" /> is missing, an <see cref="T:System.ArgumentException" /> will be thrown.</para>
        <para>This <see cref="T:yWorks.Algorithms.IDataProvider" /> provides:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Layout.Genealogy.FamilyType.Male" /> for a node representing a male individual.</item>
          <item>
            <see cref="F:yWorks.Layout.Genealogy.FamilyType.Female" /> for a node representing a female individual.</item>
          <item>
            <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> for a node representing a family.</item>
        </list>
        <para>All other values will be interpreted as if the node represents an individual.</para>
        <para>A <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> node links all members of a family. It can only have two incoming edges from the parents. Two nodes of the same type (families or individuals) cannot be directly connected. If the input graph violates these specifications, a <see cref="T:yWorks.Algorithms.InvalidGraphStructureException" /> exception will be thrown.</para>
        <para>The layout is calculated basically in two steps:</para>
        <list type="bullet">
          <item>The families are laid out by the inner layouter in a compact way.</item>
          <item>The relations between these "family groups" and their children and other families are laid out by the <see cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.TopLayout">top layout algorithm</see>.</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>The distances between nodes <see cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.SpacingBetweenFamilyMembers">in the same generation</see> as well as between <see cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.OffsetForFamilyNodes">individuals and family nodes</see> can be adjusted.</para>
        <para>Nodes in the same generation can be <see cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.Alignment">aligned</see> at three different coordinates: top, center, bottom.</para>
        <para>The location of <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> nodes can be <see cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyNodesAlwaysBelow">specified</see> in relation to the partners. This placement can be set independently for <see cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.PartnerlessBelow">parents</see>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyTypeDpKey">
      <summary>
        <para>A data provider key for assigning a node type for each node.</para>
      </summary>
      <remarks>
        <para>The layout algorithm will handle the nodes according to this type.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Genealogy.FamilyTreeLayout.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Genealogy.FamilyTreeLayout" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.TopLayout">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> that is responsible for the layout between family groups.</para>
      </summary>
      <remarks>
        <para>If the specified layout algorithm is <c>null</c>, fallback algorithm <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> is used.</para>
      </remarks>
      <value>
        <para>the layout algorithm</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.SpacingBetweenFamilyMembers">
      <summary>
        <para>Gets or sets the spacing between two nodes representing members of the same family in one generation.</para>
      </summary>
      <remarks>
        <para>Values should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given spacing is negative</para>
      </exception>
      <value>
        <para>the spacing between family members</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.OffsetForFamilyNodes">
      <summary>
        <para>Gets or sets the offset by which a <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> node is shifted down if its parents are not direct neighbors.</para>
      </summary>
      <remarks>
        <para>Values should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given offset is negative</para>
      </exception>
      <value>
        <para>the offset for <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> nodes to their parents</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.PartnerlessBelow">
      <summary>
        <para>Gets or sets whether or not <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> nodes of individuals that have only children but no partners are placed below this individual or next to it.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> nodes with only one parent will be placed below this individual, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyNodesAlwaysBelow">
      <summary>
        <para>Gets or sets whether or not <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> nodes are placed between or below the partners.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> nodes are placed below the partners, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.Genealogy.FamilyType.Family" />
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.Alignment">
      <summary>
        <para>Gets or sets the vertical alignment of the individual nodes in the same generation.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified alignment is unknown</para>
      </exception>
      <value>
        <para>one of the valid alignment specifiers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.ParallelEdgeRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing parallel edges is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing parallel edges is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouter" />
      <seealso cref="T:yWorks.Layout.ParallelEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyMembersSortingPolicy">
      <summary>
        <para>Gets or sets the order of individuals in the same generation (siblings, partners) based on their sex.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified order is unknown</para>
      </exception>
      <value>
        <para>one of the valid order specifiers</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Genealogy.FamilyTreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Applies a family tree layout to the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <exception cref="T:System.InvalidOperationException">
        <para>if no <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered using <see cref="F:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyTypeDpKey" /></para>
      </exception>
      <exception cref="T:yWorks.Algorithms.InvalidGraphStructureException">
        <para>if a <see cref="F:yWorks.Layout.Genealogy.FamilyType.Family" /> node has more than two parents or two nodes of the same type are linked together</para>
      </exception>
    </member>
    <member name="T:yWorks.Layout.Genealogy.FamilyType">
      <summary>
        <para>Enum constants that specify the node types for the <see cref="T:yWorks.Layout.Genealogy.FamilyTreeLayout" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyType.Family">
      <summary>
        <para>Type specifier for nodes that connect partners with each other and their children.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyTypeDpKey" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyType.Male">
      <summary>
        <para>Type specifier for nodes that represent men.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyTypeDpKey" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyType.Female">
      <summary>
        <para>Type specifier for nodes that represent women.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyTypeDpKey" />
    </member>
    <member name="T:yWorks.Layout.Genealogy.VerticalNodeAlignment">
      <summary>
        <para>Alignment specifier that defines that all nodes in the same layer (generation) are aligned based on their top coordinate.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.Alignment" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.VerticalNodeAlignment.Top">
      <summary>
        <para>Alignment specifier that defines that all nodes in the same layer (generation) are aligned based on their top coordinate.</para>
        <para>The descriptions of the directions are based on <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.Alignment" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.VerticalNodeAlignment.Center">
      <summary>
        <para>Alignment specifier that defines that all nodes in the same layer (generation) are aligned based on their center coordinate.</para>
        <para>The descriptions of the directions are based on <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.Alignment" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.VerticalNodeAlignment.Bottom">
      <summary>
        <para>Alignment specifier that defines that all nodes in the same layer (generation) are aligned based on their bottom coordinate.</para>
        <para>The descriptions of the directions are based on <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.Alignment" />
    </member>
    <member name="T:yWorks.Layout.Genealogy.FamilyMembersSortingPolicy">
      <summary>
        <para>Enum constants that specify how family members are sorted by the <see cref="T:yWorks.Layout.Genealogy.FamilyTreeLayout" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyMembersSortingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyMembersSortingPolicy.NoSorting">
      <summary>
        <para>Order specifier that disables sorting of individuals according to their sex.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyMembersSortingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyMembersSortingPolicy.FemaleFirst">
      <summary>
        <para>Order specifier that places female individuals before their male siblings and partners, if possible.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyMembersSortingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyMembersSortingPolicy.FemaleAlwaysFirst">
      <summary>
        <para>Order specifier that places female individuals before their male siblings and partners.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyMembersSortingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyMembersSortingPolicy.MaleFirst">
      <summary>
        <para>Order specifier that places male individuals before their female siblings and partners, if possible.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyMembersSortingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Genealogy.FamilyMembersSortingPolicy.MaleAlwaysFirst">
      <summary>
        <para>Order specifier that places male individuals before their female siblings and partners.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Genealogy.FamilyTreeLayout.FamilyMembersSortingPolicy" />
    </member>
    <member name="T:yWorks.Layout.ComponentArrangementStyles">
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.None">
      <summary>
        <para>Style specifier describing no special component arrangement at all. Components will be centered at the same position they resided at before the layout started. If combined with the style modifier <see cref="F:yWorks.Layout.ComponentArrangementStyles.ModifierNoOverlap" />, components might get moved so that they don't overlap after the layout.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.Rows">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places components in multiple rows so that the overall aspect ratio of the whole graph gets as close to the aspect ratio of the preferred layout size as possible.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.SingleRow">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places all components next to each other in a single row. If combined with the style modifier <see cref="F:yWorks.Layout.ComponentArrangementStyles.ModifierAsIs" />, components will be placed in the same order as they were placed before the layout.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.SingleColumn">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places components above each other in a single column. If combined with the style modifier <see cref="F:yWorks.Layout.ComponentArrangementStyles.ModifierAsIs" />, components will be placed in the same order as they were placed before the layout.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.PackedRectangle">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places components in a rectangular cloud around the biggest component. Entities of different components will not overlap, however the bounding boxes of the components may overlap.</para>
        <para>The aspect ratio of the rectangle is defined by the <see cref="P:yWorks.Layout.ComponentLayout.PreferredSize">preferred size</see> of the graph.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.PackedCompactRectangle">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places components in a rectangular cloud around the biggest component. Entities of different components will not overlap, however the bounding boxes of the components may overlap.</para>
        <para>In contrast to <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedRectangle" />, components might even be placed in empty spaces inside other components.</para>
        <para>The aspect ratio of the rectangle is defined by the <see cref="P:yWorks.Layout.ComponentLayout.PreferredSize">preferred size</see> of the graph.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.PackedCircle">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places components in a circular cloud around the biggest component. Entities of different components will not overlap, however the bounding boxes of the components may overlap.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.PackedCompactCircle">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places components in a circular compact cloud around the biggest component. Entities of different components will not overlap, however the bounding boxes of the components may overlap.</para>
        <para>In contrast to <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedCircle" />, components might even be placed in empty spaces inside other components.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.MultiRows">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places components in multiple rows.</para>
        <para>The strategy tries to arrange the components such that the aspect ratio of the final component placement gets as close as possible to the aspect ratio of the preferred layout size, configurable using <see cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />.</para>
        <para>In contrast to <see cref="F:yWorks.Layout.ComponentArrangementStyles.Rows" />, each row may also be divided into further sub-rows, which is especially useful if there are few very large components and many significantly smaller ones.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsCompact">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places components in multiple rows.</para>
        <para>The strategy tries to arrange the components such that the aspect ratio of the final component placement gets close to the aspect ratio of the preferred layout size, configurable using <see cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />. But in contrast to <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRows" />, this strategy does not always try to come as close to the preferred view ratio, if a ratio close to the preferred ratio only induces a lot of unused view space. This unused space will be minimized.</para>
        <para>In contrast to <see cref="F:yWorks.Layout.ComponentArrangementStyles.Rows" />, each row may also be divided into further sub-rows, which is especially useful if there are few very large components and many significantly smaller ones.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsHeightConstraint">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places the components in <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRows" /> with a restricted height. The resulting height does not exceed the preferred height (<see cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />).</para>
        <para>In contrast to <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsHeightConstraintCompact" />, the result will be an arrangement which uses as much height as possible, even if that means that all components will be arranged in one single column.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsHeightConstraintCompact">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places the components in <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRows" /> with a restricted height and as compact as possible. The resulting height does not exceed the preferred height (<see cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />).</para>
        <para>In comparison with <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsHeightConstraint" />, the result will be compacted, which means that an arrangement with the minimum width such that the height constraint is still fulfilled will be realized.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsWidthConstraint">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places the components in <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRows" /> with a restricted width. The resulting width does not exceed the preferred width (<see cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />).</para>
        <para>In contrast to <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsWidthConstraintCompact" /> the result will be an arrangement which uses as much space in width as possible, even if that means that all components will be arranged in a single row.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsWidthConstraintCompact">
      <summary>
        <para>Style specifier describing a component arrangement strategy that places the components in <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRows" /> with a restricted width and as compact as possible. The resulting width does not exceed the preferred width (<see cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />).</para>
        <para>In comparison with <see cref="F:yWorks.Layout.ComponentArrangementStyles.MultiRowsHeightConstraint" /> the result will be compacted, in order to minimize unused view space induced by components that are large in height.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
      <seealso cref="P:yWorks.Layout.ComponentLayout.PreferredSize" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.Mask">
      <summary>
        <para>A constant for masking actual style constants from style modifiers.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.ModifierAsIs">
      <summary>
        <para>A modifier that can be added to normal style specifiers to indicate that the arrangement strategy should take the initial positions of the components into account.</para>
        <para>Combining this modifier is supported with the following styles: <see cref="F:yWorks.Layout.ComponentArrangementStyles.SingleRow" />, <see cref="F:yWorks.Layout.ComponentArrangementStyles.SingleColumn" />, <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedRectangle" />, <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedCompactRectangle" />, <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedCircle" /> and <see cref="F:yWorks.Layout.ComponentArrangementStyles.PackedCompactCircle" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="F:yWorks.Layout.ComponentArrangementStyles.ModifierNoOverlap">
      <summary>
        <para>A modifier that can be added to normal style specifiers to indicate that the arrangement strategy should produce a non-overlapping component layout.</para>
        <para>Combining this modifier is not supported with <see cref="F:yWorks.Layout.ComponentArrangementStyles.None" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.ComponentLayout.Style" />
    </member>
    <member name="T:yWorks.Layout.DiscreteEdgeLabelPositions">
      <seealso cref="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.#ctor(yWorks.Layout.DiscreteEdgeLabelPositions)" />
      <seealso cref="P:yWorks.Layout.DiscreteEdgeLabelLayoutModel.CandidateMask" />
      <seealso cref="M:yWorks.Layout.DiscreteEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.DiscreteEdgeLabelPositions)" />
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.SourceHead">
      <summary>
        <para>Position specifier that describes a label placement near the source, left/above the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.Head">
      <summary>
        <para>Position specifier that describes a label placement near the middle of the edge, left/above the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.TargetHead">
      <summary>
        <para>Position specifier that describes a label placement near the target, left/above the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.SourceTail">
      <summary>
        <para>Position specifier that describes a label placement near the source, right/below the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.Tail">
      <summary>
        <para>Position specifier that describes a label placement near the middle of the edge, right/below the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.TargetTail">
      <summary>
        <para>Position specifier that describes a label placement near the target, right/below the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.SourceCenter">
      <summary>
        <para>Position specifier that describes a label placement near the source, directly on the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.Center">
      <summary>
        <para>Position specifier that describes a label placement near the middle of the edge, directly on the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.TargetCenter">
      <summary>
        <para>Position specifier that describes a label placement near the target, directly on the edge's path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.TwoPos">
      <summary>
        <para>Position mask that constrains the allowed positions to the two locations near the middle of the edge beside the edge's path.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Head" />
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Tail" />
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.Centered">
      <summary>
        <para>Position mask that constrains the allowed positions to the <see cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Center" /> of the edge's path.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Center" />
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.SixPos">
      <summary>
        <para>Position mask that constrains the allowed positions to a set of six positions beside the edge path.</para>
        <para>Two of the positions are near the source and two others are near the target. The remaining positions are in the middle of the edge.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.SourceHead" />
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.SourceTail" />
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Head" />
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Tail" />
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.TargetHead" />
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.TargetTail" />
    </member>
    <member name="F:yWorks.Layout.DiscreteEdgeLabelPositions.ThreeCenter">
      <summary>
        <para>Position mask that constrains the allowed positions to a set of three positions directly on the edge's path.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.SourceCenter" />
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.Center" />
      <seealso cref="F:yWorks.Layout.DiscreteEdgeLabelPositions.TargetCenter" />
    </member>
    <member name="T:yWorks.Layout.DiscreteNodeLabelPositions">
      <seealso cref="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.#ctor(yWorks.Layout.DiscreteNodeLabelPositions,System.Double)" />
      <seealso cref="P:yWorks.Layout.DiscreteNodeLabelLayoutModel.CandidateMask" />
      <seealso cref="M:yWorks.Layout.DiscreteNodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,yWorks.Layout.DiscreteNodeLabelPositions)" />
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.North">
      <summary>
        <para>Position specifier that describes a label placement north of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.NorthWest">
      <summary>
        <para>Position specifier that describes a label placement north-west of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.NorthEast">
      <summary>
        <para>Position specifier that describes a label placement north-east of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.East">
      <summary>
        <para>Position specifier that describes a label placement east of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.West">
      <summary>
        <para>Position specifier that describes a label placement west of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.South">
      <summary>
        <para>Position specifier that describes a label placement south of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.SouthWest">
      <summary>
        <para>Position specifier that describes a label placement south-west of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.SouthEast">
      <summary>
        <para>Position specifier that describes a label placement south-east of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.Center">
      <summary>
        <para>Position specifier that describes a label placement at the center of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.Bottom">
      <summary>
        <para>Position specifier that describes a label placement at the bottom inside the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.Top">
      <summary>
        <para>Position specifier that describes a label placement at the top inside the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.Left">
      <summary>
        <para>Position specifier that describes a label placement at the left inside the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.Right">
      <summary>
        <para>Position specifier that describes a label placement at the right inside the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.TopLeft">
      <summary>
        <para>Position specifier that describes a label placement at the top-left inside the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.TopRight">
      <summary>
        <para>Position specifier that describes a label placement at the top-right inside the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.BottomLeft">
      <summary>
        <para>Position specifier that describes a label placement at the bottom-left inside the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.BottomRight">
      <summary>
        <para>Position specifier that describes a label placement at the bottom-right inside the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.SandwichMask">
      <summary>
        <para>Position mask that constrains the positions to <see cref="F:yWorks.Layout.DiscreteNodeLabelPositions.North">above</see> and <see cref="F:yWorks.Layout.DiscreteNodeLabelPositions.South">below</see> the node.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.North" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.South" />
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.InternalMask">
      <summary>
        <para>Position mask that constrains the positions to the nine node-internal positions.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.Center" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.Top" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.Bottom" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.Left" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.Right" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.TopLeft" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.TopRight" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.BottomLeft" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.BottomRight" />
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.SidesMask">
      <summary>
        <para>Position mask that constrains the positions to the node's four sides.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.East" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.West" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.North" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.South" />
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.CornerMask">
      <summary>
        <para>Position mask that constrains the positions to the corners outside the node.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.NorthEast" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.NorthWest" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.SouthEast" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.SouthWest" />
    </member>
    <member name="F:yWorks.Layout.DiscreteNodeLabelPositions.EightPosMask">
      <summary>
        <para>Position mask that constraints the positions to the eight node-external positions.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.North" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.East" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.South" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.West" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.NorthEast" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.NorthWest" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.SouthEast" />
      <seealso cref="F:yWorks.Layout.DiscreteNodeLabelPositions.SouthWest" />
    </member>
    <member name="T:yWorks.Layout.FixPointPolicy">
      <summary>
        <para>Fix point calculation policy specifying that the <em>center</em> of a rectangle containing all fixed nodes is considered the fix point.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />
    </member>
    <member name="F:yWorks.Layout.FixPointPolicy.Center">
      <summary>
        <para>Fix point calculation policy specifying that the <em>center</em> of a rectangle containing all fixed nodes is considered the fix point.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />
    </member>
    <member name="F:yWorks.Layout.FixPointPolicy.UpperLeft">
      <summary>
        <para>Fix point calculation policy specifying that the <em>upper left corner</em> of a rectangle containing all fixed nodes is considered the fix point.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />
    </member>
    <member name="F:yWorks.Layout.FixPointPolicy.UpperRight">
      <summary>
        <para>Fix point calculation policy specifying that the <em>upper right corner</em> of a rectangle containing all fixed nodes is considered the fix point.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />
    </member>
    <member name="F:yWorks.Layout.FixPointPolicy.LowerRight">
      <summary>
        <para>Fix point calculation policy specifying that the <em>lower right corner</em> of a rectangle containing all fixed nodes is considered the fix point.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />
    </member>
    <member name="F:yWorks.Layout.FixPointPolicy.LowerLeft">
      <summary>
        <para>Fix point calculation policy specifying that the <em>lower left corner</em> of a rectangle containing all fixed nodes is considered the fix point.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.FixNodeLayoutStage.FixPointPolicy" />
    </member>
    <member name="T:yWorks.Layout.LabelPlacements">
      <seealso cref="M:yWorks.Layout.PreferredPlacementDescriptor.NewSharedInstance(yWorks.Layout.LabelPlacements)" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.PlaceAlongEdge" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.AtSource">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label should be placed near the source node of an edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.AtTarget">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label should be placed near the target node of an edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.AtCenter">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label should be placed near the center of the edge path.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.AtSourcePort">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label should be placed directly at the source port of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.AtTargetPort">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label should be placed directly at the target port of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.AlongEdgeMask">
      <summary>
        <para>Placement specifier mask that masks all placement specifiers that describe the placement along the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.OnEdge">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label should be placed on the path of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.LeftOfEdge">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label should be placed on the left hand side of the edge path.</para>
        <para>The side is interpreted relative to the direction of the edge, if no different <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideReference">side reference</see> is defined.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.RightOfEdge">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label should be placed on the right hand side of the edge path.</para>
        <para>The side is interpreted relative to the direction of the edge, if no different <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideReference">side reference</see> is defined.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.OnSideOfEdgeMask">
      <summary>
        <para>Placement specifier mask that masks all placement specifiers that describe the side of the edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelPlacements.Anywhere">
      <summary>
        <para>Preferred placement specifier for edge labels which expresses that the label can be placed anywhere along the edge or on any side of the edge.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.LayoutOrientation">
      <summary>
        <para>Orientation specifier which defines that the main layout orientation is from top to bottom.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.EdgeLabelOrientationSupport.GetOrientedDirection(yWorks.Layout.Direction,yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)" />
      <seealso cref="M:yWorks.Layout.EdgeLabelOrientationSupport.IsOrientationMirrored(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.LayoutOrientation" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="M:yWorks.Layout.OrientationLayout.#ctor(yWorks.Layout.LayoutOrientation)" />
      <seealso cref="M:yWorks.Layout.OrientationLayout.IsOrientationMirrored(yWorks.Layout.LayoutOrientation)" />
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
      <seealso cref="M:yWorks.Layout.PortCandidate.GetDirectionForLayoutOrientation(yWorks.Layout.LayoutOrientation)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.GetXOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.GetXOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.GetYOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.GetYOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.ToPortConstraintForLayoutOrientation(yWorks.Layout.LayoutOrientation)" />
    </member>
    <member name="F:yWorks.Layout.LayoutOrientation.TopToBottom">
      <summary>
        <para>Orientation specifier which defines that the main layout orientation is from top to bottom. This is the default for all layout algorithms.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LayoutOrientation.LeftToRight">
      <summary>
        <para>Orientation specifier which defines that the main layout orientation is from left to right. The layout will be rotated by <c>90</c> degrees counterclockwise.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LayoutOrientation.RightToLeft">
      <summary>
        <para>Orientation specifier which defines that the main layout orientation is from right to left. The layout will be rotated by <c>90</c> degrees clockwise.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LayoutOrientation.BottomToTop">
      <summary>
        <para>Orientation specifier which defines that the main layout orientation is from bottom to top. The layout will be flipped along the x-axis.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.RowAlignment">
      <summary>
        <para>Row alignment specifier which defines that each row will be aligned with its center.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleMultiRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,System.Double,System.Boolean,yWorks.Layout.MultiRowConstraint,yWorks.Layout.RowAlignment)" />
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="F:yWorks.Layout.RowAlignment.Leading">
      <summary>
        <para>Row alignment specifier which defines that each row will be aligned with its left border.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="F:yWorks.Layout.RowAlignment.Trailing">
      <summary>
        <para>Row alignment specifier which defines that each row will be aligned with its right border.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="F:yWorks.Layout.RowAlignment.Justified">
      <summary>
        <para>Row alignment specifier which defines that each row will be aligned with its left border and its right border.</para>
        <para>Rectangles in smaller rows will be distributed over the row, so that the row aligns with both sides.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="F:yWorks.Layout.RowAlignment.Center">
      <summary>
        <para>Row alignment specifier which defines that each row will be aligned with its center.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="T:yWorks.Layout.MultiRowConstraint">
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleMultiRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,System.Double,System.Boolean,yWorks.Layout.MultiRowConstraint,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="F:yWorks.Layout.MultiRowConstraint.None">
      <summary>
        <para>Constraint specifier for a multi-row rectangle arrangement that is unconstrained. Both, height and width, are not limited in size. The rectangles will be arranged in a way that the view ratio defined by the preferred height and width will be achieved.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleMultiRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,System.Double,System.Boolean,yWorks.Layout.MultiRowConstraint,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="F:yWorks.Layout.MultiRowConstraint.Height">
      <summary>
        <para>Constraint specifier for a multi-row rectangle arrangement that constrains the height of the layout. Limits the height of the arrangement to the given preferred height value. If some rectangles are higher than allowed, then they are placed nevertheless, but the constraint will still be considered for the rest and not weakened to the height of the higher rectangles. Having one rectangle being higher than the constraint does always result in arrangements consisting only of a single top-level row.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleMultiRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,System.Double,System.Boolean,yWorks.Layout.MultiRowConstraint,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="F:yWorks.Layout.MultiRowConstraint.Width">
      <summary>
        <para>Constraint specifier for a multi-row rectangle arrangement that constrains the width of the layout. Limits the width of the arrangement to the given preferred width value. If a rectangle is wider than allowed, then it will nevertheless be placed (in a row containing the rectangle alone), but the constraint will be still considered for other rows and not weakened.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleMultiRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,System.Double,System.Boolean,yWorks.Layout.MultiRowConstraint,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="T:yWorks.Layout.EdgeFlow">
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.DetermineEdgeFlowDirection(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="F:yWorks.Layout.EdgeFlow.Up">
      <summary>
        <para>Edge flow specifier which defines that the flow direction of most edges is up.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.DetermineEdgeFlowDirection(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="F:yWorks.Layout.EdgeFlow.Down">
      <summary>
        <para>Edge flow specifier which defines that the flow direction of most edges is down.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.DetermineEdgeFlowDirection(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="F:yWorks.Layout.EdgeFlow.Left">
      <summary>
        <para>Edge flow specifier which defines that the flow direction of most edges is left.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.DetermineEdgeFlowDirection(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="F:yWorks.Layout.EdgeFlow.Right">
      <summary>
        <para>Edge flow specifier which defines that the flow direction of most edges is right.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.DetermineEdgeFlowDirection(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="F:yWorks.Layout.EdgeFlow.None">
      <summary>
        <para>Edge flow specifier that defines that there is no main flow direction.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.DetermineEdgeFlowDirection(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="T:yWorks.Layout.NodeAlignment">
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.AlignNodeLayouts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList,yWorks.Algorithms.Node,System.Boolean,yWorks.Layout.NodeAlignment)" />
    </member>
    <member name="F:yWorks.Layout.NodeAlignment.Leading">
      <summary>
        <para>Node alignment policy that results in top-aligned nodes for vertical alignment and left-aligned nodes for horizontal alignments.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.AlignNodeLayouts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList,yWorks.Algorithms.Node,System.Boolean,yWorks.Layout.NodeAlignment)" />
    </member>
    <member name="F:yWorks.Layout.NodeAlignment.Centered">
      <summary>
        <para>Node alignment policy that results in center-aligned nodes.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.AlignNodeLayouts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList,yWorks.Algorithms.Node,System.Boolean,yWorks.Layout.NodeAlignment)" />
    </member>
    <member name="F:yWorks.Layout.NodeAlignment.Trailing">
      <summary>
        <para>Node alignment policy that results in bottom-aligned nodes for vertical alignment and right-aligned nodes for horizontal alignments.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.AlignNodeLayouts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList,yWorks.Algorithms.Node,System.Boolean,yWorks.Layout.NodeAlignment)" />
    </member>
    <member name="F:yWorks.Layout.NodeAlignment.Distributed">
      <summary>
        <para>Node alignment policy that results in vertically or horizontally distributed nodes. In this context, <em>distributed</em> means that the vertical (or horizontal) extensions of nodes do not overlap, independent of their horizontal (or vertical) position.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.AlignNodeLayouts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList,yWorks.Algorithms.Node,System.Boolean,yWorks.Layout.NodeAlignment)" />
    </member>
    <member name="T:yWorks.Layout.MirrorModes">
      <seealso cref="M:yWorks.Layout.EdgeLabelOrientationSupport.GetOrientedDirection(yWorks.Layout.Direction,yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)" />
      <seealso cref="M:yWorks.Layout.EdgeLabelOrientationSupport.IsOrientationMirrored(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)" />
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.GetMirrorMode" />
      <seealso cref="P:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.MirrorMode" />
      <seealso cref="P:yWorks.Layout.OrientationLayout.MirrorMode" />
      <seealso cref="M:yWorks.Layout.PortCandidate.GetXOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.GetYOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)" />
    </member>
    <member name="F:yWorks.Layout.MirrorModes.None">
      <summary>
        <para>Mirroring specifier that can be used for preventing any mirroring of layout orientations.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.OrientationLayout.MirrorMode" />
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="F:yWorks.Layout.MirrorModes.TopToBottom">
      <summary>
        <para>Mirroring specifier that defines that layout orientation <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" /> will be mirrored.</para>
        <para>This specifier can be used for creating a mirror mask that defines which layout orientations shall be mirrored at their corresponding axis. It can be combined with the other mirroring specifiers to mirror several orientations.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.OrientationLayout.MirrorMode" />
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="F:yWorks.Layout.MirrorModes.RightToLeft">
      <summary>
        <para>Mirroring specifier that defines that layout orientation <see cref="F:yWorks.Layout.LayoutOrientation.RightToLeft" /> will be mirrored.</para>
        <para>This specifier can be used for creating a mirror mask that defines which layout orientations shall be mirrored at their corresponding axis. It can be combined with the other mirroring specifiers to mirror several orientations.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.OrientationLayout.MirrorMode" />
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="F:yWorks.Layout.MirrorModes.BottomToTop">
      <summary>
        <para>Mirroring specifier that defines that layout orientation <see cref="F:yWorks.Layout.LayoutOrientation.BottomToTop" /> will be mirrored.</para>
        <para>This specifier can be used for creating a mirror mask that defines which layout orientations shall be mirrored at their corresponding axis. It can be combined with the other mirroring specifiers to mirror several orientations.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.OrientationLayout.MirrorMode" />
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="F:yWorks.Layout.MirrorModes.LeftToRight">
      <summary>
        <para>Mirroring specifier that defines that layout orientation <see cref="F:yWorks.Layout.LayoutOrientation.LeftToRight" /> will be mirrored.</para>
        <para>This specifier can be used to create a mirror mask that defines which layout orientations shall be mirrored at their corresponding axis. It can be combined with the other mirroring specifiers to mirror several orientations.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.OrientationLayout.MirrorMode" />
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="T:yWorks.Layout.PortDirections">
      <seealso cref="M:yWorks.Layout.PortCandidate.CreateCandidate(System.Double,System.Double,yWorks.Layout.PortDirections,System.Double)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.CreateCandidate(yWorks.Layout.PortDirections)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.CreateCandidate(yWorks.Layout.PortDirections,System.Double)" />
      <seealso cref="P:yWorks.Layout.PortCandidate.Direction" />
      <seealso cref="M:yWorks.Layout.PortCandidate.GetDirectionForLayoutOrientation(yWorks.Layout.LayoutOrientation)" />
      <seealso cref="M:yWorks.Layout.PortCandidate.IsInDirection(yWorks.Layout.PortDirections)" />
      <seealso cref="M:yWorks.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate(yWorks.Algorithms.Edge,System.Boolean,System.Double,System.Double,yWorks.Layout.PortDirections)" />
      <seealso cref="M:yWorks.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortDirections)" />
    </member>
    <member name="F:yWorks.Layout.PortDirections.North">
      <summary>
        <para>A port direction specifier indicating a port on the north (i.e., top) side of a node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortDirections.East">
      <summary>
        <para>A port direction specifier indicating a port on the east (i.e., right) side of a node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortDirections.West">
      <summary>
        <para>A port direction specifier indicating a port on the west (i.e., left) side of a node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortDirections.South">
      <summary>
        <para>A port direction specifier indicating a port on the south (i.e., bottom) side of a node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortDirections.WithTheFlow">
      <summary>
        <para>A port direction specifier indicating a port lying in the direction of the main flow of the edge or of the overall layout.</para>
        <para>The exact direction is domain-specific.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortDirections.AgainstTheFlow">
      <summary>
        <para>A port direction specifier indicating a port lying in the opposite direction of the main flow of the edge or of the overall layout.</para>
        <para>The exact direction is domain-specific.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortDirections.LeftInFlow">
      <summary>
        <para>A port direction specifier indicating a port lying left of the direction of the main flow of the edge or of the overall layout.</para>
        <para>The exact direction is domain-specific.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortDirections.RightInFlow">
      <summary>
        <para>A port direction specifier indicating a port lying right of the direction of the main flow of the edge or of the overall layout.</para>
        <para>The exact direction is domain-specific.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortDirections.Any">
      <summary>
        <para>A combination of all possible direction specifiers indicating that edges can connect to any side of a node.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.PortSide">
      <seealso cref="M:yWorks.Layout.PortConstraint.Create(yWorks.Layout.PortSide,System.Boolean)" />
      <seealso cref="P:yWorks.Layout.PortConstraint.Side" />
    </member>
    <member name="F:yWorks.Layout.PortSide.Any">
      <summary>
        <para>A weak constraint indicating that edges can connect to any side of a node.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.PortConstraint.Create(yWorks.Layout.PortSide,System.Boolean)" />
    </member>
    <member name="F:yWorks.Layout.PortSide.North">
      <summary>
        <para>A weak constraint indicating that edges can connect to the north side (i.e. top side) of a node.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.PortConstraint.Create(yWorks.Layout.PortSide,System.Boolean)" />
    </member>
    <member name="F:yWorks.Layout.PortSide.South">
      <summary>
        <para>A weak constraint indicating that edges can connect to the south side (i.e. bottom side) of a node.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.PortConstraint.Create(yWorks.Layout.PortSide,System.Boolean)" />
    </member>
    <member name="F:yWorks.Layout.PortSide.East">
      <summary>
        <para>A weak constraint indicating that edges can connect to the east side (i.e. right side) of a node.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.PortConstraint.Create(yWorks.Layout.PortSide,System.Boolean)" />
    </member>
    <member name="F:yWorks.Layout.PortSide.West">
      <summary>
        <para>A weak constraint indicating that edges can connect to the west side (i.e. left side) of a node.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.PortConstraint.Create(yWorks.Layout.PortSide,System.Boolean)" />
    </member>
    <member name="T:yWorks.Layout.LabelSideReferences">
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideReference" />
    </member>
    <member name="F:yWorks.Layout.LabelSideReferences.RelativeToEdgeFlow">
      <summary>
        <para>Side placement specifier for edge labels which expresses that the preferred side of the edge is interpreted relative to the edge flow.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideReference" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="F:yWorks.Layout.LabelSideReferences.AbsoluteWithLeftInNorth">
      <summary>
        <para>Side placement specifier for edge labels which defines that the preferred side for the label is interpreted independently of the edge direction placing <see cref="F:yWorks.Layout.LabelPlacements.LeftOfEdge">left labels</see> above horizontal segments.</para>
        <para>For vertical segments the label is placed <see cref="F:yWorks.Layout.LabelPlacements.LeftOfEdge">left</see> or <see cref="F:yWorks.Layout.LabelPlacements.RightOfEdge">right</see> of the edge. In case the segment is horizontal, the label is placed above the segment if it should be left of the edge, otherwise below the segment.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideReference" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="F:yWorks.Layout.LabelSideReferences.AbsoluteWithRightInNorth">
      <summary>
        <para>Side placement specifier for edge labels which defines that the preferred side for the label is interpreted independently of the edge direction placing <see cref="F:yWorks.Layout.LabelPlacements.RightOfEdge">left labels</see> above horizontal segments.</para>
        <para>For vertical segments the label is placed <see cref="F:yWorks.Layout.LabelPlacements.LeftOfEdge">left</see> or <see cref="F:yWorks.Layout.LabelPlacements.RightOfEdge">right</see> of the edge. In case the segment is horizontal, the label is placed above the segment if it should be right of the edge, otherwise below the segment.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideReference" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="T:yWorks.Layout.LabelAngleReferences">
      <summary>
        <para>Angle interpretation specifier for edge labels which expresses that the rotation angle should be interpreted relative to the edge slope.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleReference" />
    </member>
    <member name="F:yWorks.Layout.LabelAngleReferences.Absolute">
      <summary>
        <para>Angle interpretation specifier for edge labels which expresses that the rotation angle should be interpreted absolute and not relative to the edge slope.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleReference" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.Angle" />
    </member>
    <member name="F:yWorks.Layout.LabelAngleReferences.RelativeToEdgeFlow">
      <summary>
        <para>Angle interpretation specifier for edge labels which expresses that the rotation angle should be interpreted relative to the edge slope.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleReference" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.Angle" />
    </member>
    <member name="T:yWorks.Layout.LabelAngleOnRightSideRotations">
      <summary>
        <para>Angle interpretation specifier which expresses that the rotation angle should be interpreted <em>clockwise</em>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleRotationOnRightSide" />
    </member>
    <member name="F:yWorks.Layout.LabelAngleOnRightSideRotations.Clockwise">
      <summary>
        <para>Angle interpretation specifier which expresses that the rotation angle should be interpreted <em>clockwise</em>.</para>
        <para>Therefore, edge labels whose descriptor <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.IsRightOfEdge" /> will be co-rotating with the angle of labels that are placed left of or centered on the edge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleRotationOnRightSide" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.Angle" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="F:yWorks.Layout.LabelAngleOnRightSideRotations.CounterClockwise">
      <summary>
        <para>Angle interpretation specifier which expresses that the rotation angle should be interpreted <em>counter-clockwise</em>.</para>
        <para>Therefore, edge labels whose descriptor <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.IsRightOfEdge" /> will be counter-rotating with the angle of labels that are placed left of or centered on the edge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleRotationOnRightSide" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.Angle" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="T:yWorks.Layout.LabelAngleOnRightSideOffsets">
      <summary>
        <para>Angle offset specifier for edge labels which expresses that no additional offset should be added to the angle.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleOffsetOnRightSide" />
    </member>
    <member name="F:yWorks.Layout.LabelAngleOnRightSideOffsets.None">
      <summary>
        <para>Angle offset specifier for edge labels which expresses that no additional offset should be added to the angle.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleOffsetOnRightSide" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.Angle" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="F:yWorks.Layout.LabelAngleOnRightSideOffsets.Semi">
      <summary>
        <para>Angle offset specifier for edge labels which expresses that an additional offset of <c>180</c> degrees should be added to the angle. That way, point-symmetric label placements left and right of the edge can be attained.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleOffsetOnRightSide" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.Angle" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="T:yWorks.Layout.SliderMode">
      <summary>
        <para>Slider mode specifier which describes continuous label positions directly on the edge path.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.SliderEdgeLabelLayoutModel.#ctor(yWorks.Layout.SliderMode)" />
      <seealso cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Mode" />
    </member>
    <member name="F:yWorks.Layout.SliderMode.Center">
      <summary>
        <para>Slider mode specifier which describes continuous label positions directly on the edge path.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Mode" />
    </member>
    <member name="F:yWorks.Layout.SliderMode.Side">
      <summary>
        <para>Slider mode specifier which describes continuous label positions along the sides of the edge path.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Mode" />
    </member>
    <member name="F:yWorks.Layout.SliderMode.SingleSide">
      <summary>
        <para>Slider mode specifier which describes continuous label positions along one side of the edge path.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Mode" />
    </member>
    <member name="T:yWorks.Layout.SelfLoopStyle">
      <summary>
        <para>Self-loop style specifier which defines that the routes of self-loops are rounded.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SelfLoopRouter.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.SelfLoopStyle.Orthogonal">
      <summary>
        <para>Self-loop style specifier which defines that the routes of self-loops are orthogonal.</para>
        <para>The routes consist of an alternating sequence of horizontal and vertical line segments.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SelfLoopRouter.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.SelfLoopStyle.Rounded">
      <summary>
        <para>Self-loop style specifier which defines that the routes of self-loops are rounded.</para>
        <para>The <see cref="P:yWorks.Layout.SelfLoopRouter.LineDistance">distance between incident self-loops</see> and <see cref="P:yWorks.Layout.SelfLoopRouter.CornerApproximationPointsCount">rounding of the corners</see> can be customized for rounded self-loops.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SelfLoopRouter.LayoutStyle" />
      <seealso cref="P:yWorks.Layout.SelfLoopRouter.LineDistance" />
      <seealso cref="P:yWorks.Layout.SelfLoopRouter.CornerApproximationPointsCount" />
    </member>
    <member name="T:yWorks.Layout.SwimlanesMode">
      <seealso cref="M:yWorks.Layout.Swimlanes.ArrangeSwimlanes(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,System.Int32,yWorks.Layout.SwimlanesMode)" />
    </member>
    <member name="F:yWorks.Layout.SwimlanesMode.IgnoreGroups">
      <summary>
        <para>Swimlane ordering mode specifier defining that node grouping is ignored during the swimlane ordering optimization.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Swimlanes.ArrangeSwimlanes(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,System.Int32,yWorks.Layout.SwimlanesMode)" />
    </member>
    <member name="F:yWorks.Layout.SwimlanesMode.OnlyGroups">
      <summary>
        <para>Swimlane ordering mode specifier defining that only node grouping is considered during the swimlane ordering optimization.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Swimlanes.ArrangeSwimlanes(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,System.Int32,yWorks.Layout.SwimlanesMode)" />
    </member>
    <member name="F:yWorks.Layout.SwimlanesMode.Mixed">
      <summary>
        <para>Swimlane ordering mode specifier defining that both node grouping and edge length are considered during the swimlane ordering optimization.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Swimlanes.ArrangeSwimlanes(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,System.Int32,yWorks.Layout.SwimlanesMode)" />
    </member>
    <member name="T:yWorks.Layout.GraphLayoutLineWrapper">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.GraphLayoutLineWrapper" /> can line-wrap or column-wrap a graph layout.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> supports both wrapping a layout at a given width (height) and wrapping a layout automatically at some width (height) such that the resulting overall aspect ratio is close to a desired <see cref="P:yWorks.Layout.GraphLayoutLineWrapper.TargetRatio">target ratio</see>.</para>
        <para>The <see cref="T:yWorks.Layout.GraphLayoutLineWrapper" /> can be used on an existing graph layout or on the result of the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.GraphLayoutLineWrapper.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.GraphLayoutLineWrapper" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.GraphLayoutLineWrapper.EdgeSpacing">
      <summary>
        <para>Gets or sets the space that should be kept between edges.</para>
      </summary>
      <remarks>
        <para>The spacing must be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given spacing is a negative value</para>
      </exception>
      <value>
        <para>the space between edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.GraphLayoutLineWrapper.ColumnMode">
      <summary>
        <para>Gets or sets whether this <see cref="T:yWorks.Layout.ILayoutStage" /> wraps lines/rows or columns.</para>
      </summary>
      <remarks>
        <para>If this mode is enabled, the layout is wrapped vertically and new columns are appended to the right of the first column. Otherwise, the layout is wrapped horizontally and new rows are appended below the first row.</para>
        <para>Also, the <see cref="P:yWorks.Layout.GraphLayoutLineWrapper.FixedWidth" /> property will be interpreted as a fixed height if this mode is enabled.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> for column wrapping mode, <c>false</c> for row wrapping</para>
      </value>
      <seealso cref="P:yWorks.Layout.GraphLayoutLineWrapper.FixedWidth" />
    </member>
    <member name="P:yWorks.Layout.GraphLayoutLineWrapper.Spacing">
      <summary>
        <para>Gets or sets the space between adjacent lines of the wrapped graph layout.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Layout.GraphLayoutLineWrapper.ColumnMode">column mode</see> is enabled, this spacing defines the distance between adjacent columns.</para>
        <para>The spacing should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the spacing is negative</para>
      </exception>
      <value>
        <para>the space between the lines</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.GraphLayoutLineWrapper.Mirror">
      <summary>
        <para>Gets or sets whether or not every other line is mirrored.</para>
      </summary>
      <remarks>
        <para>When breaking a line and placing the remaining line below, this remainder can be rotated by <c>180</c> degrees. Then, the edges connecting both lines <em>stay short</em>. In case the remainder is not rotated, the edges are routed between the two lines to connect to the front of the non-mirrored line.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if every second line is rotated by <c>180</c> degrees, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks">
      <summary>
        <para>Gets or sets whether the algorithm should use the <see cref="P:yWorks.Layout.GraphLayoutLineWrapper.FixedWidth">fixed width</see> or <see cref="P:yWorks.Layout.GraphLayoutLineWrapper.TargetRatio">target aspect ratio</see> to determine line breaks.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if a fixed line width is used, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.GraphLayoutLineWrapper.FixedWidth" />
      <seealso cref="P:yWorks.Layout.GraphLayoutLineWrapper.TargetRatio" />
    </member>
    <member name="P:yWorks.Layout.GraphLayoutLineWrapper.TargetRatio">
      <summary>
        <para>Gets or sets the desired target aspect ratio for the layout.</para>
      </summary>
      <remarks>
        <para>The aspect ratio needs to be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the target ratio is <c>0</c> or less</para>
      </exception>
      <value>
        <para>the desired target aspect ratio in terms of <c>width/height</c></para>
      </value>
      <seealso cref="P:yWorks.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks" />
    </member>
    <member name="P:yWorks.Layout.GraphLayoutLineWrapper.FixedWidth">
      <summary>
        <para>Gets or sets the desired width of the lines.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.GraphLayoutLineWrapper" /> breaks the lines at the specified width.</para>
        <para>In <see cref="P:yWorks.Layout.GraphLayoutLineWrapper.ColumnMode">column mode</see>, the fixed width is interpreted as fixed height for a column.</para>
      </remarks>
      <value>
        <para>the width of the lines</para>
      </value>
      <seealso cref="P:yWorks.Layout.GraphLayoutLineWrapper.FixedWidthLineBreaks" />
      <seealso cref="P:yWorks.Layout.GraphLayoutLineWrapper.ColumnMode" />
    </member>
    <member name="M:yWorks.Layout.GraphLayoutLineWrapper.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Cuts the layout resulting from the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> at a specified width/height and shifts the remaining graph into the next row/column until the layout has the desired width/height.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Grid.ColumnDescriptor">
      <summary>
        <para>This class represents a column of a <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see> structure.</para>
      </summary>
      <remarks>
        <para>The results of the calculation of the geometry of the column will be placed into the instances of this class after the layout.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Grid.PartitionGrid" />
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.Index">
      <summary>
        <para>Gets the index of the column within the <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see>.</para>
      </summary>
      <value>
        <para>the index of the column</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grid.ColumnDescriptor.CompareTo(System.Object)">
      <summary>
        <para>Compares this <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /> instance with a given other <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /> instance based on the indices of the two instances.</para>
      </summary>
      <param name="o">
        <para>the <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /> to compare to</para>
      </param>
      <returns>
        <para>
          <c>-1</c>, <c>0</c> or <c>1</c> if this <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /> is less than, equal to, or greater than the given other <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.MinimumWidth">
      <summary>
        <para>Gets or sets the minimum width of the column.</para>
      </summary>
      <remarks>
        <para>The minimum width is defined to be at least <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum width is negative</para>
      </exception>
      <value>
        <para>the minimum column width</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.LeftInset">
      <summary>
        <para>Gets or sets the left column inset in which no element will lie in the resulting layout.</para>
      </summary>
      <remarks>
        <para>The column inset must be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the left inset is negative</para>
      </exception>
      <value>
        <para>the left column inset</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.RightInset">
      <summary>
        <para>Gets or sets the right column inset in which no element will lie in the resulting layout.</para>
      </summary>
      <remarks>
        <para>The column inset must be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the right inset is negative</para>
      </exception>
      <value>
        <para>the right column inset</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.ComputedWidth">
      <summary>
        <para>Gets or sets the computed width of the column after the layout has been calculated.</para>
      </summary>
      <remarks>
        <para>The computed width needs to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the computed width is negative</para>
      </exception>
      <value>
        <para>the computed width</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.OriginalWidth">
      <summary>
        <para>Gets or sets the original width of the column.</para>
      </summary>
      <remarks>
        <para>The original width should be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the original width is negative</para>
      </exception>
      <value>
        <para>the original width</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.OriginalPosition">
      <summary>
        <para>Gets or sets the original position (smallest x-coordinate) of the column.</para>
      </summary>
      <value>
        <para>the original position (smallest x-coordinate)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.ComputedPosition">
      <summary>
        <para>Gets or sets the computed position (smallest x-coordinate) of the column after the layout has been calculated.</para>
      </summary>
      <value>
        <para>the computed position (smallest x-coordinate)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.Tightness">
      <summary>
        <para>Gets or sets the tightness factor of this column.</para>
      </summary>
      <remarks>
        <para>This value must lie within the interval <c>[0,1]</c>.</para>
        <para>The larger the value, the more the column will be forced to obtain its minimum width:</para>
        <list type="bullet">
          <item>a value of <c>0.0d</c> will disable the compression of the column.</item>
          <item>a value of <c>1.0d</c> will try to force the column to obtain its specified <see cref="P:yWorks.Layout.Grid.ColumnDescriptor.MinimumWidth">minimum width</see>.</item>
        </list>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the tightness value is outside the interval <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a tightness value from the interval <c>[0,1]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.ColumnDescriptor.IndexFixed">
      <summary>
        <para>Gets or sets whether the index of the column is fixed or it should be chosen automatically in order to minimize edge lengths.</para>
      </summary>
      <remarks>
        <para>For all columns where this property is enabled, the relative ordering given by the indices is preserved. The remaining columns may be sorted again so that the overall edge lengths are minimized.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the column index should be fixed, <c>false</c> if it may be chosen automatically</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Grid.PartitionCellId">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> represents an identifier for partition cells of a <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see> structure.</para>
      </summary>
      <seealso cref="T:yWorks.Layout.Grid.PartitionGrid" />
    </member>
    <member name="T:yWorks.Layout.Grid.PartitionCellId.Cell">
      <summary>
        <para>This class represents a single partition cell, i.e., a pair consisting of a row and a column.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionCellId.Cell.Row">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> associated with this <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see>.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionCellId.Cell.Column">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /> associated with this <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see>.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /> instance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionCellId.Cell.CompareTo(System.Object)">
      <summary>
        <para>Compares this <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instance with a given other <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instance.</para>
      </summary>
      <remarks>
        <para>The comparison is based on the indices of the <see cref="P:yWorks.Layout.Grid.PartitionCellId.Cell.Row">rows</see> and <see cref="P:yWorks.Layout.Grid.PartitionCellId.Cell.Column">columns</see> of the two pairs. A <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> is considered to be smaller than another pair if its <see cref="P:yWorks.Layout.Grid.RowDescriptor.Index">row index</see> is smaller than the row index of the other pair. If the row indices are equal, the <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> with the smaller <see cref="P:yWorks.Layout.Grid.ColumnDescriptor.Index">column index</see> is said to be smaller. Hence, two <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instances are equal, if the row and column indices are equal.</para>
      </remarks>
      <param name="o">
        <para>the <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> to be compared</para>
      </param>
      <returns>
        <para>
          <c>-1</c>, <c>0</c> or <c>1</c> if this <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> is smaller than, equal to, or greater than the given other <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionCellId.Cell.Equals(System.Object)">
      <summary>
        <para>Compares this <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instance with a given other <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instance based on their associated <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /> and <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> instances.</para>
      </summary>
      <param name="o">
        <para>the given <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instance</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the two objects are equal, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionCellId.Cell.GetHashCode">
      <summary>
        <para>Returns the hash code value for this <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instance.</para>
      </summary>
      <returns>
        <para>the hash code value for this <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /> instance</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionCellId.Cells">
      <summary>
        <para>Gets a <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of elements of type <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" />.</para>
      </summary>
      <remarks>
        <para>Each pair consists of a <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">column</see> and a <see cref="T:yWorks.Layout.Grid.RowDescriptor">row</see> defining a single <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see>.</para>
      </remarks>
      <value>
        <para>a <see cref="T:System.Collections.Generic.ICollection`1" /> of elements of type <see cref="T:yWorks.Layout.Grid.PartitionCellId.Cell" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionCellId.IsSpanning">
      <summary>
        <para>Gets whether or not this <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> represents a multi-cell, i.e., a cell spanning multiple rows/columns.</para>
      </summary>
      <remarks>
        <para>This means that it was created using <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(System.Collections.Generic.ICollection{System.Object},System.Collections.Generic.ICollection{System.Object})" />, <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(yWorks.Layout.Grid.RowDescriptor,yWorks.Layout.Grid.ColumnDescriptor,yWorks.Layout.Grid.RowDescriptor,yWorks.Layout.Grid.ColumnDescriptor)" />, <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(System.Int32,System.Int32,System.Int32,System.Int32)" />, <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateColumnSpanId(System.Int32)" /> or <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateRowSpanId(System.Int32)" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> represents a multi-cell, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionCellId.Row">
      <summary>
        <para>Gets the first <see cref="T:yWorks.Layout.Grid.RowDescriptor">row</see> associated with this <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier.</para>
      </summary>
      <value>
        <para>the first <see cref="T:yWorks.Layout.Grid.RowDescriptor">row</see> associated with this <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionCellId.Column">
      <summary>
        <para>Gets the first <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">column</see> associated with this <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier.</para>
      </summary>
      <value>
        <para>the first <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">column</see> associated with this <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionCellId.Equals(System.Object)">
      <summary>
        <para>Compares this <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance with a given other <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance.</para>
      </summary>
      <param name="o">
        <para>the given <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the two objects are equal, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionCellId.GetHashCode">
      <summary>
        <para>Returns the hash code value for this <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance.</para>
      </summary>
      <returns>
        <para>the hash code value for this <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Grid.PartitionGrid">
      <summary>
        <para>This class represents a partition grid that partitions the drawing area into rectangular partition cells.</para>
      </summary>
      <remarks>
        <para>Such a structure allows, for example, to model vertical/horizontal swimlanes which are often used in flow diagrams to separate logical units.</para>
        <para>The grid consists of rows and columns that are created using the corresponding constructors of this class or methods <see cref="M:yWorks.Layout.Grid.PartitionGrid.AddRow" /> and <see cref="M:yWorks.Layout.Grid.PartitionGrid.AddColumn" />. The <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> object has to be registered with the graph using the <see cref="T:yWorks.Algorithms.IDataProvider" /> key <see cref="F:yWorks.Layout.Grid.PartitionGrid.PartitionGridDpKey" />.</para>
        <para>Each node can be assigned to a <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> which represents a set of partition cells. The mapping has to be registered with the graph using <see cref="T:yWorks.Algorithms.IDataProvider" /> key <see cref="F:yWorks.Layout.Grid.PartitionGrid.PartitionCellIdDpKey" />. Simple partition cell identifiers which represent a single partition cell, i.e., a row/column pair, can be created using method <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateCellId(yWorks.Layout.Grid.RowDescriptor,yWorks.Layout.Grid.ColumnDescriptor)" /> or <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateCellId(System.Int32,System.Int32)" />.</para>
        <para>Nodes can also be mapped to a partition cell identifier that represents a multi-cell, i.e., a cell spanning multiple columns and rows. Please note, however, that multi-cells are not allowed to overlap each other. This means that the user has to ensure that each partition cell (row/column pair) is associated with at most one partition cell identifier. The multi-cell identifier can be created using methods <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(yWorks.Layout.Grid.RowDescriptor,yWorks.Layout.Grid.ColumnDescriptor,yWorks.Layout.Grid.RowDescriptor,yWorks.Layout.Grid.ColumnDescriptor)" />, <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(System.Int32,System.Int32,System.Int32,System.Int32)" />, <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(System.Collections.Generic.ICollection{System.Object},System.Collections.Generic.ICollection{System.Object})" />, <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateColumnSpanId(System.Int32)" />, and <see cref="M:yWorks.Layout.Grid.PartitionGrid.CreateRowSpanId(System.Int32)" />.</para>
        <para> Sample output of a layout algorithm with a partition grid</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Grid.PartitionGrid.PartitionGridDpKey">
      <summary>
        <para>A data provider key for storing the partition grid structure.</para>
      </summary>
      <remarks>
        <para>If the <see cref="T:yWorks.Algorithms.IDataProvider" /> contains a partition grid structure, this structure will be considered during layout (provided that the layout algorithm supports such constraints).</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Grid.PartitionGrid.PartitionCellIdDpKey">
      <summary>
        <para>A data provider key for storing a set of partition cells for each node.</para>
      </summary>
      <remarks>
        <para>Each node is placed inside the columns/rows defined by the corresponding <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> identifier. Instances can be shared among multiple nodes, but don't have to be shared.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Grid.PartitionCellId" />
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.#ctor">
      <summary>
        <para>Creates a new empty instance of <see cref="T:yWorks.Layout.Grid.PartitionGrid" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.#ctor(System.Int32,System.Int32)">
      <summary>
        <para>Creates an instance of <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> with the given number of rows and columns.</para>
      </summary>
      <param name="rowCount">
        <para>the number of rows</para>
      </param>
      <param name="columnCount">
        <para>the number of columns</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an instance of <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> with the given number of rows and columns as well as with given insets and minimum sizes.</para>
      </summary>
      <param name="rowCount">
        <para>the number of rows</para>
      </param>
      <param name="columnCount">
        <para>the number of columns</para>
      </param>
      <param name="rowInsets">
        <para>the top and bottom insets of the rows</para>
      </param>
      <param name="columnInsets">
        <para>the left and right insets of the columns</para>
      </param>
      <param name="minRowSize">
        <para>the minimum row height</para>
      </param>
      <param name="minColumnSize">
        <para>the minimum column width</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionGrid.OptimizeColumnOrder">
      <summary>
        <para>Gets or sets whether or not the order of the columns should be chosen automatically to minimize edge lengths.</para>
      </summary>
      <remarks>
        <para>For all columns where <see cref="P:yWorks.Layout.Grid.ColumnDescriptor.IndexFixed" /> is set to <c>true</c>, the relative ordering given by the indices is preserved. The remaining columns may be sorted again so that the overall edge lengths are minimized.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the order is chosen automatically, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionGrid.OptimizeRowOrder">
      <summary>
        <para>Gets or sets whether or not the order of the rows should be chosen automatically to minimize edge lengths.</para>
      </summary>
      <remarks>
        <para>For all rows where <see cref="P:yWorks.Layout.Grid.RowDescriptor.IndexFixed" /> is set to <c>true</c>, the relative ordering given by the indices is preserved. The remaining rows may be sorted again so that the overall edge lengths are minimized.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the order is chosen automatically, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.CreateColumnSpanId(System.Int32)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier that represents a cell spanning a whole column.</para>
      </summary>
      <remarks>
        <para>A group node mapped to such a partition cell identifier represents the column, i.e., its enclosing boundary corresponds to that of the column. The boundary does not depend on the partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually assigned to one of the partition cells. Furthermore, edges incident to such a group node are not considered during the layout.</para>
      </remarks>
      <param name="columnIndex">
        <para>the column index of the column defining the cell</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier that represents a multi-cell spanning multiple columns and rows.</para>
      </summary>
      <remarks>
        <para>The partition cell identifier represents all cells defined by a row with index between <c>fromRowIndex</c> and <c>toRowIndex</c> (both including) and a column with index between <c>fromColIndex</c> and <c>toColIndex</c> (both including).</para>
        <para>A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds to the smallest rectangle containing all partition cells specified by the partition cell identifier. The boundary does not depend on the partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually assigned to one of the partition cells. Furthermore, edges incident to such a group node are not considered during the layout.</para>
      </remarks>
      <param name="fromRowIndex">
        <para>the row index of the topmost row defining the cell</para>
      </param>
      <param name="fromColIndex">
        <para>the column index of the leftmost column defining the cell</para>
      </param>
      <param name="toRowIndex">
        <para>the row index of the bottommost row defining the cell</para>
      </param>
      <param name="toColIndex">
        <para>the column index of the rightmost column defining the cell</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(System.Collections.Generic.ICollection{System.Object},System.Collections.Generic.ICollection{System.Object})">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier that represents a multi-cell spanning multiple columns and rows.</para>
      </summary>
      <remarks>
        <para>The partition cell identifier represents all cells spanned by the columns of <c>columnList</c> and rows of <c>rowList</c>.</para>
        <para>A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds to the smallest rectangle containing all partition cells specified by the partition cell identifier. The boundary does not depend on the partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually assigned to one of the partition cells. Furthermore, edges incident to such a group node are not considered during the layout.</para>
      </remarks>
      <param name="rowList">
        <para>the <see cref="T:yWorks.Layout.Grid.RowDescriptor">rows</see> defining the cell</para>
      </param>
      <param name="columnList">
        <para>the <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">columns</see> defining the cell</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.CreateCellSpanId(yWorks.Layout.Grid.RowDescriptor,yWorks.Layout.Grid.ColumnDescriptor,yWorks.Layout.Grid.RowDescriptor,yWorks.Layout.Grid.ColumnDescriptor)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier that represents a multi-cell spanning multiple columns and rows.</para>
      </summary>
      <remarks>
        <para>The partition cell identifier represents all cells defined by a row between <c>fromRow</c> and <c>toRow</c> (both including) and a column between <c>fromRow</c> and <c>toCol</c> (both including).</para>
        <para>A group node mapped to such a partition cell identifier represents the multi-cell, i.e., its boundary corresponds to the smallest rectangle containing all partition cells specified by the partition cell identifier. The boundary does not depend on the partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually assigned to one of the partition cells. Furthermore, edges incident to such a group node are not considered during the layout.</para>
      </remarks>
      <param name="fromRow">
        <para>the topmost row defining the cell</para>
      </param>
      <param name="fromCol">
        <para>the leftmost column defining the cell</para>
      </param>
      <param name="toRow">
        <para>the bottommost row defining the cell</para>
      </param>
      <param name="toCol">
        <para>the rightmost column defining the cell</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.CreateRowSpanId(System.Int32)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier that represents a cell spanning a whole row.</para>
      </summary>
      <remarks>
        <para>A group node mapped to such a partition cell identifier represents the row, i.e., its enclosing boundary corresponds to that of the row. The boundary does not depend on the partition cells associated with the group's descendants. Hence, each non-group descendant has to be manually assigned to one of the partition cells. Furthermore, edges incident to such a group node are not considered during the layout.</para>
      </remarks>
      <param name="rowIndex">
        <para>the row index of the row defining the cell</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.GetPartitionGrid(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> instance associated with the given graph.</para>
      </summary>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> of the graph or <c>null</c> if the graph has no associated partition grid</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.AddRow">
      <summary>
        <para>Adds a new <see cref="T:yWorks.Layout.Grid.RowDescriptor">row</see> to the <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> instance.</para>
      </summary>
      <remarks>
        <para>The index of the row (as returned by <see cref="P:yWorks.Layout.Grid.RowDescriptor.Index" />) is equal to the size of the list returned by <see cref="P:yWorks.Layout.Grid.PartitionGrid.Rows" />.</para>
      </remarks>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.AddColumn">
      <summary>
        <para>Adds a new <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">column</see> to the <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> instance.</para>
      </summary>
      <remarks>
        <para>The index of the column (as returned by <see cref="P:yWorks.Layout.Grid.ColumnDescriptor.Index" />) is equal to the size of the list returned by <see cref="P:yWorks.Layout.Grid.PartitionGrid.Columns" />.</para>
      </remarks>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Grid.ColumnDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.GetRow(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Grid.RowDescriptor">row</see> with the given index.</para>
      </summary>
      <param name="index">
        <para>the index of the row to be returned</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Grid.RowDescriptor">row</see> with the given index or <c>null</c> if no such row exists</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.GetColumn(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">column</see> with the given index.</para>
      </summary>
      <param name="index">
        <para>the index of the column to be returned</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">column</see> with the given index or <c>null</c> if no such column exists</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionGrid.Rows">
      <summary>
        <para>Gets the list of rows of the <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see>.</para>
      </summary>
      <value>
        <para>the list of <see cref="T:yWorks.Layout.Grid.RowDescriptor">rows</see> of this <see cref="T:yWorks.Layout.Grid.PartitionGrid" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.PartitionGrid.Columns">
      <summary>
        <para>Gets the columns of the <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see>.</para>
      </summary>
      <value>
        <para>the list of <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">columns</see> of this <see cref="T:yWorks.Layout.Grid.PartitionGrid" /></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.CreateCellId(yWorks.Layout.Grid.RowDescriptor,yWorks.Layout.Grid.ColumnDescriptor)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier that represents the cell defined by the given <see cref="T:yWorks.Layout.Grid.ColumnDescriptor">column</see> and <see cref="T:yWorks.Layout.Grid.RowDescriptor">row</see>.</para>
      </summary>
      <param name="rd">
        <para>the row defining the cell</para>
      </param>
      <param name="cd">
        <para>the column defining the cell</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given column/row is <c>null</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.CreateCellId(System.Int32,System.Int32)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Grid.PartitionCellId">partition cell</see> identifier that represents the cell defined by the given column and row index.</para>
      </summary>
      <param name="rowIndex">
        <para>the row index of the row defining the cell</para>
      </param>
      <param name="columnIndex">
        <para>the column index of the column defining the cell</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> instance</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given column/row index is not valid</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.FinalizeOrientationChange(yWorks.Layout.OrientationLayout)">
      <summary>
        <para>Finalizes the orientation changes and is called at the end of the <see cref="T:yWorks.Layout.OrientationLayout" /> stage.</para>
      </summary>
      <remarks>
        <para>Points are transferred to their final positions through <see cref="M:yWorks.Layout.OrientationLayout.CompleteTransform(yWorks.Algorithms.Geometry.YPoint)" />.</para>
      </remarks>
      <param name="orientationLayouter">
        <para>an <see cref="T:yWorks.Layout.OrientationLayout" /> instance</para>
      </param>
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="M:yWorks.Layout.Grid.PartitionGrid.PrepareOrientationChange(yWorks.Layout.OrientationLayout)">
      <summary>
        <para>Prepares for the orientation changes and is called at the beginning of the <see cref="T:yWorks.Layout.OrientationLayout" /> stage.</para>
      </summary>
      <remarks>
        <para>Original points are transferred to their temporary positions through <see cref="M:yWorks.Layout.OrientationLayout.PrepareTransform(yWorks.Algorithms.Geometry.YPoint)" />.</para>
      </remarks>
      <param name="orientationLayouter">
        <para>an <see cref="T:yWorks.Layout.OrientationLayout" /> instance</para>
      </param>
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="T:yWorks.Layout.Grid.RowDescriptor">
      <summary>
        <para>This class represents a row of a <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see> structure.</para>
      </summary>
      <remarks>
        <para>The results of the calculation of the geometry of the row will be placed into the instances of this class after the layout.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Grid.PartitionGrid" />
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.Index">
      <summary>
        <para>Gets the index of the row within the <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see>.</para>
      </summary>
      <value>
        <para>the index of the row</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grid.RowDescriptor.CompareTo(System.Object)">
      <summary>
        <para>Compares this <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> instance with a given other <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> instance based on the indices of the two instances.</para>
      </summary>
      <param name="o">
        <para>the <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> to compare to</para>
      </param>
      <returns>
        <para>
          <c>-1</c>, <c>0</c> or <c>1</c> if this <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> is less than, equal to, or greater than the given other <see cref="T:yWorks.Layout.Grid.RowDescriptor" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.MinimumHeight">
      <summary>
        <para>Gets or sets the minimum height of the row.</para>
      </summary>
      <remarks>
        <para>The minimum height is defined to be at least <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum height is negative</para>
      </exception>
      <value>
        <para>the current row height</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.TopInset">
      <summary>
        <para>Gets or sets the top inset in which no element will lie in the resulting layout.</para>
      </summary>
      <remarks>
        <para>The inset value needs to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given top inset is negative</para>
      </exception>
      <value>
        <para>the top inset</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.BottomInset">
      <summary>
        <para>Gets or sets the bottom inset in which no element will lie in the resulting layout.</para>
      </summary>
      <remarks>
        <para>The inset value needs to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given bottom inset is negative</para>
      </exception>
      <value>
        <para>the bottom inset</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.ComputedHeight">
      <summary>
        <para>Gets or sets the computed height of the row after the layout has been calculated.</para>
      </summary>
      <remarks>
        <para>The computed height needs to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the computed height is negative</para>
      </exception>
      <value>
        <para>the current computed height</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.OriginalPosition">
      <summary>
        <para>Gets or sets the original position (smallest y-coordinate) of the row.</para>
      </summary>
      <value>
        <para>the original position (smallest y-coordinate)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.OriginalHeight">
      <summary>
        <para>Gets or sets the original height of the row.</para>
      </summary>
      <remarks>
        <para>The original height needs to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the original height is negative</para>
      </exception>
      <value>
        <para>the original height</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.ComputedPosition">
      <summary>
        <para>Gets or sets the computed position (smallest y-coordinate) of the row after the layout has been calculated.</para>
      </summary>
      <value>
        <para>the computed position (smallest y-coordinate)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.Tightness">
      <summary>
        <para>Gets or sets the tightness factor of this row.</para>
      </summary>
      <remarks>
        <para>This value must lie within the interval <c>[0,1]</c>.</para>
        <para>The larger the value, the more the row will be forced to obtain its minimum height:</para>
        <list type="bullet">
          <item>a value of <c>0.0d</c> will disable the compression of the row.</item>
          <item>a value of <c>1.0d</c> will try to force the row to obtain its specified <see cref="P:yWorks.Layout.Grid.RowDescriptor.MinimumHeight">minimum height</see>.</item>
        </list>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the tightness value is outside the interval <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a tightness value from the interval <c>[0,1]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grid.RowDescriptor.IndexFixed">
      <summary>
        <para>Gets or sets whether the index of the row is fixed or it should be chosen automatically in order to minimize edge lengths.</para>
      </summary>
      <remarks>
        <para>For all rows where this property is enabled, the relative ordering given by the indices is preserved. The remaining rows may be sorted again so that the overall edge lengths are minimized.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the row index is fixed, <c>false</c> if it may be chosen automatically</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Grouping.FixGroupLayoutStage">
      <summary>
        <para>A <see cref="T:yWorks.Layout.ILayoutStage">layout stage</see> that can handle fixed nodes in hierarchically grouped graphs.</para>
      </summary>
      <remarks>
        <para>This stage guarantees that a <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> will <b>maintain
 the relative positions</b> of nodes within the same group.</para>
        <para>Also, this stage is responsible for routing edges that connect nodes belonging to hierarchically unrelated groups. More precisely, the stage temporarily replaces fixed group nodes (see <see cref="F:yWorks.Layout.Grouping.FixGroupLayoutStage.FixedGroupNodesDpKey" />) with normal nodes of the same size while the content of the groups is removed from the graph during layout.</para>
        <para>The nodes are used as placeholders and are responsible for keeping the relations to the remaining graph elements. Edges that originate from the outside of the group node and terminate in its interior (inter-edges) are redirected such that they connect to the node that replaces the group.</para>
        <para>After the layout process, the group nodes are restored and the stage inserts the content at the new group position (derived from the position of the associated node). The content itself (including the edges between content nodes) remains unchanged and is only relocated. Furthermore, the inter-edges are connected to their original source/target and the stage reroutes them using the specified inter-edge routing algorithm (see <see cref="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRouter" />).</para>
        <para> Initial graph. Nodes inside groups have to remain at their relative positions.  Example after using <see cref="T:yWorks.Layout.Grouping.FixGroupLayoutStage" /> with <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" />. Nodes inside groups did not change relative positions.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Grouping.FixGroupLayoutStage.FixedGroupNodesDpKey">
      <summary>
        <para>A data provider key for selecting group nodes whose contents should keep their relative positions.</para>
      </summary>
      <remarks>
        <para>A group node is considered <i>selected</i> in this context, if the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" /> returns <c>true</c> for the group node or any of its ancestor (group) nodes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Grouping.FixGroupLayoutStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Grouping.FixGroupLayoutStage" /> with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRoutingStyle">
      <summary>
        <para>Gets or sets the inter-edge routing style used by this layout stage.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given routing style is unknown</para>
      </exception>
      <value>
        <para>one of the predefined routing styles for inter-edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRouter">
      <summary>
        <para>Gets or sets the edge routing algorithm that is applied to route the inter-edges.</para>
      </summary>
      <remarks>
        <para>If no routing algorithm is set, a new instance of <see cref="T:yWorks.Layout.CompositeLayoutStage" /> associated with a <see cref="T:yWorks.Layout.Grouping.HideGroupsStage" /> and an <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" /> will be used.</para>
      </remarks>
      <value>
        <para>the edge routing algorithm for inter-edges</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grouping.FixGroupLayoutStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates the layout for the given graph, that is, prepares the graph by hiding the content of fixed group nodes for the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>, executes it and, finally, restores the graph and routes inter-edges.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Grouping.InterEdgeRoutingStyle">
      <seealso cref="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Grouping.InterEdgeRoutingStyle.Adopt">
      <summary>
        <para>An inter-edge routing style based on which the edge layout of inter-edges will be adopted from the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Grouping.InterEdgeRoutingStyle.Orthogonal">
      <summary>
        <para>An inter-edge routing style based on which inter-edges are routed in an orthogonal style.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRoutingStyle" />
      <seealso cref="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRouter" />
    </member>
    <member name="F:yWorks.Layout.Grouping.InterEdgeRoutingStyle.Straightline">
      <summary>
        <para>An inter-edge routing style based on which inter-edges are routed as straight lines.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRoutingStyle" />
      <seealso cref="P:yWorks.Layout.Grouping.FixGroupLayoutStage.InterEdgeRouter" />
    </member>
    <member name="T:yWorks.Layout.Grouping.GroupingKeys">
      <summary>
        <para>This interface defines <see cref="T:yWorks.Algorithms.IDataProvider" /> keys for those layout algorithms that can handle hierarchically grouped graphs.</para>
      </summary>
      <remarks>
        <para>There are two groups of <see cref="T:yWorks.Algorithms.IDataProvider" /> keys. <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with <see cref="F:yWorks.Layout.Grouping.GroupingKeys.NodeIdDpKey" />, <see cref="F:yWorks.Layout.Grouping.GroupingKeys.GroupDpKey" /> and <see cref="F:yWorks.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey" /> define the relationship of nodes within the hierarchy. A parent node is defined for each node in the graph. This parent is the containing group node. For top-level nodes, this parent is <c>null</c>.</para>
        <para>
          <see cref="F:yWorks.Layout.Grouping.GroupingKeys.GroupNodeInsetsDpKey" /> and <see cref="F:yWorks.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey" /> are used for registering <see cref="T:yWorks.Algorithms.IDataProvider" />s that add layout information to group nodes such as the insets and the minimum size respectively.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Grouping.GroupingSupport" />
    </member>
    <member name="F:yWorks.Layout.Grouping.GroupingKeys.NodeIdDpKey">
      <summary>
        <para>A data provider key for assigning a unique ID for each node.</para>
      </summary>
      <remarks>
        <para>The IDs of the nodes need to differ based on <see cref="M:System.Object.GetHashCode" /> and <see cref="M:System.Object.Equals(System.Object)" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey">
      <summary>
        <para>A data provider key for describing the hierarchy of nodes in the graph.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Grouping.GroupingKeys.NodeIdDpKey" />
    </member>
    <member name="F:yWorks.Layout.Grouping.GroupingKeys.GroupDpKey">
      <summary>
        <para>A data provider key for distinguishing normal nodes from group nodes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Grouping.GroupingKeys.GroupNodeInsetsDpKey">
      <summary>
        <para>A data provider key for assigning insets for group nodes.</para>
      </summary>
      <remarks>
        <para>Insets reserve space around the contents of a group node. Labels and other visual decorations may be placed inside this space.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey">
      <summary>
        <para>A data provider key for assigning minimum sizes for group nodes.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Grouping.GroupingSupport">
      <summary>
        <para>This class provides convenient and efficient access to the hierarchic graph structure.</para>
      </summary>
      <remarks>
        <para>The grouping information is provided through <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with the graph with keys <see cref="F:yWorks.Layout.Grouping.GroupingKeys.NodeIdDpKey" />, <see cref="F:yWorks.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey" /> and <see cref="F:yWorks.Layout.Grouping.GroupingKeys.GroupDpKey" />. It describes the hierarchy as a tree where a group node is the parent of the nodes that it contains.</para>
        <para> This is an example graph that contains group nodes.  The hierarchy tree of the grouped graph reveals the relationship among the nodes. The corresponding nodes have the same labels as in the grouped graph. Group nodes are considered as the parents of their content which can consist of group nodes and/or normal nodes. Top-level nodes are children of a <see cref="P:yWorks.Layout.Grouping.GroupingSupport.Root">virtual root</see>. Leaf nodes can either be normal nodes or empty groups.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.#ctor(yWorks.Algorithms.Graph)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Grouping.GroupingSupport" /> instance that represents the hierarchy of the graph.</para>
      </summary>
      <remarks>
        <para>The hierarchy information is cached during the constructor call. Later modifications to the graph are not considered and may lead to errors when using this <see cref="T:yWorks.Layout.Grouping.GroupingSupport" /> instance.</para>
      </remarks>
      <param name="graph">
        <para>the graph instance from which the hierarchy information is obtained</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.Init">
      <summary>
        <para>Initializes internal data structures.</para>
      </summary>
      <remarks>
        <para>This method is called from <see cref="M:yWorks.Layout.Grouping.GroupingSupport.#ctor(yWorks.Algorithms.Graph)" /> and retrieves the state of the hierarchic graph at the moment of invocation. It may be overridden to append additional information used for group handling.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.Dispose" />
    </member>
    <member name="P:yWorks.Layout.Grouping.GroupingSupport.Graph">
      <summary>
        <para>Gets the <see cref="T:yWorks.Algorithms.Graph" /> instance for which this <see cref="T:yWorks.Layout.Grouping.GroupingSupport" /> object provides hierarchy information.</para>
      </summary>
      <value>
        <para>the graph for which the hierarchic information is stored</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.CreateInfoMap(yWorks.Algorithms.Graph)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Algorithms.INodeMap" /> to store hierarchy information for each node.</para>
      </summary>
      <remarks>
        <para>This method is called in <see cref="M:yWorks.Layout.Grouping.GroupingSupport.Init" /> and may be overridden to customize how the <see cref="T:yWorks.Algorithms.INodeMap" /> is created.</para>
      </remarks>
      <param name="graph">
        <para>the current graph</para>
      </param>
      <returns>
        <para>the new instance of <see cref="T:yWorks.Algorithms.INodeMap" /></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.Init" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.DisposeInfoMap(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.DisposeInfoMap(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Disposes of the <see cref="T:yWorks.Algorithms.INodeMap" /> created to store hierarchy information for each node.</para>
      </summary>
      <remarks>
        <para>This method is called in <see cref="M:yWorks.Layout.Grouping.GroupingSupport.Dispose" /> and may be overridden to revert changes from <see cref="M:yWorks.Layout.Grouping.GroupingSupport.CreateInfoMap(yWorks.Algorithms.Graph)" />.</para>
      </remarks>
      <param name="graph">
        <para>the current graph</para>
      </param>
      <param name="infoMap">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> which contains the hierarchy information for each node</para>
      </param>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.Dispose" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.CreateInfoMap(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.GetParent(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the parent for the given node.</para>
      </summary>
      <remarks>
        <para>The parent is the containing group node.</para>
      </remarks>
      <param name="node">
        <para>the node for which the parent is determined</para>
      </param>
      <returns>
        <para>the parent of the given node or <c>null</c> for a top-level node</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given node is <c>null</c></para>
      </exception>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetChildren(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetDescendants(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetNearestCommonAncestor(yWorks.Algorithms.Node,yWorks.Algorithms.Node)" />
    </member>
    <member name="P:yWorks.Layout.Grouping.GroupingSupport.Root">
      <summary>
        <para>Gets a <see cref="T:yWorks.Algorithms.Node" /> instance associated with the virtual root of the hierarchy tree.</para>
      </summary>
      <remarks>
        <para>This instance can be given to the <see cref="M:yWorks.Layout.Grouping.GroupingSupport.GetChildren(yWorks.Algorithms.Node)" /> to obtain the nodes of the top level of the hierarchy.</para>
      </remarks>
      <value>
        <para>the virtual root of the hierarchy tree</para>
      </value>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetChildren(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.GetChildren(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the direct children of the given group node.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Layout.Grouping.GroupingSupport.Root">virtual root of the hierarchy tree</see> is passed, all top-level nodes are returned.</para>
      </remarks>
      <param name="parent">
        <para>the group node</para>
      </param>
      <returns>
        <para>a set of child nodes of the given parent node</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Grouping.GroupingSupport.Root" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetParent(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetDescendants(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.GetDescendants(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns all descendants of the given group node.</para>
      </summary>
      <remarks>
        <para>All nodes in the subtree rooted at this group node are collected recursively.</para>
        <para>If the <see cref="P:yWorks.Layout.Grouping.GroupingSupport.Root">virtual root of the hierarchy tree</see> is passed, all nodes in the graph are returned.</para>
      </remarks>
      <param name="parent">
        <para>the group node</para>
      </param>
      <returns>
        <para>a set of nodes that belong to a subtree of the hierarchy tree rooted at the given parent</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Grouping.GroupingSupport.Root" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetParent(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetChildren(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.IsGroupNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines whether or not the given node is a group node.</para>
      </summary>
      <remarks>
        <para>While group nodes may have children, normal nodes never have children.</para>
      </remarks>
      <param name="node">
        <para>the potential group node</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given node is a group node, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.HasChildren(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.HasChildren(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines whether or not the given node is a group node with children.</para>
      </summary>
      <remarks>
        <para>Normal nodes never have children.</para>
      </remarks>
      <param name="node">
        <para>the potential parent</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given node has children, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetChildren(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.IsGroupNode(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.IsNormalEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Determines whether or not the given edge is a normal edge as opposed to an edge that crosses any group node bounds.</para>
      </summary>
      <remarks>
        <para>Source and target of a normal edge are part of the same hierarchy level and share the same parent node.</para>
      </remarks>
      <param name="edge">
        <para>the edge to check</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given edge is normal, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetEdgesGoingIn(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetEdgesGoingOut(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.GetEdgesGoingIn(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns all edges crossing the bounds of the given group node such that their targets are inside the group node while their sources lie outside the group node.</para>
      </summary>
      <param name="group">
        <para>the group node whose bounds are crossed</para>
      </param>
      <returns>
        <para>a set of edges that cross the bounds of the group node starting outside the group node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetEdgesGoingOut(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.IsNormalEdge(yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.GetEdgesGoingOut(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns all edges crossing the bounds of the given group node such that their sources are inside the group node while their targets lie outside the group node.</para>
      </summary>
      <param name="group">
        <para>the group node whose bounds are crossed</para>
      </param>
      <returns>
        <para>a set of edges that cross the bounds of the group node starting inside the group node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.GetEdgesGoingIn(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.IsNormalEdge(yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.GetRepresentative(yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns an immediate child of the group node that represents the given node.</para>
      </summary>
      <remarks>
        <para>If this node is already a child of the group node, the group node will be its representative. In case the node is located further down in the hierarchy, the child of the group node, which is also an ancestor of the node, is used. There is no representative if the node is not a descendant of the group.</para>
      </remarks>
      <param name="node">
        <para>the node for which a representative is searched</para>
      </param>
      <param name="group">
        <para>the group node to which the representative should belong</para>
      </param>
      <returns>
        <para>the representative or <c>null</c> if the node is not a descendant of the group</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given node is <c>null</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.Dispose">
      <summary>
        <para>Disposes of all internal data structures held by this <see cref="T:yWorks.Layout.Grouping.GroupingSupport">instance</see>.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Grouping.GroupingSupport" /> should be disposed of when it is not needed anymore, or if the state of the graph changes (e.g. new nodes are added).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.IsGrouped(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns whether or not the given graph is grouped.</para>
      </summary>
      <remarks>
        <para>A graph is considered to be grouped if there are <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with the graph with keys <see cref="F:yWorks.Layout.Grouping.GroupingKeys.GroupDpKey" />, <see cref="F:yWorks.Layout.Grouping.GroupingKeys.NodeIdDpKey" /> and <see cref="F:yWorks.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the graph contains hierarchic information, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.IsFlat(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.IsFlat(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns whether or not the given graph is flat.</para>
      </summary>
      <remarks>
        <para>A graph is considered to be <i>flat</i> if there exist no group nodes or there exist group nodes but none of them has children.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if there are no groups or only empty groups in the graph, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Grouping.GroupingSupport.IsGrouped(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.GroupingSupport.GetNearestCommonAncestor(yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the nearest common ancestor of the given nodes in the hierarchy structure.</para>
      </summary>
      <remarks>
        <para>The nearest common ancestor is the local root of the smallest subtree in the hierarchy tree that contains both nodes. This group is the first node that contains these two nodes. If no such node exists, the <see cref="P:yWorks.Layout.Grouping.GroupingSupport.Root">virtual root</see> is returned.</para>
        <para>Common ancestors in special cases:</para>
        <list type="bullet">
          <item>
            <c>node1 == node2</c>: the parent of <c>node1</c>/<c>node2</c></item>
          <item>
            <c>node1 is parent of node2</c>: the parent of <c>node1</c></item>
          <item>
            <c>node2 is parent of node1</c>: the parent of <c>node2</c></item>
        </list>
      </remarks>
      <param name="node1">
        <para>one of the two nodes whose common ancestor is determined</para>
      </param>
      <param name="node2">
        <para>one of the two nodes whose common ancestor is determined</para>
      </param>
      <returns>
        <para>the nearest common ancestor node or <see cref="P:yWorks.Layout.Grouping.GroupingSupport.Root" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Grouping.HideGroupsStage">
      <summary>
        <para>A <see cref="T:yWorks.Layout.ILayoutStage">layout stage</see> that hides the group nodes of hierarchically grouped graphs.</para>
      </summary>
      <remarks>
        <para>This stage removes all group nodes and adjacent edges from the graph before passing it to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. After the core layout algorithm has arranged the graph, the hidden elements will be reinserted.</para>
        <para>This stage is used by layout algorithms that cannot handle grouped graphs (e.g. <see cref="T:yWorks.Layout.Circular.CircularLayout" />).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Grouping.HideGroupsStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates an instance of <see cref="T:yWorks.Layout.Grouping.HideGroupsStage" /> with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Grouping.HideGroupsStage.HidingEmptyGroupNodes">
      <summary>
        <para>Gets or sets whether or not empty group nodes, i.e., group nodes without children, will be hidden by this stage.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if all group nodes will be hidden, <c>false</c> if only group nodes with children will be hidden</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grouping.HideGroupsStage.HideGroupNodes(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Hides the group nodes and their incident edges of the input graph.</para>
      </summary>
      <remarks>
        <para>Furthermore, this method removes all grouping-related <see cref="T:yWorks.Algorithms.IDataProvider" />s from the input graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <seealso cref="F:yWorks.Layout.Grouping.GroupingKeys.NodeIdDpKey" />
      <seealso cref="F:yWorks.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey" />
      <seealso cref="F:yWorks.Layout.Grouping.GroupingKeys.GroupDpKey" />
      <seealso cref="M:yWorks.Layout.Grouping.HideGroupsStage.UnhideGroupNodes(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.Grouping.HideGroupsStage.UnhideGroupNodes(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Un-hides the group nodes and their incident edges of the input graph that were previously hidden using method <see cref="M:yWorks.Layout.Grouping.HideGroupsStage.HideGroupNodes(yWorks.Layout.LayoutGraph)" />.</para>
      </summary>
      <remarks>
        <para>Furthermore, this method restores all previously removed grouping related <see cref="T:yWorks.Algorithms.IDataProvider" />s on the input graph.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <seealso cref="F:yWorks.Layout.Grouping.GroupingKeys.NodeIdDpKey" />
      <seealso cref="F:yWorks.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey" />
      <seealso cref="F:yWorks.Layout.Grouping.GroupingKeys.GroupDpKey" />
      <seealso cref="M:yWorks.Layout.Grouping.HideGroupsStage.HideGroupNodes(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="P:yWorks.Layout.Grouping.HideGroupsStage.GroupBoundsCalculator">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance for calculating the sizes of group nodes.</para>
      </summary>
      <remarks>
        <para>For every group which is in its open state, the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> will be asked to calculate the bounds for the group's child nodes. The resulting size will be used during the ongoing layout calculation.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grouping.HideGroupsStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates the layout based on the given core layout algorithm.</para>
      </summary>
      <remarks>
        <para>Before calling the core layout algorithm, group nodes and their adjacent edges will be hidden. After the layout has been calculated, <see cref="T:yWorks.Layout.Grouping.HideGroupsStage" /> will restore the graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Grouping.IGroupBoundsCalculator">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> is responsible for calculating the bounds of a group node during a layout process.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Grouping.IGroupBoundsCalculator.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Calculates the bounds of the given group node that contains the given list of child nodes.</para>
      </summary>
      <remarks>
        <para>This method is called during the layout process.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="groupNode">
        <para>the group node whose bounds will be calculated</para>
      </param>
      <param name="children">
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes that reside inside the group node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.Rectangle2D" /> instance that describes the bounds of the group node</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator">
      <summary>
        <para>This <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> calculates the bounds of group nodes and allows to specify custom insets for each group node.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Algorithms.Geometry.Insets">Insets</see> are provided by a <see cref="T:yWorks.Algorithms.IDataProvider" /> that must have been registered with the graph using the specified <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">insets key</see> prior to the invocation of the layout algorithm.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.#ctor(System.Object,yWorks.Algorithms.Geometry.Insets)">
      <summary>
        <para>Constructs an instance of <see cref="T:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator" /> using the given <see cref="T:yWorks.Algorithms.IDataProvider" /> key as <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">group node insets key</see> and the given insets as <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.DefaultInsets">default insets</see>.</para>
      </summary>
      <param name="insetsDataProviderKey">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key to use as <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">insets key</see></para>
      </param>
      <param name="defaultInsets">
        <para>the insets to use as <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.DefaultInsets">default insets</see></para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the labels of nodes contained in a group are considered while calculating the bounds of the group node.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the labels of the nodes are considered when calculating the bounds of the node's parent group, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.ConsiderEdgeLabels">
      <summary>
        <para>Gets or sets whether or not the labels of edges contained in a group are considered while calculating the bounds of the group node.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the labels of the edges are considered when calculating the bounds of group nodes, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.ConsiderNodeHalos">
      <summary>
        <para>Gets or sets whether or not the calculation of the bounds of a group node considers the <see cref="T:yWorks.Layout.NodeHalo">NodeHalos</see> associated with the group's child nodes.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if <see cref="T:yWorks.Layout.NodeHalo">NodeHalos</see> associated with nodes should be considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Calculates the bounds of the given group node and enlarges the bounds by the insets associated with the group node.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.Geometry.Insets">insets</see> associated with the group node will be retrieved from a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with the current <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">insets key</see>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="groupNode">
        <para>the group node whose bounds will be calculated</para>
      </param>
      <param name="children">
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes that reside inside the group node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.Rectangle2D" /> instance that describes the bounds of the group node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.CreateEnlargedBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.NodeList,yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Enlarges the given graph bounds by the insets associated with the given group node.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.Geometry.Insets">insets</see> associated with the group node will be retrieved from a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with the current <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">insets key</see>.</para>
        <para>This method is called while <see cref="M:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.NodeList)">calculating the group bounds</see> to realize the support for custom insets. It may be overridden to change the way specific insets influence the group node bounds.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="groupNode">
        <para>the group node whose bounds should be enlarged</para>
      </param>
      <param name="children">
        <para>the list of nodes that the given group node contains</para>
      </param>
      <param name="bounds">
        <para>a <see cref="T:yWorks.Algorithms.Geometry.Rectangle2D" /> instance representing the bounds of the given group node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.Rectangle2D" /> instance representing the enlarged bounds of the given group node</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.DefaultInsets">
      <summary>
        <para>Gets or sets the default insets that will be used if the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">insets key</see> does not contain a mapping for a specific node.</para>
      </summary>
      <value>
        <para>the default insets used for group nodes without specific insets</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> that is used to access the insets for the group nodes.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key must provide a mapping from each group node to a <see cref="T:yWorks.Algorithms.Geometry.Insets" /> (or <see cref="T:yWorks.Algorithms.Geometry.Insets" />) instance.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Grouping.IsolatedGroupComponentLayout">
      <summary>
        <para>A special <see cref="T:yWorks.Layout.ComponentLayout" /> implementation that allows to lay out isolated subgraphs within a group as separate components.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout">OrthogonalLayout</see> uses this layout stage to arrange components.</para>
        <para> Example of a hierarchically grouped graph with two components that are laid out by <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout">OrthogonalLayout</see> as separate components.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Grouping.IsolatedGroupComponentLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates an instance of <see cref="T:yWorks.Layout.Grouping.IsolatedGroupComponentLayout" /> with the given layout algorithm as <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>the core layout algorithm that will be invoked for each component of the graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Grouping.IsolatedGroupComponentLayout.FindIsolatedGraphComponents(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Determines the nodes that belong to the same graph component.</para>
      </summary>
      <remarks>
        <para>Unlike <see cref="T:yWorks.Layout.ComponentLayout" />, this implementation additionally identifies isolated subgraphs within a group as separate components.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="compNumber">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled by the layout algorithm, such that it contains the zero-based index of the component number to which each node belongs</para>
      </param>
      <returns>
        <para>the number of separate components</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Grouping.IsolatedGroupComponentLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates the layout based on the current <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>Before calling the core layout algorithm, the <see cref="T:yWorks.Layout.Grouping.IsolatedGroupComponentLayout" /> identifies the isolated subgraphs within a group and treats them as separate components.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator">
      <summary>
        <para>This <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> allows custom insets for group nodes and guarantees that their provided minimum sizes will be maintained.</para>
      </summary>
      <remarks>
        <para>As a subclass of <see cref="T:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator" />, this class supports custom insets for each group node. Furthermore, it guarantees that a desired minimum size is maintained. The minimum sizes are provided by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph using the specified <see cref="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey">minimum node size key</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.#ctor(System.Object)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator" /> with the given key as <see cref="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey">minimum node size key</see>.</para>
      </summary>
      <param name="minSizeDataProviderKey">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key to use as <see cref="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey">minimum size key</see></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.CalculateBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.NodeList)">
      <summary>
        <para>Calculates the bounds of the given group node, enlarges the bounds by the insets associated with the group node and makes sure that the size of the group node obeys the associated minimum size.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.Geometry.Insets">insets</see> associated with the group node will be retrieved from a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with the current <see cref="P:yWorks.Layout.Grouping.InsetsGroupBoundsCalculator.GroupNodeInsetsDpKey">insets key</see>.</para>
        <para>The minimum sizes associated with the group node will be retrieved from a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with the current <see cref="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey">minimum size key</see>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="groupNode">
        <para>the group node whose bounds will be calculated</para>
      </param>
      <param name="children">
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> containing the nodes that reside inside the group node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.Rectangle2D" /> instance that describes the bounds of the group node</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.XAlignment">
      <summary>
        <para>Gets or sets how the nodes are resized horizontally if the calculated width is smaller than the preferred minimum width of a group node.</para>
      </summary>
      <remarks>
        <para>The alignment is defined to be a value between <c>0</c> and <c>1</c>, such that:</para>
        <list type="bullet">
          <item>A value of <c>0</c> means that the nodes grow to the right while the left border remains unchanged.</item>
          <item>A value of <c>1</c> means that the nodes grow to the left while the right border remains unchanged.</item>
        </list>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given value does not lie within <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a horizontal alignment value from the interval <c>[0,1]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.YAlignment">
      <summary>
        <para>Gets or sets how the nodes are resized vertically if the calculated height is smaller than the preferred minimum height of a group node.</para>
      </summary>
      <remarks>
        <para>The alignment is defined to be a value between <c>0</c> and <c>1</c>, such that:</para>
        <list type="bullet">
          <item>A value of <c>0</c> means that the nodes grow downwards while the top border remains unchanged.</item>
          <item>A value of <c>1</c> means that the nodes grow upwards while the bottom border remains unchanged.</item>
        </list>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given value does not lie within <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a vertical alignment value from the interval <c>[0,1]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> that is used to access the minimum sizes for the group nodes.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key must provide a mapping from each group node to a <see cref="T:yWorks.Algorithms.Geometry.YDimension" /> object defining the minimum width and height of the group node.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for minimum node sizes</para>
      </value>
      <seealso cref="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.DefaultMinimumNodeSize" />
    </member>
    <member name="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.DefaultMinimumNodeSize">
      <summary>
        <para>Gets or sets the default minimum size (width and height) for group nodes.</para>
      </summary>
      <remarks>
        <para>The default minimum size is used if the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the <see cref="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey">minimum size key</see> does not contain a mapping for a group node.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given <see cref="T:yWorks.Algorithms.Geometry.YDimension" /> is <c>null</c></para>
      </exception>
      <value>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.YDimension" /> instance representing the default minimum width and height</para>
      </value>
      <seealso cref="P:yWorks.Layout.Grouping.MinimumSizeGroupBoundsCalculator.MinimumNodeSizeDpKey" />
    </member>
    <member name="T:yWorks.Layout.Grouping.RecursiveGroupLayout">
      <summary>
        <para>This layout algorithm recursively traverses a hierarchically organized graph in a bottom-up fashion and applies a specified layout algorithm to the contents (direct children) of each group node.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The way a graph is arranged depends on the <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> which are applied to the different group nodes. <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> is able to produce different layout styles for the content of each group node.</para>
        <para>This layout algorithm can be either applied if a <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> cannot handle grouped graphs by itself or if the content of (some) group nodes should be arranged differently.</para>
        <para> <h2>Concept</h2></para>
        <para>
          <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> uses a hierarchy tree representation of the grouped graph in which the content nodes are the children of their containing group node. That way, it can traverse the tree recursively while arranging only the direct children of each group node. The layout algorithm starts by arranging the leaves in the hierarchy tree, then works its way up to the root computing the layout for each group node in the tree.</para>
        <para>All nodes other than the direct children are temporarily hidden. The layout algorithm performs two steps for each group node.</para>
        <list type="number">
          <item>It arranges the direct children using either the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> or a special layout algorithm retrieved from a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Grouping.RecursiveGroupLayout.GroupNodeLayoutDpKey" />. The content of group nodes among the children is already arranged at this time and will be ignored. These group nodes are handled like normal nodes with a size that encloses the content.</item>
          <item>Then <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> computes the final size of the group node using an implementation of <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" />. Customized <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" />s can be specified using <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.GroupBoundsCalculator" />. Aside from the resulting layout, this size is used in the following iteration.</item>
        </list>
        <para>After a layout is applied to all group nodes, the layout algorithm computes routes for the edges whose source node is located at a different hierarchy level than its target node. The edge routing algorithm for these so-called inter-edges can be <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter">customized</see>.</para>
        <para>Note that <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> can run without a <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. In this case no layout is calculated, instead the group node bounds are merely adjusted to fit their respective contents.</para>
        <para>
          <h2>Features</h2> There are two alternatives for applying different layout styles to the contents of group nodes:</para>
        <list type="number">
          <item>Mapping each group node to a corresponding <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> by registering a <see cref="T:yWorks.Algorithms.IDataProvider" /> with key <see cref="F:yWorks.Layout.Grouping.RecursiveGroupLayout.GroupNodeLayoutDpKey" />. The content of the hierarchy root is arranged with the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</item>
          <item>Using <see cref="T:yWorks.Layout.LayoutMultiplexer" /> as <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</item>
        </list>
        <para>Since <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> delegates the actual arrangement of the graph to other layout algorithms, it will support the same features as the currently used layout algorithm.</para>
        <para>The improvement of the routing of inter-edges is based on the <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.AutoAssignPortCandidates">insertion</see> of <see cref="T:yWorks.Layout.PortCandidate" />s or the <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.ReplacePortConstraints">conversion</see> of <see cref="T:yWorks.Layout.PortConstraint" />s into <see cref="T:yWorks.Layout.PortCandidate" />s. Hence, they only work well if the applied layout algorithm supports <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
        <para>This algorithm also provides a <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.FromSketchMode">From Sketch mode</see> that should be activated if the applied layout algorithm runs in From Sketch mode, too. Otherwise, the initial coordinates may not be considered correctly.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Grouping.RecursiveGroupLayout.GroupNodeLayoutDpKey">
      <summary>
        <para>A data provider key for arranging the content of each group node with an individual layout algorithm.</para>
      </summary>
      <remarks>
        <para>The specified layouter instance is applied to the content of the group node. To arrange the top level elements the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> is used.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Grouping.RecursiveGroupLayout.NullLayout" />
    </member>
    <member name="F:yWorks.Layout.Grouping.RecursiveGroupLayout.SourceSplitIdDpKey">
      <summary>
        <para>A data provider key for assigning source split ids to edges connecting to group nodes.</para>
      </summary>
      <remarks>
        <para>The edges will be aligned with edges that connect to the same group node and have the same split id at their source (preferably) or target.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Grouping.RecursiveGroupLayout.TargetSplitIdDpKey" />
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.DirectGroupContentEdgeRouting" />
    </member>
    <member name="F:yWorks.Layout.Grouping.RecursiveGroupLayout.TargetSplitIdDpKey">
      <summary>
        <para>A data provider key for assigning target split ids to edges connecting to group nodes.</para>
      </summary>
      <remarks>
        <para>The edges will be aligned with edges that connect to the same group node and have the same split id at their source or target (preferably).</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Grouping.RecursiveGroupLayout.SourceSplitIdDpKey" />
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.DirectGroupContentEdgeRouting" />
    </member>
    <member name="F:yWorks.Layout.Grouping.RecursiveGroupLayout.NullLayout">
      <summary>
        <para>A constant that represents a <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> implementation that does nothing.</para>
      </summary>
      <remarks>
        <para>This implementation can be assigned to group nodes to keep their content unchanged. The layout algorithm will still calculate the sizes of the group nodes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Grouping.RecursiveGroupLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>The layout algorithm that is applied in each recursion step.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Grouping.RecursiveGroupLayout.#ctor(yWorks.Layout.ILayoutAlgorithm,yWorks.Layout.Grouping.IGroupBoundsCalculator)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> with default settings using the given <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> and <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> implementation.</para>
      </summary>
      <param name="core">
        <para>the layout algorithm that is applied in each step of the recursion</para>
      </param>
      <param name="gbc">
        <para>the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> for calculating group sizes</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Grouping.RecursiveGroupLayout.FromSketchMode">
      <summary>
        <para>Gets or sets whether or not to consider the initial coordinates of the graph elements.</para>
      </summary>
      <remarks>
        <para>When using the initial coordinates, <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> sets the coordinates of the nodes to their initial position before the corresponding <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> is called.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the initial coordinates of the graph elements are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grouping.RecursiveGroupLayout.AutoAssignPortCandidates">
      <summary>
        <para>Gets or sets whether or not temporary <see cref="T:yWorks.Layout.PortCandidate" />s are inserted to improve the routing of inter-edges.</para>
      </summary>
      <remarks>
        <para>If enabled, <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> will insert <see cref="T:yWorks.Layout.PortCandidate" />s for all inter-edges that cross a group node border. Those <see cref="T:yWorks.Layout.PortCandidate" />s are located at the relative position of the real source/target node. Inter-edges that connect to such <see cref="T:yWorks.Layout.PortCandidate" />s will be routed when the layout of the containing group node is calculated and will not be <see cref="M:yWorks.Layout.Grouping.RecursiveGroupLayout.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)">rerouted</see> later. This may produce more suitable edge routes but cannot prevent edges from crossing nodes.</para>
        <para>Without temporary or user specified <see cref="T:yWorks.Layout.PortCandidate" />s, inter-edges will always end at the border/center of the corresponding group node. Thus, they are rerouted afterwards using an <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter">edge routing algorithm</see>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if temporary port candidates are inserted</para>
      </value>
      <seealso cref="M:yWorks.Layout.Grouping.RecursiveGroupLayout.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)" />
      <seealso cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter" />
      <seealso cref="T:yWorks.Layout.PortCandidate" />
    </member>
    <member name="P:yWorks.Layout.Grouping.RecursiveGroupLayout.ReplacePortConstraints">
      <summary>
        <para>Gets or sets whether or not <see cref="T:yWorks.Layout.PortConstraint" />s of inter-edges are temporarily replaced by <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
      </summary>
      <remarks>
        <para>If disabled, inter-edges will always end at the border/center of the corresponding group node, even if those edges have port constraints. Thus, they are <see cref="M:yWorks.Layout.Grouping.RecursiveGroupLayout.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)">rerouted</see> later without considering the constraint. Enabling this settings may produce more suitable edge routes but cannot prevent edges from crossing nodes.</para>
        <para>Port candidates are automatically redirected to their original location. Hence, enabling this option may produce more suitable edge routes if the layout algorithm applied to the content of a group node can handle port candidates.</para>
      </remarks>
      <value>
        <para>whether or not port constraints are replaced</para>
      </value>
      <seealso cref="M:yWorks.Layout.Grouping.RecursiveGroupLayout.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)" />
      <seealso cref="T:yWorks.Layout.PortCandidate" />
    </member>
    <member name="P:yWorks.Layout.Grouping.RecursiveGroupLayout.ConsiderEmptyGroups">
      <summary>
        <para>Gets or sets whether empty group nodes are handled like group nodes with content or like normal nodes.</para>
      </summary>
      <remarks>
        <para>If they are handled like other group nodes, <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> will resize them according to their (non-existing) content. This results in small empty group nodes. Handled like normal nodes, empty group nodes will keep their initial size.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if empty groups are treated like group nodes, <c>false</c> if they are treated like normal nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter">
      <summary>
        <para>Gets or sets the current edge routing algorithm for handling inter-edges.</para>
      </summary>
      <remarks>
        <para>During layout, edges that connect from outside a group node to the content inside (inter-edges) are temporarily connected to the group node itself. Hence, these edges have to be routed after restoring the original graph structure using this edge routing algorithm.</para>
        <para>It is required that a suitable <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgesDpKey">selection key</see> is specified. The same selection key must be used for setting the sphere of action for the edge router.</para>
      </remarks>
      <value>
        <para>the edge routing algorithm for inter-edges</para>
      </value>
      <seealso cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgesDpKey" />
    </member>
    <member name="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgesDpKey">
      <summary>
        <para>Gets or sets the key for marking the inter-edges to be routed.</para>
      </summary>
      <remarks>
        <para>The key should be used by the specified <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter">inter-edge routing algorithm</see> to obtain the edges to be routed. This layouter automatically marks these edges and registers the <see cref="T:yWorks.Algorithms.IDataProvider" /> using the specified key.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the inter edge selection key</para>
      </value>
      <seealso cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter" />
    </member>
    <member name="M:yWorks.Layout.Grouping.RecursiveGroupLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Invokes a recursive traversal through the grouping hierarchy of the given graph during which the specified <see cref="F:yWorks.Layout.Grouping.RecursiveGroupLayout.GroupNodeLayoutDpKey">layout algorithms</see> are applied to the content of the groups.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Grouping.RecursiveGroupLayout.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Reroutes the given inter-edges using the current <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter">edge routing algorithm</see>.</para>
      </summary>
      <remarks>
        <para>This method is called after calculating the overall layout when the positions of all nodes and normal edges are fixed.</para>
        <para>If no <see cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter">inter-edge router</see> is specified, this method <see cref="M:yWorks.Layout.LayoutGraphUtilities.ResetPath(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,System.Boolean)">resets the path</see> of all inter-edges that don't connect to the proper location within the group. This may happen for inter-edges without <see cref="T:yWorks.Layout.PortCandidate" />s or if the applied layout algorithm doesn't support such constraints.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="interEdges">
        <para>the edges which traverse the boundary of a group node</para>
      </param>
      <seealso cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.AutoAssignPortCandidates" />
      <seealso cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.ReplacePortConstraints" />
      <seealso cref="P:yWorks.Layout.Grouping.RecursiveGroupLayout.InterEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Grouping.RecursiveGroupLayout.GroupBoundsCalculator">
      <summary>
        <para>Gets or sets a <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> which computes the sizes of all group nodes.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> is used each time after calculating the layout for a content graph.</para>
      </remarks>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.HandleNaNCoordinatesStage">
      <summary>
        <para>A <see cref="T:yWorks.Layout.ILayoutStage" /> that temporarily removes all nodes and edges with <c>NaN</c>-coordinates.</para>
      </summary>
      <remarks>
        <para>This <c>layout stage</c> may be necessary when a <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> takes the initial coordinates into account. In this case initial coordinates containing <c>NaN</c>-values, can cause exceptions or strange results.</para>
        <para>
          <c>Layouter</c>s that consider initial coordinates:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> in incremental mode</item>
          <item>
            <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" /> with activated from sketch drawing</item>
          <item>
            <see cref="T:yWorks.Layout.Organic.OrganicLayout" /> for a subset of nodes</item>
          <item>
            <see cref="T:yWorks.Layout.Tree.TreeLayout" /> when using a from sketch comparator.</item>
          <item>
            <see cref="T:yWorks.Layout.Tree.BalloonLayout" /> in incremental mode</item>
          <item>
            <see cref="T:yWorks.Layout.Partial.PartialLayout" />
          </item>
          <item>all edge routing algorithms: <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />, <see cref="T:yWorks.Layout.Router.ChannelEdgeRouter" />, <see cref="T:yWorks.Layout.Router.BusRouter" />, <see cref="T:yWorks.Layout.Router.OrganicEdgeRouter" /></item>
        </list>
        <para>Since this stage only hides the invalid graph elements and doesn't apply any new coordinates, it is not defined where those nodes and edges will be placed within the calculated layout.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.HandleNaNCoordinatesStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Hides all graph elements with <c>NaN</c>-coordinates during <see cref="M:yWorks.Layout.LayoutStageBase.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">core layout</see> and restores them afterwards.</para>
      </summary>
      <param name="graph">
        <para>the graph.</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.AsIsLayerer">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.AsIsLayerer" /> assigns nodes to layers by analyzing already existing node coordinates.</para>
      </summary>
      <remarks>
        <para>Nodes whose bounding boxes overlap in the main layout direction are assigned to the same layer. To influence to which amount the boxes need to overlap, the nodes can temporarily be <see cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeScalingFactor">scaled</see>. Alternatively, a minimum and maximum size or a halo can be specified for the nodes.</para>
        <para />
        <para>Initial graph</para>
        <para />
        <para>Hierarchic layout when the initial drawing is used as sketch</para>
        <para />
        <para>Hierarchic layout when the initial drawing is not used as sketch</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.AsIsLayerer.#ctor">
      <summary>
        <para>Creates an instance of <see cref="T:yWorks.Layout.Hierarchic.AsIsLayerer" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeScalingFactor">
      <summary>
        <para>Gets or sets the scaling factor used for scaling the size of the nodes.</para>
      </summary>
      <remarks>
        <para>Nodes are being scaled from their center. This can be used for more fuzzy layering.</para>
        <para>The scaling factor can take positive values. Factors smaller than <c>1</c> only consider large overlaps of the nodes' bounding boxes in the main layout direction. Factors larger than <c>1</c> also combine nodes with some distance between them.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is less than <c>0</c></para>
      </exception>
      <value>
        <para>a positive double value</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.MinimumNodeSize" />
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.MaximumNodeSize" />
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeHalo" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.AsIsLayerer.MaximumNodeSize">
      <summary>
        <para>Gets or sets the maximum size of a node used for calculating layer overlaps.</para>
      </summary>
      <remarks>
        <para>This can be used for more fuzzy layering.</para>
        <para>The maximum size can take positive values.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is less than <c>0</c></para>
      </exception>
      <value>
        <para>a positive double value</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeScalingFactor" />
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeHalo" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.AsIsLayerer.MinimumNodeSize">
      <summary>
        <para>Gets or sets the minimum size of a node used for calculating layer overlaps.</para>
      </summary>
      <remarks>
        <para>This can be used for more fuzzy layering.</para>
        <para>The minimum size can take positive values.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is less than <c>0</c></para>
      </exception>
      <value>
        <para>a positive double value</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeScalingFactor" />
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeHalo" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeHalo">
      <summary>
        <para>Gets or sets the size of the halo around a node, that means the insets that are used for calculating layer overlaps.</para>
      </summary>
      <remarks>
        <para>If the value of the halo is positive, it specifies a border around a node. In case it is negative, it is considered as an inset that defines a smaller area inside the node.</para>
        <para>This can be used for more fuzzy layering.</para>
      </remarks>
      <value>
        <para>the size of a node's halo</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeScalingFactor" />
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.MinimumNodeSize" />
      <seealso cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.MaximumNodeSize" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.AsIsLayerer.GetMin(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Callback used for calculating the upper (min) value of a given node.</para>
      </summary>
      <remarks>
        <para>It is called by method <see cref="M:yWorks.Layout.Hierarchic.AsIsLayerer.AssignNodeLayer(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.EdgeList)" />.</para>
      </remarks>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the upper (min) value of a given node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.AsIsLayerer.GetMax(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Callback used for calculating the lower (max) value of a given node.</para>
      </summary>
      <remarks>
        <para>It is called by method <see cref="M:yWorks.Layout.Hierarchic.AsIsLayerer.AssignNodeLayer(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.EdgeList)" />.</para>
      </remarks>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the lower (max) of a given node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.AsIsLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers by analyzing already existing node coordinates and adds them to the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <remarks>
        <para>Nodes whose bounding boxes overlap in the main layout direction are assigned to the same layer. To influence to which amount the boxes need to overlap, the nodes can temporarily be <see cref="P:yWorks.Layout.Hierarchic.AsIsLayerer.NodeScalingFactor">scaled</see>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be filled with the results of the calculation</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for querying information about the nodes and edges</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.AsIsSequencer">
      <summary>
        <para>This class calculates the sequence of the nodes within each layer using the nodes' coordinates.</para>
      </summary>
      <remarks>
        <para>For <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see> <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" />, the order corresponds to that obtain when sorting the nodes according to their x-coordinate.</para>
        <para>An instance of this class can be set to <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> using method <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" /> and <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer" /> respectively.</para>
        <para> Initial graph that will be used as sketch  Hierarchic layout when the initial graph is used as sketch</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.AsIsSequencer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.AsIsSequencer" /> instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.AsIsSequencer.SequenceNodeLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Calculates the sequence of the nodes within each layer using the nodes' coordinates.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> and finally writes back the calculated sequence using method <see cref="M:yWorks.Layout.Hierarchic.ILayer.SetNodeOrder(yWorks.Algorithms.YList)" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that defines the layering structure</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the nodes and edges of the graph</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> used for creating and destroying helper structures</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer">
      <summary>
        <para>This class is a wrapper <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> implementation that delegates the actual layering to a delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> object.</para>
      </summary>
      <remarks>
        <para>If the graph consists of multiple components, they will be identified and each of the components will be layered separately using the delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance. After that they will all be merged such that the desired aspect ratio is fulfilled best.</para>
        <para> Sample output of <see cref="T:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer" /> with default settings on a graph with two connected components.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer.DesiredAspectRatio" />
      <seealso cref="T:yWorks.Layout.Hierarchic.MultiComponentLayerer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer.#ctor(yWorks.Layout.Hierarchic.ILayerer)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer" /> using the given delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> is <c>null</c></para>
      </exception>
      <param name="singleComponentLayerer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer.SingleComponentLayerer">
      <summary>
        <para>Gets or sets the delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer.ConsiderNodeSize">
      <summary>
        <para>Gets or sets whether or not the size of the nodes should be considered.</para>
      </summary>
      <remarks>
        <para>If this option is disabled, all nodes are considered to be of equal size. Hence, the given aspect ratio specifies the ratio between the number of nodes within a layer and the overall number of layers.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the size of the node is considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer.DesiredAspectRatio">
      <summary>
        <para>Gets or sets the desired aspect ratio.</para>
      </summary>
      <remarks>
        <para>If the graph consists of multiple components, they will be identified and each of the components will be layered separately using the delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance. After that, they will all be merged such that the desired aspect ratio is best fulfilled.</para>
        <para>The given aspect ratio should be greater or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the aspect ratio is negative</para>
      </exception>
      <value>
        <para>the desired aspect ratio</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.AspectRatioComponentLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers and registers them to the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance based on the given aspect ratio.</para>
      </summary>
      <remarks>
        <para>If the graph consists of multiple components, they will be identified and each of the components will be layered separately using the delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance. After that, they will all be merged such that the desired aspect ratio is best fulfilled.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be filled with the results of the calculation</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for query information about the nodes and edges</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.BFSLayerer">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.BFSLayerer" /> uses a breadth first search for assigning layers to the nodes.</para>
      </summary>
      <remarks>
        <para>The nodes of the first layer can be freely selected (see <see cref="F:yWorks.Layout.Hierarchic.BFSLayerer.CoreNodesDpKey" />). The nodes that belong to a subsequent layer are determined as follows: Add all yet unassigned nodes to the new layer that are connected to nodes already assigned. As a consequence, all connected nodes will be at most one layer apart. Also, edges between nodes that belong to the same layer are possible.</para>
        <para />
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.BFSLayerer.CoreNodesDpKey">
      <summary>
        <para>A data provider key for identifying the core nodes of the BFS layering.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key should provide boolean values for the nodes of the graph. The boolean value determines whether or not a node is to be placed in the first layer. If there are no nodes marked as core nodes, then nodes with in-degree <c>0</c> are considered to be the core nodes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.BFSLayerer.#ctor">
      <summary>
        <para>Creates an instance of <see cref="T:yWorks.Layout.Hierarchic.BFSLayerer" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.BFSLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers and adds them to the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be filled with the results of the calculation</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for query information about the nodes and edges</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer">
      <summary>
        <para>This class is a <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> implementation that observes relative and absolute layering constraints defined by the <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory">layer constraint factory</see>.</para>
      </summary>
      <remarks>
        <para>Furthermore, it can handle the edge directedness as specified by <see cref="T:yWorks.Algorithms.IDataProvider" /> key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.EdgeDirectednessDpKey" />.</para>
        <para>For a given graph instance, the layer constraint factory can be created using method <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateLayerConstraintFactory(yWorks.Algorithms.Graph)" />. The <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> can be used for both common layering and layering of incremental nodes.</para>
        <para> Sample output of applying <see cref="T:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer" />. The red colored node should reside in the topmost layer, blue nodes in the medium layer while green nodes in the bottommost layer.  Sample output of applying <see cref="T:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer" /> on a graph with a <see cref="T:yWorks.Layout.Grid.PartitionGrid" />. Same colors represent nodes that belong to the same partition grid cell and should be layered with respect to the partition grid cell to which they belong.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory" />
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer.AdditionalEdgeWeightDpKey">
      <summary>
        <para>A data provider key for assigning additional edge weights.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> tries to maintain edges with higher weights short.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer.#ctor(yWorks.Layout.Hierarchic.ILayerer)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer" /> with the given <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance.</para>
      </summary>
      <param name="coreLayerer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer.AllowSameLayerEdges">
      <summary>
        <para>Gets or sets whether or not same-layer edges can be created by this <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance.</para>
      </summary>
      <remarks>
        <para>This only concerns edges between nodes that have no hard constraints that will force a same-layer edge (i.e. a same-layer constraint).</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if same-layer edges can be created, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers and adds them to the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance based on relative and absolute layering constraints defined by the given layering constraints.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be filled with the results of the calculation</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for query information about the nodes and edges</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer.CheckConstraints">
      <summary>
        <para>Checks if the current setting of constraints is consistent (i.e.</para>
      </summary>
      <remarks>
        <para>the induced constraint graph has no cycles).</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the constraint graph is inconsistent</para>
      </exception>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator">
      <summary>
        <para>This class is a default <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> implementation that is used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> to configure the <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.Initialize(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <param name="graph" />
      <param name="layers" />
      <param name="ldp" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.Dispose(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <param name="graph" />
      <param name="layers" />
      <param name="ldp" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.AdaptiveMinimumEdgeDistanceEnabled">
      <summary>
        <para>Gets or sets whether or not an adaptive minimum edge distance is used.</para>
      </summary>
      <remarks>
        <para>If this option is enabled the minimum distance between two adjacent edges is the minimum of the current minimum edge distance and the distance of the edges' source/target points.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if an adaptive minimum distance should be used, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.Compaction">
      <summary>
        <para>Gets or sets whether or not the compaction option is enabled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if compaction is enabled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.GetMinDistance(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayer,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Determines the minimum distance between two <see cref="T:yWorks.Algorithms.Node" />s of the same layer.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layer">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> object that will be used during subsequent calls</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for querying information</para>
      </param>
      <param name="left">
        <para>the left of the two <see cref="T:yWorks.Algorithms.Node" />s whose minimum distance is to be determined or <c>null</c> if only the left border of the right <see cref="T:yWorks.Algorithms.Node" /> is of interest</para>
      </param>
      <param name="right">
        <para>the right of the two <see cref="T:yWorks.Algorithms.Node" />s whose minimum distance is to be determined or <c>null</c> if only the right border of the left <see cref="T:yWorks.Algorithms.Node" /> is of interest</para>
      </param>
      <returns>
        <para>the minimum distances between <see cref="T:yWorks.Algorithms.Node" />s of same layer</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.NodeToNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two <see cref="T:yWorks.Algorithms.Node" />s.</para>
      </summary>
      <remarks>
        <para>Minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.NodeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between a <see cref="T:yWorks.Algorithms.Node" /> and an (non-adjacent) <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <remarks>
        <para>Minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.EdgeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two edges.</para>
      </summary>
      <remarks>
        <para>Minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum distance is negative</para>
      </exception>
      <value>
        <para>the given minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator.OptimizeSwimlaneDistances">
      <summary>
        <para>Gets or sets whether or not to use an optimized minimum distance calculation for swimlane layouts.</para>
      </summary>
      <remarks>
        <para>If set to <c>true</c> this instance will report <c>0.0d</c> as the minimum distance between two nodes if they belong to different swimlanes. This avoids unwanted feedback between different swimlanes during node placement.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if modified distance calculation for swimlane layouts should be used, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.DefaultLayerSequencer">
      <summary>
        <para>This class is a <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> implementation that performs the second phase of the Sugiyama algorithm.</para>
      </summary>
      <remarks>
        <para>It minimizes the crossings in the diagram by using either the barycentric or median heuristic.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultLayerSequencer.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultLayerSequencer" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultLayerSequencer.Transposition">
      <summary>
        <para>Gets or sets whether or not to apply an additional crossing minimization heuristic.</para>
      </summary>
      <remarks>
        <para>Activating this heuristic can reduce the overall number of edge crossings. On the other hand, it may increase the running time.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the crossing minimization heuristic is applied, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultLayerSequencer.GroupTransposition">
      <summary>
        <para>Gets or sets whether or not an additional crossing minimization heuristic should be used in the presence of grouped graphs.</para>
      </summary>
      <remarks>
        <para>Activating this heuristic can reduce the overall number of edge crossings in grouped graphs. On the other hand, it may increase running time.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the crossing minimization heuristic should be applied, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultLayerSequencer.WeightHeuristic">
      <summary>
        <para>Gets or sets the weight heuristic that should be used.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the constant is unknown</para>
      </exception>
      <value>
        <para>one of the predefined weight heuristics</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultLayerSequencer.MaximumDuration">
      <summary>
        <para>Gets or sets the time limit (in milliseconds) set for this sequencer per execution.</para>
      </summary>
      <remarks>
        <para>Values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the maximum duration is negative.</para>
      </exception>
      <value>
        <para>a non-negative value that specifies the time limit</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultLayerSequencer.RandomizationRounds">
      <summary>
        <para>Gets or sets the number of randomized rounds that this algorithm performs, if there was no optimal solution.</para>
      </summary>
      <remarks>
        <para>Values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if a negative value is given</para>
      </exception>
      <value>
        <para>the number of additional rounds</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultLayerSequencer.SequenceNodeLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <param name="graph" />
      <param name="glayers" />
      <param name="ldp" />
      <param name="itemFactory" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger">
      <summary>
        <para>A default implementation of a <see cref="T:yWorks.Layout.Hierarchic.ILayeredComponentsMerger" /> that provides simple default behaviors.</para>
      </summary>
      <remarks>
        <para>Instances of this class are used internally by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> and <see cref="T:yWorks.Layout.Hierarchic.MultiComponentLayerer" /> when e.g. the graph is grouped or it consists of more than one connected component.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.#ctor(yWorks.Layout.Hierarchic.MergingPolicy)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger" /> using the given merging policy.</para>
      </summary>
      <param name="policy">
        <para>one of the predefined merging constants</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown policy is given</para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy">
      <summary>
        <para>Gets or sets the merging policy constant as defined in <see cref="T:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger" />.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown policy is given</para>
      </exception>
      <value>
        <para>one of the predefined merging policy constants</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Merge(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayers)">
      <param name="graph" />
      <param name="ldp" />
      <param name="srcLayers" />
      <param name="targetLayers" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.DefaultPortAllocator">
      <summary>
        <para>This class is a default <see cref="T:yWorks.Layout.Hierarchic.IPortAllocator" /> implementation.</para>
      </summary>
      <remarks>
        <para>It is used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> after the sequencing phase.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultPortAllocator.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultPortAllocator" /> with default settings.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultPortAllocator.DefaultPortBorderGapRatio" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultPortAllocator.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns source and target port coordinates to each edge of the graph.</para>
      </summary>
      <remarks>
        <para>This method assigns:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Layout.PortSide.Any" /> ports to appropriate sides.</item>
          <item>
            <see cref="P:yWorks.Layout.PortConstraint.Strong">Weak</see> ports to appropriate positions between strong ones.</item>
        </list>
        <para>This method is called by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> after the sequencing phase.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance containing the layering structure</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the nodes and edges of the graph</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> used for creating and destroying helper structures</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultPortAllocator.GetPortBorderGap(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,System.Int32,System.Double,System.Int32)">
      <summary>
        <para>Callback method used for determining the port border gap for each node and side.</para>
      </summary>
      <remarks>
        <para>It may be overridden for a custom calculation of port border gap on a given node.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the nodes and edges of the graph</para>
      </param>
      <param name="node">
        <para>the given node</para>
      </param>
      <param name="sideIndex">
        <para>the zero-based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</para>
      </param>
      <param name="sideLength">
        <para>the width/height of the side</para>
      </param>
      <param name="edgeCount">
        <para>the number of edges/ports that connect to this side</para>
      </param>
      <returns>
        <para>the absolute gap on both sides of the ports</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Hierarchic.DefaultPortAllocator.GetPortDistanceDelta(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,System.Int32,System.Double,System.Int32,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultPortAllocator.GetPortDistanceDelta(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,System.Int32,System.Double,System.Int32,System.Double)">
      <summary>
        <para>Callback method used for determining the distance between two adjacent ports.</para>
      </summary>
      <remarks>
        <para>It may be overridden for a custom calculation of the distance between two adjacent ports..</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the nodes and edges of the graph</para>
      </param>
      <param name="node">
        <para>the given node</para>
      </param>
      <param name="sideIndex">
        <para>the zero-based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</para>
      </param>
      <param name="sideLength">
        <para>the width/height of the side</para>
      </param>
      <param name="edgeCount">
        <para>the number of edges/ports that connect to this side</para>
      </param>
      <param name="portBorderGap">
        <para>the previously calculated port border gap</para>
      </param>
      <returns>
        <para>the absolute distance between two adjacent ports</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.DefaultPortAllocator.GetPortBorderGapRatio(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,System.Int32,System.Double,System.Int32)">
      <summary>
        <para>Callback method used for determining the port border gap ratio.</para>
      </summary>
      <remarks>
        <para>See <see cref="P:yWorks.Layout.Hierarchic.DefaultPortAllocator.DefaultPortBorderGapRatio" /> for an explanation.</para>
        <para>It may be overridden for a custom calculation of port border gap ratio on a given node.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the nodes and edges of the graph</para>
      </param>
      <param name="node">
        <para>the given node</para>
      </param>
      <param name="sideIndex">
        <para>the zero-based (top is 0) clock-wise index of the side of the node (for top-to-bottom layouts)</para>
      </param>
      <param name="sideLength">
        <para>the width/height of the side</para>
      </param>
      <param name="edgeCount">
        <para>the number of edges/ports that connect to this side</para>
      </param>
      <returns>
        <para>the border gap ratio</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.DefaultPortAllocator.DefaultPortBorderGapRatio">
      <summary>
        <para>Gets or sets the border gap ratio for the default port.</para>
      </summary>
      <remarks>
        <para>This ratio determines the gap between a corner of the node and the first assigned port.</para>
        <para>The ratio should be greater than <c>0</c>.</para>
        <para>A value of <c>0.0d</c> results in ports being placed directly on the corner of the node (if there is more than one port).</para>
        <para>A value of <c>0.5d</c> results in ports being distributed along the side of the node so that the distance between the corner of the node and the first port is half as wide as the distance between two adjacent ports.</para>
        <para>A value of <c>Double.POSITIVE_INFINITY</c> results in all ports being centered at the side in one point.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given ratio is negative</para>
      </exception>
      <value>
        <para>the border gap ratio</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor">
      <summary>
        <para>This class is used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> during the various phases to provide routing details for the edges of the graph.</para>
      </summary>
      <remarks>
        <para>An <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance can be specified individually for single edges using a <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance for each edge of the graph, or <c>null</c> if no <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> is bound to an edge. The <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.EdgeLayoutDescriptorDpKey" />.</para>
        <para>This class is designed as a class to allow future additions of new getter methods.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.EdgeLayoutDescriptorDpKey" />
      <seealso cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.#ctor">
      <summary>
        <para>Creates a new instance of an <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> with the default values.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.MinimumFirstSegmentLength">
      <summary>
        <para>Gets or sets the minimum length of the first segment of the edge path (at the source node).</para>
      </summary>
      <remarks>
        <para>The minimum length should be greater than <c>0</c>.</para>
        <para>If the value is <c>0.0d</c> the first segment does not need to be orthogonal.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length of the first segment is negative</para>
      </exception>
      <value>
        <para>the minimum length of the first segment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.MinimumLastSegmentLength">
      <summary>
        <para>Gets or sets the minimum length of the last segment of the edge path (at the target node).</para>
      </summary>
      <remarks>
        <para>The minimum length should be greater than <c>0</c>.</para>
        <para>If the value is <c>0.0d</c> the last segment does not need to be orthogonal.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length of the last segment is negative</para>
      </exception>
      <value>
        <para>the minimum length of the last segment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.MinimumLength">
      <summary>
        <para>Gets or sets the minimum length of an edge.</para>
      </summary>
      <remarks>
        <para>If this is used for polyline routing, it describes the minimum vertical length of the mid segment. If it is used for orthogonal routing, it describes the minimum length of the whole edge.</para>
        <para>The minimum length should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length is negative</para>
      </exception>
      <value>
        <para>the minimum segment length.</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.MinimumDistance">
      <summary>
        <para>Gets or sets the preferred minimum distance to obstacles.</para>
      </summary>
      <remarks>
        <para>The minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length is negative</para>
      </exception>
      <value>
        <para>the minimum distance to obstacles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.MinimumSlope">
      <summary>
        <para>Gets or sets the minimum slope that the mid segments of this edge should have, if the edge is routed polyline in vertical layouts.</para>
      </summary>
      <remarks>
        <para>The minimum slope should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum slope is negative</para>
      </exception>
      <value>
        <para>the minimum slope of the mid segments</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.SourcePortOptimization">
      <summary>
        <para>Gets or sets whether or not source port optimization is enabled.</para>
      </summary>
      <remarks>
        <para>This means that the algorithm should try to find a better source <see cref="T:yWorks.Layout.PortConstraint">port constraint</see> if the current constraint is <c>null</c> or <see cref="F:yWorks.Layout.PortSide.Any" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if source port optimization is enabled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.TargetPortOptimization">
      <summary>
        <para>Gets or sets whether or not target port optimization is enabled.</para>
      </summary>
      <remarks>
        <para>This means that the algorithm should try to find a better target <see cref="T:yWorks.Layout.PortConstraint">port constraint</see> if the current constraint is <c>null</c> or <see cref="F:yWorks.Layout.PortSide.Any" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if target port optimization should be enabled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RoutingStyle">
      <summary>
        <para>Gets or sets the routing style for this edge.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.RoutingStyle" /> instance</para>
      </value>
      <seealso cref="T:yWorks.Layout.Hierarchic.RoutingStyle" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.MinimumOctilinearSegmentLength">
      <summary>
        <para>Gets or sets the minimum length of octilinear segments for this edge.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length of the first segment is negative</para>
      </exception>
      <value>
        <para>the minimum length of octilinear segment</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RoutingStyle" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.CreateCopy">
      <summary>
        <para>Creates a copy of this <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance.</para>
      </summary>
      <returns>
        <para>a copy of this <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RecursiveEdgeStyle">
      <summary>
        <para>Gets or sets how edges in grouped graphs are routed between the content of different groups.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown style is specified</para>
      </exception>
      <value>
        <para>one of the predefined recursive routing styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.DirectGroupContentEdgeRouting">
      <summary>
        <para>Gets or sets whether or not this edge is routed directly to a group node's border if it connects the group node with one of its descendants.</para>
      </summary>
      <remarks>
        <para>When enabled, the edge will connect to the inner side of the group node's border instead of leaving the group node and connect from outside.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the edge is routed directly, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.WeightHeuristic">
      <summary>
        <para>A weight assignment specifier based on a median heuristic.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayerSequencer.WeightHeuristic" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.WeightHeuristic.Barycenter">
      <summary>
        <para>A weight assignment specifier based on a barycenter heuristic.</para>
        <para>The position of a node within a layer will be determined by the barycenter of its successor (downward pass) and predecessor (upward pass) nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayerSequencer.WeightHeuristic" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.WeightHeuristic.Median">
      <summary>
        <para>A weight assignment specifier based on a median heuristic.</para>
        <para>The position of a node within a layer will be determined by the median position of its successor (downward pass) and predecessor (upward pass) nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayerSequencer.WeightHeuristic" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.MergingPolicy">
      <seealso cref="M:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.#ctor(yWorks.Layout.Hierarchic.MergingPolicy)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.MergingPolicy.AddBelow">
      <summary>
        <para>A constant that adds the new layers of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see> below the layers of the target <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.MergingPolicy.AddAbove">
      <summary>
        <para>A constant that adds the new layers of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see> above the layers of the target <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.MergingPolicy.AddRightTopAligned">
      <summary>
        <para>A constant that adds the new layers of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see> to the right of the layers of the target layering.</para>
        <para>Both <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>s will become top-aligned before the merge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.MergingPolicy.AddRightBottomAligned">
      <summary>
        <para>A constant that adds the new layers of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see> to the right of the layers of the target <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>.</para>
        <para>Both <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>s will become bottom-aligned before the merge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.MergingPolicy.AddRightCenterAligned">
      <summary>
        <para>A constant that adds the new layers of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see> to the right of the layers of the target <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>.</para>
        <para>Both <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>s will become center-aligned before the merge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.MergingPolicy.AddLeftTopAligned">
      <summary>
        <para>A constant that adds the new layers of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see> to the left of the layers of the target <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>.</para>
        <para>Both <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>s will become top-aligned before the merge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.MergingPolicy.AddLeftBottomAligned">
      <summary>
        <para>A constant that adds the new layers of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see> to the left of the layers of the target <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>.</para>
        <para>Both <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>s will become bottom-aligned before the merge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.MergingPolicy.AddLeftCenterAligned">
      <summary>
        <para>A constant that adds the new layers of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see> to the left of the layers of the target <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>.</para>
        <para>Both <see cref="T:yWorks.Layout.Hierarchic.ILayers">layering</see>s will become center-aligned before the merge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger.Policy" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.EdgeDataType">
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeDataType.Normal">
      <summary>
        <para>A constant describing a normal edge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeDataType.SourceGroupNodeConnector">
      <summary>
        <para>A constant describing an edge that connects to a source group node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeDataType.TargetGroupNodeConnector">
      <summary>
        <para>A constant describing an edge that connects to a target group node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeDataType.GroupNodeInterconnector">
      <summary>
        <para>A constant describing an edge that connects two group nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeDataType.DirectSameLayerEdge">
      <summary>
        <para>A constant describing a same-layer edge that connects directly two neighboring nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeDataType.NonDirectSameLayerEdge">
      <summary>
        <para>A constant describing a same-layer edge that does not connect directly two neighboring nodes.</para>
        <para>This means that two nodes of the same layer are not connected directly with a straight-line edge, but with an edge consisting of polyline segments.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeDataType.BorderEdge">
      <summary>
        <para>A constant describing an edge that connects group border nodes in adjacent layers.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeDataType.RedirectedGroupEdge">
      <summary>
        <para>A constant describing an edge that has been added temporarily to replace an edge connected to a group node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.RecursiveEdgeStyle">
      <summary>
        <para>Routing specifier that routes edges between different group contents non-recursively.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RecursiveEdgeStyle" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.RecursiveEdgeStyle.Off">
      <summary>
        <para>Routing specifier that routes edges between different group contents non-recursively. <see cref="T:yWorks.Algorithms.Edge" />s may leave and enter group nodes at the left and right side in order to connect as directly as possible.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RecursiveEdgeStyle" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.RecursiveEdgeStyle.Directed">
      <summary>
        <para>Routing specifier that routes edges between different group contents recursively and directed. <see cref="T:yWorks.Algorithms.Edge" />s can only leave the groups at the bottom side and enter them at the top side.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RecursiveEdgeStyle" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.RecursiveEdgeStyle.Undirected">
      <summary>
        <para>Routing specifier that routes edges between different group contents recursively and undirected. <see cref="T:yWorks.Algorithms.Edge" />s can leave the groups at the bottom or top side and enter them at the bottom or top side. This style is more compact than the directed edge style.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RecursiveEdgeStyle" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ComponentArrangementPolicy">
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.ComponentArrangementPolicy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.ComponentArrangementPolicy.Compact">
      <summary>
        <para>A component arrangement policy that achieves a <c>1:1</c> aspect ratio for the graph.</para>
        <para>After layering the single components with the core layerer, the components will be merged such that an 1:1 aspect ratio is fulfilled best.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.ComponentArrangementPolicy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.ComponentArrangementPolicy.Topmost">
      <summary>
        <para>A component arrangement policy that aligns the components with their topmost layer.</para>
        <para>After layering the single components with the core layerer, the components are aligned with their topmost layer.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.ComponentArrangementPolicy" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.LayoutMode">
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayoutMode.Incremental">
      <summary>
        <para>A layout mode that allows to keep some nodes fixed and insert the remaining nodes incrementally.</para>
        <para>Fixed elements will be handled by the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer">fixed elements sequencer</see> and <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer">fixed elements layerer</see>. Incremental elements will be added during the layering or the sequencing phase. They are handled by <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer">from scratch layerer</see> and <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer">fixed elements layerer</see> respectively.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateLayerIncrementallyHint(System.Object)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayoutMode.FromScratch">
      <summary>
        <para>A layout mode that will recompute the complete layout from scratch.</para>
        <para>All elements will be handled by the same <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer">layerer</see> and <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer">sequencer</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.LayeringStrategy">
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayeringStrategy.HierarchicalTopmost">
      <summary>
        <para>A layering strategy which places each node in the highest possible layer without passing its predecessor in the topological order of nodes.</para>
        <para>All nodes with indegree zero will be assigned to the topmost layer of the layout. The number of separate layers will be as small as possible.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayeringStrategy.HierarchicalOptimal">
      <summary>
        <para>A layering strategy which places each node in the optimal layer to minimize the layer distances.</para>
        <para>The layer distance of an edge is the absolute difference between the layer numbers of its source and target node. The layer assignment will minimize the overall sum of the layer distances of all edges in the layout.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayeringStrategy.HierarchicalTightTree">
      <summary>
        <para>A layering strategy which applies a heuristic to approximate the <see cref="F:yWorks.Layout.Hierarchic.LayeringStrategy.HierarchicalOptimal">optimal layering</see>.</para>
        <para>The quality of the result may not be as good as with <see cref="F:yWorks.Layout.Hierarchic.LayeringStrategy.HierarchicalOptimal">optimal layering</see> but it is usually achieved faster.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayeringStrategy.HierarchicalDownshift">
      <summary>
        <para>A layering strategy which applies a fast heuristic that improves the layering done by <see cref="F:yWorks.Layout.Hierarchic.LayeringStrategy.HierarchicalTopmost" /> by shifting some nodes down.</para>
        <para>The quality of the result is usually worse than the one produced by <see cref="F:yWorks.Layout.Hierarchic.LayeringStrategy.HierarchicalTightTree" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayeringStrategy.Bfs">
      <summary>
        <para>A layering strategy based on a breadth first search (BFS).</para>
        <para>All edges will span at most one layer in the resulting drawing. Edges between nodes that belong to the same layer are possible.</para>
        <para>The nodes that will be placed in the first layer can be provided by a data provider bound to the input graph using the key <see cref="F:yWorks.Layout.Hierarchic.BFSLayerer.CoreNodesDpKey" />. If this data provider is not given, then nodes that have no incoming edges are placed in the first layer.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayeringStrategy.FromSketch">
      <summary>
        <para>A layering strategy which derives the layers from the initial coordinates of the nodes.</para>
        <para>It tries to find a layering that is similar to the one in the input graph. The layout algorithm may place nodes in the same layer, even though they are connected by an edge.</para>
        <para>In a vertically oriented layout, nodes that overlap vertically are placed in the same layer. The same holds for a horizontally oriented layout in the case where the nodes overlap horizontally.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayeringStrategy.UserDefined">
      <summary>
        <para>A layering strategy which uses a layer assignment specified by the user.</para>
        <para>The nodes' layer assignment must be provided by a data provider bound to the input graph using the key <see cref="F:yWorks.Layout.Hierarchic.GivenLayersLayerer.LayerIdDpKey" />.</para>
        <para>This layering strategy allows edges whose source and target share a layer.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayeringStrategy.Unknown">
      <summary>
        <para>A dummy layering strategy which describes a strategy that is not part of the default strategies.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.GroupAlignmentPolicy">
      <summary>
        <para>A group layering alignment strategy which aligns groups and normal nodes that occupy the same layer to the top with respect to their inner layers.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.GroupAlignmentPolicy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.GroupAlignmentPolicy.Top">
      <summary>
        <para>A group layering alignment strategy which aligns groups and normal nodes that occupy the same layer to the top with respect to their inner layers.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.GroupAlignmentPolicy" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.RecursiveGroupLayering" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.GroupAlignmentPolicy.Center">
      <summary>
        <para>A group layering alignment strategy which aligns groups and normal nodes that occupy the same layer to the center with respect to their inner layers.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.GroupAlignmentPolicy" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.RecursiveGroupLayering" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.GroupAlignmentPolicy.Bottom">
      <summary>
        <para>A group layering alignment strategy which aligns groups and normal nodes that occupy the same layer to the bottom with respect to their inner layers.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.GroupAlignmentPolicy" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.RecursiveGroupLayering" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.LayerType">
      <seealso cref="P:yWorks.Layout.Hierarchic.ILayer.Type" />
      <seealso cref="M:yWorks.Layout.Hierarchic.ILayers.Insert(yWorks.Layout.Hierarchic.LayerType,System.Int32)" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayerType.Normal">
      <summary>
        <para>A constant describing a normal layer consisting mainly of normal nodes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayerType.Label">
      <summary>
        <para>A constant describing a layer consisting mainly of label nodes or dummy nodes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayerType.SourceGroupNodes">
      <summary>
        <para>A constant describing a layer consisting of source group nodes and dummy nodes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayerType.TargetGroupNodes">
      <summary>
        <para>A constant describing a layer consisting of target group nodes and dummy nodes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayerType.UpperGroupConnectorNodes">
      <summary>
        <para>Describes a layer above a group to store the connector proxies where edges connect to groups.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.LayerType.LowerGroupConnectorNodes">
      <summary>
        <para>Describes a layer below a group to store the connector proxies where edges connect to groups.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.NodeDataType">
      <seealso cref="M:yWorks.Layout.Hierarchic.IItemFactory.CreateGroupBorderNode(yWorks.Algorithms.Node,yWorks.Layout.Hierarchic.ILayer,yWorks.Layout.Hierarchic.NodeDataType)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.Normal">
      <summary>
        <para>A constant describing a normal <see cref="T:yWorks.Algorithms.Node" />.</para>
        <para>A normal node may have any degree, any size and any number of connected same-layer edges.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.Bend">
      <summary>
        <para>A constant describing a bend <see cref="T:yWorks.Algorithms.Node" />.</para>
        <para>A bend node has degree <c>2</c>, small size and no same-layer edges.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.SideProxy">
      <summary>
        <para>A constant describing a side proxy <see cref="T:yWorks.Algorithms.Node" />.</para>
        <para>A side proxy node, in case port constraints are used for the drawing phase, has degree <c>1</c>, small size and no same-layer edges. The associated node is the one of which this node is the proxy.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.SameLayerSideProxy">
      <summary>
        <para>A constant describing a side proxy <see cref="T:yWorks.Algorithms.Node" /> for drawing same-layer edges.</para>
        <para>A side proxy node for drawing same-layer edges has degree <c>0</c>, small size and one same-layer edge. The associated node is the one of which this node is the proxy. The associated edge is the same-layer edge of which this node is the proxy.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.Label">
      <summary>
        <para>A constant describing a label <see cref="T:yWorks.Algorithms.Node" />.</para>
        <para>A label node has degree <c>2</c>, size of the labels and no same-layer edges. The borders of this node describe the layout of the labels.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.Group">
      <summary>
        <para>A constant describing a group <see cref="T:yWorks.Algorithms.Node" /> for nested graph layouts.</para>
        <para>This group node carries additional <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> information.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.GroupLayers" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.SourceGroupNode">
      <summary>
        <para>A constant describing a source group <see cref="T:yWorks.Algorithms.Node" /> for bus edges.</para>
        <para>This node serves as a dummy node in a <see cref="F:yWorks.Layout.Hierarchic.LayerType.SourceGroupNodes" /> layer.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.GroupId" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.TargetGroupNode">
      <summary>
        <para>A constant describing a target group <see cref="T:yWorks.Algorithms.Node" /> for bus edges.</para>
        <para>This node serves as a dummy node in a <see cref="F:yWorks.Layout.Hierarchic.LayerType.TargetGroupNodes" /> layer.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.GroupId" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.SourceBackLoopProxy">
      <summary>
        <para>A constant describing a back-loop proxy that belongs to the source of an edge.</para>
        <para>A back-loop proxy that belongs to the source of an edge has degree <c>2</c>, small size and exactly one same-layer edge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.TargetBackLoopProxy">
      <summary>
        <para>A constant describing a back-loop proxy that belongs to the target of an edge.</para>
        <para>A back-loop proxy that belongs to the target of an edge has degree <c>2</c>, small size and exactly one same-layer edge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.SameLayerCenterNode">
      <summary>
        <para>A constant describing a same-layer edge crossing dummy <see cref="T:yWorks.Algorithms.Node" />.</para>
        <para>A same-layer edge crossing dummy node has degree <c>2</c>, small size and exactly two same-layer edges. It is used for marking the crossing of the layer, if source and target port are at opposite layer sides.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.DistanceNode">
      <summary>
        <para>A constant describing a <see cref="T:yWorks.Algorithms.Node" /> used for the drawing phase to keep the distance between two nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.GroupBegin">
      <summary>
        <para>A constant describing a <see cref="T:yWorks.Algorithms.Node" /> used during the drawing phase for marking the beginning of a node group interval.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.GroupEnd">
      <summary>
        <para>A constant describing a <see cref="T:yWorks.Algorithms.Node" /> used during the drawing phase for marking the ending of a node group interval.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.GroupLayerDummy">
      <summary>
        <para>A constant describing a <see cref="T:yWorks.Algorithms.Node" /> used during the sequencing and drawing phase for marking a dummy node inserted to guarantee that a group is non-empty on the layer on which it is defined.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.ProxyForEdgeAtGroup">
      <summary>
        <para>A constant describing a <see cref="T:yWorks.Algorithms.Node" /> used during the sequencing and drawing phase for marking a dummy node inserted as a legal endpoint of an edge connecting to a group node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.ProxyForContentEdgeAtGroup">
      <summary>
        <para>A constant describing a <see cref="T:yWorks.Algorithms.Node" /> used during the sequencing and drawing phase for marking a dummy node inserted as a legal endpoint of an edge connecting a descendant node to a group node. It has degree <c>0</c> or <c>1</c> depending on whether or not the opposite node of the edge is assigned to the same layer. This kind of proxy nodes is only used if there are edges that shall connect to the group node without backloops.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.DirectGroupContentEdgeRouting" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeDataType.RecursiveEdgeDummy">
      <summary>
        <para>A constant describing a <see cref="T:yWorks.Algorithms.Node" /> used during sequencing and drawing phase for routing an <see cref="T:yWorks.Algorithms.Edge" /> recursively. An <see cref="T:yWorks.Algorithms.Edge" /> that connects to the content of a group node has to leave the group node at the bottom side and enter it at the top side.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.PortAssignmentMode">
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.PortAssignment" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.PortAssignmentMode.Default">
      <summary>
        <para>A port assignment strategy that distributes ports evenly along the border of the node.</para>
        <para>This is the default port assignment strategy of <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.PortAssignment" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.PortAssignmentMode.OnGrid">
      <summary>
        <para>A port assignment strategy that places all edges on grid lines.</para>
        <para>If there are not enough grid lines for each port, ports may overlap. In case there is no grid line available at the side of a node, the ports are placed centered at that side.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.PortAssignment" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.PortAssignmentMode.OnSubgrid">
      <summary>
        <para>A port assignment strategy that places all edges on grid lines or sub-grid lines.</para>
        <para>If there are not enough grid lines for each port, the grid gets subdivided with sub-grid lines until each edge has space for its port.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.PortAssignment" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.NodeLabelMode">
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeLabelMode.Never">
      <summary>
        <para>A constant that prevents node labels from being considered during the layout.</para>
        <para>It is used by <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" /> and <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeLabelMode.ConsiderForSelfLoops">
      <summary>
        <para>A constant that makes the algorithm consider node labels for self-loops, node placement and routing.</para>
        <para>It is used by <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" /> and <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeLabelMode.ConsiderForDrawing">
      <summary>
        <para>A constant that makes the algorithm consider node labels for node placement and routing, but not for self-loops.</para>
        <para>It is used by <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" /> and <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.NodeLabelMode.ConsiderForRouting">
      <summary>
        <para>A constant that makes the algorithm consider node labels during routing only.</para>
        <para>It is used by <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" /> and <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.EdgeRoutingStyle">
      <summary>
        <para>A routing style constant specifying that the edges should be polyline.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Hierarchic.RoutingStyle.#ctor(yWorks.Layout.Hierarchic.EdgeRoutingStyle)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.RoutingStyle.BackLoopRoutingStyle" />
      <seealso cref="P:yWorks.Layout.Hierarchic.RoutingStyle.DefaultEdgeRoutingStyle" />
      <seealso cref="P:yWorks.Layout.Hierarchic.RoutingStyle.EdgeGroupRoutingStyle" />
      <seealso cref="P:yWorks.Layout.Hierarchic.RoutingStyle.SameLayerEdgeRoutingStyle" />
      <seealso cref="P:yWorks.Layout.Hierarchic.RoutingStyle.SelfLoopRoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeRoutingStyle.Orthogonal">
      <summary>
        <para>A routing style constant specifying that the edges should be orthogonal. Orthogonal edges only consist of vertical and horizontal segments.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeRoutingStyle.Octilinear">
      <summary>
        <para>A routing style constant specifying that the edges should be octilinear. Octilinear edges consist of vertical and horizontal segments as well as segments with slope <c>-1</c> and <c>1</c>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.EdgeRoutingStyle.Polyline">
      <summary>
        <para>A routing style constant specifying that the edges should be polyline.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.GroupCompactionPolicy">
      <summary>
        <para>A strategy specifying no horizontal group compaction.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.GroupCompactionStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.GroupCompactionPolicy.None">
      <summary>
        <para>A strategy specifying no horizontal group compaction.</para>
        <para>This means that group node contents will occupy nearly the same horizontal positions as when not grouped at all.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.GroupCompactionStrategy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.GroupCompactionPolicy.Maximal">
      <summary>
        <para>A strategy specifying maximal horizontal group compaction.</para>
        <para>This means that the node placer will try to minimize the horizontally occupied space for a group node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.GroupCompactionStrategy" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.RankingPolicy">
      <seealso cref="P:yWorks.Layout.Hierarchic.TopologicalLayerer.RankingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.RankingPolicy.NoReranking">
      <summary>
        <para>A ranking policy that specifies that nodes are not re-ranked after the initial topological layering step.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.RankingPolicy.DownShift">
      <summary>
        <para>A ranking policy that specifies that nodes are re-ranked by an inexpensive downshift rule.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.RankingPolicy.TightTree">
      <summary>
        <para>A ranking policy that specifies that nodes are re-ranked by finding a spanning tree that contains only tight (length <c>1</c>) edges.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.GivenLayersLayerer">
      <summary>
        <para>This layering algorithm implementation assigns nodes to layers given a mapping of nodes to layer IDs.</para>
      </summary>
      <remarks>
        <para>The layer IDs are given by a <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the integer layer ID of each node of the graph. Nodes with the same ID are in the same layer while the layers are sorted according to their IDs such that the smallest ID represents the top layer.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GivenLayersLayerer.#ctor">
      <summary>
        <para>Creates an instance of <see cref="T:yWorks.Layout.Hierarchic.GivenLayersLayerer" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.GivenLayersLayerer.LayerIdDpKey">
      <summary>
        <para>A data provider key for storing the layer IDs.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Algorithms.IDataProvider" /> stores for each node the layer ID to which it belongs. Nodes with the same ID are in the same layer while the layers are sorted according to their IDs such that the smallest ID represents the top layer.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GivenLayersLayerer.Normalize(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataAcceptor)">
      <summary>
        <para>Convenience method that removes empty layers and ensures that the smallest layer has value <c>0</c>.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="layerId">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an integer value (layer) for each node; the first layer has the number <c>0</c></para>
      </param>
      <param name="normalizedLayerId">
        <para>the <see cref="T:yWorks.Algorithms.IDataAcceptor" /> that will be filled by the layout algorithm and holds an integer value (layer ID after normalization) for each node</para>
      </param>
      <returns>
        <para>the number of layers after the removal of empty layers</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GivenLayersLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers and adds them to the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be filled with the results of the calculation</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for querying information about the nodes and edges</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.GivenSequenceSequencer">
      <summary>
        <para>This class is a <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> implementation that determines the sequence of nodes of the same <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> based on a given <see cref="T:System.Collections.Generic.IComparer`1">comparator</see> constraint.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GivenSequenceSequencer.#ctor(System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.GivenSequenceSequencer" /> using a given <see cref="T:System.Collections.Generic.IComparer`1" /> for the sequencing.</para>
      </summary>
      <param name="c" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.GivenSequenceSequencer.SequenceComparer">
      <summary>
        <para>Gets or sets the <see cref="T:System.Collections.Generic.IComparer`1" /> used by this <see cref="T:yWorks.Layout.Hierarchic.GivenSequenceSequencer" /> to determine the sequence of the nodes.</para>
      </summary>
      <value>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> instance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GivenSequenceSequencer.SequenceNodeLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Calculates the sequence of the nodes within a <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance based on the given <see cref="T:System.Collections.Generic.IComparer`1" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> during the sequencing phase and finally writes back the calculated sequence using the <see cref="M:yWorks.Layout.Hierarchic.ILayer.SetNodeOrder(yWorks.Algorithms.YList)" /> method.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance containing the elements of the layers</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the nodes and edges of the graph</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> used for creating and destroying helper structures</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.GroupingSupport">
      <summary>
        <para>This class is responsible for managing hierarchically grouped graphs.</para>
      </summary>
      <remarks>
        <para>The grouping information is provided through <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with the graph with keys <see cref="F:yWorks.Layout.Grouping.GroupingKeys.NodeIdDpKey" />, <see cref="F:yWorks.Layout.Grouping.GroupingKeys.ParentNodeIdDpKey" /> and <see cref="F:yWorks.Layout.Grouping.GroupingKeys.GroupDpKey" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Grouping.GroupingSupport" />
      <seealso cref="T:yWorks.Layout.Grouping.GroupingKeys" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.HideGroupNodes">
      <summary>
        <para>Hides the group nodes and incident edges from the graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.UnhideGroupNodes">
      <summary>
        <para>Un-hides all previously hidden group nodes and incident edges.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.GroupingSupport.MinimumGroupDistance">
      <summary>
        <para>Gets or sets the minimum distance between group nodes.</para>
      </summary>
      <remarks>
        <para>The minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance between group nodes</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.AssignEdgeGroupNodesToGroups(yWorks.Layout.Hierarchic.ILayers)">
      <summary>
        <para>Assigns edge group nodes to groups based on a given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance containing the elements in the layering</para>
      </param>
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.SourceGroupNode" />
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.TargetGroupNode" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.RemoveEdgeGroupAssignment(yWorks.Layout.Hierarchic.ILayers)">
      <summary>
        <para>Removes the current assignment of source/target edge groups from a given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance containing the elements in the layering</para>
      </param>
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.SourceGroupNode" />
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.TargetGroupNode" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.IsGroupNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns whether or not the given <see cref="T:yWorks.Algorithms.Node" /> is a non-empty group node.</para>
      </summary>
      <param name="node">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given node is a non-empty group node, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.AssignLabelNodesToGroups(yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns label nodes to groups.</para>
      </summary>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance containing the elements in the layering</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> used temporarily for modifying the graph instance</para>
      </param>
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.Label" />
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.Bend" />
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.GroupBegin" />
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.GroupEnd" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.GroupingSupport.IVisitor">
      <summary>
        <para>Visitor interface that can be used to traverse the descendants of a group node</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.IVisitor.Visit(yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Visits the descendants of a group node.</para>
      </summary>
      <param name="node">
        <para>A descandant of the group node.</para>
      </param>
      <param name="parentNode">
        <para>A group node.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.GroupingSupport.Active">
      <summary>
        <para>Gets whether or not <see cref="T:yWorks.Layout.Hierarchic.GroupingSupport" /> is active.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if <see cref="T:yWorks.Layout.Hierarchic.GroupingSupport" /> is active, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.VisitDescendants(yWorks.Algorithms.Node,yWorks.Layout.Hierarchic.GroupingSupport.IVisitor)">
      <summary>
        <para>Visits all descendant <see cref="T:yWorks.Algorithms.Node" />s of the given group node.</para>
      </summary>
      <remarks>
        <para>The descendants are all direct or indirect children of a group node.</para>
      </remarks>
      <param name="groupNode">
        <para>the given group node</para>
      </param>
      <param name="visitor">
        <para>a <see cref="T:yWorks.Layout.Hierarchic.GroupingSupport.IVisitor" /> implementation</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.GetDescendants(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the descendant <see cref="T:yWorks.Algorithms.Node" />s of the given group node.</para>
      </summary>
      <remarks>
        <para>The descendants are all direct or indirect children of a group node.</para>
      </remarks>
      <param name="groupNode">
        <para>the given group node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> of all descendants or <c>null</c> if <see cref="T:yWorks.Layout.Hierarchic.GroupingSupport" /> <see cref="P:yWorks.Layout.Hierarchic.GroupingSupport.Active">is not active</see></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.GetChildren(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the direct children of the given group node.</para>
      </summary>
      <param name="groupNode">
        <para>the given group node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> of all direct children or <c>null</c> if <see cref="T:yWorks.Layout.Hierarchic.GroupingSupport" /> <see cref="P:yWorks.Layout.Hierarchic.GroupingSupport.Active">is not active</see></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.GetParentNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the parent group node of the given <see cref="T:yWorks.Algorithms.Node" /> or <c>null</c> if the given node is a top-level node.</para>
      </summary>
      <param name="node">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <returns>
        <para>the parent group node or <c>null</c> if the given node is a top-level node or if <see cref="T:yWorks.Layout.Hierarchic.GroupingSupport" /> <see cref="P:yWorks.Layout.Hierarchic.GroupingSupport.Active">is not active</see></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.GroupingSupport.IsDescendant(yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns whether or not the given node is a descendant <see cref="T:yWorks.Algorithms.Node" /> of the given group node.</para>
      </summary>
      <remarks>
        <para>The descendants are all direct or indirect children of a group node.</para>
      </remarks>
      <param name="node">
        <para>the given node</para>
      </param>
      <param name="groupNode">
        <para>the given group node</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given node is a descendant of the given group node, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.HierarchicLayout">
      <summary>
        <para>This layout algorithm arranges graphs in a hierarchic fashion.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The nodes are distributed into layers so that most of the edges point to the main layout direction. The order of the nodes within the layers ensures that the number of edge crossings is as small as possible. There are different edge routing styles available. Edges can be orthogonal, polyline or octilinear.</para>
        <para>Hierarchical diagrams are commonly used for the visualization of hierarchical data, since they facilitate the identification of dependencies and relationships among the nodes of the graph. Possible application domains are the following: workflow visualization, call graph visualization, entity-relationship diagrams, biochemical pathways and network management.</para>
        <para> Hierarchic Layout obtained with default settings <h2>Concept</h2> The layout algorithm runs in three main phases:</para>
        <list type="bullet">
          <item>
            <term>Layering</term>
            <description>The nodes are distributed into layers by means of <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer" /> or <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer" />, respectively. If the layout orientation is top-to-bottom, the nodes in each layer are arranged horizontally while the layers are ordered vertically top-to-bottom.</description>
          </item>
          <item>
            <term>Sequencing</term>
            <description>The order of the nodes in each layer is determined such that the number of edge crossings is as small as possible. To specify the sequencing algorithm, use <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer" /> or <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" />.</description>
          </item>
          <item>
            <term>Drawing</term>
            <description>The layout algorithm assigns the final coordinates to all nodes and routes the edges.</description>
          </item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>This layout algorithm is able to create hierarchic layouts from scratch or add new elements to the existing sketch drawing incrementally. In order to add elements incrementally to the current sketch or let the algorithm optimize certain elements in the current sketch, set the layout mode to <see cref="F:yWorks.Layout.Hierarchic.LayoutMode.Incremental" />. Then register a <see cref="T:yWorks.Algorithms.IDataProvider" /> (e.g. use <see cref="M:yWorks.Algorithms.Util.Maps.CreateHashedDataMap" />) with the graph using the <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.IncrementalHintsDpKey" /> DataProvider key and associate the hints obtained from the <see cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" /> with the elements to be added incrementally.</para>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> and <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instances can be used for specifying individual information (e.g. distances or routing styles) for each node and edge in the graph. The descriptors are bound to the graph using <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodeLayoutDescriptorDpKey" /> or <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.EdgeLayoutDescriptorDpKey" />. If there is no descriptor assigned to some nodes/edges, a default descriptor will be used. To set default descriptors use <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.NodeLayoutDescriptor" /> and <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.EdgeLayoutDescriptor" />.</para>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> supports two approaches to connect edges on a specific side or even an exact location to a node. <see cref="T:yWorks.Layout.PortConstraint" />s define a single constraint for the ports of an edge. To realize more complex port restrictions, several <see cref="T:yWorks.Layout.PortCandidate" />s or <see cref="T:yWorks.Layout.PortCandidateSet" />s can be assigned to edges or nodes. If an edge with registered <see cref="T:yWorks.Layout.PortCandidate" />s connects to nodes with <see cref="T:yWorks.Layout.PortCandidateSet" />s, the layouter will try to match both collections to find an appropriate port. In case there is no matching port candidate, a <see cref="T:yWorks.Layout.PortCandidate" /> specified for the edge is preferred. For the matching to work properly, the candidates in both collection need to be the same <em>instances</em>. Since their simultaneous existence at the same node may be ambiguous, it is not recommended to use a combination of <see cref="T:yWorks.Layout.PortConstraint" />s and <see cref="T:yWorks.Layout.PortCandidate" />s in the same layout.</para>
        <para>The edge grouping feature of this layout algorithm is restricted to normal, hierarchic edges. Edges with <see cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RecursiveEdgeStyle">recursive edge style</see> <see cref="F:yWorks.Layout.Hierarchic.RecursiveEdgeStyle.Directed" /> or <see cref="F:yWorks.Layout.Hierarchic.RecursiveEdgeStyle.Undirected" /> will not be grouped. They are also not grouped when enabling <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.AutomaticEdgeGrouping">automatic edge grouping</see>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.EdgeDirectednessDpKey">
      <summary>
        <para>A data provider key for specifying the directedness of edges.</para>
      </summary>
      <remarks>
        <para>Generally, the hierarchic layout algorithm assigns nodes to layers such that most of the edges point in the <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">main layout direction</see>. The directedness of an edge specifies whether it should comply with this strategy. More precisely, a value of <c>1</c> means that the edge should fully comply, a value of <c>-1</c> that it should comply inversely (the edge should point against the main layout direction), and a value of <c>0</c> means that the direction doesn't matter at all and the endpoints of the edges may be placed at the same layer. If there are conflicting preferences, edges with higher absolute values are more likely to point in the desired direction.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.CriticalEdgePriorityDpKey">
      <summary>
        <para>A data provider key for defining the priority of critical edges.</para>
      </summary>
      <remarks>
        <para>Critical edges highlight different edge paths that are relevant for a user. The layouter tries to vertically align each node pair that is connected by a critical edge. Conflicts between different critical edges are always resolved in favor of the higher priority.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.EdgeThicknessDpKey">
      <summary>
        <para>A data provider key for specifying the thickness of the edges.</para>
      </summary>
      <remarks>
        <para>The specified non-negative thickness is considered when calculating minimum distances so that there are no overlaps between edges and other graph elements. By default, each edge has thickness <c>0</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.IncrementalHintsDpKey">
      <summary>
        <para>A data provider key for specifying incremental hints.</para>
      </summary>
      <remarks>
        <para>Incremental hints are created using an <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateIncrementalHintsFactory">incremental hints factory</see>.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey" />
      <seealso cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.LayerIndexDpKey">
      <summary>
        <para>A data acceptor key for publishing the layer IDs for all nodes in the graph.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.LayerIndexDpKey" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.SequenceIndexDpKey">
      <summary>
        <para>A data acceptor key for publishing the index inside their layer for all nodes in the graph.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SequenceIndexDpKey" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.SwimlaneDescriptorDpKey">
      <summary>
        <para>A data provider key for defining swimlanes for the nodes.</para>
      </summary>
      <remarks>
        <para>The layout algorithm will arrange nodes in swimlanes according to the registered descriptors.</para>
        <para>Layout information about the swimlanes is finally written back to the descriptor instances. Instances can be shared among multiple nodes in the same lane.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SwimlaneDescriptorDpKey" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.AlternativeGroupBoundsDpKey">
      <summary>
        <para>A data provider key for associating an alternative bounds with the collapsed/expanded group.</para>
      </summary>
      <remarks>
        <para>When running in <see cref="F:yWorks.Layout.Hierarchic.LayoutMode.Incremental">incremental</see> <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode">layout mode</see>, the alternative bounds of the collapsed/expanded group will be used during the layering and sequencing phase of the algorithm.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.AlternativeEdgePathDpKey" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.AlternativeEdgePathDpKey">
      <summary>
        <para>A data provider key for associating alternative paths for edges connecting to groups, group content or folder nodes.</para>
      </summary>
      <remarks>
        <para>When running in <see cref="F:yWorks.Layout.Hierarchic.LayoutMode.Incremental">incremental</see> <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode">layout mode</see>, the alternative edge paths are considered during the routing of fixed (i.e., non-incremental) edges.</para>
        <para>The alternative paths should be used in conjunction with <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.AlternativeGroupBoundsDpKey">alternative group bounds</see> to achieve more stable layout results when collapsing/expanding a group node as follows:</para>
        <list type="number">
          <item>Collapsing: edges adjacent to the group itself and edges where one of the endpoints (source/target) lies inside the group should get the path <em>before</em> collapsing the group as alternative path. If both endpoints are either inside or outside the group, no alternative path is required.</item>
          <item>Expanding: edges adjacent to the expanded folder node (which is now a group) should get the path <em>before</em> expanding as alternative path.</item>
        </list>
      </remarks>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.AlternativeGroupBoundsDpKey" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.FolderNodesDpKey">
      <summary>
        <para>A data provider key for marking folder nodes.</para>
      </summary>
      <remarks>
        <para>When using recursive edge styles in incremental mode, edges will also start at the bottom and end at the top of marked folder nodes. This will keep the edge routes more stable since the connection sides won't change.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.SequenceConstraintsMementoDpKey">
      <summary>
        <para>A data provider key for storing the constraint graph.</para>
      </summary>
      <remarks>
        <para>A <c>v1 before v2</c> constraint is represented as an edge between the representatives of <c>v1</c> and <c>v2</c> in the constraint graph.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayout.LayerConstraintsMementoDpKey">
      <summary>
        <para>A data provider key for storing the constraint graph.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.GroupAlignmentPolicy">
      <summary>
        <para>Gets or sets the group layer alignment strategy used for recursive group layering.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown group alignment policy is given</para>
      </exception>
      <value>
        <para>one of the default group alignment policies</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.RecursiveGroupLayering" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.CompactGroups">
      <summary>
        <para>Gets or sets whether or not layer compaction for recursive group layering is active.</para>
      </summary>
      <remarks>
        <para>The number of node layers is decreased if possible without reversing edge directions. The resulting layering tries to keep the layer span of a group node minimum while minimizing the overall vertical space.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if group compaction is active, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.RecursiveGroupLayering" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.ComponentArrangementPolicy">
      <summary>
        <para>Gets or sets the policy that specifies how to arrange connected components.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified policy does not match a default component arrangement policy</para>
      </exception>
      <value>
        <para>one of the default component arrangement policies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.MaximumDuration">
      <summary>
        <para>Gets or sets the time limit (in milliseconds) set for the layout algorithm.</para>
      </summary>
      <remarks>
        <para>Values have to be greater or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the maximum duration is negative</para>
      </exception>
      <value>
        <para>a non-negative value that specifies the time limit</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.RecursiveGroupLayering">
      <summary>
        <para>Gets or sets whether or not groups are respected during the layering stage.</para>
      </summary>
      <remarks>
        <para>If this option is enabled, groups are layered recursively, i.e.</para>
        <list type="bullet">
          <item>nodes in the same group always occupy adjacent layers</item>
          <item>layer intervals spanned by different group nodes are either disjoint or are nested</item>
        </list>
        <para>If it is disabled, group information is ignored for the layering step.</para>
        <para>If the graph is flat, this setting is ignored.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if group information is used, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.CompactGroups" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.GridSpacing">
      <summary>
        <para>Gets or sets the equidistant spacing between the horizontal and vertical grid lines.</para>
      </summary>
      <remarks>
        <para>When the spacing is negative or zero, no grid is defined, otherwise nodes and edges are placed on multiples of the grid spacing.</para>
      </remarks>
      <value>
        <para>the grid spacing</para>
      </value>
      <seealso cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> instance with the default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.BackLoopRouting">
      <summary>
        <para>Gets or sets whether or not reversed edges should be routed as back-loops.</para>
      </summary>
      <remarks>
        <para>When this option is enabled, back-loops attach to the same node sides as the other edges, i.e., for layout orientation top-to-bottom, they leave their source at the bottom and enter their target at the top.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if back-loop routing is applied, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.BackLoopRoutingForSelfLoops">
      <summary>
        <para>Gets or sets whether or not self-loops should be routed in a similar manner as back-loops.</para>
      </summary>
      <remarks>
        <para>Self-loops will start at the bottom of their attached nodes and end at the top of them.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if self-loops should be routed like back-loops, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.BackLoopRouting" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.AutomaticEdgeGrouping">
      <summary>
        <para>Gets or sets whether or not edges are grouped automatically.</para>
      </summary>
      <remarks>
        <para>The automatic edge grouping tries to group a high number of edges without changing the semantic of the graph, i.e., it groups edges either at a common source node or a common target node. Edge groupings often allow more compact layouts since grouped edges are routed in a bus-style manner.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the edge grouping should be applied, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.OrthogonalRouting">
      <summary>
        <para>Gets or sets whether or not edges should be routed orthogonally.</para>
      </summary>
      <remarks>
        <para>When orthogonal routing is enabled, all resulting edge paths will be composed of vertical and horizontal segments, only.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if edges are routed orthogonally, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.IntegratedEdgeLabeling">
      <summary>
        <para>Gets or sets whether or not the layout algorithm reserves space for labels and places them.</para>
      </summary>
      <remarks>
        <para>To define the desired placement for each label add a <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> on <see cref="T:yWorks.Layout.IEdgeLabelLayout" />.</para>
        <para>This method is a convenience method that assures that the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see> is of type <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> and <see cref="P:yWorks.Layout.LabelLayoutTranslator.TranslateEdgeLabels" /> is set to <c>true</c>.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>if integrated labeling should be enabled but the current <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see> is not of type <see cref="T:yWorks.Layout.LabelLayoutTranslator" /></para>
      </exception>
      <exception cref="T:System.InvalidOperationException">
        <para>if no properly configured <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> is registered even though integrated labeling was enabled earlier (can happen when manually specifying the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see>).</para>
      </exception>
      <value>
        <para>
          <c>true</c> if integrated edge labeling is enabled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the layout algorithm considers node labels when calculating node positions to avoid overlaps.</para>
      </summary>
      <remarks>
        <para>This method is a convenience method that assures that the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see> is of type <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> and <see cref="P:yWorks.Layout.LabelLayoutTranslator.TranslateNodeLabels" /> is set to <c>true</c>.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>if this property should be enabled but the current <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see> is not of type <see cref="T:yWorks.Layout.LabelLayoutTranslator" /></para>
      </exception>
      <exception cref="T:System.InvalidOperationException">
        <para>if no properly configured <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> is registered even though this property was enabled earlier (can happen when manually specifying the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see>).</para>
      </exception>
      <value>
        <para>
          <c>true</c> if the layout algorithm takes the node labels into account, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.MinimumLayerDistance">
      <summary>
        <para>Gets or sets the minimum distance between two adjacent layers.</para>
      </summary>
      <remarks>
        <para>The specified distance should have a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.StopAfterLayering">
      <summary>
        <para>Gets or sets whether or not to stop the layout algorithm after the layering step.</para>
      </summary>
      <remarks>
        <para>By then, each node will be assigned to a layer. Since the sequencing and drawing phases are skipped, the order of the nodes within a layer matches the initial order of the nodes, edges won't be routed and the nodes won't get coordinates assigned.</para>
        <para>The calculated layering information can be retrieved from the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.LayerIndexDpKey" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the layout algorithm should stop after the layering phase, <c>false</c> if the complete layout should be calculated</para>
      </value>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.LayerIndexDpKey" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.StopAfterSequencing">
      <summary>
        <para>Gets or sets whether or not to stop the layout algorithm after the sequencing step.</para>
      </summary>
      <remarks>
        <para>By then, each node will be assigned to a layer and will have a place in the sequence of nodes in this layer. Since the drawing phase is skipped, edges won't be routed and the nodes won't get coordinates assigned.</para>
        <para>The calculated layering and sequencing information can be retrieved from the <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with the keys <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.LayerIndexDpKey" /> and <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.SequenceIndexDpKey" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the layout algorithm should stop after the sequencing phase, <c>false</c> if the complete layout should be calculated</para>
      </value>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.SequenceIndexDpKey" />
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.LayerIndexDpKey" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.NodeToNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two adjacent nodes in one layer.</para>
      </summary>
      <remarks>
        <para>All values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the distance is negative</para>
      </exception>
      <exception cref="T:System.InvalidOperationException">
        <para>if the current <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> is not an instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /></para>
      </exception>
      <value>
        <para>the non-negative minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.NodeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between an edge and an adjacent node in one layer.</para>
      </summary>
      <remarks>
        <para>All values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the distance is negative</para>
      </exception>
      <exception cref="T:System.InvalidOperationException">
        <para>if the current <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> is not an instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /></para>
      </exception>
      <value>
        <para>the non-negative minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.EdgeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two adjacent edges in one layer.</para>
      </summary>
      <remarks>
        <para>All values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the distance is negative</para>
      </exception>
      <exception cref="T:System.InvalidOperationException">
        <para>if the current <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> is not an instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /></para>
      </exception>
      <value>
        <para>the non-negative minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.SeparateLayers">
      <summary>
        <para>Gets or sets whether or not to separate layers.</para>
      </summary>
      <remarks>
        <para>In case layers are not separated, nodes of a layer may extend into adjacent layers. Otherwise, nodes of different layers are strictly separated, i.e., layers are placed below each other.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if layers are separated, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.DefaultDrawingDistanceCalculator">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /> that is registered with the layout algorithm by default.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if the current instance returned by <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.DrawingDistanceCalculator" /> is not an instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /> instance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateHierarchicLayoutCore">
      <summary>
        <para>Returns a new <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> instance.</para>
      </summary>
      <remarks>
        <para>This method may be overridden to create a new <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> object with different configuration settings.</para>
        <para>This factory method provides the initial <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> instance.</para>
      </remarks>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> instance</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.HierarchicLayoutCore">
      <summary>
        <para>Gets the current layout algorithm instance.</para>
      </summary>
      <remarks>
        <para>By default, this method will return a <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> instance created with <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateHierarchicLayoutCore" />.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateHierarchicLayoutCore" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayeringStrategy">
      <summary>
        <para>Gets or sets a predefined layering strategy for the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer">from scratch</see> layerer.</para>
      </summary>
      <remarks>
        <para>The layouter assigns the nodes to separate layers. The nodes within each layer will be placed on the same horizontal layer. The layers will be arranged vertically starting with the small-numbered layers.</para>
        <para>An important layering strategy for the hierarchic layout style is called Hierarchical Layering. A hierarchical layering tries to assign nodes to layers in a way such that as much edges of the graph as possible will point to the main layout direction, i.e., the start nodes of the edges will be in a layer with a smaller number than the corresponding end nodes. Also, a hierarchical layering will never put two connected nodes in the same layer.</para>
        <para>This method wraps the internal implementations into a <see cref="T:yWorks.Layout.Hierarchic.MultiComponentLayerer" /> instance so that it is possible to specify the behavior of the algorithm if the <see cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled">component layouter</see> is disabled.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown strategy is given</para>
      </exception>
      <value>
        <para>one of the predefined layering strategies</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Delegates the calculation of the hierarchic layout to a configured <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> instance.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> applies its own configuration to <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> and also prepares the graph for layout.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.GetMirrorMode">
      <summary>
        <para>Returns the mirror mask of the <see cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout">orientation layouter</see>.</para>
      </summary>
      <remarks>
        <para>It may be overridden in order to configure a different mirror mask.</para>
      </remarks>
      <returns>
        <para>the mirror mask</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.ConfigureCoreLayout(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.HierarchicLayoutCore)">
      <summary>
        <para>Configures the core layout algorithm with the settings of this <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> before the actual layout is calculated. It may be overridden in order to manually reconfigure the core layout algorithm.</para>
        <para>This implementation will temporarily set a <see cref="T:yWorks.Layout.Hierarchic.PortCandidateOptimizer" /> if a <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with <see cref="F:yWorks.Layout.PortCandidateSet.NodePortCandidateSetDpKey" /> and no <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortConstraintOptimizer" /> is assigned.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="coreLayouter">
        <para>the given core layout algorithm instance</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.DisposeCoreLayout(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.HierarchicLayoutCore)">
      <summary>
        <para>Disposes of the core layout algorithm.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> after the actual layout is calculated. It may be overridden in order to revert a custom configuration made in <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.ConfigureCoreLayout(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.HierarchicLayoutCore)" />.</para>
        <para>This implementation will remove the <see cref="T:yWorks.Layout.Hierarchic.PortCandidateOptimizer" /> that was created in case a <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with <see cref="F:yWorks.Layout.PortCandidateSet.NodePortCandidateSetDpKey" /> and no <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortConstraintOptimizer" /> was initially assigned.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="coreLayouter">
        <para>the given core layout algorithm instance</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateIncrementalHintsFactory">
      <summary>
        <para>Returns a <see cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" /> instance that must be used to obtain hints to be associated with graph elements that should be laid out incrementally.</para>
      </summary>
      <remarks>
        <para>Use this factory and a <see cref="T:yWorks.Algorithms.IDataProvider" /> that is registered to the graph using the <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.IncrementalHintsDpKey" /> key to associate appropriate hints with the graph elements that should be laid out incrementally by the algorithm.</para>
      </remarks>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" /> instance</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateIncrementalHintsFactory" />
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.IncrementalHintsDpKey" />
      <seealso cref="M:yWorks.Algorithms.Graph.AddDataProvider(System.Object,yWorks.Algorithms.IDataProvider)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode" />
      <seealso cref="F:yWorks.Layout.Hierarchic.LayoutMode.Incremental" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateSequenceConstraintFactory(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Returns a <see cref="T:yWorks.Layout.Hierarchic.ISequenceConstraintFactory" /> instance that can be used for specifying sequence constraints for the given graph.</para>
      </summary>
      <remarks>
        <para>For these sequence constraints to have any effect, the <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> that determines the in-layer node order (<em>sequence</em>) has to support constraints. Both, <see cref="T:yWorks.Layout.Hierarchic.DefaultLayerSequencer">DefaultLayerSequencer</see> and the incremental sequencer used internally support sequence constraints.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ISequenceConstraintFactory" /> instance</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateLayerConstraintFactory(yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory" /> instance that can be used for specifying layer constraints for the given graph.</para>
      </summary>
      <remarks>
        <para>The instance is usually bound to <see cref="T:yWorks.Algorithms.Graph" /> instance <c>graph</c>, i.e., if the input graph for the layerer changes, a new instance must be retrieved. This instance can be used for creating constraints for this graph instance.</para>
        <para>You can create an instance without binding it to a graph instance initially by passing a <c>null</c> parameter. In that case, you <b>must</b> bind the returned instance to the graph, see <see cref="F:yWorks.Layout.Hierarchic.LayerConstraintFactoryCompanion.LayerConstraintsMementoDpKey" /> and <see cref="P:yWorks.Layout.Hierarchic.ILayerConstraintFactory.Memento" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory" /> instance</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance that obtains the layering for the nodes if the layout algorithm runs in <see cref="F:yWorks.Layout.Hierarchic.LayoutMode.FromScratch">From Scratch mode</see>.</para>
      </summary>
      <remarks>
        <para>If the graph consists of multiple components, then the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance should be wrapped in <see cref="T:yWorks.Layout.Hierarchic.MultiComponentLayerer" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance that calculates the node sequence if the layout algorithm runs in <see cref="F:yWorks.Layout.Hierarchic.LayoutMode.FromScratch">From Scratch mode</see>.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.NodePlacer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> instance that will calculate the final node placement of the layout.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance that obtains the layering for fixed nodes during the incremental layout run.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance used for fixed nodes</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance that calculates the sequence of the fixed nodes during the incremental layout run.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance used for fixed elements</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.LayoutMode">
      <summary>
        <para>Gets or sets the layout mode this layouter should use for upcoming layouts.</para>
      </summary>
      <remarks>
        <para>Depending on the mode the layout algorithm will use different <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> and <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> implementations. <br /></para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given layout mode is unknown</para>
      </exception>
      <value>
        <para>the new layout mode</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateEdgeLayoutDescriptor">
      <summary>
        <para>Returns a new <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance that will be used during the various phases of the layout algorithm to determine the drawing details of the edges of the graph.</para>
      </summary>
      <remarks>
        <para>This method may be overridden to create a new <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance with different configuration settings.</para>
      </remarks>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.EdgeLayoutDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance used for all those edges that do not have a specific layout descriptor assigned.</para>
      </summary>
      <remarks>
        <para>By default, this method will return a <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance created with <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateEdgeLayoutDescriptor" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance</para>
      </value>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.EdgeLayoutDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateNodeLayoutDescriptor">
      <summary>
        <para>Returns a new <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance that will be used during the various phases of the layout algorithm to determine the drawing details of the nodes of the graph.</para>
      </summary>
      <remarks>
        <para>This method may be overridden to create a new <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance with different configuration settings.</para>
      </remarks>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayout.NodeLayoutDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance used for all those nodes that do not have a specific layout descriptor assigned.</para>
      </summary>
      <remarks>
        <para>By default, this method will return a <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance created with <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateNodeLayoutDescriptor" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance</para>
      </value>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodeLayoutDescriptorDpKey" />
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateNodeLayoutDescriptor" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore">
      <summary>
        <para>This class arranges graphs in a hierarchic/layered fashion and supports complete re-layout as well as incremental graph layout.</para>
      </summary>
      <remarks>
        <para>Note that class <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> offers a facade to this class which is easier to use. Hence, we strongly recommend to not directly use class <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" />.</para>
        <para>
          <h2>Layout Style</h2> The nodes are distributed into layers such that most of the edges point to the main layout direction. The order of the nodes within the layers ensures that the number of edge crossings is as small as possible. There are different edge routing styles available. Edges can be orthogonal, polyline or octilinear.</para>
        <para>Hierarchical diagrams are commonly used for the visualization of hierarchical data, since they facilitate the identification of dependencies and relationships among the nodes of the graph. Possible application domains are the following: workflow visualization, call graph visualization, entity-relationship diagrams, biochemical pathways and network management.</para>
        <para> Hierarchic Layout obtained with default settings <h2>Concept</h2> The layout algorithm runs in three main phases:</para>
        <list type="bullet">
          <item>
            <term>Layering</term>
            <description>The nodes are distributed into layers by means of <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Layerer" />. If the layout orientation is top-to-bottom, the nodes in each layer are arranged horizontally while the layers are ordered vertically top-to-bottom.</description>
          </item>
          <item>
            <term>Sequencing</term>
            <description>The order of the nodes in each layer is determined such that the number of edge crossings is as small as possible. To specify the sequencing algorithm, use <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Sequencer" />.</description>
          </item>
          <item>
            <term>Drawing</term>
            <description>The layout algorithm assigns the final coordinates to all nodes and routes the edges.</description>
          </item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>In order to customize this layout algorithm, modify the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Layerer">Layerer</see>, <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Sequencer">Sequencer</see>, <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortAllocator">PortAllocator</see>, <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.DrawingDistanceCalculator">DrawingDistanceCalculator</see>, and <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodePlacer">NodePlacer</see> instances.</para>
        <para>This layout algorithm is able to incrementally add new elements to an existing drawing of a graph. In order to add elements incrementally, register a <see cref="T:yWorks.Algorithms.IDataProvider" /> with the graph using the <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey" /> DataProvider key and associate the hints obtained from the <see cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" /> with the elements to be added incrementally.</para>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> and <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instances can be used for specifying individual information (e.g. distances or routing styles) for each node and edge in the graph. The descriptors are bound to the graph using <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodeLayoutDescriptorDpKey" /> or <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.EdgeLayoutDescriptorDpKey" />.</para>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> supports two approaches to connect edges on a specific side or even an exact location to a node. <see cref="T:yWorks.Layout.PortConstraint" />s define a single constraint for the ports of an edge. To realize more complex port restrictions, several <see cref="T:yWorks.Layout.PortCandidate" />s or <see cref="T:yWorks.Layout.PortCandidateSet" />s can be assigned to edges or nodes. If an edge with registered <see cref="T:yWorks.Layout.PortCandidate" />s connects to nodes with <see cref="T:yWorks.Layout.PortCandidateSet" />s, the layouter will try to match both collections to find an appropriate port. In case there is no matching port candidate, a <see cref="T:yWorks.Layout.PortCandidate" /> specified for the edge is preferred. Since their simultaneous existence at the same node may be ambiguous, it is not recommended to use a combination of <see cref="T:yWorks.Layout.PortConstraint" />s and <see cref="T:yWorks.Layout.PortCandidate" />s in the same layout.</para>
        <para>This algorithm specifies a <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> instance as the current <see cref="P:yWorks.Layout.MultiStageLayout.Labeling" /> and configures it such that the node labels are passed to it by setting <see cref="P:yWorks.Layout.LabelLayoutTranslator.TranslateNodeLabels" /> to <c>true</c>.</para>
        <para>In order to enable integrated edge labeling of this algorithm, make sure <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> is registered and edge labels are being translated and written back after the layout.</para>
        <para>Moreover, this algorithm supports layer and sequence constraints. These constraints can be specified using a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory" /> and <see cref="T:yWorks.Layout.Hierarchic.ISequenceConstraintFactory" />, respectively.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerer" />
      <seealso cref="T:yWorks.Layout.Hierarchic.ISequencer" />
      <seealso cref="T:yWorks.Layout.Hierarchic.IPortAllocator" />
      <seealso cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" />
      <seealso cref="T:yWorks.Layout.Hierarchic.INodePlacer" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey">
      <summary>
        <para>A data provider key for specifying incremental hints.</para>
      </summary>
      <remarks>
        <para>Incremental hints are created using an <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateIncrementalHintsFactory">incremental hints factory</see>.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey" />
      <seealso cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.EdgeLayoutDescriptorDpKey">
      <summary>
        <para>A data provider key for providing layout information for each edge.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.EdgeLayoutDescriptor" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodeLayoutDescriptorDpKey">
      <summary>
        <para>A data provider key for providing layout information for each node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.NodeLayoutDescriptor" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SwimlaneDescriptorDpKey">
      <summary>
        <para>A data provider key for providing information about swimlanes.</para>
      </summary>
      <remarks>
        <para>If this key is present during the layout, the layout algorithm will arrange nodes in swimlanes. The information about the swimlanes is finally written back to the descriptor instances.</para>
        <para>Instances can be shared among multiple nodes in the same lane, but don't have to be shared.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" />
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.SwimLaneDescriptor" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.LayerIndexDpKey">
      <summary>
        <para>A data acceptor key for publishing the layer IDs for all nodes in the graph.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.LayerIndexDpKey" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SequenceIndexDpKey">
      <summary>
        <para>A data acceptor key for publishing the index inside their layer for all nodes in the graph.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.SequenceIndexDpKey" />
    </member>
    <member name="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalNodesDpKey">
      <summary>
        <para>A data provider key for internal use only.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> instance with the default settings.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateLayerer" />
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateIncrementalLayerer" />
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateSequencer" />
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateDrawingDistanceCalculator" />
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateNodePlacer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateLabelLayout">
      <summary>
        <para>Factory method called during the initialization of this <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> instance that creates a <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">label layouter</see>.</para>
      </summary>
      <remarks>
        <para>In order to use the integrated node label awareness feature one has to use a <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> instance and set <see cref="P:yWorks.Layout.LabelLayoutTranslator.TranslateNodeLabels" /> to <c>true</c>. Likewise, in order to make use of the integrated edge labeling <see cref="P:yWorks.Layout.LabelLayoutTranslator.TranslateEdgeLabels" /> must be set to <c>true</c> and also <see cref="P:yWorks.Layout.LabelLayoutTranslator.WriteBackEdgeLabels" /> must be set to <c>true</c> (which is the default).</para>
      </remarks>
      <value>
        <para>a new <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> instance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateLayerer">
      <summary>
        <para>Factory method that is called lazily upon first usage by <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Layerer" /> if no <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance is given as input.</para>
      </summary>
      <remarks>
        <para>The default implementation returns a <c>new MultiComponentLayerer(new WeightedLayerer())</c> instance. It may be overridden to return a custom <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Layerer" />
      <seealso cref="T:yWorks.Layout.Hierarchic.MultiComponentLayerer" />
      <seealso cref="T:yWorks.Layout.Hierarchic.WeightedLayerer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ComponentLayoutEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.ComponentLayout" /> should be enabled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if <see cref="T:yWorks.Layout.ComponentLayout" /> is enabled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.MaximumDuration">
      <summary>
        <para>Gets or sets the time limit (in milliseconds) set for the layout algorithm.</para>
      </summary>
      <remarks>
        <para>Values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the maximum duration is negative</para>
      </exception>
      <value>
        <para>a non-negative value that specifies the time limit</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateSequencer">
      <summary>
        <para>Factory method that is called lazily upon first usage by <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Sequencer" /> if the given <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance is <c>null</c>.</para>
      </summary>
      <remarks>
        <para>The default implementation returns a <see cref="T:yWorks.Layout.Hierarchic.DefaultLayerSequencer" /> instance. It may be overridden to return a custom <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Sequencer" />
      <seealso cref="T:yWorks.Layout.Hierarchic.DefaultLayerSequencer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateDrawingDistanceCalculator">
      <summary>
        <para>Factory method that is called lazily upon first usage by <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.DrawingDistanceCalculator" /> if the given <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> instance is <c>null</c>.</para>
      </summary>
      <remarks>
        <para>The default implementation returns a <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /> instance. It may be overridden to return a custom <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" /> instance.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> instance</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.DrawingDistanceCalculator" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreatePortAllocator">
      <summary>
        <para>Factory method that is called lazily upon first usage by <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortAllocator" /> if the given <see cref="T:yWorks.Layout.Hierarchic.IPortAllocator" /> instance is <c>null</c>.</para>
      </summary>
      <remarks>
        <para>The default implementation returns a <see cref="T:yWorks.Layout.Hierarchic.DefaultPortAllocator" /> instance. It may be overridden to return a custom <see cref="T:yWorks.Layout.Hierarchic.IPortAllocator" /> instance.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.IPortAllocator" /> instance</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortAllocator" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreatePortConstraintOptimizer">
      <summary>
        <para>Factory method that is called lazily upon first usage by <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortConstraintOptimizer" /> if the given <see cref="T:yWorks.Layout.Hierarchic.IPortConstraintOptimizer" /> instance is <c>null</c>.</para>
      </summary>
      <remarks>
        <para>The default implementation returns <c>null</c>. It may be overridden to return a custom <see cref="T:yWorks.Layout.Hierarchic.IPortConstraintOptimizer" /> instance.</para>
      </remarks>
      <returns>
        <para>
          <c>null</c>
        </para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortConstraintOptimizer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateNodePlacer">
      <summary>
        <para>Factory method that is called lazily upon first usage by <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodePlacer" /> if the given <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> instance is <c>null</c>.</para>
      </summary>
      <remarks>
        <para>The default implementation returns a <see cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" /> instance. It may be overridden to return a custom <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> instance.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> instance</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodePlacer" />
      <seealso cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Layerer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance responsible for generating the layer assignment (first phase of the layout algorithm).</para>
      </summary>
      <remarks>
        <para>To set the default layerer, see <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateLayerer" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateLayerer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Sequencer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance responsible for calculating the sequence of nodes within each layer (second phase of the layout algorithm).</para>
      </summary>
      <remarks>
        <para>To set the default sequencer, see <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateSequencer" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateSequencer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodePlacer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> instance responsible for the assignment of the x-(sequence) and preliminary y-coordinates of the nodes.</para>
      </summary>
      <remarks>
        <para>To set the default node placer, see <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateNodePlacer" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateNodePlacer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortAllocator">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.IPortAllocator" /> instance responsible for assigning port coordinates to the adjacent edges of each node.</para>
      </summary>
      <remarks>
        <para>To set the default port allocator, see <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreatePortAllocator" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.IPortAllocator" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Hierarchic.IPortAllocator" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreatePortAllocator" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortConstraintOptimizer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.IPortConstraintOptimizer" /> instance responsible for optimizing the assignment of port constraints to the adjacent edges of each node.</para>
      </summary>
      <remarks>
        <para>To set the default port allocator, see <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreatePortConstraintOptimizer" />.</para>
      </remarks>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Hierarchic.IPortConstraintOptimizer" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreatePortConstraintOptimizer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.DrawingDistanceCalculator">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> instance responsible for determining the minimum distances between elements that belong to the same layer.</para>
      </summary>
      <remarks>
        <para>To set the default port allocator, see <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateDrawingDistanceCalculator" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateDrawingDistanceCalculator" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.GridSpacing">
      <summary>
        <para>Gets or sets the equidistant spacing between the horizontal and vertical grid lines.</para>
      </summary>
      <remarks>
        <para>When the spacing is negative or zero, no grid is defined, otherwise nodes and edges are placed on multiples of the grid spacing.</para>
      </remarks>
      <value>
        <para>the grid spacing</para>
      </value>
      <seealso cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.GetAlgorithmProperty(System.Object)">
      <summary>
        <para>Provides access to implementation specific properties of the algorithms used.</para>
      </summary>
      <remarks>
        <para>Used for internal purposes.</para>
      </remarks>
      <param name="key">
        <para>the key to a property</para>
      </param>
      <returns>
        <para>the associated value or <c>null</c></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SetAlgorithmProperty(System.Object,System.Object)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SetAlgorithmProperty(System.Object,System.Object)">
      <summary>
        <para>Provides access to implementation specific properties of the algorithms used.</para>
      </summary>
      <remarks>
        <para>Used for internal purposes.</para>
      </remarks>
      <param name="key">
        <para>the key to a property</para>
      </param>
      <param name="value">
        <para>the value to associate with the key</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SetAlgorithmProperty(System.Object,System.Object)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates a hierarchic layout of the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateGrouping(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Factory method that is called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and creates a <see cref="T:yWorks.Layout.Grouping.GroupingSupport" /> instance in case of a grouped graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Grouping.GroupingSupport" /> instance or <c>null</c> if the graph is not grouped</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.GetIncrementalHints(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Callback method called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and returns a <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHint" />s information.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> holding the information about <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHint" />s is registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> instance or <c>null</c></para>
      </returns>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.GetEdgeLayoutDescriptors(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Callback method called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and returns a <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds the <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> information.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> holding the information about the node layout is registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.EdgeLayoutDescriptorDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> instance or <c>null</c></para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" />
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.EdgeLayoutDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.GetNodeLayoutDescriptors(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Callback method called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and returns a <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds the <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> information.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> holding the information about the node layout is registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodeLayoutDescriptorDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> instance or <c>null</c></para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" />
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodeLayoutDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.GetSwimLaneDescriptors(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Callback method called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and returns a <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds the <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> information.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> holding the information about swimlanes is registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SwimlaneDescriptorDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> instance or <c>null</c></para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" />
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SwimlaneDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateItemData(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Callback method that is called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" />, creates the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances and binds them to the elements using the given <see cref="T:yWorks.Layout.Hierarchic.IItemFactory">itemFactory</see>.</para>
      </summary>
      <param name="g">
        <para>the input graph</para>
      </param>
      <param name="itemFactory">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> instance</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateSubgraphLayerSequencer">
      <summary>
        <para>Factory method called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and creates a <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> implementation that can sequence subgraphs incrementally.</para>
      </summary>
      <remarks>
        <para>By default, a suitable private implementation of <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> is returned. It may be overridden to return custom implementations of the <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> interface.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ISequencer" /> implementation</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateLayers(yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Factory method called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and creates an appropriate <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> implementation using the given <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> instance.</para>
      </summary>
      <remarks>
        <para>By default, a suitable private implementation of <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> is returned. It may be overridden to return custom implementations of the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> interface.</para>
      </remarks>
      <param name="ldp">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> instance</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> implementation</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateIncrementalLayerer">
      <summary>
        <para>Factory method called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and creates an appropriate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> implementation.</para>
      </summary>
      <remarks>
        <para>By default, a <see cref="T:yWorks.Layout.Hierarchic.ConstraintIncrementalLayerer" /> instance with a <see cref="T:yWorks.Layout.Hierarchic.TopologicalLayerer" /> instance as argument is returned. This method may be overridden to return a custom <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> implementation.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> implementation</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateEdgeReverser">
      <summary>
        <para>Factory method called during <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> and reates an appropriate <see cref="T:yWorks.Layout.Hierarchic.IEdgeReverser" /> implementation.</para>
      </summary>
      <remarks>
        <para>By default, a suitable private implementation of <see cref="T:yWorks.Layout.Hierarchic.IEdgeReverser" /> is returned. It may be overridden to return a custom <see cref="T:yWorks.Layout.Hierarchic.IEdgeReverser" /> implementation.</para>
      </remarks>
      <returns>
        <para>an implementation</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PublishLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers)">
      <summary>
        <para>Callback method that publishes the layering information.</para>
      </summary>
      <remarks>
        <para>The layering information is stored in a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.LayerIndexDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> implementation that provides the layering information</para>
      </param>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.LayerIndexDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PublishSequences(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Callback method that publishes the sequencing information.</para>
      </summary>
      <remarks>
        <para>The sequencing information is stored in a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SequenceIndexDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> implementation that provides the layering information</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.LayerIndexDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ReduceBendCount(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Removes the bends which are obviously not necessary.</para>
      </summary>
      <remarks>
        <para>By default, this method removes collinear bends from the graph. A bend point is considered to be collinear if it lies on a line with its preceding and succeeding bend point. It may be overridden for a custom implementation of bend removal.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.ReduceBendCount(yWorks.Layout.LayoutGraph,System.Double)">
      <summary>
        <para>Removes the bends which are obviously not necessary.</para>
      </summary>
      <remarks>
        <para>By default, this method removes collinear bends from the graph. A bend point is considered to be collinear if it lies on a line with its preceding and succeeding bend point. It may be overridden for a custom implementation of bend removal.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="bendReductionThreshold">
        <para>this method removes a bend, if its horizontal/vertical distance to the closest collinear bend is above this value</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateIncrementalHintsFactory">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" /> implementation used for obtaining hint objects associated with nodes and edges of the graph prior to the invocation of the layout algorithm.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHint" />s can be obtained from a <see cref="T:yWorks.Algorithms.IDataProvider" /> that is registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey" />.</para>
      </remarks>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory" /> instance</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateSequenceConstraintFactory(yWorks.Algorithms.Graph)">
      <summary>
        <para>Creates sequence constraints that affect the sequence of the nodes within each layer.</para>
      </summary>
      <remarks>
        <para>By default, a suitable private implementation of <see cref="T:yWorks.Layout.Hierarchic.ISequenceConstraintFactory" /> is returned.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ISequenceConstraintFactory" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateLayerConstraintFactory(yWorks.Algorithms.Graph)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory">layer constraint factory</see> that allows to create hints that affect the assignment of the nodes to layers.</para>
      </summary>
      <remarks>
        <para>By default, a suitable private implementation of <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory" /> is returned.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator">
      <summary>
        <para>This interface determines the minimum distances between elements that belong to the same layer.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> is implemented by a helper class used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> during the phase of node placement (i.e. when the final coordinates for all nodes are calculated). <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> uses instances of this interface to determine the minimum distances between elements that belong to the same layer.</para>
        <para>Information about graph elements (i.e. nodes or edges) is given using a <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> while information about layers is given through <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> (describes a single layer of the hierarchic layout) or <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> (manages multiple <see cref="T:yWorks.Layout.Hierarchic.ILayer">layers</see> of the hierarchic layout).</para>
        <para>Implementations not needed any more should be <see cref="M:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator.Dispose(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">disposed of</see>.</para>
        <para>The default implementation used by the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> is <see cref="T:yWorks.Layout.Hierarchic.DefaultDrawingDistanceCalculator" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator.Initialize(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Initializes internal data structures.</para>
      </summary>
      <remarks>
        <para>Implementations may cache lengthy calculations in the initialization phase.</para>
      </remarks>
      <param name="graph">
        <para>the input graph that contains all elements that are used during the node placement</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> object that will be used during subsequent calls</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator.Dispose(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator.GetMinDistance(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayer,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Main interface method called by <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> instances to determine the minimum distance between <see cref="T:yWorks.Algorithms.Node" />s of same layer.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layer">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> object that will be used during subsequent calls</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="left">
        <para>the left of the two <see cref="T:yWorks.Algorithms.Node" />s whose minimum distance is to be determined or <c>null</c> if only the left border of the right <see cref="T:yWorks.Algorithms.Node" /> is of interest</para>
      </param>
      <param name="right">
        <para>the right of the two <see cref="T:yWorks.Algorithms.Node" />s whose minimum distance is to be determined or <c>null</c> if only the right border of the left <see cref="T:yWorks.Algorithms.Node" /> is of interest</para>
      </param>
      <returns>
        <para>the minimum distance between two <see cref="T:yWorks.Algorithms.Node" />s of the same layer</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator.Dispose(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Disposes of internal data structures.</para>
      </summary>
      <remarks>
        <para>Implementations should release internally held data structures when they are not needed any more.</para>
      </remarks>
      <param name="graph">
        <para>the input graph that contains all elements that are used during the node placement</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> object that will be used during subsequent calls</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator.Initialize(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.IEdgeData">
      <summary>
        <para>This interface provides layout information about the edges of the graph during the layout.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> is a multi-purpose edge descriptor for each edge, holding information about the <see cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type">type</see> of an edge, associated <see cref="T:yWorks.Layout.PortConstraint">port constraints</see>, <see cref="T:yWorks.Layout.PortCandidate">port candidates</see>, edge groups as well as the current edge state.</para>
        <para>It is used in all phases of the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> to store edge information.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.Type">
      <summary>
        <para>Gets the type of the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <value>
        <para>the type of the associated <see cref="T:yWorks.Algorithms.Edge" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.AssociatedNode">
      <summary>
        <para>Gets the <see cref="T:yWorks.Algorithms.Node" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Algorithms.Node" /> is associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance, <c>null</c> should be returned.</para>
      </remarks>
      <value>
        <para>the associated <see cref="T:yWorks.Algorithms.Node" /> or <c>null</c> no such <see cref="T:yWorks.Algorithms.Node" /> exists</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.AssociatedEdge">
      <summary>
        <para>Gets the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Algorithms.Edge" /> is associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance, <c>null</c> should be returned.</para>
      </remarks>
      <value>
        <para>the associated <see cref="T:yWorks.Algorithms.Edge" /> or <c>null</c> no such <see cref="T:yWorks.Algorithms.Edge" /> exists</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.SourcePortConstraint">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.PortConstraint">port constraints</see> for the source port of the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.PortConstraint" />s are obtained by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />.</para>
      </remarks>
      <value>
        <para>a <see cref="T:yWorks.Layout.PortConstraint" /> instance for the source port</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.SourcePortGroup">
      <summary>
        <para>Gets the ID of the edge port group at the source node to which the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance belongs (if any).</para>
      </summary>
      <remarks>
        <para>Information about edge port grouping at the source node is obtained by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.PortConstraintKeys.SourcePortGroupIdDpKey" />.</para>
      </remarks>
      <value>
        <para>the ID of the port group at the source node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.SourcePortCandidates">
      <summary>
        <para>Gets the <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of <see cref="T:yWorks.Layout.PortCandidate" />s for the source port of the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.PortCandidate">Source port candidates</see> are obtained by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.PortCandidate.SourcePortCandidateCollectionDpKey" />.</para>
      </remarks>
      <value>
        <para>a <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of <see cref="T:yWorks.Layout.PortCandidate" /> for the source port</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.TargetPortConstraint">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.PortConstraint">port constraints</see> for the target port of the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.PortConstraint" />s are obtained by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />.</para>
      </remarks>
      <value>
        <para>a <see cref="T:yWorks.Layout.PortConstraint" /> instance for the target port</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.TargetPortGroup">
      <summary>
        <para>Gets the ID of the edge port group at the target node to which the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance belongs (if any).</para>
      </summary>
      <remarks>
        <para>Information about edge port grouping at the target node is obtained by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.PortConstraintKeys.TargetPortGroupIdDpKey" />.</para>
      </remarks>
      <value>
        <para>the ID of the group at the target node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.TargetPortCandidates">
      <summary>
        <para>Gets the <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of <see cref="T:yWorks.Layout.PortCandidate" />s for the target port of the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.PortCandidate">Target port candidates</see> are obtained by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.PortCandidate.TargetPortCandidateCollectionDpKey" />.</para>
      </remarks>
      <value>
        <para>a <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of <see cref="T:yWorks.Layout.PortCandidate" /> for the target port</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.SourceGroup">
      <summary>
        <para>Gets the ID of the edge group at the source node to which the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance belongs (if any).</para>
      </summary>
      <remarks>
        <para>Information about edge grouping at the source node is obtained by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />.</para>
      </remarks>
      <value>
        <para>the ID of the group at the source node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.TargetGroup">
      <summary>
        <para>Gets the ID of the edge group at the target node to which the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance belongs (if any).</para>
      </summary>
      <remarks>
        <para>Information about edge grouping at the target node is obtained by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />.</para>
      </remarks>
      <value>
        <para>the ID of the group at the target node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.Group">
      <summary>
        <para>Gets the group that is represented by the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <value>
        <para>the group represented by the associated <see cref="T:yWorks.Algorithms.Edge" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.Reversed">
      <summary>
        <para>Gets whether or not the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance has been reversed.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the associated <see cref="T:yWorks.Algorithms.Edge" /> has been reversed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.UpperSameLayerEdge">
      <summary>
        <para>Gets whether or not the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance is an upper same-layer edge.</para>
      </summary>
      <remarks>
        <para>An upper same-layer edge is an edge connecting two nodes of the same layer with polyline segments (not directly, with a straight-line) and is routed above the layer.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the associated <see cref="T:yWorks.Algorithms.Edge" /> is an upper same-layer edge, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.EdgeLayoutDescriptor">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance bound to the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> is bound to the edge, <c>null</c> should be returned.</para>
      </remarks>
      <value>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> instance or <c>null</c> if no <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> is registered</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.FallbackUpperSameLayerEdge">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance should be an upper same-layer edge (if it is a same-layer edge).</para>
      </summary>
      <remarks>
        <para>An upper same-layer edge is an edge connecting two nodes of the same layer with polyline segments (not directly, with a straight-line) and is routed above the layer.</para>
        <para>If enabled the edge will be routed above the layer, otherwise below it.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the same-layer edge should be routed above the layer, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.IEdgeData.Thickness">
      <summary>
        <para>Gets the thickness of the <see cref="T:yWorks.Algorithms.Edge" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance.</para>
      </summary>
      <remarks>
        <para>The thickness is considered when calculating minimum distances so that there are no overlaps between edges and other graph elements.</para>
        <para>The thickness must have a non-negative value.</para>
      </remarks>
      <value>
        <para>the thickness for the edge</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.IEdgeReverser">
      <summary>
        <para>This interface handles edges that should be reversed during the hierarchic layout process.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.IEdgeReverser" /> contains methods for reversing all (or a given edge) that point to the wrong direction, i.e. the layer indices of the source nodes are greater than the layer indices of the target nodes. It also provides methods to restore the edges that have been reversed at the end of the layout algorithm.</para>
        <para>Implementations of this interface perform operations after the layering phase of the hierarchic layout algorithm.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IEdgeReverser.NormalizeEdges(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Reverses all edges which point to the wrong direction.</para>
      </summary>
      <remarks>
        <para>It is called after the layering phase of the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore">hierarchic layout algorithm</see>.</para>
        <para>An edge is reversed if the layer index of its source node is greater than the layer index of its target node.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing layering information about the nodes and edges of the graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.ILayoutDataProvider.GetNodeData(yWorks.Algorithms.Node)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Layer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IEdgeReverser.Reverse(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Edge)">
      <summary>
        <para>Reverses a given edge which points to the wrong direction.</para>
      </summary>
      <remarks>
        <para>It may be called by the incremental parts of the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore">hierarchic layout algorithm</see>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing layering information about the nodes and edges of the graph</para>
      </param>
      <param name="edge">
        <para>the edge to be reversed</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.ILayoutDataProvider.GetNodeData(yWorks.Algorithms.Node)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.INodeData.Layer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IEdgeReverser.RestoreEdgeDirections(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Restores the original direction of edges marked as reversed.</para>
      </summary>
      <remarks>
        <para>It is called at the end of the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore">hierarchic layout algorithm</see>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the nodes and edges of the graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.IIncrementalHintsFactory">
      <summary>
        <para>This interface provides factory methods for creating incremental hints for the hierarchic layout.</para>
      </summary>
      <remarks>
        <para>Incremental hints can be used for specifying that a subset of nodes (called <em>incremental</em> nodes) should be added to an existing graph layout. A layer hint specifies that both, a node's layer and its position within the layer should be freely determined by the algorithm. A sequence hint specifies that the algorithm should consider the current layer of a node while its position within the layer should be freely determined by the algorithm. A node without any hint is called a <em>fixed</em> node.</para>
        <para>Sequence hints can also be specified for edges. These <em>incremental</em> edges are inserted in a suitable position within the layers crossed by the edges. For <em>fixed</em> edges the given input route is considered to calculate the position with the layers.</para>
        <para>Information about incremental hints is provided by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayout.IncrementalHintsDpKey" />.</para>
        <para>An instance of a class implementing this interface can be obtained through method <see cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateIncrementalHintsFactory" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateLayerIncrementallyHint(System.Object)">
      <summary>
        <para>Creates a hint <see cref="T:System.Object" /> for a <see cref="T:yWorks.Algorithms.Node" /> that should be inserted incrementally during the layering phase.</para>
      </summary>
      <remarks>
        <para>This will place the node in a suitable layer, possibly creating new layers.</para>
        <para>Neighbors of this node may be also marked such that they are laid out incrementally. This makes it possible to incrementally add whole subgraphs to the current layout.</para>
      </remarks>
      <param name="forNodeId">
        <para>the node to be layered and sequenced incrementally</para>
      </param>
      <returns>
        <para>an <see cref="T:System.Object" /> that can be interpreted as a hint by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateSequenceIncrementallyHint(System.Object)">
      <summary>
        <para>Creates a hint <see cref="T:System.Object" /> for a <see cref="T:yWorks.Algorithms.Node" /> or <see cref="T:yWorks.Algorithms.Edge" /> that should be inserted incrementally during the sequencing phase.</para>
      </summary>
      <remarks>
        <para>All nodes that are not incrementally inserted during the layering phase (see <see cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateLayerIncrementallyHint(System.Object)" />) stay in their current layer. More precisely, the default <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer" /> implementation is an instance of <see cref="T:yWorks.Layout.Hierarchic.AsIsLayerer" /> that determines the layer of the "fixed" nodes by analyzing the current node coordinates. Note that for the other nodes, the layout algorithm may insert new layers in between the existing layers.</para>
        <para>For edges associated with this hint (or which are incident to an incremental node), the algorithm automatically calculates a suitable sequencing (position within the layer). For edges between two non-incremental nodes that do not have a hint, the sequencing phase considers the current route.</para>
      </remarks>
      <param name="forItemId">
        <para>the node or edge to be sequenced/inserted incrementally</para>
      </param>
      <returns>
        <para>an <see cref="T:System.Object" /> that can be interpreted as a hint by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateIncrementalGroupHint(System.Object)">
      <summary>
        <para>Creates a hint <see cref="T:System.Object" /> for a group <see cref="T:yWorks.Algorithms.Node" /> that should be inserted incrementally during the layering phase.</para>
      </summary>
      <remarks>
        <para>The group will be placed on a suitable position. The descendants of the group may be associated with hints created by methods <see cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateLayerIncrementallyHint(System.Object)" />, <see cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateSequenceIncrementallyHint(System.Object)" /> or this method (if the descendant is an inner group).</para>
        <para>All hints of the descendants of a group are interpreted relative to the group node. Descendants without hints maintain their relative order within the group node (but not with elements outside the group).</para>
        <para>The positions of groups without incremental hints depend on the position of their descendants (i.e., the group is not interpreted as fixed - it is simply ignored).</para>
      </remarks>
      <param name="forItemId">
        <para>the group node to be inserted incrementally</para>
      </param>
      <returns>
        <para>an <see cref="T:System.Object" /> that can be interpreted as a hint by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactCoordinatesHint(System.Object)">
      <summary>
        <para>Creates a hint <see cref="T:System.Object" /> for a <see cref="T:yWorks.Algorithms.Node" /> that should be inserted incrementally into the graph on its exact current position.</para>
      </summary>
      <remarks>
        <para>As for nodes without hints, the algorithm uses the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer" /> instance to determine the layer of such nodes and the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" /> instance to determine the position within the layer. By default, both implementations use the current coordinates of the nodes to derive the layer/position. However, for nodes marked with this hint, the algorithm should also preserve the exact coordinates while for nodes without hints the coordinates may be changed (these nodes only keep their relative positions).</para>
      </remarks>
      <param name="forNodeId">
        <para>the node to be placed on its exact current position</para>
      </param>
      <returns>
        <para>an <see cref="T:System.Object" /> that can be interpreted as a hint by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactSequenceCoordinatesHint(System.Object)" />
      <seealso cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactLayerCoordinatesHint(System.Object)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.ExactPlacement" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactLayerCoordinatesHint(System.Object)">
      <summary>
        <para>Creates a hint <see cref="T:System.Object" /> for a <see cref="T:yWorks.Algorithms.Node" /> that should be inserted incrementally into the graph on its exact current layer position.</para>
      </summary>
      <remarks>
        <para>The algorithm uses the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer" /> instance to determine the layer of such nodes and the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer" /> instance to determine the sequencing.</para>
      </remarks>
      <param name="forNodeId">
        <para>the node to be placed on its exact current layer position</para>
      </param>
      <returns>
        <para>an <see cref="T:System.Object" /> that can be interpreted as a hint by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactCoordinatesHint(System.Object)" />
      <seealso cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactSequenceCoordinatesHint(System.Object)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.ExactPlacement" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactSequenceCoordinatesHint(System.Object)">
      <summary>
        <para>Creates a hint <see cref="T:System.Object" /> for a <see cref="T:yWorks.Algorithms.Node" /> that should be inserted incrementally into the graph on its exact current sequence position.</para>
      </summary>
      <remarks>
        <para>The algorithm uses the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer" /> instance to determine the layer of such nodes and the <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" /> instance to determine the sequencing.</para>
      </remarks>
      <param name="forNodeId">
        <para>the node to be placed on its exact current sequence position</para>
      </param>
      <returns>
        <para>an <see cref="T:System.Object" /> that can be interpreted as a hint by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactCoordinatesHint(System.Object)" />
      <seealso cref="M:yWorks.Layout.Hierarchic.IIncrementalHintsFactory.CreateUseExactLayerCoordinatesHint(System.Object)" />
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.ExactPlacement" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.IItemFactory">
      <summary>
        <para>This interface is a factory for creating and destroying helper structures used in the graph during layout.</para>
      </summary>
      <remarks>
        <para>An implementation of this interface is provided by the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> during the layout for the different sub-modules.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.InsertGroupNodeLayer(System.Boolean,System.Int32)">
      <summary>
        <para>Inserts a <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> for group <see cref="T:yWorks.Algorithms.Node" />s.</para>
      </summary>
      <param name="source">
        <para>
          <c>true</c> if the group refers to the source node of an edge, <c>false</c> otherwise</para>
      </param>
      <param name="index">
        <para>the index at which the specified <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> is to be inserted</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.InsertLabelNodeLayer(System.Boolean,System.Int32)">
      <summary>
        <para>Inserts a <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> for labels.</para>
      </summary>
      <param name="source">
        <para>
          <c>true</c> if the source node of the edge, <c>false</c> otherwise</para>
      </param>
      <param name="index">
        <para>the index at which the specified <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> is to be inserted</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.DestroyLabelNodeLayer(yWorks.Layout.Hierarchic.ILayer,System.Boolean)">
      <summary>
        <para>Destroys a previously created label layer</para>
      </summary>
      <param name="layer">
        <para>the layer to destroy</para>
      </param>
      <param name="useInEdges">
        <para>whether the incoming edges should be used as the resulting edges</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.InsertGroupConnectorLayer(System.Boolean,System.Int32)">
      <summary>
        <para>Inserts a layer for proxies at groups to handle direct group content connector edges between a node in the first/last layer of the group node and the groups border.</para>
      </summary>
      <param name="top">
        <para>
          <c>true</c> if this layer is placed above a group nodes, <c>false</c> if placed below</para>
      </param>
      <param name="index">
        <para>the index where the layer is inserted</para>
      </param>
      <returns>
        <para>the new layer</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.DirectGroupContentEdgeRouting" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.DestroyGroupConnectorLayer(yWorks.Layout.Hierarchic.ILayer,System.Boolean)">
      <summary>
        <para>Removes the given layer for proxies at groups to handle direct group content connector edges between a node in the first/last layer of the group node and the groups border.</para>
      </summary>
      <param name="layer">
        <para>the layer to destroy</para>
      </param>
      <param name="useInEdges">
        <para>whether the incoming edges should be used as the resulting edges</para>
      </param>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.DirectGroupContentEdgeRouting" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.InsertEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Inserts a same-layer <see cref="T:yWorks.Algorithms.Edge" /> or an <see cref="T:yWorks.Algorithms.Edge" /> that may span multiple layers into the data structure and returns the resulting list of <see cref="T:yWorks.Algorithms.Edge" />s that has been created if this edge spans multiple layers.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>the resulting list of <see cref="T:yWorks.Algorithms.Edge" />s that has been created if this edge spans multiple layers</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.RegisterSameLayerEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Registers an <see cref="T:yWorks.Algorithms.Edge" /> as a same-layer <see cref="T:yWorks.Algorithms.Edge" /> appropriately into all data structures.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /> to be registered</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.ConvertToLabelNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Converts a given <see cref="T:yWorks.Algorithms.Node" /> to a label node.</para>
      </summary>
      <param name="dummyNode">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /> to be converted</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.UnconvertToLabelNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Reverts a label node to the normal <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <param name="labelNode">
        <para>the given label node to be converted</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateProxyNode(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.Hierarchic.SwimlaneDescriptor)">
      <summary>
        <para>Creates a proxy <see cref="T:yWorks.Algorithms.Node" /> for an <see cref="T:yWorks.Algorithms.Edge" /> during the drawing phase, changing the <see cref="T:yWorks.Algorithms.Edge" /> to end/start at the proxy and assigns it to a <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="source">
        <para>
          <c>true</c> if the node is the source node of the edge, <c>false</c> otherwise</para>
      </param>
      <param name="laneDescriptor">
        <para>a given <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance</para>
      </param>
      <returns>
        <para>the new proxy <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.DestroyProxyNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Destroys a proxy <see cref="T:yWorks.Algorithms.Node" /> created using <see cref="M:yWorks.Layout.Hierarchic.IItemFactory.CreateProxyNode(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.Hierarchic.SwimlaneDescriptor)" /> for the drawing phase.</para>
      </summary>
      <param name="proxyNode">
        <para>the proxy <see cref="T:yWorks.Algorithms.Node" /> to be destroyed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateSameLayerSideProxy(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Layout.Hierarchic.SwimlaneDescriptor)">
      <summary>
        <para>Creates a proxy <see cref="T:yWorks.Algorithms.Node" /> for a same-layer <see cref="T:yWorks.Algorithms.Edge" /> during the drawing phase that ends at the side of a node.</para>
      </summary>
      <param name="inLayer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance</para>
      </param>
      <param name="forNode">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="sld">
        <para>a given <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance</para>
      </param>
      <returns>
        <para>the new proxy <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.DestroySameLayerSideProxy(yWorks.Algorithms.Node)">
      <summary>
        <para>Destroys a proxy <see cref="T:yWorks.Algorithms.Node" /> created using <see cref="M:yWorks.Layout.Hierarchic.IItemFactory.CreateProxyNode(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.Hierarchic.SwimlaneDescriptor)" /> for the drawing phase.</para>
      </summary>
      <param name="proxyNode">
        <para>the proxy <see cref="T:yWorks.Algorithms.Node" /> to be destroyed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateEdgeGroupNode(yWorks.Layout.Hierarchic.ILayer,System.Object)">
      <summary>
        <para>Creates an edge group <see cref="T:yWorks.Algorithms.Node" /> in the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" />.</para>
      </summary>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance</para>
      </param>
      <param name="groupId">
        <para>the ID of the edge group</para>
      </param>
      <returns>
        <para>the new group <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateBendNode(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Edge,yWorks.Layout.Hierarchic.SwimlaneDescriptor)">
      <summary>
        <para>Creates a bend <see cref="T:yWorks.Algorithms.Node" /> for the given <see cref="T:yWorks.Algorithms.Edge" /> in the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> and assigns it to the given <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance.</para>
      </summary>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance</para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="laneDescriptor">
        <para>a given <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance</para>
      </param>
      <returns>
        <para>the new bend <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateDistanceNode(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Edge[])">
      <summary>
        <para>Creates a spacer <see cref="T:yWorks.Algorithms.Node" /> for the drawing phase using the given bounds in the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" />.</para>
      </summary>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance</para>
      </param>
      <param name="size">
        <para>the given bounds</para>
      </param>
      <param name="edges">
        <para>an array of <see cref="T:yWorks.Algorithms.Edge" />s</para>
      </param>
      <returns>
        <para>the new spacer <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.DestroyDistanceNode(yWorks.Algorithms.Node)">
      <summary>
        <para>Destroys a spacer <see cref="T:yWorks.Algorithms.Node" /> for the drawing phase created using <see cref="M:yWorks.Layout.Hierarchic.IItemFactory.CreateDistanceNode(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Geometry.Rectangle2D,yWorks.Algorithms.Edge[])" />.</para>
      </summary>
      <param name="distanceNode">
        <para>the <see cref="T:yWorks.Algorithms.Node" /> to be destroyed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateDummyEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a dummy <see cref="T:yWorks.Algorithms.Edge" /> using the given data.</para>
      </summary>
      <param name="newSource">
        <para>the source node of the <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="newTarget">
        <para>the target node of the <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="oldEdge">
        <para>the old <see cref="T:yWorks.Algorithms.Edge" /> from which to retrieve the data</para>
      </param>
      <param name="sourceEnd">
        <para>
          <c>true</c> if the source node of the edge is referred, <c>false</c> otherwise</para>
      </param>
      <param name="targetEnd">
        <para>
          <c>true</c> if the target node of the edge is referred, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>a new dummy <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateReverseDummyEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a reversed dummy <see cref="T:yWorks.Algorithms.Edge" /> using the given data.</para>
      </summary>
      <param name="newSource">
        <para>the source node of the <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="newTarget">
        <para>the target node of the <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="oldEdge">
        <para>the old <see cref="T:yWorks.Algorithms.Edge" /> from which to retrieve the data</para>
      </param>
      <param name="sourceEnd">
        <para>
          <c>true</c> if the source node of the edge is referred, <c>false</c> otherwise</para>
      </param>
      <param name="targetEnd">
        <para>
          <c>true</c> if the target node of the edge is referred, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>a new reversed dummy <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateRedirectedGroupEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates a redirected <see cref="T:yWorks.Algorithms.Edge" /> to replace an <see cref="T:yWorks.Algorithms.Edge" /> connected to a group <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <param name="newSource">
        <para>the source node of the <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="newTarget">
        <para>the target node of the <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="groupEdge">
        <para>the given group <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>a new redirected <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateGroupNodeConnectorEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates a group node connector <see cref="T:yWorks.Algorithms.Edge" /> between two group <see cref="T:yWorks.Algorithms.Node" />s.</para>
      </summary>
      <param name="groupNode1">
        <para>the first group node</para>
      </param>
      <param name="groupNode2">
        <para>the first group node</para>
      </param>
      <param name="representative">
        <para>the given representative <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>a new connector <see cref="T:yWorks.Algorithms.Edge" /> between two group <see cref="T:yWorks.Algorithms.Node" />s</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateSameLayerProxy(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Edge,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a same-layer <see cref="T:yWorks.Algorithms.Edge" /> proxy connecting a newly created proxy <see cref="T:yWorks.Algorithms.Node" /> and a given proxy <see cref="T:yWorks.Algorithms.Node" /> in the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" />.</para>
      </summary>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /></para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="toProxy">
        <para>the given proxy <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <returns>
        <para>a new redefined same-layer <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.DestroySameLayerProxy(yWorks.Algorithms.Edge)">
      <summary>
        <para>Destroys a same-layer <see cref="T:yWorks.Algorithms.Edge" /> proxy created using <see cref="M:yWorks.Layout.Hierarchic.IItemFactory.CreateSameLayerProxy(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Edge,yWorks.Algorithms.Node)" />.</para>
      </summary>
      <param name="edge">
        <para>the <see cref="T:yWorks.Algorithms.Edge" /> whose proxy will be destroyed</para>
      </param>
      <returns>
        <para>the redefined <see cref="T:yWorks.Algorithms.Edge" /> after the removal of the proxy <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateSameLayerSwitchProxy(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates a same-layer switch proxy <see cref="T:yWorks.Algorithms.Node" /> (switching between two same-layer <see cref="T:yWorks.Algorithms.Edge" />s on two different sides of the layer).</para>
      </summary>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /></para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>the new same-layer switch proxy <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.DestroySameLayerSwitchProxy(yWorks.Algorithms.Node)">
      <summary>
        <para>Destroys a same-layer switch proxy <see cref="T:yWorks.Algorithms.Node" /> created using <see cref="M:yWorks.Layout.Hierarchic.IItemFactory.CreateSameLayerSwitchProxy(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Edge)" />.</para>
      </summary>
      <param name="node">
        <para>the <see cref="T:yWorks.Algorithms.Node" /> to be destroyed</para>
      </param>
      <returns>
        <para>the redefined <see cref="T:yWorks.Algorithms.Edge" /> after the removal of the same-layer switch proxy <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateNormalNodeData(yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> object for a normal <see cref="T:yWorks.Algorithms.Node" /> and associates it with the <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <param name="node">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> object for the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateProxyNodeData(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> object for a proxy <see cref="T:yWorks.Algorithms.Node" /> and associates it with the proxy node.</para>
      </summary>
      <param name="node">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <param name="proxy">
        <para>the given proxy node</para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> object for the given proxy node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateBendNodeData(yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Layout.Hierarchic.SwimlaneDescriptor)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> object for a bend <see cref="T:yWorks.Algorithms.Node" /> and associates it with the <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <remarks>
        <para>The bend is assigned to the given <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance.</para>
      </remarks>
      <param name="node">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="laneDescriptor">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> object for the given bend <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateEdgeGroupNodeData(yWorks.Algorithms.Node,System.Object,System.Boolean)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> object for an edge group <see cref="T:yWorks.Algorithms.Node" /> and associates it with the <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <param name="node">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <param name="groupId">
        <para>the given group ID</para>
      </param>
      <param name="source">
        <para>
          <c>true</c> if the edge group is referred to the source node, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> object for the given edge group <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateGroupBorderNode(yWorks.Algorithms.Node,yWorks.Layout.Hierarchic.ILayer,yWorks.Layout.Hierarchic.NodeDataType)">
      <summary>
        <para>Creates a group boundary <see cref="T:yWorks.Algorithms.Node" /> for a group node in the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" />.</para>
      </summary>
      <param name="groupNode">
        <para>the given group <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /></para>
      </param>
      <param name="type">
        <para>one of <see cref="F:yWorks.Layout.Hierarchic.NodeDataType.GroupBegin" /> or <see cref="F:yWorks.Layout.Hierarchic.NodeDataType.GroupEnd" /></para>
      </param>
      <returns>
        <para>the new group boundary <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateGroupLayerDummyNode">
      <summary>
        <para>Create a dummy <see cref="T:yWorks.Algorithms.Node" /> for a group <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see>.</para>
      </summary>
      <returns>
        <para>a new dummy <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateNormalEdgeData(yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object for a normal <see cref="T:yWorks.Algorithms.Edge" /> and associates it with the edge.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object for the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateSameLayerEdgeData(yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object for a same-layer <see cref="T:yWorks.Algorithms.Edge" /> and associates it with the edge.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object for the same-layer <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateSelfLoopEdgeData(yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object for a self-loop <see cref="T:yWorks.Algorithms.Edge" /> and associates it with the edge.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object for a self-loop <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.SetDirectlyConnectSameLayerEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Converts a same-layer <see cref="T:yWorks.Algorithms.Edge" /> to an <see cref="T:yWorks.Algorithms.Edge" /> of type <see cref="F:yWorks.Layout.Hierarchic.EdgeDataType.DirectSameLayerEdge" />.</para>
      </summary>
      <param name="sameLayerEdge">
        <para>the given same-layer <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryPortConstraint(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortConstraint)">
      <summary>
        <para>Specifies a port constraint for an <see cref="T:yWorks.Algorithms.Edge" /> at the given side and assigns it to an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="source">
        <para>
          <c>true</c> of the port constraint is defined on the source node of the <see cref="T:yWorks.Algorithms.Edge" />, <c>false</c> otherwise</para>
      </param>
      <param name="pc">
        <para>the given <see cref="T:yWorks.Layout.PortConstraint" /> instance</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryEdgeThickness(yWorks.Algorithms.Edge,System.Double)">
      <summary>
        <para>Specifies the thickness for an <see cref="T:yWorks.Algorithms.Edge" /> and defines it in an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="thickness">
        <para>the new edge thickness</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object with an adjusted <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryEdgeGroups(yWorks.Algorithms.Edge,System.Object,System.Object)">
      <summary>
        <para>Specifies an edge group constraint for an <see cref="T:yWorks.Algorithms.Edge" /> and assigns it to an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="sgId">
        <para>the ID of the edge group at the source node</para>
      </param>
      <param name="tgId">
        <para>the ID of the edge group at the target node</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateGroupBorderEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Algorithms.Edge" /> that connects two group border <see cref="T:yWorks.Algorithms.Node" />s.</para>
      </summary>
      <param name="source">
        <para>the source <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <param name="target">
        <para>the target <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <returns>
        <para>the new <see cref="T:yWorks.Algorithms.Edge" /> connecting the two group <see cref="T:yWorks.Algorithms.Node" />s</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateConnectorProxyForGroup(yWorks.Algorithms.Node,System.Object,yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates a dummy <see cref="T:yWorks.Algorithms.Node" /> that mimics a connector to a group <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <param name="groupNode">
        <para>the given group <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <param name="groupId">
        <para>the given group ID</para>
      </param>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance</para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <returns>
        <para>the new <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateContentConnectorProxyForGroup(yWorks.Algorithms.Node,System.Object,yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Edge)">
      <summary>
        <para>Creates a dummy node that mimics a connector to a group node from a descendant.</para>
      </summary>
      <param name="groupNode">
        <para>the group node to which the edge is connected</para>
      </param>
      <param name="groupId">
        <para>the id of the group node</para>
      </param>
      <param name="layer">
        <para>the layer to which the dummy node will be assigned</para>
      </param>
      <param name="e">
        <para>the edge that connects to the dummy node</para>
      </param>
      <returns>
        <para>the dummy node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateRecursiveEdgeDummy(yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Edge,yWorks.Layout.Hierarchic.SwimlaneDescriptor)">
      <summary>
        <para>Creates a dummy <see cref="T:yWorks.Algorithms.Node" /> that represents a bend node of a recursive <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> to which the dummy <see cref="T:yWorks.Algorithms.Node" /> is assigned</para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /> to which the dummy <see cref="T:yWorks.Algorithms.Node" /> belongs</para>
      </param>
      <param name="laneDescriptor">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance</para>
      </param>
      <returns>
        <para>the new <see cref="T:yWorks.Algorithms.Node" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateRecursiveEdgeNodeData(yWorks.Algorithms.Node,yWorks.Algorithms.Edge,yWorks.Layout.Hierarchic.SwimlaneDescriptor)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> for a dummy <see cref="T:yWorks.Algorithms.Node" /> of a recursive <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <param name="node">
        <para>the given <see cref="T:yWorks.Algorithms.Node" /></para>
      </param>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /> to which the dummy <see cref="T:yWorks.Algorithms.Node" /> belongs</para>
      </param>
      <param name="laneDescriptor">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance</para>
      </param>
      <returns>
        <para>the new <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateRecursiveDummyEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a dummy edge that belongs to a recursive <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <param name="newSource">
        <para>the source node of the <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="newTarget">
        <para>the target node of the <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="oldEdge">
        <para>the old <see cref="T:yWorks.Algorithms.Edge" /> from which to retrieve the data</para>
      </param>
      <param name="sourceEnd">
        <para>
          <c>true</c> if the source node of the edge is referred, <c>false</c> otherwise</para>
      </param>
      <param name="targetEnd">
        <para>
          <c>true</c> if the target node of the edge is referred, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>a new dummy <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IItemFactory.CreateRecursiveSameLayerEdgeData(yWorks.Algorithms.Edge,yWorks.Layout.Hierarchic.IEdgeData,System.Boolean)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object for a same-layer recursive <see cref="T:yWorks.Algorithms.Edge" /> and associates it with the edge.</para>
      </summary>
      <param name="edge">
        <para>the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="originalEdgeData">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object of the original edge</para>
      </param>
      <param name="isUpper">
        <para>
          <c>true</c> is the recursive edge is an upper same layer edge, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> object for the recursive same-layer <see cref="T:yWorks.Algorithms.Edge" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ILayer">
      <summary>
        <para>This interface describes a single layer in a hierarchic layout.</para>
      </summary>
      <remarks>
        <para>A layer consists of nodes along with the associated same-layer edges. Each layer has a <see cref="P:yWorks.Layout.Hierarchic.ILayer.Type">type</see> and an index representing its order in the <see cref="T:yWorks.Layout.Hierarchic.ILayers">list of layers</see>.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayers" />
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" />
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayer.Add(yWorks.Algorithms.Node)">
      <summary>
        <para>Adds a newly created <see cref="T:yWorks.Algorithms.Node" /> to this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance.</para>
      </summary>
      <param name="node">
        <para>the <see cref="T:yWorks.Algorithms.Node" /> to be added</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayer.AddSameLayerEdge(yWorks.Algorithms.Edge)">
      <summary>
        <para>Adds a same-layer <see cref="T:yWorks.Algorithms.Edge" /> to this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance.</para>
      </summary>
      <param name="edge">
        <para>the same-layer <see cref="T:yWorks.Algorithms.Edge" /> to be added</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ILayer.SameLayerEdges">
      <summary>
        <para>Gets a list of all same-layer <see cref="T:yWorks.Algorithms.Edge" />s associated with this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance.</para>
      </summary>
      <value>
        <para>a list of all same-layer <see cref="T:yWorks.Algorithms.Edge" />s</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayer.Remove(yWorks.Algorithms.Node)">
      <summary>
        <para>Removes a <see cref="T:yWorks.Algorithms.Node" /> from this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance.</para>
      </summary>
      <param name="node">
        <para>the <see cref="T:yWorks.Algorithms.Node" /> to be removed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayer.Remove">
      <summary>
        <para>Removes the current layer from the <see cref="T:yWorks.Layout.Hierarchic.ILayers">list of layers</see>.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ILayer.List">
      <summary>
        <para>Gets a list of the <see cref="T:yWorks.Algorithms.Node" />s associated with this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance.</para>
      </summary>
      <value>
        <para>a list of the <see cref="T:yWorks.Algorithms.Node" />s of this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayer.SetNodeOrder(yWorks.Algorithms.YList)">
      <summary>
        <para>Adjusts the order of the <see cref="T:yWorks.Algorithms.Node" />s of this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance according to the given order.</para>
      </summary>
      <param name="list">
        <para>the given list to be used</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ILayer.Type">
      <summary>
        <para>Gets the type of this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance.</para>
      </summary>
      <value>
        <para>one of the predefined layer types</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ILayer.Index">
      <summary>
        <para>Gets the index of this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance in the <see cref="T:yWorks.Layout.Hierarchic.ILayers">list of all layers</see>.</para>
      </summary>
      <value>
        <para>the index of this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ILayer.Row">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> associated with this <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Layout.Grid.RowDescriptor" /> instance</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ILayerConstraint">
      <summary>
        <para>This interface describes a layering constraint.</para>
      </summary>
      <remarks>
        <para>Such constraints can be given as additional input to the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ILayerConstraint.Priority">
      <summary>
        <para>Gets or sets the priority of a constraint.</para>
      </summary>
      <remarks>
        <para>This value is used for resolving conflicting constraints. A constraint with a higher priority is more likely to be considered.</para>
        <para>The priority has to be greater than <c>0</c>.</para>
      </remarks>
      <value>
        <para>the constraint priority</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ILayerConstraintFactory">
      <summary>
        <para>This interface provides methods for creating layering constraints.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ILayerConstraintFactory.Memento">
      <summary>
        <para>Gets a token that allows to bind a constraint factory to a graph instance after creation.</para>
      </summary>
      <remarks>
        <para>This method should only be used if the constraint factory is not bound to a graph instance initially. It allows to bind this factory to a graph instance after creation. See the factory methods that create instances of this interface for a description.</para>
      </remarks>
      <value>
        <para>a token that allows to bind the constraint factory to a graph instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayout.CreateLayerConstraintFactory(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.Dispose">
      <summary>
        <para>Disposes this factory.</para>
      </summary>
      <remarks>
        <para>This method should be called when this factory is not needed anymore, i.e. after the layout has been calculated. Calling this method also clears all constraints.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object)">
      <summary>
        <para>Adds a constraint that forces a <see cref="T:yWorks.Algorithms.Node" /> with ID <c>belowId</c> to lie below the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>referenceId</c>.</para>
      </summary>
      <param name="referenceId">
        <para>the ID of the reference node</para>
      </param>
      <param name="belowId">
        <para>the ID of the node that should lie below</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" /> object that represents the constraint</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.AddPlaceNodeBelowConstraint(System.Object,System.Object,System.Int32,System.Int32)">
      <summary>
        <para>Adds a constraint that forces the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>belowId</c> to lie at least <c>minDistance</c> layers below the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>referenceId</c> with a given weight penalty for larger layer differences.</para>
      </summary>
      <remarks>
        <para>The minimum distance includes potentially empty layers that are removed by the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance. In that case, the actual layer difference may be smaller than the minimum distance.</para>
      </remarks>
      <param name="referenceId">
        <para>the ID of the reference node</para>
      </param>
      <param name="belowId">
        <para>the ID of the node that should lie below</para>
      </param>
      <param name="minDistance">
        <para>the minimum layer distance between the node and its reference node</para>
      </param>
      <param name="weight">
        <para>the weight penalty for larger layer differences</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" /> object that represents the constraint</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object)">
      <summary>
        <para>Adds a constraint that forces the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>aboveId</c> to lie above the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>referenceId</c>.</para>
      </summary>
      <param name="referenceId">
        <para>the ID of the reference node</para>
      </param>
      <param name="aboveId">
        <para>the ID of the node that should lie above</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" /> object that represents the constraint</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.AddPlaceNodeAboveConstraint(System.Object,System.Object,System.Int32,System.Int32)">
      <summary>
        <para>Adds a constraint that forces the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>aboveId</c> to lie at least <c>minDistance</c> layers above the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>referenceId</c> with a given weight penalty for larger layer differences.</para>
      </summary>
      <remarks>
        <para>The minimum distance includes potentially empty layers that are removed by the <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance. In that case, the actual layer difference may be smaller than the minimum distance.</para>
      </remarks>
      <param name="referenceId">
        <para>the ID of the reference node</para>
      </param>
      <param name="aboveId">
        <para>the ID of the node that should lie above</para>
      </param>
      <param name="minDistance">
        <para>the minimum layer distance between the node and its reference node</para>
      </param>
      <param name="weight">
        <para>the weight penalty for larger layer differences</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" /> object that represents the constraint</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.AddPlaceNodeInSameLayerConstraint(System.Object,System.Object)">
      <summary>
        <para>Adds a constraint that forces the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>sameLayerId</c> to lie in the same layer as the <see cref="T:yWorks.Algorithms.Node" /> with ID <c>referenceId</c>.</para>
      </summary>
      <param name="referenceId">
        <para>the ID of the reference node</para>
      </param>
      <param name="sameLayerId">
        <para>the ID of the node that should lie in the same layer</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" /> object that represents the constraint</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.AddPlaceNodeAtTopConstraint(System.Object)">
      <summary>
        <para>Adds a constraint that places a <see cref="T:yWorks.Algorithms.Node" /> on the topmost layer.</para>
      </summary>
      <param name="nodeId">
        <para>the ID of the node that should lie on the top layer</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" /> object that represents the constraint</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.AddPlaceNodeAtBottomConstraint(System.Object)">
      <summary>
        <para>Adds a constraint that places a <see cref="T:yWorks.Algorithms.Node" /> on the bottom layer.</para>
      </summary>
      <param name="nodeId">
        <para>the ID of the node that should lie on the bottom layer</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" /> object that represents the constraint</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerConstraintFactory.RemoveConstraints(System.Object)">
      <summary>
        <para>Clears all constraints for a given <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <param name="nodeId">
        <para>the ID of the node for which all constraints should be cleared</para>
      </param>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayerConstraint" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ILayeredComponentsMerger">
      <summary>
        <para>This interface merges two <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instances whose nodes reside in the same graph.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface may provide different strategies for merging.</para>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger">Default implementations</see> of this interface are used internally by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> and <see cref="T:yWorks.Layout.Hierarchic.MultiComponentLayerer" /> when e.g. the graph is grouped or it consists of more than one connected component.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayeredComponentsMerger.Merge(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayers)">
      <summary>
        <para>Merges two <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instances.</para>
      </summary>
      <remarks>
        <para>All nodes that belong to the source and target <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> are part of the graph at the moment of invocation.</para>
        <para>The state of the source <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance is discarded after this call and does not need to be updated to reflect the changes. The target <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance must be updated accordingly.</para>
      </remarks>
      <param name="graph">
        <para>the graph containing the nodes of source and target <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instances</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for querying the layer indices</para>
      </param>
      <param name="srcLayers">
        <para>the source <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be merged into the target <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance</para>
      </param>
      <param name="targetLayers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be modified to contain the resulting layering</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ILayerer">
      <summary>
        <para>This interface is used by classes capable of generating a layer assignment.</para>
      </summary>
      <remarks>
        <para>Layer assignment takes place during the first part of the hierarchic layout algorithms. During this phase, each node of the graph is assigned to a <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Layerer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsLayerer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchLayerer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers and adds them to the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <remarks>
        <para>In order to create new layers, factory method <see cref="M:yWorks.Layout.Hierarchic.ILayers.Insert(yWorks.Layout.Hierarchic.LayerType,System.Int32)" /> has to be used.</para>
        <para>Information about the nodes is provided by a <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" />. However, positional information (see <see cref="P:yWorks.Layout.Hierarchic.INodeData.Position" /> and <see cref="P:yWorks.Layout.Hierarchic.INodeData.Layer" />) is not available during this phase.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be filled with the results of the calculation</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for querying information about the nodes and edges</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.ILayers.Insert(yWorks.Layout.Hierarchic.LayerType,System.Int32)" />
      <seealso cref="M:yWorks.Layout.Hierarchic.ILayer.Add(yWorks.Algorithms.Node)" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ILayers">
      <summary>
        <para>This interface manages multiple <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instances.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> creates instances of this class and passes them to the instances that handle the various sub-tasks of the layout process during automatic layout.</para>
        <para>Method <see cref="M:yWorks.Layout.Hierarchic.ILayers.CreateInstance" /> can be used as a factory method to obtain temporary <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instances.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.ILayer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayers.Size">
      <summary>
        <para>Returns the number of <see cref="T:yWorks.Layout.Hierarchic.ILayer">layers</see> associated with this <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <returns>
        <para>the number of layers of this <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayers.GetLayer(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> at the specified position in this <see cref="T:yWorks.Layout.Hierarchic.ILayers">list of layers</see>.</para>
      </summary>
      <param name="i">
        <para>the zero-based index of the <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> to return</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> at the specified position</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayers.Insert(yWorks.Layout.Hierarchic.LayerType,System.Int32)">
      <summary>
        <para>Creates, inserts and returns a <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> of a given type associated with this <see cref="T:yWorks.Layout.Hierarchic.ILayers">list of layers</see>.</para>
      </summary>
      <param name="type">
        <para>one of the predefined layer types as defined in <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> interface</para>
      </param>
      <param name="position">
        <para>the index at which the specified <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> is to be inserted</para>
      </param>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayers.Remove(System.Int32)">
      <summary>
        <para>Removes the <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> at the specified position from this <see cref="T:yWorks.Layout.Hierarchic.ILayers">list of layers</see>.</para>
      </summary>
      <param name="index">
        <para>the zero-based index of the <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see> to remove</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayers.CreateInstance">
      <summary>
        <para>Creates a new and empty <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that can be used on the same graph instance for temporary results.</para>
      </summary>
      <returns>
        <para>a new and empty <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ILayoutDataProvider">
      <summary>
        <para>This interface retrieves <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances for elements in the current layout graph.</para>
      </summary>
      <remarks>
        <para>Instances of this interface are provided by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> for instances implementing sub-tasks during the layout.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayoutDataProvider.GetNodeData(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance associated with the given <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <param name="node">
        <para>the given node</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance associated with the node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ILayoutDataProvider.GetEdgeData(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance associated with the given <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instance associated with the edge</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.INodeData">
      <summary>
        <para>This interface provides layout information about the nodes of the graph during the layout.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> is a multi-purpose node descriptor for each node of the graph during the hierarchic layout used internally by the algorithm implementations.</para>
        <para>Instances of this interface can be obtained during the layout from instances of the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> interface.</para>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> typically carries the <see cref="P:yWorks.Layout.Hierarchic.INodeData.Type">type</see> of the node and depending on the type an optional <see cref="P:yWorks.Layout.Hierarchic.INodeData.AssociatedEdge">associated edge</see> and <see cref="P:yWorks.Layout.Hierarchic.INodeData.AssociatedNode">associated node</see>. Optionally, it may carry a geometric description of the borders of the node and descriptors for various aspects of the layout.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.GroupNode">
      <summary>
        <para>Gets the group node this node belongs to.</para>
      </summary>
      <value>
        <para>the group node to which the associated <see cref="T:yWorks.Algorithms.Node" /> belongs or <c>null</c> if the associated <see cref="T:yWorks.Algorithms.Node" /> is a top level node.</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.INodeData.GetNormalizedBorderLine(System.Int32)">
      <summary>
        <para>Returns a <see cref="T:yWorks.Algorithms.Geometry.BorderLine" /> for the given side which is treated as if the position of the node is at (0,0).</para>
      </summary>
      <remarks>
        <para>Clients may modify this instance but should always reset it to the original position, since this is a shared instance.</para>
        <para>It may return <c>null</c> to indicate that the <see cref="T:yWorks.Algorithms.Geometry.BorderLine" /> can be determined through the <see cref="T:yWorks.Layout.INodeLayout" /> instance.</para>
        <para>Side value must be inside <c>[0,3]</c> interval, where <c>0</c> corresponds to the top side, <c>1</c> to the right side, <c>2</c> to the bottom side and <c>3</c> to the left side.</para>
      </remarks>
      <param name="side">
        <para>an integer value from <c>[0,3]</c> interval</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.BorderLine" /> instance or <c>null</c></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Hierarchic.INodeData.CreateBorderLine(System.Int32,yWorks.Layout.INodeLayout)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.INodeData.CreateBorderLine(System.Int32,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Creates, stores and returns a <see cref="T:yWorks.Algorithms.Geometry.BorderLine" /> for the given side or returns the current <see cref="T:yWorks.Algorithms.Geometry.BorderLine" /> instance if it already exists.</para>
      </summary>
      <remarks>
        <para>Not every <see cref="P:yWorks.Layout.Hierarchic.INodeData.Type">type</see> of node supports this operation. <see cref="F:yWorks.Layout.Hierarchic.NodeDataType.Normal" /> supports <see cref="T:yWorks.Algorithms.Geometry.BorderLine" />s.</para>
        <para>Side value must be inside <c>[0,3]</c> interval, where <c>0</c> corresponds to the top side, <c>1</c> to the right side, <c>2</c> to the bottom side and <c>3</c> to the left side.</para>
      </remarks>
      <param name="side">
        <para>an integer value from <c>[0,3]</c> interval</para>
      </param>
      <param name="nodeLayout">
        <para>the <see cref="T:yWorks.Layout.INodeLayout" /> of the current node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.BorderLine" /> instance</para>
      </returns>
      <exception cref="T:System.NotSupportedException">
        <para>if this <see cref="P:yWorks.Layout.Hierarchic.INodeData.Type">type</see> of node does not support node borders</para>
      </exception>
      <seealso cref="M:yWorks.Layout.Hierarchic.INodeData.GetNormalizedBorderLine(System.Int32)" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.FirstSameLayerEdgeCell">
      <summary>
        <para>Gets the first same-layer edge <see cref="T:yWorks.Algorithms.ListCell" /> of all same-layer edges or <c>null</c> if there exists no same-layer edge.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Algorithms.ListCell" /> containing the first same-layer edge or <c>null</c> if no same-layer edge exists</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.INodeData.SameLayerEdgeCount">
      <summary>
        <para>Returns the number of same-layer edges associated with the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance.</para>
      </summary>
      <returns>
        <para>the number of same-layer edges associated with the node</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.Type">
      <summary>
        <para>Gets the type constant for the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance.</para>
      </summary>
      <value>
        <para>one of the predefined type constants</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.GroupId">
      <summary>
        <para>Gets the group ID of the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance if it is a bus-group node.</para>
      </summary>
      <value>
        <para>a group ID or <c>null</c> if this node does not belong to an edge group node construct</para>
      </value>
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.SourceGroupNode" />
      <seealso cref="F:yWorks.Layout.Hierarchic.NodeDataType.TargetGroupNode" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.AssociatedNode">
      <summary>
        <para>Gets the associated <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance (in case of e.g.</para>
      </summary>
      <remarks>
        <para>back-loop proxy and side proxy).</para>
      </remarks>
      <value>
        <para>the associated <see cref="T:yWorks.Algorithms.Node" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.AssociatedEdge">
      <summary>
        <para>Gets the associated <see cref="T:yWorks.Algorithms.Edge" /> of the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance (in case of e.g.</para>
      </summary>
      <remarks>
        <para>bend or same-layer center node).</para>
      </remarks>
      <value>
        <para>the associated <see cref="T:yWorks.Algorithms.Edge" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.Layer">
      <summary>
        <para>Gets the index of the <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance to which the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance belongs.</para>
      </summary>
      <value>
        <para>the index of the <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> instance to which this <see cref="T:yWorks.Algorithms.Node" /> belongs</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.Position">
      <summary>
        <para>Gets the current position of the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance within its layer.</para>
      </summary>
      <value>
        <para>the zero-based position index of the <see cref="T:yWorks.Algorithms.Node" /> within its current layer</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.ParentGroupNode">
      <summary>
        <para>Gets the parent group node of the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance (if any).</para>
      </summary>
      <value>
        <para>the parent of the <see cref="T:yWorks.Algorithms.Node" /> (in the sense of hierarchically grouped graphs)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.GroupLayers">
      <summary>
        <para>Gets the inner layers of the group <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance.</para>
      </summary>
      <remarks>
        <para>If this node is of type <see cref="F:yWorks.Layout.Hierarchic.NodeDataType.Group" />, this method returns the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> object that describes the layering in the subgraph.</para>
      </remarks>
      <value>
        <para>the layers of the subgraph</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.IncrementalHint">
      <summary>
        <para>Gets the hint of the incremental mode of the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance if this node is of type <see cref="F:yWorks.Layout.Hierarchic.NodeDataType.Normal" />.</para>
      </summary>
      <remarks>
        <para>The corresponding hint has been set by a <see cref="T:yWorks.Algorithms.IDataProvider" /> using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.IncrementalHintsDpKey" />.</para>
      </remarks>
      <value>
        <para>the hint of this <see cref="T:yWorks.Algorithms.Node" /> or a hint instance that marks this node as non-incremental</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.NodeLayoutDescriptor">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance initially bound to the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance or <c>null</c> if no <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> has been registered.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance or <c>null</c> if no <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> has been registered</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.INodeData.SwimLaneDescriptor">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance initially bound to the <see cref="T:yWorks.Algorithms.Node" /> of this <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> instance or <c>null</c> if no <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> has been registered.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance or <c>null</c> if no <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> has been registered</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.INodePlacer">
      <summary>
        <para>This interface is responsible for the assignment of the x-(sequence) and preliminary y-coordinates of the nodes in a hierarchic layout.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface are used during the drawing phase of <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" />. They determine preliminary y-coordinates (which may be adjusted during the final edge routing) and the resulting x-coordinates of all elements that are part of the graph during the node placement phase.</para>
        <para>The minimum distance between each pair of nodes of the graph is determined by a <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> instance.</para>
        <para>The default implementation used by the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> is <see cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" />. Custom implementations of <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> interface can be used for hierarchic layout algorithms using methods <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodePlacer" /> or <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.NodePlacer" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" />
      <seealso cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" />
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodePlacer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.NodePlacer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.INodePlacer.AssignLayerCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers)">
      <summary>
        <para>Assigns preliminary y-coordinates for each layer of a hierarchic layout.</para>
      </summary>
      <remarks>
        <para>The distance between two layers will be adjusted later by the edge routing algorithm. This method is responsible for assigning the relative positions of the nodes within each layer.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layoutDataProvider">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the elements</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be calculated by this method</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.INodePlacer.AssignSequenceCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.IDrawingDistanceCalculator)">
      <summary>
        <para>Determines the resulting x-coordinates of a hierarchic layout.</para>
      </summary>
      <remarks>
        <para>The minimum distance between each pair of nodes of the graph is determined by a <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> instance.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layoutDataProvider">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the elements</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be calculated by this method</para>
      </param>
      <param name="drawingDistanceCalculator">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> instance</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.IPortAllocator">
      <summary>
        <para>This interface is responsible for assigning port coordinates to the adjacent edges of each node of the graph.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Hierarchic.IPortAllocator" /> is used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> after the sequencing phase.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IPortAllocator.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns to each edge of the graph a source port and target port coordinate pair.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> after the sequencing phase.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance containing the elements in the layering</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing layering information about the nodes and edges of the graph</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> used temporarily for modifying the graph instance</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.IPortConstraintOptimizer">
      <summary>
        <para>This interface serves as a callback for <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> after the layering and sequencing phases.</para>
      </summary>
      <remarks>
        <para>Implementations of this interface may modify the <see cref="T:yWorks.Layout.PortConstraint">port constraint</see> information via <see cref="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryPortConstraint(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortConstraint)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IPortConstraintOptimizer.OptimizeAfterLayering(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns new temporary port constraints after the layering information has been determined.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the elements</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> to set the temporary port constraints with</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryPortConstraint(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortConstraint)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.IPortConstraintOptimizer.OptimizeAfterSequencing(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns new temporary port constraints after the sequence of the nodes has been determined.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> containing information about the elements</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> to set the temporary port constraints with</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryPortConstraint(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortConstraint)" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ISequenceConstraintFactory">
      <summary>
        <para>This interface specifies the general contract for factory classes that can be used to associate sequence constraints with a graph.</para>
      </summary>
      <remarks>
        <para>Sequence constraints affect the sequence of nodes within a <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see>.</para>
        <para>A <see cref="T:yWorks.Layout.Hierarchic.ISequenceConstraintFactory" /> has to be <see cref="M:yWorks.Layout.Hierarchic.ISequenceConstraintFactory.Dispose">disposed of</see> after use. Disposing of the factory will also remove all constraints previously specified for the factory's associated graph.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.ISequenceConstraintFactory.Memento">
      <summary>
        <para>Gets a token that allows to bind a constraint factory to a graph instance after creation.</para>
      </summary>
      <remarks>
        <para>This method should only be used if the constraint factory is not bound to a graph instance initially. It allows to bind this factory to a graph instance after creation.</para>
      </remarks>
      <value>
        <para>a token that allows to bind the constraint factory to a graph instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.HierarchicLayoutCore.CreateSequenceConstraintFactory(yWorks.Algorithms.Graph)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ISequenceConstraintFactory.Dispose">
      <summary>
        <para>Disposes of the <see cref="T:yWorks.Layout.Hierarchic.ISequenceConstraintFactory" />.</para>
      </summary>
      <remarks>
        <para>This method should be called when the factory is not needed anymore, i.e. after the layout has been calculated. Calling this method also clears all constraints.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ISequenceConstraintFactory.AddPlaceBeforeConstraint(System.Object,System.Object)">
      <summary>
        <para>Adds a constraint that forces the <see cref="T:yWorks.Algorithms.Node" /> or <see cref="T:yWorks.Algorithms.Edge" /> with id <c>before</c> to lie before the <see cref="T:yWorks.Algorithms.Node" /> or <see cref="T:yWorks.Algorithms.Edge" /> with id <c>reference</c>.</para>
      </summary>
      <param name="referenceId">
        <para>the ID of the reference node or edge</para>
      </param>
      <param name="beforeId">
        <para>the ID of the node or edge that should be placed before the reference element</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ISequenceConstraintFactory.AddPlaceAfterConstraint(System.Object,System.Object)">
      <summary>
        <para>Adds a constraint that forces the <see cref="T:yWorks.Algorithms.Node" /> or <see cref="T:yWorks.Algorithms.Edge" /> with id <c>after</c> to lie after the <see cref="T:yWorks.Algorithms.Node" /> or <see cref="T:yWorks.Algorithms.Edge" /> with id <c>reference</c>.</para>
      </summary>
      <param name="referenceId">
        <para>the ID of the reference node or edge</para>
      </param>
      <param name="afterId">
        <para>the ID of the node or edge that should be placed after the reference element</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ISequenceConstraintFactory.AddPlaceAtHeadConstraint(System.Object)">
      <summary>
        <para>Adds a constraint that places a <see cref="T:yWorks.Algorithms.Node" /> or <see cref="T:yWorks.Algorithms.Edge" /> at the start of the sequence.</para>
      </summary>
      <param name="id">
        <para>the ID of the node or edge that should be placed at the start</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ISequenceConstraintFactory.AddPlaceAtTailConstraint(System.Object)">
      <summary>
        <para>Adds a constraint that places a <see cref="T:yWorks.Algorithms.Node" /> or <see cref="T:yWorks.Algorithms.Edge" /> at the end of the sequence.</para>
      </summary>
      <param name="id">
        <para>the ID of the node or edge that should be placed at the end</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.ISequencer">
      <summary>
        <para>This interface is used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> to calculate the order of the nodes within each <see cref="T:yWorks.Layout.Hierarchic.ILayers">layer</see>.</para>
      </summary>
      <remarks>
        <para>Implementations are used during the second phase of the hierarchic layout process and can be set using method <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" /> or <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer" />).</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.Sequencer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FixedElementsSequencer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.FromScratchSequencer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.ISequencer.SequenceNodeLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Calculates the sequence of the nodes within each <see cref="T:yWorks.Layout.Hierarchic.ILayers">layer</see>.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> during the second phase and finally writes back the calculated sequence using the <see cref="M:yWorks.Layout.Hierarchic.ILayer.SetNodeOrder(yWorks.Algorithms.YList)" /> method.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance containing the elements in the layering</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory" /> used temporarily for modifying the graph instance</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.MultiComponentLayerer">
      <summary>
        <para>This class is a wrapper <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> implementation that delegates the actual layering to a delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" />.</para>
      </summary>
      <remarks>
        <para>If the graph consists of multiple components, they will be identified and sorted and each of the components will be layered separately using the delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance. After that they will all be merged using the specified <see cref="T:yWorks.Layout.Hierarchic.ILayeredComponentsMerger" /> instance.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.MultiComponentLayerer.#ctor(yWorks.Layout.Hierarchic.ILayerer)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.MultiComponentLayerer" /> using the given delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" />.</para>
      </summary>
      <remarks>
        <para>A new instance of <see cref="T:yWorks.Layout.Hierarchic.DefaultLayeredComponentsMerger" /> will be used as merger while no component <see cref="T:System.Collections.Generic.IComparer`1" /> will be used.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given layerer is <c>null</c></para>
      </exception>
      <param name="singleComponentLayerer" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.MultiComponentLayerer.#ctor(yWorks.Layout.Hierarchic.ILayerer,yWorks.Layout.Hierarchic.ILayeredComponentsMerger,System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.MultiComponentLayerer" /> using the given <see cref="T:yWorks.Layout.Hierarchic.ILayeredComponentsMerger" /> and <see cref="T:System.Collections.Generic.IComparer`1" /> instances.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given layerer or merger is <c>null</c></para>
      </exception>
      <param name="singleComponentLayerer" />
      <param name="merger" />
      <param name="componentComparator" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.MultiComponentLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <param name="graph" />
      <param name="layers" />
      <param name="ldp" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.MultiComponentLayerer.Sort(yWorks.Algorithms.NodeList[],yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Sorts an array which consists of <see cref="T:yWorks.Algorithms.NodeList" />s each of which contains nodes that belong to the same component.</para>
      </summary>
      <remarks>
        <para>It is called during <see cref="M:yWorks.Layout.Hierarchic.MultiComponentLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)" />.</para>
        <para>By default this method uses the <see cref="P:yWorks.Layout.Hierarchic.MultiComponentLayerer.ComponentComparer">ComponentComparator</see> to sort the list and has no effect if the instance is <c>null</c>.</para>
      </remarks>
      <param name="nodeLists">
        <para>the array of <see cref="T:yWorks.Algorithms.NodeList" />s each of which containing nodes that belong to the same component</para>
      </param>
      <param name="componentIndexProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an object (the component index) for each node (this value can be either integer or object)</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.MultiComponentLayerer.SingleComponentLayerer">
      <summary>
        <para>Gets or sets the delegate <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayerer" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.MultiComponentLayerer.Merger">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Hierarchic.ILayeredComponentsMerger">merger</see> instance.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Hierarchic.ILayeredComponentsMerger" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayeredComponentsMerger">merger</see> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.MultiComponentLayerer.ComponentComparer">
      <summary>
        <para>Gets or sets the component <see cref="T:System.Collections.Generic.IComparer`1" /> instance.</para>
      </summary>
      <value>
        <para>the component <see cref="T:System.Collections.Generic.IComparer`1" /> or <c>null</c> if no specific <see cref="T:System.Collections.Generic.IComparer`1" /> exists</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor">
      <summary>
        <para>This class is used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> during the various phases to provide the drawing details of the nodes of the graph.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance can be specified individually for single nodes using a <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance for each node of the graph, or <c>null</c> if no <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> is bound to an edge. The <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with the graph with key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodeLayoutDescriptorDpKey" />.</para>
        <para>This class is designed as a class to allow future additions of new getter methods.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.NodeLayoutDescriptorDpKey" />
      <seealso cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.#ctor">
      <summary>
        <para>Creates a new instance of a <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> with the default values.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.SetPortBorderGapRatio(System.Int32,System.Double)">
      <summary>
        <para>Specifies the port border gap ratio for the port distribution at a given side of the node.</para>
      </summary>
      <remarks>
        <para>This ratio determines the gap between a corner of the node and the first assigned port.</para>
        <para>The ratio should be greater than <c>0</c>.</para>
        <para>A value of <c>0.0d</c> results in ports being placed directly on the corner of the node (if there is more than one port).</para>
        <para>A value of <c>0.5d</c> results in ports being distributed along the side of the node so that the distance between the corner of the node and the first port is half as wide as the distance between two adjacent ports.</para>
        <para>A value of <c>Double.POSITIVE_INFINITY</c> results in all ports being centered at the side in one point.</para>
      </remarks>
      <param name="side">
        <para>the zero-based clockwise side index for top-to-bottom layouts (i.e., top is 0)</para>
      </param>
      <param name="ratio">
        <para>the given ratio</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given ratio is negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.PortBorderGapRatios" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.PortBorderGapRatios">
      <summary>
        <para>Sets the port border gap ratio for the port distribution on all sides of the node.</para>
      </summary>
      <remarks>
        <para>This ratio determines the gap between a corner of the node and the first assigned port.</para>
        <para>The ratio should be greater than <c>0</c>.</para>
        <para>A value of <c>0.0d</c> results in ports being placed directly on the corner of the node (if there is more than one port).</para>
        <para>A value of <c>0.5d</c> results in ports being distributed along the side of the node so that the distance between the corner of the node and the first port is half as wide as the distance between two adjacent ports.</para>
        <para>A value of <c>Double.POSITIVE_INFINITY</c> results in all ports being centered at the side in one point.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given ratio is negative</para>
      </exception>
      <value>
        <para>the given ratio</para>
      </value>
      <seealso cref="M:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.SetPortBorderGapRatio(System.Int32,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.GetPortBorderGapRatio(System.Int32)">
      <summary>
        <para>Returns the port border gap ratio for the port distribution at a given side of the node.</para>
      </summary>
      <remarks>
        <para>This ratio determines the gap between a corner of the node and the first assigned port.</para>
        <para>The ratio should be greater than <c>0</c>.</para>
        <para>A value of <c>0.0d</c> results in ports being placed directly on the corner of the node (if there is more than one port).</para>
        <para>A value of <c>0.5d</c> results in ports being distributed along the side of the node so that the distance between the corner of the node and the first port is half as wide as the distance between two adjacent ports.</para>
        <para>A value of <c>Double.POSITIVE_INFINITY</c> results in all ports being centered at the side in one point.</para>
      </remarks>
      <param name="side">
        <para>the zero-based clockwise side index for top-to-bottom layouts (i.e., top is 0)</para>
      </param>
      <returns>
        <para>the border gap ratio of a given side</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.PortBorderGapRatios" />
      <seealso cref="M:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.SetPortBorderGapRatio(System.Int32,System.Double)" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.LayerAlignment">
      <summary>
        <para>Gets or sets the alignment of the <see cref="T:yWorks.Algorithms.Node">node</see> of this <see cref="T:yWorks.Layout.Hierarchic.NodeLayoutDescriptor" /> instance within its layer.</para>
      </summary>
      <remarks>
        <list type="bullet">
          <item>A value of <c>0.0d</c> corresponds to top-alignment.</item>
          <item>A value of <c>0.5d</c> corresponds to center-alignment.</item>
          <item>A value of <c>1.0d</c> corresponds to bottom-alignment.</item>
        </list>
        <para>This value should be within <c>[0,1]</c> interval.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the alignment is not within [0.0d .. 1.0d]</para>
      </exception>
      <value>
        <para>a value from <c>[0,1]</c> interval</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.NodeLabelMode">
      <summary>
        <para>Gets or sets the mode that determines how node labels are handled by the algorithm during the layout.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the constant is unknown.</para>
      </exception>
      <value>
        <para>one of the predefined constants</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.ConsiderNodeLabels" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.MinimumLayerHeight">
      <summary>
        <para>Gets or sets the minimum height of the layer to which this node is assigned.</para>
      </summary>
      <remarks>
        <para>Values should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum height is negative</para>
      </exception>
      <value>
        <para>a non-negative minimum height</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.MinimumDistance">
      <summary>
        <para>Gets or sets the preferred minimum distance to obstacles.</para>
      </summary>
      <remarks>
        <para>The minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length is negative</para>
      </exception>
      <value>
        <para>the minimum distance to obstacles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.GridReference">
      <summary>
        <para>Gets or sets a reference point relative to the center of the node which will be placed on a grid coordinate.</para>
      </summary>
      <value>
        <para>the reference point for grid placement</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.PortAssignment">
      <summary>
        <para>Gets or sets the assignment strategy which distributes the ports along the node borders.</para>
      </summary>
      <value>
        <para>one of the predefined port assignment strategies</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.PartitionGridLayoutStage">
      <summary>
        <para>This class implements a <see cref="T:yWorks.Layout.ILayoutStage">layout stage</see> that handles a given <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see> structure.</para>
      </summary>
      <remarks>
        <para>Information about the <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see> structure are held by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Grid.PartitionGrid.PartitionGridDpKey" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Grid.PartitionGrid" />
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PartitionGridLayoutStage.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.PartitionGridLayoutStage" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PartitionGridLayoutStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates the layout based on a <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> structure.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> structure exists, the core layouter will be called immediately.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.PortCandidateOptimizer">
      <summary>
        <para>This class is an implementation of the <see cref="T:yWorks.Layout.Hierarchic.IPortConstraintOptimizer" /> interface that tries to assign the edges of the graph to <see cref="T:yWorks.Layout.PortConstraint">ports</see> considering the specified <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
      </summary>
      <remarks>
        <para>Instances of this class can be set using property <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayoutCore.PortConstraintOptimizer" />.</para>
        <para>This implementation will query for <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with the graph with keys <see cref="F:yWorks.Layout.PortCandidate.SourcePortCandidateCollectionDpKey" />, <see cref="F:yWorks.Layout.PortCandidate.TargetPortCandidateCollectionDpKey" /> and <see cref="F:yWorks.Layout.PortCandidateSet.NodePortCandidateSetDpKey" />. It will <b>try</b> to assign each edge one of the matching <see cref="T:yWorks.Layout.PortCandidate" />s without introducing too many crossings and without violating the <see cref="P:yWorks.Layout.PortCandidate.Cost">cost</see> or <see cref="P:yWorks.Layout.PortCandidateSet.ConnectionCount">capacity</see> constraints.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.PortCandidate.Cost" />
      <seealso cref="P:yWorks.Layout.PortCandidateSet.Entries" />
      <seealso cref="P:yWorks.Layout.PortCandidateSet.ConnectionCount" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortCandidateOptimizer.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.PortCandidateOptimizer" /> with the default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.PortCandidateOptimizer.Deterministic">
      <summary>
        <para>Gets or sets whether or not this implementation uses a deterministic algorithm to assign the <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if a deterministic algorithm should be applied, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.PortCandidateOptimizer.BackLoopPenalty">
      <summary>
        <para>Gets or sets the penalty cost associated with each back-loop.</para>
      </summary>
      <remarks>
        <para>Values should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the penalty cost is negative</para>
      </exception>
      <value>
        <para>the penalty for a back-loop</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.PortCandidateOptimizer.CrossingPenalty">
      <summary>
        <para>Gets or sets the penalty cost associated with a crossing that would occur if a given combination of <see cref="T:yWorks.Layout.PortCandidate" />s would be chosen.</para>
      </summary>
      <remarks>
        <para>Values should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the crossing penalty is negative</para>
      </exception>
      <value>
        <para>the penalty for a produced edge ctossing</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.PortCandidateOptimizer.OverUsagePenalty">
      <summary>
        <para>Gets or sets the penalty cost associated with each edge being assigned to a port which has already reached its <see cref="P:yWorks.Layout.PortCandidateSet.IEntry.Connections">capacity</see>.</para>
      </summary>
      <remarks>
        <para>Values should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the penalty cost is negative</para>
      </exception>
      <value>
        <para>the penalty for over-saturated <see cref="T:yWorks.Layout.PortCandidate" />s</para>
      </value>
      <seealso cref="P:yWorks.Layout.PortCandidateSet.IEntry.Connections" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortCandidateOptimizer.OptimizeAfterLayering(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <param name="graph" />
      <param name="layers" />
      <param name="ldp" />
      <param name="itemFactory" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortCandidateOptimizer.InsertSameLayerStructures(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <param name="graph" />
      <param name="layers" />
      <param name="ldp" />
      <param name="itemFactory" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortCandidateOptimizer.GetPortCandidateSetDataProvider(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Returns the data provider that provides the port candidate sets for nodes.</para>
      </summary>
      <param name="graph">
        <para>The graph that stores the data provider</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortCandidateOptimizer.OptimizeAfterSequencing(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <param name="graph" />
      <param name="layers" />
      <param name="ldp" />
      <param name="itemFactory" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortCandidateOptimizer.OptimizeAfterSequencing(yWorks.Algorithms.Node,System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object},yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <param name="node" />
      <param name="inEdgeOrder" />
      <param name="outEdgeOrder" />
      <param name="graph" />
      <param name="ldp" />
      <param name="itemFactory" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase">
      <summary>
        <para>This class is an abstract implementation of the <see cref="T:yWorks.Layout.Hierarchic.IPortConstraintOptimizer" /> interface that minimizes the effort required to modify the port assignment after the sequencing phase of hierarchic layout algorithm.</para>
      </summary>
      <remarks>
        <para>The <see cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">callback method invoked after sequencing</see> performs the following three steps:</para>
        <list type="number">
          <item>Restores <b>temporarily</b> all same-layer edges which are not currently present in the layout graph at this time of the layout algorithm.</item>
          <item>Invokes <see cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Algorithms.Node,System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object},yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">the hook</see> in which the custom port assignment should be done.</item>
          <item>Restores the original state of the layout graph by removing the temporary same-layer edges added in Step <c>1</c>.</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.MirrorMode">
      <summary>
        <para>Gets or sets the mirror mask that defines which orientations should be mirrored.</para>
      </summary>
      <remarks>
        <para>Setting a layout orientation can be considered as rotating the graph by <c>90</c>, <c>180</c> or <c>270</c> degrees. Afterwards, the graph can be mirrored at the x-axis (for horizontal layout orientations) or y-axis (for vertical layout orientations). Which directions are mirrored can be defined by the given mask.</para>
      </remarks>
      <value>
        <para>one of the predefined mirror masks</para>
      </value>
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
      <seealso cref="T:yWorks.Layout.LayoutOrientation" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.LayoutOrientation">
      <summary>
        <para>Gets or sets the layout orientation.</para>
      </summary>
      <remarks>
        <para>This setting is necessary to correctly interpret the values provided by the <see cref="T:yWorks.Layout.PortCandidate" />s since the <see cref="T:yWorks.Layout.OrientationLayout" /> cannot automatically adjust these values.</para>
      </remarks>
      <value>
        <para>a predefined orientation constant</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterLayering(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns new temporary port constraints after the nodes have been assigned to layers.</para>
      </summary>
      <remarks>
        <para>More precisely, it is called after the layering information has been determined. In this phase, it is possible to create back-loops by assigning incoming edges to the south (i.e. bottom) side or outgoing edges to the north (i.e. top) side, respectively.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance holding the layering information</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory">factory</see> that sets the temporary port constraints</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryPortConstraint(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortConstraint)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns new temporary port constraints after the order of the nodes in each layer has been determined.</para>
      </summary>
      <remarks>
        <para>More precisely, it is called after the sequence of the nodes has been determined. It <see cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.InsertSameLayerStructures(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">inserts the same-layer structures</see>, invokes <see cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Algorithms.Node,System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object},yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">the hook</see> in which the custom port assignment should be done, and finally <see cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.RemoveSameLayerStructures(yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData,yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">restores the original state</see> of the layout graph by removing the temporary edges.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance holding the layering information</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory">factory</see> that sets the temporary port constraints</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.InsertSameLayerStructures(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)" />
      <seealso cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)" />
      <seealso cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.RemoveSameLayerStructures(yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData,yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object},yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns new temporary port constraints after the order of the nodes in each layer has been determined.</para>
      </summary>
      <remarks>
        <para>More precisely, it is called after the sequence of the nodes has been determined. It invokes <see cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Algorithms.Node,System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object},yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)" /> for every node of the original layout graph and omits the nodes of the same-layer structures.</para>
        <para>Incoming and outgoing edges are sorted using <see cref="T:System.Collections.Generic.IComparer`1" /> instances which define the preferred ordering of the incoming and outgoing edges from left to right.</para>
      </remarks>
      <param name="inEdgeOrder">
        <para>a given <see cref="T:System.Collections.Generic.IComparer`1" /> instance for incoming edges</para>
      </param>
      <param name="outEdgeOrder">
        <para>a given <see cref="T:System.Collections.Generic.IComparer`1" /> instance for outgoing edges</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory">factory</see> that sets the temporary port constraints</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)" />
      <param name="layers" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Algorithms.Node,System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object},yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Assigns new temporary port constraints to a given node of the graph after the order of the nodes in each layer has been determined.</para>
      </summary>
      <remarks>
        <para>More precisely, it is called after the sequence of the nodes has been determined.</para>
        <para>Incoming and outgoing edges are sorted using <see cref="T:System.Collections.Generic.IComparer`1" /> instances which define the preferred ordering of the incoming and outgoing edges from left to right.</para>
      </remarks>
      <param name="node">
        <para>the original node to set temporary port constraints</para>
      </param>
      <param name="inEdgeOrder">
        <para>a given <see cref="T:System.Collections.Generic.IComparer`1" /> instance for incoming edges</para>
      </param>
      <param name="outEdgeOrder">
        <para>a given <see cref="T:System.Collections.Generic.IComparer`1" /> instance for outgoing edges</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory">factory</see> that sets the temporary port constraints</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.OptimizeAfterSequencing(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.InsertSameLayerStructures(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Inserts a same-layer edge structure for each same-layer edge of the original graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance holding the layering information</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory">factory</see> that sets the temporary port constraints</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryPortConstraint(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortConstraint)" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.RemoveSameLayerStructures(yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData,yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)">
      <summary>
        <para>Removes the same-layer edge structure created using <see cref="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.InsertSameLayerStructures(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.IItemFactory)" />.</para>
      </summary>
      <param name="sameLayerData">
        <para>a given <see cref="T:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData" /> instance holding the information about the same-layer structures.</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="itemFactory">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.IItemFactory">factory</see> that sets the temporary port constraints</para>
      </param>
      <seealso cref="M:yWorks.Layout.Hierarchic.IItemFactory.SetTemporaryPortConstraint(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortConstraint)" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData">
      <summary>
        <para>This static class provides information about the same-layer structures created by class <see cref="T:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData" /> instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData.AddDummyNode(yWorks.Algorithms.Node,yWorks.Algorithms.Edge)">
      <summary>
        <para>Adds a given dummy <see cref="T:yWorks.Algorithms.Node" /> to this <see cref="T:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData" /> instance and associates it with the given original (same-layer) <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <param name="sameLayerDummy">
        <para>a dummy node</para>
      </param>
      <param name="originalEdge">
        <para>the original (same-layer) edge</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData.DummyNodes">
      <summary>
        <para>Gets all dummy nodes of this <see cref="T:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData" /> instance.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Algorithms.NodeList" /> of dummy nodes</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.PortConstraintOptimizerBase.SameLayerData.GetOriginalEdge(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the original (same-layer) edge associated with the given dummy <see cref="T:yWorks.Algorithms.Node" />.</para>
      </summary>
      <param name="sameLayerDummy">
        <para>a given dummy node</para>
      </param>
      <returns>
        <para>the original (same-layer) edge associated with the given dummy node</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.RoutingStyle">
      <summary>
        <para>This class is used by <see cref="T:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor" /> to specify the routing style for different types of edges.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Hierarchic.EdgeLayoutDescriptor.RoutingStyle" />
      <seealso cref="P:yWorks.Layout.Hierarchic.IEdgeData.Type" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.RoutingStyle.#ctor(yWorks.Layout.Hierarchic.EdgeRoutingStyle)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.RoutingStyle" /> instance with the given routing style for each edge.</para>
      </summary>
      <param name="routingStyle">
        <para>one of the predefined routing styles</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown routing style is given</para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.RoutingStyle.BackLoopRoutingStyle">
      <summary>
        <para>Gets or sets the routing style for back-loop edges.</para>
      </summary>
      <remarks>
        <para>This style is used for routing U-turns of common edges (i.e., edges that are neither self-loops nor same-layer edges). A U-turn is a non-monotonic part of the edge route that is required for reversed edges if option <see cref="P:yWorks.Layout.Hierarchic.HierarchicLayout.BackLoopRouting" /> is enabled or in some other scenarios with port constraints/candidates.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown routing style is given</para>
      </exception>
      <value>
        <para>one of the predefined routing styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.RoutingStyle.EdgeGroupRoutingStyle">
      <summary>
        <para>Gets or sets the routing style for grouped edges at the common segments.</para>
      </summary>
      <remarks>
        <para>More precisely, grouped edges are routed in a bus-style fashion (i.e., the paths of the edges will share a common edge segment) and this option allows to specify the routing style at the bus.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown routing style is given</para>
      </exception>
      <value>
        <para>one of the predefined routing styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.RoutingStyle.DefaultEdgeRoutingStyle">
      <summary>
        <para>Gets or sets the default routing style for edges that have no individual routing style.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown routing style is given</para>
      </exception>
      <value>
        <para>one of the predefined routing styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.RoutingStyle.SameLayerEdgeRoutingStyle">
      <summary>
        <para>Gets or sets the routing style for same-layer edges.</para>
      </summary>
      <remarks>
        <para>A same-layer edge is an edge whose source/target are assigned to the same layer.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown routing style is given</para>
      </exception>
      <value>
        <para>one of the predefined routing styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.RoutingStyle.SelfLoopRoutingStyle">
      <summary>
        <para>Gets or sets the routing style for self-loops.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown routing style is given</para>
      </exception>
      <value>
        <para>one of the predefined routing styles</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.SelfLoopCalculator">
      <summary>
        <para>This class calculates bend points for self-loops routed in orthogonal or octilinear fashion.</para>
      </summary>
      <remarks>
        <para>It is used during the layout phase of <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" />, but can be used as a stand-alone tool.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumNodeDistanceDpKey">
      <summary>
        <para>A data provider key for defining for each node a minimum distance to the self-loop edges.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.OctilinearEdgesDpKey">
      <summary>
        <para>A data provider key for specifying whether or not an edge is octilinear.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumOctilinearSegmentLengthDpKey">
      <summary>
        <para>A data provider key for specifying the minimum length of the octilinear segments of an octilinear edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumFirstSegmentLengthDpKey">
      <summary>
        <para>A data provider key for specifying the minimum length of the first segment of each edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumLastSegmentLengthDpKey">
      <summary>
        <para>A data provider key for specifying the minimum length of the last segment of each edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumEdgeDistanceDpKey">
      <summary>
        <para>A data provider key for specifying the minimum distance to the next edge or node side.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.SelfLoopCalculator" /> using the given parameters.</para>
      </summary>
      <param name="minFirstSegmentLength">
        <para>the minimum length of the first and last segment of an orthogonally routed self-loop</para>
      </param>
      <param name="minEdgeDistance">
        <para>the minimum distance between a pair of self-loops</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.CalculateSelfLoops(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Calculates all self-loops at the given node of the given input graph.</para>
      </summary>
      <remarks>
        <para>The current port positions will be used for determining the start and end ports. The <see cref="T:yWorks.Algorithms.IDataProvider" /> instances hold information about the source/target ports of the edges and can be used for specifying the direction of first and last segments.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node">
        <para>the node whose self-loops will be routed</para>
      </param>
      <param name="spc">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the <see cref="T:yWorks.Layout.PortConstraint" /> object associated with the source ports of the edges</para>
      </param>
      <param name="tpc">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the <see cref="T:yWorks.Layout.PortConstraint" /> object associated with the target ports of the edges</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.CalculateSelfLoops(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.YList,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Convenience method that calculates a list of self-loops that belong to a given node.</para>
      </summary>
      <remarks>
        <para>The current port positions will be used for determining the start and end ports. The <see cref="T:yWorks.Algorithms.IDataProvider" /> instances hold information about the source/target ports of the edges and can be used for specifying the direction of first and last segments.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node">
        <para>the node whose self-loops will be routed</para>
      </param>
      <param name="selfLoops">
        <para>a list of <see cref="T:yWorks.Algorithms.Edge" />s that will be routed</para>
      </param>
      <param name="spc">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the <see cref="T:yWorks.Layout.PortConstraint" /> object associated with the source ports of the edges</para>
      </param>
      <param name="tpc">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns the <see cref="T:yWorks.Layout.PortConstraint" /> object associated with the target ports of the edges</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.GetMinimumFirstSegmentLength(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the minimum length of the first segment of the given edge.</para>
      </summary>
      <remarks>
        <para>The value is fetched from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumFirstSegmentLengthDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <returns>
        <para>the minimum length of the first segment of an edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.IsOctilinearEdge(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns whether or not the given edge is octilinear.</para>
      </summary>
      <remarks>
        <para>The value is fetched from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.OctilinearEdgesDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge is octilinear, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.GetMinimumOctilinearSegmentLength(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the minimum octilinear segment length of the given edge.</para>
      </summary>
      <remarks>
        <para>The value is fetched from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumOctilinearSegmentLengthDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <returns>
        <para>the minimum octilinear segment length of the given edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.GetMinimumLastSegmentLength(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the minimum length of the last segment of the given edge.</para>
      </summary>
      <remarks>
        <para>The value is fetched from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumLastSegmentLengthDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <returns>
        <para>the minimum length of the last segment of the given edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.GetMinimumDistance(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the minimum length between two edges associated with the given edge.</para>
      </summary>
      <remarks>
        <para>The value is fetched from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumEdgeDistanceDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <returns>
        <para>the minimum length between two edges</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SelfLoopCalculator.GetMinimumNodeDistance(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the minimum distance between two nodes associated with the given node.</para>
      </summary>
      <remarks>
        <para>The value is fetched from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Hierarchic.SelfLoopCalculator.MinimumNodeDistanceDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node">
        <para>the given node</para>
      </param>
      <returns>
        <para>the minimum distance between two nodes</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.SimplexNodePlacer">
      <summary>
        <para>This class is a <see cref="T:yWorks.Layout.Hierarchic.INodePlacer" /> implementation based on <see cref="T:yWorks.Algorithms.RankAssignments">rank assignment</see>.</para>
      </summary>
      <remarks>
        <para>The drawer works with integer values and rounds double values to integers using sophisticated quantizing.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.NodeCompaction">
      <summary>
        <para>Gets or sets whether or not nodes should be placed in a more compact style with respect to layout width.</para>
      </summary>
      <remarks>
        <para>If enabled, the algorithm may place the nodes of a layer in a stacked style (horizontally interleaving), i.e., it splits the layer into an upper and lower sublayer and places adjacent nodes into different sublayers if this reduces the width of the layer.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if nodes are placed in a compact style, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.MinimumSublayerDistance" />
      <seealso cref="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignNodesToSublayer(yWorks.Algorithms.NodeList,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.MinimumSublayerDistance">
      <summary>
        <para>Gets or sets the minimum distance between the upper and lower sublayer.</para>
      </summary>
      <remarks>
        <para>A too small distance value may prevent adjacent nodes from being placed in a stacked style (horizontally interleaving) because the vertical distance between these nodes must be greater than or equal to the value specified by <see cref="P:yWorks.Layout.Hierarchic.NodeLayoutDescriptor.MinimumDistance" />.</para>
        <para>Values should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if minimum sublayer distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.NodeCompaction" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.LabelCompaction">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" /> places labels in a more compact style.</para>
      </summary>
      <remarks>
        <para>If this option is enabled the algorithm tries to place adjacent label elements in a stacked style, i.e., horizontally interleaving.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if labels are placed compact, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.BendReduction">
      <summary>
        <para>Gets or sets whether or not an optimization step should be applied that tries to further reduce the number of bends.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the bend optimization step is applied, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.MaximumDuration" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.HorizontalCompaction">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" /> tries to create a maximally compact horizontal layout at the cost of more bends.</para>
      </summary>
      <remarks>
        <para>For best results, <see cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.BreakLongSegments" /> and <see cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.LabelCompaction" /> should also be enabled.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if a maximally compact horizontal layout is created, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.LabelCompaction" />
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.BreakLongSegments" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.StraightenEdges">
      <summary>
        <para>Gets or sets whether or not a postprocessing step should be applied to reduce the number of bends.</para>
      </summary>
      <remarks>
        <para>Furthermore, enabling this option may violate some minimum distances specified by the user and the edge distribution is no longer uniform.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the number of bends is reduced, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.GroupCompactionStrategy">
      <summary>
        <para>Gets or sets the strategy used for controlling the horizontal compactness of group nodes.</para>
      </summary>
      <value>
        <para>one of the predefined compaction strategies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.ExactPlacement">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" /> enforces the placement of nodes at their exact current positions, even if this violates minimum distance constraints.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if exact coordinates are enforced, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.FromSketchLayerAssignment">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" /> should try to use the coordinates given from the current sketch for the determination of the layer coordinates.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the current sketch is used, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.MaximumDuration">
      <summary>
        <para>Gets or sets the time limit (in milliseconds) set for the layout algorithm.</para>
      </summary>
      <remarks>
        <para>Values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the maximum duration is negative</para>
      </exception>
      <value>
        <para>a non-negative value that specifies the time limit</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.SwimLaneCrossingWeight">
      <summary>
        <para>Gets or sets the relative weight of edges crossing a swimlane relative to edges that stay in their lane.</para>
      </summary>
      <remarks>
        <para>Higher values lead to more compact drawings but may cause additional bends.</para>
        <para>Values should lie within <c>[0,1]</c> interval.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the relative weight does not lie within [0,1]</para>
      </exception>
      <value>
        <para>a double value from <c>[0,1]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.BarycenterMode">
      <summary>
        <para>Gets or sets whether or not a barycenter drawing mode should be used.</para>
      </summary>
      <remarks>
        <para>If this mode is enabled the resulting drawing is likely to have more bends, but may be more symmetric.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if a barycenter drawing mode is used, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignLayerCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers)">
      <param name="graph" />
      <param name="layoutDataProvider" />
      <param name="layers" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignNodesToSublayer(yWorks.Algorithms.NodeList,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Assigns the nodes of a given layer to the corresponding upper/lower sublayer if <see cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.NodeCompaction">node compaction</see> is enabled.</para>
      </summary>
      <remarks>
        <para>Information about sublayers is given by a <see cref="T:yWorks.Algorithms.INodeMap" /> whose <see cref="M:yWorks.Algorithms.INodeMap.GetBool(System.Object)" /> method has to return <c>true</c> for each node that should be placed in the lower sublayer (values are set by this method).</para>
      </remarks>
      <param name="layerNodes">
        <para>a <see cref="T:yWorks.Algorithms.NodeList">list</see> of all @link y.layout.hierarchic.incremental.NodeData#TYPE_NORMAL normal nodes} of a layer</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="lowerSublayer">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> holding sublayer information</para>
      </param>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.NodeCompaction" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.IsFixedNode(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,System.Boolean)">
      <summary>
        <para>Returns whether or not the given node should be treated as a node with fixed (given) coordinates.</para>
      </summary>
      <remarks>
        <para>This callback method is used by both <see cref="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignLayerCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers)" /> and <see cref="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignSequenceCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.IDrawingDistanceCalculator)" />.</para>
        <para>If <c>inLayer</c> argument is <c>true</c>, this method is called from within the <see cref="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignLayerCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers)" /> method.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="provider">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="node">
        <para>the given node</para>
      </param>
      <param name="inLayer">
        <para>
          <c>true</c> if the layer coordinate of the node is queried, <c>false</c> if the sequence coordinate is queried</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the node should be treated as fixed, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.GetMinimumLayerHeight(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayer)">
      <summary>
        <para>Returns the minimum height of a given <see cref="T:yWorks.Layout.Hierarchic.ILayer">layer</see>.</para>
      </summary>
      <remarks>
        <para>This callback method is used by <see cref="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignLayerCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers)" />.</para>
      </remarks>
      <param name="graph">
        <para>the given graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="layer">
        <para>the given <see cref="T:yWorks.Layout.Hierarchic.ILayer" /> object</para>
      </param>
      <returns>
        <para>the minimum height</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.GetLayerAlignment(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,System.Int32,System.Double)">
      <summary>
        <para>Returns the alignment of the node with a specified layer.</para>
      </summary>
      <remarks>
        <para>This callback method used by <see cref="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignLayerCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers)" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> implementation which provides access to the <see cref="T:yWorks.Layout.Hierarchic.INodeData" /> and <see cref="T:yWorks.Layout.Hierarchic.IEdgeData" /> instances</para>
      </param>
      <param name="node">
        <para>the given node</para>
      </param>
      <param name="layerIndex">
        <para>the index of the layer</para>
      </param>
      <param name="minLayerHeight">
        <para>the minimum height of the layer</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignSequenceCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.IDrawingDistanceCalculator)">
      <param name="graph" />
      <param name="layoutDataProvider" />
      <param name="layers" />
      <param name="drawingDistanceCalculator" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.GetMinDistance(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayer,yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Specifies the minimum allowed distance between two nodes of the same given layer.</para>
      </summary>
      <remarks>
        <para>This callback method is used by <see cref="M:yWorks.Layout.Hierarchic.SimplexNodePlacer.AssignSequenceCoordinates(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.IDrawingDistanceCalculator)" />.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the nodes</para>
      </param>
      <param name="layer">
        <para>the layer that contains the nodes</para>
      </param>
      <param name="predNode">
        <para>the node to the left of the other one, may be <c>null</c> to indicate a border line</para>
      </param>
      <param name="succ">
        <para>the node to the right of the other one, may be <c>null</c> to indicate a border line</para>
      </param>
      <returns>
        <para>the minimum distance allowed between those two nodes ( &gt;=0 )</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.BreakLongSegments">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.Hierarchic.SimplexNodePlacer" /> should break <em>long</em> edge segments in favor of a potentially more compact layout.</para>
      </summary>
      <remarks>
        <para>A <em>long</em> edge is an edge that spans multiple layers. For each layer, a dummy node is necessary to model the edge path from source to target.</para>
        <list type="bullet">
          <item>Not breaking such edges means that there is a constraint that enforces the alignment of all these dummy nodes (same x-coordinate). This favors straight edge paths.</item>
          <item>Breaking an edge means that the dummy nodes are not necessarily aligned, but additional bends can be generated if that leads to a horizontally more compact layout result.</item>
        </list>
      </remarks>
      <value>
        <para>
          <c>true</c> if long edges are broken, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor">
      <summary>
        <para>This class is used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayoutCore" /> during the various phases and models a swimlane structure.</para>
      </summary>
      <remarks>
        <para>For layout orientation <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" />, swimlanes partition the drawing area into vertical stripes. Each node is placed within a user-specified lane. Swimlanes are, for example, often used in flow diagrams to separate logical units.</para>
        <para>Each node should be associated with a SwimLaneDescriptor instance; nodes in the same lane may share one instance. The results of the calculation of the swimlanes' geometry will be stored by the instances after the layout.</para>
        <para>A <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance can be bound to the layout algorithm using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph using key <see cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SwimlaneDescriptorDpKey" /> that returns a <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance for each node of the graph.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Hierarchic.HierarchicLayoutCore.SwimlaneDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SwimlaneDescriptor.#ctor(System.IComparable)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance with a given <see cref="T:System.IComparable" /> object.</para>
      </summary>
      <param name="clientObject">
        <para>a <see cref="T:System.IComparable" /> used for determining the order of the lanes</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the specified client object is <c>null</c>.</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SwimlaneDescriptor.#ctor(System.Object,System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instance with a given client <see cref="T:System.Object" /> and a given <see cref="T:System.Collections.Generic.IComparer`1" />.</para>
      </summary>
      <remarks>
        <para>The given client <see cref="T:System.Object" /> should be an instance of <see cref="T:System.IComparable" /> if the given <see cref="T:System.Collections.Generic.IComparer`1" /> is <c>null</c>.</para>
      </remarks>
      <param name="clientObject">
        <para>a client <see cref="T:System.Object" /> used for sorting the lanes</para>
      </param>
      <param name="comparator">
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> used for comparing the client objects</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the specified client <see cref="T:System.Object" /> is <c>null</c> or the specified <see cref="T:System.Collections.Generic.IComparer`1" /> is <c>null</c> but the specified client <see cref="T:System.Object" /> is not an instance of <see cref="T:System.IComparable" />.</para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.IndexFixed">
      <summary>
        <para>Gets or sets whether or not an index of a swimlane is fixed (based on the result of the comparison with the other swimlanes) or whether the index should be chosen automatically in order to minimize edge lengths.</para>
      </summary>
      <remarks>
        <para>For all swimlanes where this property is set to <c>true</c>, the relative ordering given by the client objects is preserved. The remaining swimlanes may be sorted again so that the overall edge lengths are minimized.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the swimlane index are determined automatically, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.ClientObject">
      <summary>
        <para>Gets or sets the client <see cref="T:System.Object">object</see>.</para>
      </summary>
      <remarks>
        <para>The given client <see cref="T:System.Object" /> should be an instance of <see cref="T:System.IComparable" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if there is currently no <see cref="T:System.Collections.Generic.IComparer`1">comparator</see> and the specified object is not a <see cref="T:System.IComparable" /> instance</para>
      </exception>
      <value>
        <para>the given client <see cref="T:System.Object" /></para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.Comparer" />
      <seealso cref="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.Comparer" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.LaneTightness">
      <summary>
        <para>Gets or sets the tightness factor of the lane.</para>
      </summary>
      <remarks>
        <para>This value should lie within <c>[0,1]</c> interval.</para>
        <para>The greater the value, the more will the lane be forced to obtain its minimum possible width.</para>
        <list type="bullet">
          <item>A value of <c>0.0d</c> will disable compression of the lane.</item>
          <item>A value of <c>1.0d</c> will try to force the lane to obtain its <see cref="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.MinimumLaneWidth">minimum width</see>.</item>
        </list>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the tightness value is outside <c>[0,1]</c> interval</para>
      </exception>
      <value>
        <para>a tightness value from <c>[0,1]</c> interval</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.Comparer">
      <summary>
        <para>Gets or sets the <see cref="T:System.Collections.Generic.IComparer`1" /> instance used for sorting the lanes.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:System.Collections.Generic.IComparer`1" /> is <c>null</c>.</para>
      </exception>
      <value>
        <para>the current <see cref="T:System.Collections.Generic.IComparer`1" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.MinimumLaneWidth">
      <summary>
        <para>Gets or sets the minimum width of the swimlane.</para>
      </summary>
      <remarks>
        <para>The minimum width should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value negative</para>
      </exception>
      <value>
        <para>the minimum width</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.LeftLaneInset">
      <summary>
        <para>Gets or sets the left insets of the swimlane in which no element will lie in the resulting layout.</para>
      </summary>
      <remarks>
        <para>The inset should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is less than <c>0</c>.</para>
      </exception>
      <value>
        <para>the current left insets</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.RightLaneInset">
      <summary>
        <para>Gets or sets the right insets of the swimlane in which no element will lie in the resulting layout.</para>
      </summary>
      <remarks>
        <para>The inset should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is less than <c>0</c>.</para>
      </exception>
      <value>
        <para>the current right insets</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.ComputedLanePosition">
      <summary>
        <para>Gets the computed position (smaller coordinate) of the swimlane after the layout has been calculated.</para>
      </summary>
      <value>
        <para>the smaller coordinate of the swimlane</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.ComputedLaneWidth">
      <summary>
        <para>Gets the computed width of the swimlane after the layout has been calculated.</para>
      </summary>
      <value>
        <para>the computed width of the swimlane</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.ComputedLaneIndex">
      <summary>
        <para>Gets the computed zero-based index of the swimlane after the layout has been calculated.</para>
      </summary>
      <value>
        <para>the computed lane index or <c>-1</c> if no index has been computed for this lane.</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.SwimlaneDescriptor.CompareTo(System.Object)">
      <summary>
        <para>Implements the <see cref="T:System.IComparable" /> interface using the <see cref="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.Comparer" /> and <see cref="P:yWorks.Layout.Hierarchic.SwimlaneDescriptor.ClientObject" /> fields.</para>
      </summary>
      <param name="o" />
    </member>
    <member name="T:yWorks.Layout.Hierarchic.TopLevelGroupToSwimlaneStage">
      <summary>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage">layout stage</see> can be used for automatically assigning <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instances to nodes by treating top-level group nodes as swimlanes.</para>
      </summary>
      <remarks>
        <para>This stage will modify the hierarchy by temporarily removing the top-level group nodes and assigning corresponding descriptors to the remaining nodes. After running the core layout, the top-level group nodes will be arranged to function as swimlanes. This class allows using the current coordinates of the group nodes to <see cref="P:yWorks.Layout.Hierarchic.TopLevelGroupToSwimlaneStage.OrderSwimlanesFromSketch">arrange the swimlanes from sketch</see>. Also, the <see cref="P:yWorks.Layout.Hierarchic.TopLevelGroupToSwimlaneStage.Spacing">spacing</see> between swimlanes may be specified.</para>
        <para>This stage can be <see cref="M:yWorks.Layout.MultiStageLayout.AppendStage(yWorks.Layout.ILayoutStage)">appended</see> to the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />
      <seealso cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" />
      <seealso cref="T:yWorks.Layout.Grouping.GroupingKeys" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.TopLevelGroupToSwimlaneStage.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.TopLevelGroupToSwimlaneStage" /> with the default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.TopLevelGroupToSwimlaneStage.Spacing">
      <summary>
        <para>Gets or sets the spacing between the swimlanes.</para>
      </summary>
      <remarks>
        <para>The spacing should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the spacing is negative</para>
      </exception>
      <value>
        <para>a non-negative spacing value</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.TopLevelGroupToSwimlaneStage.OrderSwimlanesFromSketch">
      <summary>
        <para>Gets or sets whether or not the order of the swimlanes should be determined based on the current sketch.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the order of the swimlanes is determined from the current sketch, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.TopLevelGroupToSwimlaneStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates the layout by automatically assigning <see cref="T:yWorks.Layout.Hierarchic.SwimlaneDescriptor" /> instances to nodes and treating top-level group nodes as swimlanes.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.TopologicalLayerer">
      <summary>
        <para>This class implements the layering phase of the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> (i.e., assignment of the nodes to layers).</para>
      </summary>
      <remarks>
        <para>It uses topological sorting to assign layers to the nodes.</para>
        <para />
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.TopologicalLayerer.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.TopologicalLayerer" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.TopologicalLayerer.RankingPolicy">
      <summary>
        <para>Gets or sets the (re-)ranking policy used by this <see cref="T:yWorks.Layout.Hierarchic.TopologicalLayerer" /> instance.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown ranking policy is given</para>
      </exception>
      <value>
        <para>one of the predefined ranking policies</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.TopologicalLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers and adds them to the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be filled with the results of the calculation</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for querying information about the nodes and edges</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator">
      <summary>
        <para>This class is a <see cref="T:yWorks.Layout.Hierarchic.IDrawingDistanceCalculator" /> implementation that returns the minimum distances for each kind of node pair based on their type as returned by <see cref="P:yWorks.Layout.Hierarchic.INodeData.Type" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.GetMinDistance(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayer,yWorks.Layout.Hierarchic.ILayoutDataProvider,yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <param name="graph" />
      <param name="layer" />
      <param name="ldp" />
      <param name="left" />
      <param name="right" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.Compaction">
      <summary>
        <para>Gets or sets whether or not the compaction option is enabled.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if compaction is enabled, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.NodeCompaction" />
      <seealso cref="P:yWorks.Layout.Hierarchic.SimplexNodePlacer.LabelCompaction" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.NodeToNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two <see cref="T:yWorks.Algorithms.Node" />s.</para>
      </summary>
      <remarks>
        <para>Minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.NodeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between a <see cref="T:yWorks.Algorithms.Node" /> and an (non-adjacent) <see cref="T:yWorks.Algorithms.Edge" />.</para>
      </summary>
      <remarks>
        <para>Minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.EdgeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two edges.</para>
      </summary>
      <remarks>
        <para>Minimum distance should be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum distance is negative</para>
      </exception>
      <value>
        <para>the given minimum distance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.Dispose(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <param name="graph" />
      <param name="layers" />
      <param name="ldp" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.Initialize(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <param name="graph" />
      <param name="layers" />
      <param name="ldp" />
    </member>
    <member name="P:yWorks.Layout.Hierarchic.TypeBasedDrawingDistanceCalculator.MinimumFirstSegmentLength">
      <summary>
        <para>Gets or sets the minimum length of the first segment of the edge path (at the source node).</para>
      </summary>
      <remarks>
        <para>The minimum length should be greater than <c>0</c>.</para>
        <para>If the value is <c>0.0d</c> the first segment does not need to be orthogonal.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length of the first segment is negative</para>
      </exception>
      <value>
        <para>the minimum length of the first segment</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Hierarchic.WeightedLayerer">
      <summary>
        <para>This class implements the layering phase of the <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> (i.e., the assignment of the nodes to layers).</para>
      </summary>
      <remarks>
        <para>It first makes the directed graph acyclic. Then, it assigns the layers such that edge weights are respected. A weight defines a minimum distance between the two end points of an edge.</para>
        <para />
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.WeightedLayerer.weight">
      <summary>
        <para>This is a <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds for each <see cref="T:yWorks.Algorithms.Edge" /> an integer value representing its weight.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Hierarchic.WeightedLayerer.key">
      <summary>
        <para>The key to access the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds the edge weights.</para>
      </summary>
      <remarks>
        <para>More precisely, the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" /> maps each edge of the input graph to an integer value representing the edge's weight.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.WeightedLayerer.#ctor(System.Object)">
      <summary>
        <para>Creates an instance of <see cref="T:yWorks.Layout.Hierarchic.WeightedLayerer" /> with the given key that provides access to the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds the edge weights and unlimited maximum duration for the <see cref="T:yWorks.Layout.Hierarchic.WeightedLayerer" />.</para>
      </summary>
      <param name="key">
        <para>the key to access the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds the edge weights</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.WeightedLayerer.WeightedCycleRemoval">
      <summary>
        <para>Gets or sets whether or not the edges that need to be reversed are determined using an edge weight based heuristic or using a depth first search based approach.</para>
      </summary>
      <remarks>
        <para>The weight based approach may result in fewer reversed edges (especially for cases with many multi-edges) whereas the DFS based approach is likely to be faster.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if an edge weight based heuristic is used; <c>false</c> if a DFS based approach is used</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Hierarchic.WeightedLayerer.MaximumDuration">
      <summary>
        <para>Gets or sets the time limit in milliseconds set for the layout algorithm.</para>
      </summary>
      <remarks>
        <para>Values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the maximum duration is negative</para>
      </exception>
      <value>
        <para>a non-negative value that specifies the time limit</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.WeightedLayerer.AssignNodeLayer(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeMap,yWorks.Algorithms.EdgeList,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers.</para>
      </summary>
      <param name="graph">
        <para>the graph for which the layers are determined</para>
      </param>
      <param name="layerID">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled by the layout algorithm and returns a zero-based layer index for each node</para>
      </param>
      <param name="reversedEdges">
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges which had been reversed</para>
      </param>
      <param name="weight">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an integer value (weight) for each edge</para>
      </param>
      <returns>
        <para>the number of layers</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.WeightedLayerer.GetWeight(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the edge weight of the given edge using the weight based cycle removal heuristic.</para>
      </summary>
      <remarks>
        <para>By default, all edges are considered to have weight <c>1.0</c>.</para>
        <para>It may be overridden if non-uniform weights are desired.</para>
      </remarks>
      <param name="edge">
        <para>given edge</para>
      </param>
      <returns>
        <para>the edge weight of the specified edge</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Hierarchic.WeightedLayerer.WeightedCycleRemoval" />
      <seealso cref="P:yWorks.Layout.Hierarchic.WeightedLayerer.WeightedCycleRemoval" />
    </member>
    <member name="M:yWorks.Layout.Hierarchic.WeightedLayerer.MakeDFSAcyclic(yWorks.Algorithms.Graph,yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Removes cycles from the graph using a depth first search.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="reversedEdges">
        <para>an <see cref="T:yWorks.Algorithms.EdgeList" /> containing the edges which will be reversed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.WeightedLayerer.AssignLayers(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Assigns all nodes of the graph to layers.</para>
      </summary>
      <param name="graph">
        <para>the graph for which the layers are determined</para>
      </param>
      <param name="layerID">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled by the layout algorithm and returns the zero-based index of the layer to which each node belongs</para>
      </param>
      <returns>
        <para>the number of layers</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.WeightedLayerer.AssignLayersFast(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Assigns all nodes of the graph to layers.</para>
      </summary>
      <param name="graph">
        <para>the graph for which the layers are determined</para>
      </param>
      <param name="layerID">
        <para>the <see cref="T:yWorks.Algorithms.INodeMap" /> that will be filled by the layout algorithm and returns a zero-based layer index for each node</para>
      </param>
      <returns>
        <para>the number of layers</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Hierarchic.WeightedLayerer.AssignLayers(yWorks.Layout.LayoutGraph,yWorks.Layout.Hierarchic.ILayers,yWorks.Layout.Hierarchic.ILayoutDataProvider)">
      <summary>
        <para>Assigns all nodes of the graph to layers and adds them to the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layers">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayers" /> instance that will be filled with the results of the calculation</para>
      </param>
      <param name="ldp">
        <para>the <see cref="T:yWorks.Layout.Hierarchic.ILayoutDataProvider" /> used for querying information about the nodes and edges</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.IEdgeLabelLayout">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> defines the properties of one edge label from the perspective of a labeling algorithm.</para>
      </summary>
      <remarks>
        <para>Note: To avoid inconsistencies, changing the <see cref="P:yWorks.Layout.ILabelLayout.ModelParameter">model parameter</see> should always be combined with updating the corresponding <see cref="P:yWorks.Layout.ILabelLayout.OrientedBox">oriented box</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.IEdgeLabelLayout.LabelModel">
      <summary>
        <para>Gets the label model that describes the valid locations for this label.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" /> associated with this <see cref="T:yWorks.Layout.IEdgeLabelLayout" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.IEdgeLabelLayout.PreferredPlacementDescriptor">
      <summary>
        <para>Gets the preferred placement for this edge label, which can be considered by <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see>.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> for this <see cref="T:yWorks.Layout.IEdgeLabelLayout" /></para>
      </value>
    </member>
    <member name="T:yWorks.Layout.IEdgeLabelLayoutModel">
      <summary>
        <para>This interface defines the properties of the model associated with an <see cref="T:yWorks.Layout.IEdgeLabelLayout" />.</para>
      </summary>
      <remarks>
        <para>An <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" /> provides a set of possible <em>candidates</em> for the placement of an edge label. It also defines a <em>parameter</em> that describes the current location of the label.</para>
        <para>It is important that all state information is encapsulated in the <see cref="M:yWorks.Layout.IEdgeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">model parameter</see>. <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" /> instances may be shared between multiple edge labels but produce different parameters for labels with different locations.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.IEdgeLabelLayoutModel.DefaultParameter">
      <summary>
        <para>Gets a model parameter that encodes the default position of this model's allowed edge label positions.</para>
      </summary>
      <remarks>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.IEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the corresponding label box.</para>
      </remarks>
      <value>
        <para>the model parameter describing the default placement of the edge label</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.IEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)">
      <summary>
        <para>Returns the oriented box of the label for the position encoded by the given model parameter.</para>
      </summary>
      <param name="labelSize">
        <para>the width and height of the label</para>
      </param>
      <param name="edgeLayout">
        <para>the layout of the edge to which the label belongs</para>
      </param>
      <param name="sourceLayout">
        <para>the layout of the source node of the label-owning edge</para>
      </param>
      <param name="targetLayout">
        <para>the layout of the target node of the label-owning edge</para>
      </param>
      <param name="parameter">
        <para>the model parameter that describes the abstract position of the label within this model</para>
      </param>
      <returns>
        <para>the oriented bounds of the label</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.IEdgeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.IEdgeLabelLayout,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.EdgeLabelCandidate" />s that describe valid label positions within this model.</para>
      </summary>
      <remarks>
        <para>In case the implementing <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" /> allows every possible location, this method always returns the current location as a <see cref="T:yWorks.Layout.LabelCandidate" />.</para>
      </remarks>
      <param name="labelLayout">
        <para>the label for which candidates should be generated</para>
      </param>
      <param name="edgeLayout">
        <para>the layout of the edge to which the label belongs</para>
      </param>
      <param name="sourceLayout">
        <para>the layout of the source node of the label-owning edge</para>
      </param>
      <param name="targetLayout">
        <para>the layout of the target node of the label-owning edge</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.EdgeLabelCandidate" /> instances</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.IEdgeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Creates a model parameter that represents the given edge label position within this model.</para>
      </summary>
      <remarks>
        <para>The created model parameter is the closest parameter representation of the given label location that can be achieved within this model.</para>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.IEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the current label box.</para>
        <para>A model parameter can be an arbitrary <see cref="T:System.Object" />. However it must contain all information to allow restoring of the encoded location with this <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" />.</para>
      </remarks>
      <param name="labelBounds">
        <para>the oriented box of the label, encoding the label location for which the parameter should be created</para>
      </param>
      <param name="edgeLayout">
        <para>the layout of the edge to which the label belongs</para>
      </param>
      <param name="sourceLayout">
        <para>the layout of the source node of the label-owning edge</para>
      </param>
      <param name="targetLayout">
        <para>the layout of the target node of the label-owning edge</para>
      </param>
      <returns>
        <para>the model parameter representing the given label location</para>
      </returns>
      <seealso cref="M:yWorks.Layout.IEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" />
    </member>
    <member name="T:yWorks.Layout.IEdgeLayout">
      <summary>
        <para>An <see cref="T:yWorks.Layout.IEdgeLayout" /> encapsulates the layout information for an edge.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the two end points of the edge layout and a sequence of control points that determine the visual path of the edge.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.IEdgeLayout.PointCount">
      <summary>
        <para>Returns the number of control points of the edge.</para>
      </summary>
      <remarks>
        <para>The source and target points are not included in the point count.</para>
      </remarks>
      <returns>
        <para>the number of control points</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.IEdgeLayout.GetPoint(System.Int32)">
      <summary>
        <para>Returns the control point at the given position in the sequence of control points.</para>
      </summary>
      <remarks>
        <para>The first control point in the sequence has index <c>0</c> and the last control point has index <see cref="M:yWorks.Layout.IEdgeLayout.PointCount" /> <c>-1</c>.</para>
      </remarks>
      <param name="index">
        <para>the position of the control point in the control point sequence</para>
      </param>
      <returns>
        <para>the absolute coordinates of the control point at the given index</para>
      </returns>
      <seealso cref="M:yWorks.Layout.IEdgeLayout.SetPoint(System.Int32,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.IEdgeLayout.SetPoint(System.Int32,System.Double,System.Double)">
      <summary>
        <para>Sets the absolute coordinates of the control point at the given position in the sequence of control points.</para>
      </summary>
      <remarks>
        <para>The first control point in the sequence has index <c>0</c> and the last control point has index <see cref="M:yWorks.Layout.IEdgeLayout.PointCount" /> <c>-1</c>.</para>
      </remarks>
      <param name="index">
        <para>the position of the changing control point in the sequence</para>
      </param>
      <param name="x">
        <para>the new absolute x-coordinate of the control point at the given index</para>
      </param>
      <param name="y">
        <para>the new absolute y-coordinate of the control point at the given index</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.IEdgeLayout.AddPoint(System.Double,System.Double)">
      <summary>
        <para>Adds a control point to the end of the control point sequence.</para>
      </summary>
      <param name="x">
        <para>the absolute x-coordinate of the new control point</para>
      </param>
      <param name="y">
        <para>the absolute y-coordinate of the new control point</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.IEdgeLayout.ClearPoints">
      <summary>
        <para>Removes all control points from this edge layout.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.IEdgeLayout" /> still keeps the <see cref="P:yWorks.Layout.IEdgeLayout.SourcePoint">source point</see> and the <see cref="P:yWorks.Layout.IEdgeLayout.TargetPoint">target point</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.IEdgeLayout.SourcePoint">
      <summary>
        <para>Gets or sets the relative coordinates of the first end point of this layout.</para>
      </summary>
      <remarks>
        <para>These coordinates are relative to the center location of the edge's source node. To obtain the absolute coordinates of the end point, the relative coordinates have to be added to the center coordinates of the source <see cref="T:yWorks.Layout.INodeLayout" />.</para>
      </remarks>
      <value>
        <para>the relative coordinates of the source point</para>
      </value>
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetCenterX(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetCenterY(yWorks.Algorithms.Node)" />
      <seealso cref="P:yWorks.Layout.INodeLayout.X" />
      <seealso cref="P:yWorks.Layout.INodeLayout.Y" />
    </member>
    <member name="P:yWorks.Layout.IEdgeLayout.TargetPoint">
      <summary>
        <para>Gets or sets the relative coordinates of the second end point of this layout.</para>
      </summary>
      <remarks>
        <para>These coordinates are relative to the center location of the edge's target node. To obtain the absolute coordinates of the end point, the relative coordinates have to be added to the center coordinates of the target <see cref="T:yWorks.Layout.INodeLayout" />.</para>
      </remarks>
      <value>
        <para>the relative coordinates of the target point</para>
      </value>
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetCenterX(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetCenterY(yWorks.Algorithms.Node)" />
      <seealso cref="P:yWorks.Layout.INodeLayout.X" />
      <seealso cref="P:yWorks.Layout.INodeLayout.Y" />
    </member>
    <member name="T:yWorks.Layout.IIntersectionCalculator">
      <summary>
        <para>An <see cref="T:yWorks.Layout.IIntersectionCalculator" /> is responsible for calculating the intersection point between an edge and the visual representation of its source or target node.</para>
      </summary>
      <remarks>
        <para>This interface is especially useful in conjunction with <see cref="T:yWorks.Layout.PortCalculator" /> when adjusting the final port locations after the layout is calculated.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.PortCalculator" />
    </member>
    <member name="M:yWorks.Layout.IIntersectionCalculator.CalculateIntersectionPoint(yWorks.Layout.INodeLayout,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Calculates an intersection point between the edge and the given <see cref="T:yWorks.Layout.INodeLayout" />.</para>
      </summary>
      <remarks>
        <para>Implementing classes use a point on the connecting edge segment (specified with an offset to the node's center) along with a direction pointing to the node and calculate the intersection between this line and the node.</para>
      </remarks>
      <param name="nodeLayout">
        <para>the layout information of the node</para>
      </param>
      <param name="xOffset">
        <para>the x-coordinate of a point on the last line segment relative to the node's center</para>
      </param>
      <param name="yOffset">
        <para>the y-coordinate of a point on the last line segment relative to the node's center</para>
      </param>
      <param name="dx">
        <para>the x-component of the normalized direction vector indicating the direction of the segment pointing towards the node</para>
      </param>
      <param name="dy">
        <para>the y-component of the normalized direction vector indicating the direction of the segment pointing towards the node</para>
      </param>
      <returns>
        <para>the intersection coordinates relative to the node's center or <c>null</c> if no such intersection was found</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.IntersectionCalculatorKeys">
      <summary>
        <para>Helper class that declares several keys for <see cref="T:yWorks.Algorithms.IDataProvider" /> that provide <see cref="T:yWorks.Layout.IIntersectionCalculator" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.IntersectionCalculatorKeys.SourceIntersectionCalculatorDpKey">
      <summary>
        <para>A data provider key for providing an individual intersection calculation for each edge source in the graph.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.IntersectionCalculatorKeys.TargetIntersectionCalculatorDpKey">
      <summary>
        <para>A data provider key for providing an individual intersection calculation for each edge target in the graph.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.ILabelLayout">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.ILabelLayout" /> defines the properties of a label from the perspective of a labeling algorithm.</para>
      </summary>
      <remarks>
        <para>Both node and edge labels need to implement this interface. It describes the size and position of a label.</para>
        <para>Note: To avoid inconsistencies, changing the <see cref="P:yWorks.Layout.ILabelLayout.ModelParameter">model parameter</see> should always be combined with updating the corresponding <see cref="P:yWorks.Layout.ILabelLayout.OrientedBox">oriented box</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.ILabelLayout.BoundingBox">
      <summary>
        <para>Gets the bounding box of the label.</para>
      </summary>
      <remarks>
        <para>The bounding box is the smallest, paraxial rectangle that contains the whole label.</para>
      </remarks>
      <value>
        <para>the bounding box of the label</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.ILabelLayout.OrientedBox">
      <summary>
        <para>Gets the box of the label.</para>
      </summary>
      <remarks>
        <para>This box matches the area that is covered by the label. The <see cref="M:yWorks.Algorithms.Geometry.YOrientedRectangle.SetUpVector(System.Double,System.Double)">up vector</see> of the rectangle encodes the orientation of the label.</para>
      </remarks>
      <value>
        <para>the oriented box of the label</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.ILabelLayout.ModelParameter">
      <summary>
        <para>Gets or sets the label model parameter that describes the position of this label.</para>
      </summary>
      <remarks>
        <para>The model parameter must fit the according label model.</para>
      </remarks>
      <value>
        <para>the label model parameter</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.ILabelLayoutFactory">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.ILabelLayoutFactory" /> provides methods to create, add and remove node/edge labels for <see cref="T:yWorks.Layout.LayoutGraph" />s.</para>
      </summary>
      <remarks>
        <para>It can be used, e.g., to temporarily add labels during layout calculation.</para>
        <para>Note that original labels which are removed during a layout calculation have to be re-added when the layout calculation is done.</para>
        <para>An instance of this factory can be obtained with method <see cref="M:yWorks.Layout.LayoutGraphUtilities.GetLabelFactory(yWorks.Layout.LayoutGraph)" />. This method uses the <see cref="M:yWorks.Layout.LayoutGraph.CreateLabelFactory" /> method to create the factory.</para>
        <para>Note that each factory instance is bound to a specific graph instance, i.e., you can only create, add and remove labels for the graph which was given to method <see cref="M:yWorks.Layout.LayoutGraphUtilities.GetLabelFactory(yWorks.Layout.LayoutGraph)" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.ILabelLayoutFactory.Graph">
      <summary>
        <para>Gets the graph associated with this label factory instance.</para>
      </summary>
      <value>
        <para>the graph associated with this label factory instance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.ILabelLayoutFactory.AddLabelLayout(yWorks.Algorithms.Node,yWorks.Layout.INodeLabelLayout)">
      <summary>
        <para>Adds the given node label layout to the given node.</para>
      </summary>
      <remarks>
        <para>The given label layout has to be created with method <see cref="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YOrientedRectangle)" /> or <see cref="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.INodeLabelLayoutModel)" />.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="labelLayout">
        <para>the node label layout that should be added to the given node</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given label layout has already been added to the graph</para>
      </exception>
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YOrientedRectangle)" />
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.INodeLabelLayoutModel)" />
    </member>
    <member name="M:yWorks.Layout.ILabelLayoutFactory.RemoveLabelLayout(yWorks.Algorithms.Node,yWorks.Layout.INodeLabelLayout)">
      <summary>
        <para>Removes the given node label layout from the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="labelLayout">
        <para>the label layout that should be removed from the given node</para>
      </param>
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.AddLabelLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLabelLayout)" />
    </member>
    <member name="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YOrientedRectangle)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ILabelLayout" /> for the given node.</para>
      </summary>
      <remarks>
        <para>This method should create a <see cref="T:yWorks.Layout.ILabelLayout" /> with a <see cref="T:yWorks.Layout.INodeLabelLayoutModel" /> that supports the desired oriented label box exactly as given.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="orientedBox">
        <para>the box specifying the size and location of the label</para>
      </param>
      <returns>
        <para>a new node label layout</para>
      </returns>
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.AddLabelLayout(yWorks.Algorithms.Node,yWorks.Layout.INodeLabelLayout)" />
    </member>
    <member name="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.INodeLabelLayoutModel)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ILabelLayout" /> for the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="orientedBox">
        <para>the box specifying the size and location of the label</para>
      </param>
      <param name="model">
        <para>specifies the model of the created node label</para>
      </param>
      <returns>
        <para>a new node label layout</para>
      </returns>
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.AddLabelLayout(yWorks.Algorithms.Node,yWorks.Layout.INodeLabelLayout)" />
    </member>
    <member name="M:yWorks.Layout.ILabelLayoutFactory.AddLabelLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLabelLayout)">
      <summary>
        <para>Adds the given <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> to the given edge.</para>
      </summary>
      <remarks>
        <para>The given <see cref="T:yWorks.Layout.ILabelLayout" /> has to be created with method <see cref="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YOrientedRectangle)" /> or <see cref="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.IEdgeLabelLayoutModel,yWorks.Layout.PreferredPlacementDescriptor)" />.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="labelLayout">
        <para>the edge label layout that should be added to the given edge</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given label layout has already been added to the graph</para>
      </exception>
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YOrientedRectangle)" />
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.IEdgeLabelLayoutModel,yWorks.Layout.PreferredPlacementDescriptor)" />
    </member>
    <member name="M:yWorks.Layout.ILabelLayoutFactory.RemoveLabelLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLabelLayout)">
      <summary>
        <para>Removes the given <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> from the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="labelLayout">
        <para>the label layout that should be removed from the given edge</para>
      </param>
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.AddLabelLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLabelLayout)" />
    </member>
    <member name="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YOrientedRectangle)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ILabelLayout" /> for the given edge.</para>
      </summary>
      <remarks>
        <para>This method should create a <see cref="T:yWorks.Layout.ILabelLayout" /> with an <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" /> that supports the desired oriented label box exactly as given.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="orientedBox">
        <para>the box specifying the size and location of the label</para>
      </param>
      <returns>
        <para>a new edge label layout</para>
      </returns>
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.AddLabelLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLabelLayout)" />
    </member>
    <member name="M:yWorks.Layout.ILabelLayoutFactory.CreateLabelLayout(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.IEdgeLabelLayoutModel,yWorks.Layout.PreferredPlacementDescriptor)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ILabelLayout" /> for the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="orientedBox">
        <para>the box specifying the size and location of the label</para>
      </param>
      <param name="model">
        <para>specifies the model of the created edge label</para>
      </param>
      <param name="descriptor">
        <para>specifies the preferred placement descriptor of the created label. If this value is <c>null</c>, the default descriptor is used</para>
      </param>
      <returns>
        <para>a new edge label layout</para>
      </returns>
      <seealso cref="M:yWorks.Layout.ILabelLayoutFactory.AddLabelLayout(yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLabelLayout)" />
    </member>
    <member name="T:yWorks.Layout.ILayoutAlgorithm">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> describes the general interface for algorithms that perform a layout process on a <see cref="T:yWorks.Layout.LayoutGraph" />.</para>
      </summary>
      <remarks>
        <para>The main method for invoking the layout calculation is <see cref="M:yWorks.Layout.ILayoutAlgorithm.ApplyLayout(yWorks.Layout.LayoutGraph)" />. Implementing classes will arrange the graph there.</para>
        <para>This class also provides keys to register <see cref="T:yWorks.Algorithms.IDataProvider" />s with the graph that contain information about the nodes and edges in the graph. <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with <see cref="F:yWorks.Layout.LayoutKeys.NodeIdDpKey" /> and <see cref="F:yWorks.Layout.LayoutKeys.EdgeIdDpKey" /> contain unique identifiers for both nodes and edges. These identifiers allow for ensuring consistent results even if the order of nodes and edges was changed between two layout runs.<br /> The selection state of nodes and edges is stored in <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with the keys <see cref="F:yWorks.Layout.LayoutKeys.AffectedNodesDpKey" /> and <see cref="F:yWorks.Layout.LayoutKeys.AffectedEdgesDpKey" />. Based on this information, the layout algorithm may reduce its calculations to the selected subset of nodes or edges.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.ILayoutAlgorithm.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Main layout routine that assigns new layout information to the given graph.</para>
      </summary>
      <remarks>
        <para>The call to this routine will only succeed if the layout algorithm can handle the input graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.LayoutKeys">
      <summary>
        <para>Helper class that provides unique identifiers for some general purpose <see cref="T:yWorks.Algorithms.IDataProvider">data providers</see>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LayoutKeys.NodeIdDpKey">
      <summary>
        <para>A data provider key for looking up a unique identifier for each node in a graph.</para>
      </summary>
      <remarks>
        <para>Layout algorithms may use this information to provide consistent layouts for multiple runs.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.LayoutKeys.EdgeIdDpKey">
      <summary>
        <para>A data provider key for looking up a unique identifier for each edge in a graph.</para>
      </summary>
      <remarks>
        <para>Layout algorithms may use this information to provide consistent layouts for multiple runs.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.LayoutKeys.AffectedNodesDpKey">
      <summary>
        <para>A data provider key for looking up the selected state of the nodes in the graph.</para>
      </summary>
      <remarks>
        <para>A layout algorithm can retrieve a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key to apply a special handling to the selected nodes. For example, the layout algorithm may restrict its scope, i.e., it only arranges the selected nodes.</para>
        <para>However, it is often more convenient to use a specific <see cref="T:yWorks.Algorithms.IDataProvider" /> key for this purpose, e.g., if you want to combine two layout algorithms of the same kind which have to operate on different subsets of the graph. Thus, these algorithms may provide a method like <c>setSubgraphNodesDpKey(Object)</c> that customizes the <see cref="T:yWorks.Algorithms.IDataProvider" /> key allowing to specify different sets of selected nodes for nested layout algorithms.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.LayoutKeys.AffectedEdgesDpKey">
      <summary>
        <para>A data provider key for looking up the selected state of the edges in the graph.</para>
      </summary>
      <remarks>
        <para>A layout algorithm can retrieve a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key to apply a special handling to the selected edges. For example, the layout algorithm may restrict its scope, i.e., it only routes the selected edges.</para>
        <para>However, it is often more convenient to use a specific <see cref="T:yWorks.Algorithms.IDataProvider" /> key for this purpose, e.g., if you want to combine two layout algorithms of the same kind which have to operate on different subsets of the graph. Thus, these algorithms may provide a method like <c>setSubgraphEdgesDpKey(Object)</c> that customizes the <see cref="T:yWorks.Algorithms.IDataProvider" /> key allowing to specify different sets of selected edges for nested layout algorithms.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Layout.ILayoutStage">
      <summary>
        <para>A <see cref="T:yWorks.Layout.ILayoutStage" /> is a layout algorithm that represents a stage of a larger layout process.</para>
      </summary>
      <remarks>
        <para>It delegates the core layout process to another <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see>. Implementing classes may perform pre-processing steps before the <see cref="P:yWorks.Layout.ILayoutStage.CoreLayout">core layout algorithm</see> gets called and post-processing steps afterwards.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.MultiStageLayout" />
    </member>
    <member name="P:yWorks.Layout.ILayoutStage.CoreLayout">
      <summary>
        <para>Gets or sets the core layout algorithm.</para>
      </summary>
      <remarks>
        <para>This algorithm is wrapped by this stage. It is invoked in <see cref="M:yWorks.Layout.ILayoutAlgorithm.ApplyLayout(yWorks.Layout.LayoutGraph)" />. The <see cref="T:yWorks.Layout.ILayoutStage" /> may add pre- and post-processing steps before and after calling the core layout algorithm.</para>
      </remarks>
      <value>
        <para>the core layout algorithm</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.INodeLabelLayout">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.INodeLabelLayout" /> defines the properties of one node label from the perspective of a labeling algorithm.</para>
      </summary>
      <remarks>
        <para>Note: To avoid inconsistencies, changing the <see cref="P:yWorks.Layout.ILabelLayout.ModelParameter">model parameter</see> should always be combined with updating the corresponding <see cref="P:yWorks.Layout.ILabelLayout.OrientedBox">oriented box</see>.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.INodeLabelLayout.LabelModel">
      <summary>
        <para>Gets the label model that describes the valid locations for this label.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.INodeLabelLayoutModel" /> associated with this <see cref="T:yWorks.Layout.INodeLabelLayout" /></para>
      </value>
    </member>
    <member name="T:yWorks.Layout.INodeLabelLayoutModel">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.INodeLabelLayoutModel" /> defines the properties of the model associated with a <see cref="T:yWorks.Layout.INodeLabelLayout" />.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:yWorks.Layout.INodeLabelLayoutModel" /> provides a set of possible <em>candidates</em> for the placement of a node label. It also defines a <em>parameter</em> that describes the current location of the label.</para>
        <para>It is important that all state information is encapsulated in the <see cref="M:yWorks.Layout.INodeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.INodeLayout)">model parameter</see>. <see cref="T:yWorks.Layout.INodeLabelLayoutModel" /> instances may be shared between multiple node labels but produce different parameters for labels with different locations.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.INodeLabelLayoutModel.DefaultParameter">
      <summary>
        <para>Gets a model parameter that encodes the default position of this model's allowed node label positions.</para>
      </summary>
      <remarks>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.INodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the corresponding label box.</para>
      </remarks>
      <value>
        <para>the model parameter describing the default placement of the node label</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.INodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)">
      <summary>
        <para>Returns the bounds of the label for the position encoded by the given model parameter.</para>
      </summary>
      <param name="labelSize">
        <para>the width and height of the label</para>
      </param>
      <param name="nodeLayout">
        <para>the layout of the node to which the label belongs</para>
      </param>
      <param name="param">
        <para>the model parameter that describes the abstract position of the label within this model</para>
      </param>
      <returns>
        <para>the oriented box of the label</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.INodeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.INodeLabelLayout,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.NodeLabelCandidate" />s that describe valid label positions within this model.</para>
      </summary>
      <remarks>
        <para>In case the implementing <see cref="T:yWorks.Layout.INodeLabelLayoutModel" /> allows every possible location, this method always returns the current location as a <see cref="T:yWorks.Layout.LabelCandidate" />.</para>
      </remarks>
      <param name="labelLayout">
        <para>the label for which candidates should be generated</para>
      </param>
      <param name="nodeLayout">
        <para>the layout of the node to which the label belongs</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.NodeLabelCandidate" /> instances</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.INodeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Creates a model parameter that represents the given node label position within this model.</para>
      </summary>
      <remarks>
        <para>The created model parameter is the closest parameter representation of the given label location that can be achieved within this model.</para>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.INodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the current label box.</para>
        <para>A model parameter can be an arbitrary <see cref="T:System.Object" />. However it must contain all information to allow restoring of the encoded location with this <see cref="T:yWorks.Layout.INodeLabelLayoutModel" />.</para>
      </remarks>
      <param name="labelBounds">
        <para>the box of the label, encoding the label location for which the parameter should be created</para>
      </param>
      <param name="nodeLayout">
        <para>the layout of the node to which the label belongs</para>
      </param>
      <returns>
        <para>the model parameter representing the given label location</para>
      </returns>
      <seealso cref="M:yWorks.Layout.INodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)" />
    </member>
    <member name="T:yWorks.Layout.INodeLayout">
      <summary>
        <para>A <see cref="T:yWorks.Layout.INodeLayout" /> encapsulates the layout information for a node.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the size and position of the node.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.INodeLayout.X">
      <summary>
        <para>Gets the x-coordinate of the upper-left corner of the node.</para>
      </summary>
      <remarks>
        <para>The location of the node is described by the coordinates of the upper-left corner of the node.</para>
      </remarks>
      <value>
        <para>the x-coordinate of the node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.INodeLayout.Y">
      <summary>
        <para>Gets the y-coordinate of the upper-left corner of the node.</para>
      </summary>
      <remarks>
        <para>The location of the node is described by the coordinates of the upper-left corner of the node.</para>
      </remarks>
      <value>
        <para>the y-coordinate of the node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.INodeLayout.Width">
      <summary>
        <para>Gets the width of the node.</para>
      </summary>
      <remarks>
        <para>The width of the node is the horizontal distance the node spans.</para>
      </remarks>
      <value>
        <para>the width of the node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.INodeLayout.Height">
      <summary>
        <para>Gets the height of the node.</para>
      </summary>
      <remarks>
        <para>The height of the node is the vertical distance the node spans.</para>
      </remarks>
      <value>
        <para>the height of the node</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.INodeLayout.SetLocation(System.Double,System.Double)">
      <summary>
        <para>Sets the coordinates of the upper-left corner of the node.</para>
      </summary>
      <param name="x">
        <para>the new x-coordinate of the node</para>
      </param>
      <param name="y">
        <para>the new y-coordinate of the node</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.INodeLayout.SetSize(System.Double,System.Double)">
      <summary>
        <para>Sets the size of the node.</para>
      </summary>
      <param name="width">
        <para>the new width of the node</para>
      </param>
      <param name="height">
        <para>the new height of the node</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.IProfitModel">
      <summary>
        <para>A <see cref="T:yWorks.Layout.IProfitModel" /> ranks <see cref="T:yWorks.Layout.LabelCandidate" />s used for prioritizing certain label locations over others.</para>
      </summary>
      <remarks>
        <para>Generic labeling algorithm <see cref="T:yWorks.Layout.Labeling.GenericLabeling" /> will use the ranking to decide which <see cref="T:yWorks.Layout.LabelCandidate" />s to eliminate.</para>
        <para>
          <see cref="T:yWorks.Layout.LabelCandidate" />s with a high profit will be preferred over <see cref="T:yWorks.Layout.LabelCandidate" />s with a low profit.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.IProfitModel.GetProfit(yWorks.Layout.LabelCandidate)">
      <summary>
        <para>Returns the profit for placing a label using the given <see cref="T:yWorks.Layout.LabelCandidate" />.</para>
      </summary>
      <remarks>
        <para>Higher profit means better candidates. Hence, there is a higher probability that the candidate is chosen by a labeling algorithm.</para>
        <para>Profits need to have a value between <c>0</c> and <c>1</c>.</para>
      </remarks>
      <param name="candidate">
        <para>the candidate</para>
      </param>
      <returns>
        <para>the profit of the candidate</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.LabelCandidate">
      <summary>
        <para>A <see cref="T:yWorks.Layout.LabelCandidate" /> describes one valid placement for a label considering the label model.</para>
      </summary>
      <remarks>
        <para>Generic labeling algorithms place labels according to their label model. To get valid locations for the label, the label model generates various <see cref="T:yWorks.Layout.LabelCandidate" />s. One of these candidates will be chosen to provide the actual placement of the label.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.INodeLabelLayoutModel" />
      <seealso cref="T:yWorks.Layout.IEdgeLabelLayoutModel" />
      <seealso cref="T:yWorks.Layout.Labeling.GenericLabeling" />
    </member>
    <member name="M:yWorks.Layout.LabelCandidate.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YDimension,System.Object,yWorks.Layout.ILabelLayout,System.Boolean)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.LabelCandidate" /> described by location, size, model parameter and internal flag.</para>
      </summary>
      <param name="pos">
        <para>the location of the upper left corner of the candidate</para>
      </param>
      <param name="size">
        <para>the size of the candidate</para>
      </param>
      <param name="param">
        <para>the parameters of the label model associated with this candidate</para>
      </param>
      <param name="owner">
        <para>the label associated with the candidate</para>
      </param>
      <param name="internal">
        <para>
          <c>true</c> if the candidate is allowed to overlap with its owner, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LabelCandidate.#ctor(yWorks.Algorithms.Geometry.YOrientedRectangle,System.Object,yWorks.Layout.ILabelLayout,System.Boolean)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.LabelCandidate" /> described by its box, model parameter and internal flag.</para>
      </summary>
      <param name="labelBox">
        <para>the box that specifies the candidate's size and position</para>
      </param>
      <param name="param">
        <para>the parameters of the label model associated with this candidate</para>
      </param>
      <param name="owner">
        <para>the label associated with the candidate</para>
      </param>
      <param name="internal">
        <para>
          <c>true</c> if the candidate is allowed to overlap with its owner, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.CustomProfit">
      <summary>
        <para>Gets or sets the custom profit for this candidate.</para>
      </summary>
      <remarks>
        <para>The profit describes the priority of this candidate with respect to other candidates. Labeling algorithms will use the profit to decide which candidate to choose.</para>
        <para>The value is restricted to the interval <c>[0,1]</c>, where <c>1</c> specifies the highest possible profit.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value lies outside of <c>[0,1]</c></para>
      </exception>
      <value>
        <para>the custom profit for this candidate</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.ModelParameter">
      <summary>
        <para>Gets the model parameter that was used by the underlying model to generate this label candidate.</para>
      </summary>
      <value>
        <para>the model parameter</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Location">
      <summary>
        <para>Gets the coordinates of the upper-left corner of the candidate's bounds.</para>
      </summary>
      <remarks>
        <para>The bounds are the smallest paraxial box that contains the candidate.</para>
      </remarks>
      <value>
        <para>the coordinates of the upper-left corner</para>
      </value>
      <seealso cref="P:yWorks.Layout.LabelCandidate.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Size">
      <summary>
        <para>Gets the width and height of the candidate's bounds.</para>
      </summary>
      <remarks>
        <para>The bounds are the smallest paraxial box that contains the candidate.</para>
      </remarks>
      <value>
        <para>the size of the candidate's bounds</para>
      </value>
      <seealso cref="P:yWorks.Layout.LabelCandidate.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.X">
      <summary>
        <para>Gets the minimum x-coordinate of the candidate's bounds.</para>
      </summary>
      <remarks>
        <para>The bounds are the smallest paraxial box that contains the candidate.</para>
      </remarks>
      <value>
        <para>the x-coordinate of the candidate's bounds</para>
      </value>
      <seealso cref="P:yWorks.Layout.LabelCandidate.Location" />
      <seealso cref="P:yWorks.Layout.LabelCandidate.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Y">
      <summary>
        <para>Gets the minimum y-coordinate of the candidate's bounds.</para>
      </summary>
      <remarks>
        <para>The bounds are the smallest paraxial box that contains the candidate.</para>
      </remarks>
      <value>
        <para>the y-coordinate of the candidate's bounds</para>
      </value>
      <seealso cref="P:yWorks.Layout.LabelCandidate.Location" />
      <seealso cref="P:yWorks.Layout.LabelCandidate.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Width">
      <summary>
        <para>Gets the width of the candidate's bounds.</para>
      </summary>
      <remarks>
        <para>The bounds are the smallest paraxial box that contains the candidate.</para>
      </remarks>
      <value>
        <para>the width of the candidate's bounds</para>
      </value>
      <seealso cref="P:yWorks.Layout.LabelCandidate.Size" />
      <seealso cref="P:yWorks.Layout.LabelCandidate.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Height">
      <summary>
        <para>Gets the height of the candidate's bounding box.</para>
      </summary>
      <remarks>
        <para>The bounding box is the smallest paraxial box that contains the candidate.</para>
      </remarks>
      <value>
        <para>the height of the candidate's bounding box</para>
      </value>
      <seealso cref="P:yWorks.Layout.LabelCandidate.Size" />
      <seealso cref="P:yWorks.Layout.LabelCandidate.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.BoundingBox">
      <summary>
        <para>Gets the bounding box of this candidate.</para>
      </summary>
      <remarks>
        <para>The bounding box describes the smallest paraxial box that contains the candidate.</para>
      </remarks>
      <value>
        <para>the bounding box</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Box">
      <summary>
        <para>Gets the oriented box of this candidate.</para>
      </summary>
      <remarks>
        <para>If the label is rotated, this box will be oriented accordingly.</para>
      </remarks>
      <value>
        <para>the size, location and orientation of the candidate</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Owner">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.ILabelLayout" /> for which this candidate was created.</para>
      </summary>
      <value>
        <para>the actual label to which the candidate belongs</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Internal">
      <summary>
        <para>Gets whether or not this candidate describes an internal label.</para>
      </summary>
      <remarks>
        <para>Internal labels reside inside the boundaries of a node.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the candidate represents an internal label, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.LabelCandidate.Propagate">
      <summary>
        <para>Replaces the model parameter and box of the owner with the model parameter and box of this candidate.</para>
      </summary>
      <remarks>
        <para>When this candidate is chosen to provide the placement of the label, this method transfers the model parameter and the candidate box to the <see cref="T:yWorks.Layout.ILabelLayout" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.LabelCandidate.Owner" />
      <seealso cref="P:yWorks.Layout.LabelCandidate.ModelParameter" />
      <seealso cref="P:yWorks.Layout.LabelCandidate.Box" />
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.NodeOverlapPenalty">
      <summary>
        <para>Gets or sets a penalty for a candidate position that overlaps the box of a node.</para>
      </summary>
      <remarks>
        <para>The penalty should be a factor between <c>0</c> and <c>1</c>, where <c>0</c> means that an overlap is considered unimportant and <c>1</c> means that an overlap is considered severe.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified penalty is outside <c>[0,1]</c></para>
      </exception>
      <value>
        <para>the penalty for overlaps with nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.EdgeOverlapPenalty">
      <summary>
        <para>Gets or sets a penalty for a candidate position that overlaps the path of an edge.</para>
      </summary>
      <remarks>
        <para>The penalty should be a factor between <c>0</c> and <c>1</c>, where <c>0</c> means that an overlap is considered unimportant and <c>1</c> means that an overlap is considered severe.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified penalty is outside <c>[0,1]</c></para>
      </exception>
      <value>
        <para>the penalty for overlaps with edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.OverlapPenalty">
      <summary>
        <para>Gets the sum of node overlap penalty and edge overlap penalty.</para>
      </summary>
      <value>
        <para>the added penalty for edge overlaps and node overlaps</para>
      </value>
      <seealso cref="P:yWorks.Layout.LabelCandidate.EdgeOverlapPenalty" />
      <seealso cref="P:yWorks.Layout.LabelCandidate.NodeOverlapPenalty" />
    </member>
    <member name="P:yWorks.Layout.LabelCandidate.Propagated">
      <summary>
        <para>Gets whether or not this candidate's box had already been chosen by the labeling algorithm.</para>
      </summary>
      <remarks>
        <para>If this candidate is propagated, its model parameter and box were transferred to the <see cref="P:yWorks.Layout.LabelCandidate.Owner">label</see>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this candidate was chosen, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Layout.LabelCandidate.Propagate" />
    </member>
    <member name="M:yWorks.Layout.LabelCandidate.ToString">
      <summary>
        <para>Returns a <see cref="T:System.String" /> representation of this <see cref="T:yWorks.Layout.LabelCandidate" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:System.String" /> contains the owning label and the coordinates of the candidate's bounds.</para>
      </remarks>
      <returns>
        <para>a representation of the candidate</para>
      </returns>
      <seealso cref="P:yWorks.Layout.LabelCandidate.Owner" />
      <seealso cref="P:yWorks.Layout.LabelCandidate.Location" />
    </member>
    <member name="T:yWorks.Layout.LabelLayoutBase">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.LabelLayoutBase" /> is the default implementation of the <see cref="T:yWorks.Layout.ILabelLayout" /> interface.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.LabelLayoutBase.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.LabelLayoutBase" /> instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutBase.OrientedBox">
      <summary>
        <para>Sets the box of the label.</para>
      </summary>
      <remarks>
        <para>This box matches the area that is covered by the label. The <see cref="M:yWorks.Algorithms.Geometry.YOrientedRectangle.SetUpVector(System.Double,System.Double)">up vector</see> of the rectangle encodes the orientation of the label.</para>
      </remarks>
      <value>
        <para>the oriented box of the label</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutBase.BoundingBox">
      <summary>
        <para>Sets the bounding box of the label.</para>
      </summary>
      <remarks>
        <para>The bounding box is the smallest, paraxial rectangle that contains the whole label.</para>
      </remarks>
      <value>
        <para>the bounding box of the label</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.LabelLayoutData">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.LabelLayoutData" /> encapsulates layout information for a label.</para>
      </summary>
      <remarks>
        <para>The information is used by clients to inform label-aware <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> about labeling constraints like label size and preferred placement.</para>
        <para>Label-aware algorithms like <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> return the calculated label positions by assigning the corresponding box to the provided <see cref="T:yWorks.Layout.LabelLayoutData" /> instances.</para>
        <para>
          <see cref="T:yWorks.Algorithms.IDataProvider">DataProviders</see> are used for associating an array of <see cref="T:yWorks.Layout.LabelLayoutData" /> instances with either the nodes or the edges of a <see cref="T:yWorks.Layout.LayoutGraph" />. The <see cref="T:yWorks.Algorithms.IDataProvider">DataProviders</see> must be registered with the input graph using one of the keys defined in <see cref="T:yWorks.Layout.LabelLayoutKeys" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.LabelLayoutData.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.LabelLayoutData" /> for a label with the given width and height.</para>
      </summary>
      <param name="width">
        <para>the width of the label</para>
      </param>
      <param name="height">
        <para>the height of the label</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LabelLayoutData.#ctor(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.PreferredPlacementDescriptor)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.LabelLayoutData" /> for a label with the given oriented box and preferred placement descriptor.</para>
      </summary>
      <param name="bounds">
        <para>the box of the label</para>
      </param>
      <param name="preferredPlacement">
        <para>a preferred placement descriptor</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the specified descriptor is <c>null</c></para>
      </exception>
      <seealso cref="T:yWorks.Layout.PreferredPlacementDescriptor" />
      <seealso cref="P:yWorks.Layout.LabelLayoutData.PreferredPlacementDescriptor" />
    </member>
    <member name="P:yWorks.Layout.LabelLayoutData.Bounds">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.Geometry.YOrientedRectangle">oriented box</see> of the label.</para>
      </summary>
      <value>
        <para>the bounds of the label</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.LabelLayoutData.SetSize(System.Double,System.Double)">
      <summary>
        <para>Specifies the width and height of the <see cref="P:yWorks.Layout.LabelLayoutData.Bounds">oriented box</see> of this label.</para>
      </summary>
      <param name="width">
        <para>the width of the oriented box</para>
      </param>
      <param name="height">
        <para>the height of the oriented box</para>
      </param>
      <seealso cref="P:yWorks.Layout.LabelLayoutData.Bounds" />
    </member>
    <member name="P:yWorks.Layout.LabelLayoutData.Width">
      <summary>
        <para>Gets the width of the label's bounding box.</para>
      </summary>
      <value>
        <para>the width of the bounding box of the label</para>
      </value>
      <seealso cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelLayoutData.Height">
      <summary>
        <para>Gets the height of the label's bounding box.</para>
      </summary>
      <value>
        <para>the height of the bounding box of the label</para>
      </value>
      <seealso cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.BoundingBox" />
    </member>
    <member name="M:yWorks.Layout.LabelLayoutData.SetLocation(System.Double,System.Double)">
      <summary>
        <para>Specifies the coordinates of the upper-left corner of the bounding box of the label.</para>
      </summary>
      <param name="x">
        <para>the new x-coordinate of the upper-left corner</para>
      </param>
      <param name="y">
        <para>the new y-coordinate of the upper-left corner</para>
      </param>
      <seealso cref="P:yWorks.Layout.LabelLayoutData.X" />
      <seealso cref="P:yWorks.Layout.LabelLayoutData.Y" />
      <seealso cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelLayoutData.X">
      <summary>
        <para>Gets the x-coordinate of the upper-left corner of the label's bounding box.</para>
      </summary>
      <value>
        <para>the x-coordinate of the upper-left corner</para>
      </value>
      <seealso cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelLayoutData.Y">
      <summary>
        <para>Gets the y-coordinate of the upper-left corner of the label's bounding box.</para>
      </summary>
      <value>
        <para>the y-coordinate of the upper-left corner</para>
      </value>
      <seealso cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.BoundingBox" />
    </member>
    <member name="P:yWorks.Layout.LabelLayoutData.PreferredPlacementDescriptor">
      <summary>
        <para>Gets or sets the preferred placement of this label.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified descriptor is <c>null</c></para>
      </exception>
      <value>
        <para>the desired placement</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.LabelLayoutData.ToString">
      <summary>
        <para>Returns a <see cref="T:System.String" /> representation of <see cref="T:yWorks.Layout.LabelLayoutData" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:System.String" /> contains the bounds of the label and the preferred placement</para>
      </remarks>
      <returns>
        <para>the <see cref="T:System.String" /> representation of <see cref="T:yWorks.Layout.LabelLayoutData" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.LabelLayoutKeys">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.LabelLayoutKeys" /> are used for associating <see cref="T:yWorks.Algorithms.IDataProvider" />s that contain label-specific information for edge and node labels.</para>
      </summary>
      <remarks>
        <para>Label-aware layout algorithms like <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> may look for such <see cref="T:yWorks.Algorithms.IDataProvider" />s that contain <see cref="T:yWorks.Layout.LabelLayoutData" /> for each edge.</para>
        <para>Instead of setting up <see cref="T:yWorks.Layout.LabelLayoutData" /> and <see cref="T:yWorks.Algorithms.IDataProvider" />s one can also use <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> to automatically translate information provided by the standard label layout classes <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> and <see cref="T:yWorks.Layout.INodeLabelLayout" /> to layout data accessible through the keys defined below.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.LabelLayoutKeys.EdgeLabelLayoutDpKey">
      <summary>
        <para>A data provider key for accessing label information of each edge in the input graph.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelLayoutKeys.NodeLabelLayoutDpKey">
      <summary>
        <para>A data provider key for accessing label information of each node in the input graph.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LabelLayoutKeys.IgnoredLabelsDpKey">
      <summary>
        <para>A data provider key for marking labels that should be ignored by the layout algorithm.</para>
      </summary>
      <remarks>
        <para>A label is ignored if there is a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key which returns <c>true</c> for the given <see cref="T:yWorks.Layout.ILabelLayout" />.</para>
        <para>The <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> only translates labels that should not be ignored.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Layout.LabelLayoutTranslator">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> automatically translates label layout information provided by the standard label layout classes <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> and <see cref="T:yWorks.Layout.INodeLabelLayout" /> to layout data of type <see cref="T:yWorks.Layout.LabelLayoutData" /> that is accessible by the keys defined in class <see cref="T:yWorks.Layout.LabelLayoutKeys" />.</para>
      </summary>
      <remarks>
        <para>One can use this <see cref="T:yWorks.Layout.ILayoutStage" /> as label layout algorithm of a label-aware layout algorithm like <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />. This can be done by assigning the stage by an appropriate call to <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">setLabelLayouter</see>.</para>
        <para>When writing the <see cref="T:yWorks.Layout.LabelLayoutData" />, the <see cref="P:yWorks.Layout.LabelLayoutData.Bounds">boxes</see> are set relative. In case of a node label, the box's <see cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.Anchor">anchor</see> is relative to the center of the owning node. In case of an edge label the box's anchor is relative to the center of the source node of the owning edge.</para>
        <para>If <see cref="P:yWorks.Layout.LabelLayoutTranslator.WriteBackNodeLabels">writing back node labels</see> and/or <see cref="P:yWorks.Layout.LabelLayoutTranslator.WriteBackEdgeLabels">writing back edge labels</see> is enabled, the <see cref="T:yWorks.Layout.LabelLayoutData" /> is transferred back to the <see cref="T:yWorks.Layout.INodeLabelLayout" />s and/or <see cref="T:yWorks.Layout.IEdgeLabelLayout" />s.</para>
        <para>By default, the <see cref="P:yWorks.Layout.LabelLayoutData.Bounds">boxes</see> are now interpreted absolute but by activating <see cref="P:yWorks.Layout.LabelLayoutTranslator.WriteBackRelativeNodeLabelLocation" /> and/or <see cref="P:yWorks.Layout.LabelLayoutTranslator.WriteBackRelativeEdgeLabelLocation" /> this can be changed to interpret them relative as explained above.</para>
        <para>Note that care must be taken on the choice of the label model that is used by the classes <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> and <see cref="T:yWorks.Layout.INodeLabelLayout" />. The calculated label positions must be consistent with the label positions allowed by the label model. The best label layout results are achieved by choosing <see cref="T:yWorks.Layout.FreeEdgeLabelLayoutModel" /> for edge layouts and <see cref="T:yWorks.Layout.FreeNodeLabelLayoutModel" /> for node layouts.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.LabelLayoutTranslator.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.CoreLayout">
      <summary>
        <para>Gets or sets the core layout algorithm that is wrapped by this <see cref="T:yWorks.Layout.ILayoutStage" />.</para>
      </summary>
      <value>
        <para>the core layout routine</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.LabelLayoutTranslator.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Translates traditional <see cref="T:yWorks.Layout.ILabelLayout" /> information to <see cref="T:yWorks.Algorithms.IDataProvider" />-based <see cref="T:yWorks.Layout.LabelLayoutData" />.</para>
      </summary>
      <remarks>
        <para>Afterwards, the calculated layout data will be written back to the original label layout.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.AutoFlippingEnabled">
      <summary>
        <para>Gets or sets whether or not this stage should automatically flip edge label content depending on the label's rotation angle.</para>
      </summary>
      <remarks>
        <para>More precisely, if this option is enabled and the up vector of the <see cref="T:yWorks.Algorithms.Geometry.YOrientedRectangle" /> associated with an <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> points downwards (<see cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.UpY">upY</see> &gt; 0), this <see cref="T:yWorks.Layout.ILayoutStage" /> automatically flips the label. It rotates the label by <c>180</c> degrees without changing the label's center.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this <see cref="T:yWorks.Layout.ILayoutStage" /> automatically flips edge label content depending on the label's rotation angle, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.AutoFlipBox(yWorks.Algorithms.Geometry.YOrientedRectangle)" />
      <seealso cref="P:yWorks.Layout.ILabelLayout.OrientedBox" />
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.ResettingNodeLabelOrientation">
      <summary>
        <para>Gets or sets whether or not to reset the orientation of node labels.</para>
      </summary>
      <remarks>
        <para>If this option is enabled, the up vector of the corresponding oriented box is set to <c>(0,-1)</c> before adding it to the <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the orientation of node labels is reset, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.ResettingEdgeLabelOrientation">
      <summary>
        <para>Gets or sets whether or not to reset the orientation of edge labels.</para>
      </summary>
      <remarks>
        <para>If this option is enabled, the up vector of the corresponding oriented box is set to <c>(0,-1)</c> before adding it to the <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the orientation of edge labels is reset, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.WriteBackEdgeLabels">
      <summary>
        <para>Gets or sets whether or not edge label information is written back to the model after core layout.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge label information is written back, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.WriteBackRelativeEdgeLabelLocation">
      <summary>
        <para>Gets or sets whether or not edge label <see cref="P:yWorks.Layout.LabelLayoutData.Bounds">boxes</see> are interpreted relative to the edge when writing them back to the model.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the bounds are interpreted relative, <c>false</c> for absolute interpretation</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.WriteBackNodeLabels">
      <summary>
        <para>Gets or sets whether or not node label information is written back to the model after the core layout.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node label information is written back, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.WriteBackRelativeNodeLabelLocation">
      <summary>
        <para>Gets or sets whether or not node label <see cref="P:yWorks.Layout.LabelLayoutData.Bounds">bounds</see> are interpreted relative to the node when writing them back to the model.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the bounds are interpreted relative, <c>false</c> for absolute interpretation</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.TranslateNodeLabels">
      <summary>
        <para>Gets or sets whether or not node label information is translated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node label information is translated, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.LabelLayoutTranslator.TranslateEdgeLabels">
      <summary>
        <para>Gets or sets whether or not edge label information is translated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge label information is translated, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Labeling.OptimizationStrategy">
      <seealso cref="P:yWorks.Layout.Labeling.MISLabelingBase.OptimizationStrategy" />
    </member>
    <member name="F:yWorks.Layout.Labeling.OptimizationStrategy.Balanced">
      <summary>
        <para>An optimization strategy aiming at a good balance between the available optimization options.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Labeling.MISLabelingBase.OptimizationStrategy" />
    </member>
    <member name="F:yWorks.Layout.Labeling.OptimizationStrategy.NodeOverlap">
      <summary>
        <para>An optimization strategy that especially reduces overlaps between labels and nodes as well as labels and node halos.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Labeling.MISLabelingBase.OptimizationStrategy" />
    </member>
    <member name="F:yWorks.Layout.Labeling.OptimizationStrategy.LabelOverlap">
      <summary>
        <para>An optimization strategy that especially reduces overlaps between labels.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Labeling.MISLabelingBase.OptimizationStrategy" />
    </member>
    <member name="F:yWorks.Layout.Labeling.OptimizationStrategy.EdgeOverlap">
      <summary>
        <para>An optimization strategy that especially reduces overlaps between labels and edges.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Labeling.MISLabelingBase.OptimizationStrategy" />
    </member>
    <member name="F:yWorks.Layout.Labeling.OptimizationStrategy.PreferredPlacement">
      <summary>
        <para>An optimization strategy that mainly tries to satisfy the preferences described by a <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> associated with edge labels.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Labeling.MISLabelingBase.OptimizationStrategy" />
    </member>
    <member name="F:yWorks.Layout.Labeling.OptimizationStrategy.None">
      <summary>
        <para>Use no optimization strategy.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Labeling.GenericLabeling">
      <summary>
        <para>A generic labeling algorithm for placing the labels of a graph.</para>
      </summary>
      <remarks>
        <para> Node labels and edge labels placed by the labeling algorithm</para>
        <para>This algorithm can switch between two internal implementations. By default, it generates high quality label placements even for difficult instances. This especially holds if the label models allow a large number of different <see cref="T:yWorks.Layout.LabelCandidate" />s, i.e., there is a high potential for optimizations.</para>
        <para>If the duration of the calculation is of utmost importance, the internal algorithm can be changed to a simpler implementation by setting <see cref="P:yWorks.Layout.Labeling.GenericLabeling.MaximumDuration" /> to <c>0</c>. On the downside, the results will not be as good as the ones of the default mode.</para>
        <para>In default mode, this algorithm reduces the labeling problem to the maximum independent set (MIS) problem and solves the problem using simulated annealing. It is inspired by the article from Christensen, Marks and Shieber: <i>A General
 Cartographic Labelling Algorithm</i>.</para>
        <para>It is recommended to use <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" />s and <see cref="T:yWorks.Layout.INodeLabelLayoutModel" />s which allow free positioning of labels to achieve best results with this generic labeling algorithm.</para>
        <para>This algorithm works according to the general labeling concept defined by <see cref="T:yWorks.Layout.Labeling.LabelingBase" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Labeling.LabelingBase" />
    </member>
    <member name="M:yWorks.Layout.Labeling.GenericLabeling.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Labeling.GenericLabeling" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Labeling.GenericLabeling.Deterministic">
      <summary>
        <para>Gets or sets whether or not this algorithm behaves deterministically.</para>
      </summary>
      <remarks>
        <para>If enabled, it produces the same results given the same input graph and settings.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this algorithm works deterministically, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.GenericLabeling.MaximumDuration">
      <summary>
        <para>Gets or sets the time limit for this algorithm in milliseconds.</para>
      </summary>
      <remarks>
        <para>
          <see cref="F:System.Int32.MaxValue" /> denotes that there is no time limit. Values have to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given maximum duration is negative</para>
      </exception>
      <value>
        <para>a non-negative value representing the time limit in milliseconds</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Labeling.LabelingBase">
      <summary>
        <para>An abstract base class for generic labeling algorithms which place labels of graphs.</para>
      </summary>
      <remarks>
        <para>Labeling algorithms compute positions for labels in a given graph. The main goal is to place labels such that they do not overlap with other graph elements. Labeling algorithms do not modify positions of nodes and edges.</para>
        <para>
          <h2>Concept</h2>
        </para>
        <para>Generic labeling algorithms use the model associated with a label (i.e. <see cref="P:yWorks.Layout.INodeLabelLayout.LabelModel">node label model</see> for nodes and <see cref="P:yWorks.Layout.IEdgeLabelLayout.LabelModel">edge label model</see> for edges). The models are necessary to compute a set of <see cref="T:yWorks.Layout.LabelCandidate" />s, i.e., candidate positions for a label. Then, one <i>best matching</i> candidate from the set will be selected. This selection depends on several preferences, e.g., if <see cref="P:yWorks.Layout.Labeling.LabelingBase.RemoveNodeOverlaps">overlaps with nodes</see> are not allowed, candidates encoding overlapping positions will be ignored.</para>
        <para>After one <see cref="T:yWorks.Layout.LabelCandidate" /> has been chosen, the label model's parameter is used for encoding the label position. Therefore, the result of a generic labeling algorithm is one model parameter per label. The parameter is <see cref="P:yWorks.Layout.ILabelLayout.ModelParameter">stored with the label</see> and expresses the label position with respect to the underlying label model.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>This class provides a general frame, offering functionality which can be shared by other generic labeling algorithms.</para>
        <para>To only place labels or a subset of labels, the main labeling methods <see cref="M:yWorks.Layout.Labeling.LabelingBase.Label(yWorks.Layout.LayoutGraph,System.Object)" />, <see cref="M:yWorks.Layout.Labeling.LabelingBase.Label(yWorks.Layout.LayoutGraph,System.Object)" /> and <see cref="M:yWorks.Layout.Labeling.LabelingBase.Label(yWorks.Layout.LayoutGraph,yWorks.Algorithms.YList,yWorks.Algorithms.YList)" /> are offered.</para>
        <para>As this class represents an <see cref="T:yWorks.Layout.LayoutStageBase" />, it allows usage as a generic labeling stage. By combining it with a <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layouter</see>, the labeling will take place after the core layouter was executed (<see cref="M:yWorks.Layout.Labeling.LabelingBase.ApplyLayout(yWorks.Layout.LayoutGraph)" />). This is especially useful if the core layouter does not support label handling.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Labeling.LabelingBase.LabelModelDpKey">
      <summary>
        <para>A data provider key for mapping models to edge/node labels.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.INodeLabelLayoutModel" />s and <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" />s linked to <see cref="T:yWorks.Layout.INodeLabelLayout" />s and <see cref="T:yWorks.Layout.IEdgeLabelLayout" />s by this <see cref="T:yWorks.Algorithms.IDataProvider" /> are taken as replacement models. This means that the original model is internally replaced by another model when computing valid positions for the label. A model parameter that fits the calculated position of the replacement model best is set for the original label model.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Labeling.LabelingBase.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Labeling.LabelingBase" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.ProfitModel">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.IProfitModel" /> for ranking the <see cref="T:yWorks.Layout.LabelCandidate" />s for labels.</para>
      </summary>
      <remarks>
        <para>The profit model is used when <see cref="M:yWorks.Layout.Labeling.LabelingBase.GetProfit(yWorks.Layout.LabelCandidate)">calculating the profit</see> of a candidate.</para>
        <para>The higher the profit (rank) of a candidate is, the more likely it will be chosen as actual position by the algorithm.</para>
      </remarks>
      <value>
        <para>a <see cref="T:yWorks.Layout.IProfitModel" /> instance for ranking label candidates</para>
      </value>
      <seealso cref="T:yWorks.Layout.IProfitModel" />
      <seealso cref="T:yWorks.Layout.SimpleProfitModel" />
      <seealso cref="M:yWorks.Layout.Labeling.LabelingBase.GetProfit(yWorks.Layout.LabelCandidate)" />
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.MoveInternalNodeLabels">
      <summary>
        <para>Gets or sets whether or not <em>internal</em> node labels are allowed to move.</para>
      </summary>
      <remarks>
        <para>A node label is <em>internal</em> if the label's boundaries are completely within the node's boundaries.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if internal node labels may be moved, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.ReduceLabelOverlaps">
      <summary>
        <para>Gets or sets whether or not a post-processing step to reduce the number of label overlaps is applied.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if a post-processing step for reducing the number of label overlaps is applied, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.RemoveNodeOverlaps">
      <summary>
        <para>Gets or sets whether or not <see cref="T:yWorks.Layout.LabelCandidate">label candidates</see> that overlap with nodes are removed.</para>
      </summary>
      <remarks>
        <para>If overlapping candidates are not removed, they will be considered but get a penalty. Therefore, it is still less likely that an overlapping candidate is finally chosen.</para>
        <para>The detection and removal of labels that overlap with nodes may increase the runtime of this algorithm.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if candidates overlapping with nodes are removed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.RemoveEdgeOverlaps">
      <summary>
        <para>Gets or sets whether or not <see cref="T:yWorks.Layout.LabelCandidate">label candidates</see> that overlap with edges are removed.</para>
      </summary>
      <remarks>
        <para>If overlapping candidates are not removed, they will be considered but get a penalty. Therefore, it is still less likely that an overlapping candidate is finally chosen.</para>
        <para>The detection and removal of labels that overlap with edges may increase the runtime of this algorithm.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if candidates overlapping with edges are removed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.PlaceNodeLabels">
      <summary>
        <para>Gets or sets whether or not labels assigned to nodes are placed.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node labels should be placed, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Labeling.LabelingBase.AffectedLabelsDpKey" />
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.PlaceEdgeLabels">
      <summary>
        <para>Gets or sets whether or not labels assigned to edges are placed.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels should be placed, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Labeling.LabelingBase.AffectedLabelsDpKey" />
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.AffectedLabelsDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key to mark labels as selected for placement.</para>
      </summary>
      <remarks>
        <para>If a <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with this key, only the selected labels will be placed, while all other labels are considered fixed.</para>
        <para>The registered <see cref="T:yWorks.Algorithms.IDataProvider" /> needs to map from <see cref="T:yWorks.Layout.ILabelLayout" /> to <see cref="T:System.Boolean" /> where <c>true</c> indicates that a label should be placed and <c>false</c> indicates that a label should be ignored.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for marking labels as selected or <c>null</c> if all labels should be considered selected</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.AutoFlipping">
      <summary>
        <para>Gets or sets whether or not edge labels are automatically flipped if otherwise they would be upside-down.</para>
      </summary>
      <value>
        <para>
          <c>true</c>, if edge labels automatically flip, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Labeling.LabelingBase.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Places the labels in the graph after first executing the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layouter</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.Labeling.LabelingBase.Label(yWorks.Layout.LayoutGraph,System.Object)" />
    </member>
    <member name="M:yWorks.Layout.Labeling.LabelingBase.Label(yWorks.Layout.LayoutGraph,System.Object)">
      <summary>
        <para>Places the labels of the input graph using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered to the input graph with the given key for determining which labels to place.</para>
      </summary>
      <remarks>
        <para>Instead of considering the current <see cref="P:yWorks.Layout.Labeling.LabelingBase.AffectedLabelsDpKey">selection key</see>, the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the given key will be used for selecting labels. Invoking this method has the same effect as first <see cref="P:yWorks.Layout.Labeling.LabelingBase.AffectedLabelsDpKey">specifying the key</see> as selection key and then invoking <see cref="M:yWorks.Layout.Labeling.LabelingBase.Label(yWorks.Layout.LayoutGraph,System.Object)" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="key">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for label selection</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Labeling.LabelingBase.Label(yWorks.Layout.LayoutGraph,yWorks.Algorithms.YList,yWorks.Algorithms.YList)">
      <summary>
        <para>Places the labels of the input graph restricting the placement to labels contained in the given lists.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Layout.Labeling.LabelingBase.AffectedLabelsDpKey">selection</see> will not be considered; the given lists will define the selection of labels that are to be placed.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="nodeLabels">
        <para>a list of <see cref="T:yWorks.Layout.INodeLabelLayout" />s defining the set of node labels that will be placed</para>
      </param>
      <param name="edgeLabels">
        <para>a list of <see cref="T:yWorks.Layout.IEdgeLabelLayout" />s defining the set of edge labels that will be placed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Labeling.LabelingBase.GetProfit(yWorks.Layout.LabelCandidate)">
      <summary>
        <para>Returns the profit for placing a <see cref="T:yWorks.Layout.LabelCandidate" /> with respect to the current <see cref="P:yWorks.Layout.Labeling.LabelingBase.ProfitModel">profit model</see>.</para>
      </summary>
      <remarks>
        <para>Method <see cref="M:yWorks.Layout.IProfitModel.GetProfit(yWorks.Layout.LabelCandidate)" /> on the current profit model will be invoked to compute the actual profit value.</para>
        <para>The higher the profit (rank) of a candidate is, the more likely it will be chosen as actual position by the algorithm.</para>
      </remarks>
      <param name="candidate">
        <para>a label candidate</para>
      </param>
      <returns>
        <para>the profit value between <c>0</c> and <c>1</c></para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Labeling.LabelingBase.EdgeGroupOverlapAllowed">
      <summary>
        <para>Gets or sets whether or not edge labels may overlap with edges belonging to the same edge group as the label's edge.</para>
      </summary>
      <remarks>
        <para>An edge group is a set of edges which share a common bus near the target or source node. They are defined using <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with <see cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" /> and <see cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if edge labels may overlap with edges of the same edge group, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="T:yWorks.Layout.Labeling.MISLabelingBase">
      <summary>
        <para>A base class for generic labeling algorithms which solve the labeling problem by reducing it to the maximum independent set (MIS) problem.</para>
      </summary>
      <remarks>
        <para>Different optimization strategies are available; an optimization strategy defines which criteria the algorithm should try to optimize. For example, reducing the number of overlaps between labels and nodes may be considered more important than reducing the number of overlaps between labels and edges.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Labeling.GenericLabeling" />
    </member>
    <member name="F:yWorks.Layout.Labeling.MISLabelingBase.graph">
      <summary>
        <para>The input graph that will be labeled.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph">
      <summary>
        <para>The conflict graph modeling <see cref="T:yWorks.Layout.LabelCandidate" />s as nodes and edges between them as conflicts, i.e., overlaps among candidates.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges" />
    </member>
    <member name="F:yWorks.Layout.Labeling.MISLabelingBase.nodesToBoxes">
      <summary>
        <para>The mapping from each node in the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" /> to the corresponding <see cref="T:yWorks.Layout.LabelCandidate" /> instance.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" />
    </member>
    <member name="F:yWorks.Layout.Labeling.MISLabelingBase.boxesToNodes">
      <summary>
        <para>The mapping from the <see cref="T:yWorks.Layout.LabelCandidate" />s to the corresponding nodes in the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" />.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" />
    </member>
    <member name="F:yWorks.Layout.Labeling.MISLabelingBase.nodesToID">
      <summary>
        <para>The mapping from nodes in the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" /> to a corresponding integer value (ID).</para>
      </summary>
      <remarks>
        <para>The ID denotes the actual label which a <see cref="T:yWorks.Layout.LabelCandidate" /> (i.e. a node in the conflict graph) belongs to.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Labeling.MISLabelingBase.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Labeling.MISLabelingBase" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Labeling.MISLabelingBase.CustomProfitModelRatio">
      <summary>
        <para>Gets or sets the ratio between the internal profit (ip) and the profit computed using the specified <see cref="P:yWorks.Layout.Labeling.LabelingBase.ProfitModel">profit model</see> (sp).</para>
      </summary>
      <remarks>
        <para>This ratio defines how to weight the two profit values (ip) and (sp). The overall ratio is then computed as <c>ratio * sp + (1 - ratio) * ip</c>. The profit of a <see cref="T:yWorks.Layout.LabelCandidate" /> defines how likely it is that the candidate will be chosen as actual label position.</para>
        <para>The ratio is defined to be a value from the interval <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given ratio is negative or larger than <c>1</c></para>
      </exception>
      <value>
        <para>the ratio (from the interval <c>[0,1]</c>) between the internal profit and the profit calculated using the current profit model</para>
      </value>
      <seealso cref="P:yWorks.Layout.Labeling.LabelingBase.ProfitModel" />
      <seealso cref="P:yWorks.Layout.Labeling.MISLabelingBase.OptimizationStrategy" />
    </member>
    <member name="P:yWorks.Layout.Labeling.MISLabelingBase.OptimizationStrategy">
      <summary>
        <para>Gets or sets the optimization strategy which defines the importance of criteria when optimizing labeling results.</para>
      </summary>
      <remarks>
        <para>Depending on the strategy, criteria like label-node overlaps, label-label overlaps and others are more or less important. For example, if the number of overlaps between labels and nodes is the most important criterion for the result, strategy <see cref="F:yWorks.Layout.Labeling.OptimizationStrategy.NodeOverlap" /> should be chosen.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given strategy is unknown</para>
      </exception>
      <value>
        <para>one of the predefined optimization strategies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.MISLabelingBase.RemoveNodeOverlaps">
      <summary>
        <para>Gets or sets whether or not <see cref="T:yWorks.Layout.LabelCandidate">label candidates</see> that overlap with nodes are removed.</para>
      </summary>
      <remarks>
        <para>If overlapping candidates are not removed, they will be considered but get a penalty. Therefore, it is still less likely that an overlapping candidate is finally chosen.</para>
        <para>The detection and removal of labels that overlap with nodes may increase the runtime of this algorithm.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if candidates overlapping with nodes are removed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.MISLabelingBase.RemoveEdgeOverlaps">
      <summary>
        <para>Gets or sets whether or not <see cref="T:yWorks.Layout.LabelCandidate">label candidates</see> that overlap with edges are removed.</para>
      </summary>
      <remarks>
        <para>If overlapping candidates are not removed, they will be considered but get a penalty. Therefore, it is still less likely that an overlapping candidate is finally chosen.</para>
        <para>The detection and removal of labels that overlap with edges may increase the runtime of this algorithm.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if candidates overlapping with edges are removed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Labeling.MISLabelingBase.ReduceAmbiguity">
      <summary>
        <para>Gets or sets whether or not the number of ambiguous label placements is reduced by applying an additional optimization step.</para>
      </summary>
      <remarks>
        <para>A label position is considered to be ambiguous if it might not be possible to identify to which graph element the label belongs. For example, an edge label placed in between two edges is ambiguous.</para>
        <para>Enabling this reduction step does not guarantee that no ambiguous placements are selected. The algorithm will try to avoid them if other good positions without ambiguity are available. Other aspects like <see cref="T:yWorks.Layout.PreferredPlacementDescriptor">preferred placement</see> for edge labels will still be more important than the reduction of ambiguity.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the algorithm tries to avoid ambiguous label placements, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges">
      <summary>
        <para>Creates the edges in the conflict graph, i.e., one edge between two nodes if the corresponding <see cref="T:yWorks.Layout.LabelCandidate" />s intersect.</para>
      </summary>
      <remarks>
        <para>The nodes of the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph">conflict graph</see> represent <see cref="T:yWorks.Layout.LabelCandidate" />s. An edge between candidates signals that they overlap. A maximum independent set will be computed on the conflict graph to choose candidates such that no two candidates overlap.</para>
        <para>This method may be overridden to change the structure of the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph">conflict graph</see>. Edges between two <see cref="T:yWorks.Layout.LabelCandidate" />s in the conflict graph signal that the two candidates should not be selected together. By overriding this method, arbitrary reasons for indicating that two label candidates should not be chosen at the same time can be modeled.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" />
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.nodesToBoxes" />
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.boxesToNodes" />
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.nodesToID" />
    </member>
    <member name="M:yWorks.Layout.Labeling.MISLabelingBase.AssignProfit">
      <summary>
        <para>Returns a <see cref="T:yWorks.Algorithms.INodeMap" /> which assigns a profit value to each node in the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph">conflict graph</see>.</para>
      </summary>
      <remarks>
        <para>As the conflict graph's nodes represent <see cref="T:yWorks.Layout.LabelCandidate" />s, this mapping gives the profit value of label candidates. The assigned value is defined as the difference between the <see cref="M:yWorks.Layout.Labeling.LabelingBase.GetProfit(yWorks.Layout.LabelCandidate)">profit induced by the profit model</see> and the candidate's <see cref="P:yWorks.Layout.LabelCandidate.OverlapPenalty">overlap penalty</see>.</para>
        <para>The returned map is a mapping from each <see cref="T:yWorks.Algorithms.Node" /> (representing a label candidate) in the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" /> to a <see cref="T:System.Double" /> representing the profit value of the candidate.</para>
      </remarks>
      <returns>
        <para>a mapping from nodes (i.e. label candidates) to their profit value</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Labeling.MISLabelingBase.FoundLabelOverlap(yWorks.Layout.LabelCandidate,yWorks.Layout.LabelCandidate,yWorks.Algorithms.Edge)">
      <summary>
        <para>Indicates that an overlap between two <see cref="T:yWorks.Layout.LabelCandidate" />s has been found.</para>
      </summary>
      <remarks>
        <para>This method is called when finding overlaps while <see cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges">creating edges</see> of the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph">conflict graph</see>. It will store a factor indicating how much the two candidates overlap. The factor influences the penalty assigned when both candidates are chosen, i.e., the penalty for the corresponding overlap.</para>
        <para>This method may be overridden to realize a custom strategy for reacting to overlaps among <see cref="T:yWorks.Layout.LabelCandidate" />s.</para>
      </remarks>
      <param name="candidate1">
        <para>the first overlapping <see cref="T:yWorks.Layout.LabelCandidate" /></para>
      </param>
      <param name="candidate2">
        <para>the second overlapping <see cref="T:yWorks.Layout.LabelCandidate" /></para>
      </param>
      <param name="edge">
        <para>the <see cref="T:yWorks.Algorithms.Edge" /> in <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" /> representing the found overlap</para>
      </param>
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" />
      <seealso cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges" />
    </member>
    <member name="M:yWorks.Layout.Labeling.MISLabelingBase.FoundNodeOverlap(yWorks.Layout.LabelCandidate,yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Indicates that an overlap between a <see cref="T:yWorks.Layout.LabelCandidate" /> and a <see cref="T:yWorks.Algorithms.Node" /> of the input graph has been found.</para>
      </summary>
      <remarks>
        <para>This method is called when finding overlaps while <see cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges">creating edges</see> of the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph">conflict graph</see>. It will store a factor indicating how much the two elements overlap. The factor influences the <see cref="M:yWorks.Layout.Labeling.LabelingBase.GetProfit(yWorks.Layout.LabelCandidate)">profit</see> assigned to the given label candidate.</para>
        <para>This method may be overridden to realize a custom strategy for reacting to overlaps between label candidates and nodes.</para>
      </remarks>
      <param name="labelCandidate">
        <para>the <see cref="T:yWorks.Layout.LabelCandidate" /> overlapping with the given node</para>
      </param>
      <param name="node">
        <para>the <see cref="T:yWorks.Algorithms.Node" /> overlapping with the given label candidate</para>
      </param>
      <param name="nodeBox">
        <para>the bounding box of the given node</para>
      </param>
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" />
      <seealso cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges" />
    </member>
    <member name="M:yWorks.Layout.Labeling.MISLabelingBase.FoundEdgeOverlap(yWorks.Layout.LabelCandidate,yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.LineSegment)">
      <summary>
        <para>Indicates that an overlap between a <see cref="T:yWorks.Layout.LabelCandidate" /> and an <see cref="T:yWorks.Algorithms.Edge" /> of the input graph has been found.</para>
      </summary>
      <remarks>
        <para>This method is called when finding overlaps while <see cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges">creating edges</see> of the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph">conflict graph</see>. It will store a factor indicating how much the two elements overlap. The factor influences the <see cref="M:yWorks.Layout.Labeling.LabelingBase.GetProfit(yWorks.Layout.LabelCandidate)">profit</see> assigned to the given label candidate.</para>
        <para>This method may be overridden to realize a custom strategy for reacting to overlaps between label candidates and edges.</para>
      </remarks>
      <param name="labelCandidate">
        <para>the <see cref="T:yWorks.Layout.LabelCandidate" /> overlapping with the given <see cref="T:yWorks.Algorithms.Edge" /></para>
      </param>
      <param name="edge">
        <para>the <see cref="T:yWorks.Algorithms.Edge" /> overlapping with the given <see cref="T:yWorks.Layout.LabelCandidate" /></para>
      </param>
      <param name="eSegment">
        <para>the <see cref="T:yWorks.Algorithms.Geometry.LineSegment" /> of the given edge overlapping with the given candidate</para>
      </param>
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" />
      <seealso cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges" />
    </member>
    <member name="M:yWorks.Layout.Labeling.MISLabelingBase.FoundHaloOverlap(yWorks.Layout.LabelCandidate,yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Indicates that an overlap between a <see cref="T:yWorks.Layout.LabelCandidate" /> and a <see cref="T:yWorks.Layout.NodeHalo" /> of the input graph has been found.</para>
      </summary>
      <remarks>
        <para>This method is called when finding overlaps while <see cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges">creating edges</see> of the <see cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph">conflict graph</see>. It will store a factor indicating how much the two elements overlap. The factor influences the <see cref="M:yWorks.Layout.Labeling.LabelingBase.GetProfit(yWorks.Layout.LabelCandidate)">profit</see> assigned to the given label candidate.</para>
        <para>This method may be overridden to realize a custom strategy for reacting to overlaps between label candidates and node halos.</para>
      </remarks>
      <param name="labelCandidate">
        <para>the <see cref="T:yWorks.Layout.LabelCandidate" /> overlapping with a node halo</para>
      </param>
      <param name="node">
        <para>the <see cref="T:yWorks.Algorithms.Node" /> whose <see cref="T:yWorks.Layout.NodeHalo" /> is overlapping with the given label candidate</para>
      </param>
      <param name="haloRect">
        <para>the bounding box of the <see cref="T:yWorks.Layout.NodeHalo" /> overlapping with the given label candidate</para>
      </param>
      <seealso cref="F:yWorks.Layout.Labeling.MISLabelingBase.conflictGraph" />
      <seealso cref="M:yWorks.Layout.Labeling.MISLabelingBase.CreateEdges" />
    </member>
    <member name="T:yWorks.Layout.LayoutGraph">
      <summary>
        <para>A <see cref="T:yWorks.Layout.LayoutGraph" /> is a <see cref="T:yWorks.Algorithms.Graph" /> with attached layout information that basically represents a drawing of a graph.</para>
      </summary>
      <remarks>
        <para>It provides access to the layout information for nodes, edges and labels. This layout information consists of coordinates for the elements.</para>
        <para>
          <see cref="T:yWorks.Layout.ILayoutAlgorithm">Layout algorithms</see> work on <see cref="T:yWorks.Layout.LayoutGraph" />s and arrange their nodes and edges.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.#ctor">
      <summary>
        <para>Creates a new, empty <see cref="T:yWorks.Layout.LayoutGraph" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.#ctor(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.LayoutGraph" /> which is a copy of the given subgraph.</para>
      </summary>
      <param name="subgraph">
        <para>the original subgraph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.#ctor(yWorks.Layout.LayoutGraph,yWorks.Algorithms.ICursor)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.LayoutGraph" /> which is a copy of the given subgraph.</para>
      </summary>
      <param name="graph">
        <para>the original graph</para>
      </param>
      <param name="nodeSubset">
        <para>the nodes that induce the subgraph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.CreateLabelFactory">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ILabelLayoutFactory" /> for this <see cref="T:yWorks.Layout.LayoutGraph" /> that can be used for copying layout information of labels.</para>
      </summary>
      <returns>
        <para>the new <see cref="T:yWorks.Layout.ILabelLayoutFactory" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetLayout(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the layout information for the given node.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the location and size of the node.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the layout information for the node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetLayout(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the layout information for the given edge.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the locations of the control points and end points of the edge.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the layout information for the edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetLabelLayout(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the layout information for all labels associated with the given node.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the location, size and orientation of the label.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the layout information for the node's labels</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetLabelLayout(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the layout information for all labels associated with the given edge.</para>
      </summary>
      <remarks>
        <para>The layout information consists of the location, size and orientation of the label.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the layout information for the edge's labels</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetOwner(yWorks.Layout.INodeLabelLayout)">
      <summary>
        <para>Returns the node to which the given <see cref="T:yWorks.Layout.INodeLabelLayout" /> belongs.</para>
      </summary>
      <param name="labelLayout">
        <para>the label's layout information</para>
      </param>
      <returns>
        <para>the node that owns the label</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetOwner(yWorks.Layout.IEdgeLabelLayout)">
      <summary>
        <para>Returns the edge to which the given <see cref="T:yWorks.Layout.IEdgeLabelLayout" /> belongs.</para>
      </summary>
      <param name="labelLayout">
        <para>the label's layout information</para>
      </param>
      <returns>
        <para>the edge that owns the label</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetCenterX(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the x-coordinate of the given node's center.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the x-value of the node's center coordinate</para>
      </returns>
      <seealso cref="T:yWorks.Layout.INodeLayout" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetCenterY(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the y-coordinate of the given node's center.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the y-value of the node's center coordinate</para>
      </returns>
      <seealso cref="T:yWorks.Layout.INodeLayout" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetCenter(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the center coordinates of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the location of the node's center</para>
      </returns>
      <seealso cref="T:yWorks.Layout.INodeLayout" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetX(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the x-coordinate of the given node's upper-left corner.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the x-value of the node's upper-left corner</para>
      </returns>
      <seealso cref="P:yWorks.Layout.INodeLayout.X" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetY(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the y-coordinate of the given node's upper-left corner.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the y-value of the node's upper-left corner</para>
      </returns>
      <seealso cref="P:yWorks.Layout.INodeLayout.Y" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetLocation(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the coordinates of the given node's upper-left corner.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the location of the node's upper-left corner</para>
      </returns>
      <seealso cref="P:yWorks.Layout.INodeLayout.X" />
      <seealso cref="P:yWorks.Layout.INodeLayout.Y" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetWidth(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the width of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the width of the node</para>
      </returns>
      <seealso cref="P:yWorks.Layout.INodeLayout.Width" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetHeight(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the height of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the height of the node</para>
      </returns>
      <seealso cref="P:yWorks.Layout.INodeLayout.Height" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetSize(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the size of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the size of the node</para>
      </returns>
      <seealso cref="P:yWorks.Layout.INodeLayout.Width" />
      <seealso cref="P:yWorks.Layout.INodeLayout.Height" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetBoundingBox(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the rectangle describing the bounding box of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the bounds of the node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetLocation(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetSize(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetCenter(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Specifies the center coordinates of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="position">
        <para>the new location of the node's center</para>
      </param>
      <seealso cref="T:yWorks.Layout.INodeLayout" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)">
      <summary>
        <para>Specifies the center coordinates of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="x">
        <para>the new x-coordinate of the node's center</para>
      </param>
      <param name="y">
        <para>the new y-coordinate of the node's center</para>
      </param>
      <seealso cref="T:yWorks.Layout.INodeLayout" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetSize(yWorks.Algorithms.Node,System.Double,System.Double)">
      <summary>
        <para>Specifies the width and height of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="width">
        <para>the new width of the node</para>
      </param>
      <param name="height">
        <para>the new height of the node</para>
      </param>
      <seealso cref="M:yWorks.Layout.INodeLayout.SetSize(System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetSize(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YDimension)">
      <summary>
        <para>Specifies the size of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="size">
        <para>the new size of the node</para>
      </param>
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetSize(yWorks.Algorithms.Node,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.INodeLayout.SetSize(System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetLocation(yWorks.Algorithms.Node,System.Double,System.Double)">
      <summary>
        <para>Specifies the coordinates of the upper-left corner of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="x">
        <para>the new x-coordinate of the upper-left corner</para>
      </param>
      <param name="y">
        <para>the new y-coordinate of the upper-left corner</para>
      </param>
      <seealso cref="M:yWorks.Layout.INodeLayout.SetLocation(System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetLocation(yWorks.Algorithms.Node,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Specifies the coordinates of the upper-left corner of the given node.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="position">
        <para>the new location of the upper-left corner</para>
      </param>
      <seealso cref="M:yWorks.Layout.INodeLayout.SetLocation(System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetLocation(yWorks.Algorithms.Node,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.MoveBy(yWorks.Algorithms.Node,System.Double,System.Double)">
      <summary>
        <para>Moves the upper-left corner of a node by a given vector.</para>
      </summary>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="dx">
        <para>the x-component of the vector</para>
      </param>
      <param name="dy">
        <para>the y-component of the vector</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetPoints(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the control points of an edge.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.YPointPath" /> representing the sequence of control points of the edge</para>
      </returns>
      <seealso cref="T:yWorks.Layout.IEdgeLayout" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetPointList(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the control points of an edge.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" />s representing the sequence of control points of the edge</para>
      </returns>
      <seealso cref="T:yWorks.Layout.IEdgeLayout" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetPath(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the path of an edge, including the ports.</para>
      </summary>
      <remarks>
        <para>The path of an edge is the position of the source port, followed by the positions of the bends, followed by the position of the target port.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the path of the given edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetPathList(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the path of an edge, including the ports.</para>
      </summary>
      <remarks>
        <para>The path of an edge is the position of the source port, followed by the positions of the bends, followed by the position of the target port.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" />s representing the path of the given edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetPath(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPointPath)">
      <summary>
        <para>Sets the path of the given edge.</para>
      </summary>
      <remarks>
        <para>The path of an edge is the position of the source port, followed by the positions of the bends, followed by the position of the target port.</para>
        <para>Both source and target port are expected to be given in absolute coordinates.</para>
      </remarks>
      <param name="edge">
        <para>an edge in the graph</para>
      </param>
      <param name="path">
        <para>the new path sequence of the edge</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetPath(yWorks.Algorithms.Edge,yWorks.Algorithms.YList)">
      <summary>
        <para>Sets the path of the given edge.</para>
      </summary>
      <remarks>
        <para>The path of an edge is the position of the source port, followed by the positions of the bends, followed by the position of the target port.</para>
        <para>Both source and target port are expected to be given in absolute coordinates.</para>
      </remarks>
      <param name="edge">
        <para>an edge in the graph</para>
      </param>
      <param name="path">
        <para>the list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" />s representing the new path sequence of the edge</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetPoints(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPointPath)">
      <summary>
        <para>Sets the control points of the given edge.</para>
      </summary>
      <remarks>
        <para>The source and target points of the edge will not be modified.</para>
      </remarks>
      <param name="edge">
        <para>an edge in the graph</para>
      </param>
      <param name="points">
        <para>the new sequence of control points</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetPoints(yWorks.Algorithms.Edge,yWorks.Algorithms.YList)">
      <summary>
        <para>Sets the control points of the given edge.</para>
      </summary>
      <remarks>
        <para>The source and target points of the edge will not be modified.</para>
      </remarks>
      <param name="edge">
        <para>an edge in the graph</para>
      </param>
      <param name="points">
        <para>the list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" />s representing the new sequence of control points</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetEndPointsAbs(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Specifies the two end points of the given edge in absolute coordinates.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="source">
        <para>the port on the source side of the edge</para>
      </param>
      <param name="target">
        <para>the port on the target side of the edge</para>
      </param>
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetSourcePointAbs(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetTargetPointAbs(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetSourcePointRel(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the relative coordinates of the source point of the given edge.</para>
      </summary>
      <remarks>
        <para>The coordinates are interpreted relative to the center of the source node.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the relative source point coordinates of the edge</para>
      </returns>
      <seealso cref="P:yWorks.Layout.IEdgeLayout.SourcePoint" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetTargetPointRel(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the relative coordinates of the target point of the given edge.</para>
      </summary>
      <remarks>
        <para>The coordinates are interpreted relative to the center of the target node.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the relative target point coordinates of the edge</para>
      </returns>
      <seealso cref="P:yWorks.Layout.IEdgeLayout.TargetPoint" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetSourcePointRel(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Specifies the relative coordinates of the source point of the given edge.</para>
      </summary>
      <remarks>
        <para>The coordinates are interpreted relative to the center of the source node.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="point">
        <para>the new relative source point coordinates of the edge</para>
      </param>
      <seealso cref="P:yWorks.Layout.IEdgeLayout.SourcePoint" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetTargetPointRel(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Specifies the relative coordinates of the target point of the given edge.</para>
      </summary>
      <remarks>
        <para>The coordinates are interpreted relative to the center of the target node.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="point">
        <para>the new relative target point coordinates of the edge</para>
      </param>
      <seealso cref="P:yWorks.Layout.IEdgeLayout.TargetPoint" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetSourcePointAbs(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the absolute coordinates of the source point of the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the absolute source point coordinates of the edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.GetTargetPointAbs(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the absolute coordinates of the target point of the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the absolute target point coordinates of the edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetSourcePointAbs(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Specifies the absolute coordinates of the source point of the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="point">
        <para>the new absolute source point coordinates of the edge</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraph.SetTargetPointAbs(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Specifies the absolute coordinates of the target point of the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="point">
        <para>the new absolute target point coordinates of the edge</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.LayoutGraph.EdgeList">
      <summary>
        <para>Gets a list of all edges in the graph.</para>
      </summary>
      <value>
        <para>the edges contained in the graph</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.LayoutGraphUtilities">
      <summary>
        <para>The <see cref="T:yWorks.Layout.LayoutGraphUtilities" /> provides several helper and utility functions for <see cref="T:yWorks.Layout.LayoutGraph" /> and the <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see>.</para>
      </summary>
      <seealso cref="T:yWorks.Layout.LayoutGraph" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetLabelFactory(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.ILabelLayoutFactory" /> for the given graph.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <returns>
        <para>the label factory of the graph</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.DetermineEdgeFlowDirection(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Determines the main direction of the edge flow by analyzing the current layout of the graph.</para>
      </summary>
      <remarks>
        <para>The method only considers edges that are marked in the given <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </remarks>
      <param name="graph">
        <para>the underlying graph</para>
      </param>
      <param name="considerEdges">
        <para>the edges to consider</para>
      </param>
      <returns>
        <para>one of the predefined flow directions</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.IsUsingOrthogonalEdgeRoutes(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Determines whether or not most of the edges of the graph are routed orthogonally.</para>
      </summary>
      <remarks>
        <para>The method only considers edges marked in the given <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </remarks>
      <param name="graph">
        <para>the underlying graph</para>
      </param>
      <param name="considerEdges">
        <para>the edges to consider</para>
      </param>
      <returns>
        <para>
          <c>true</c> if most of the edges in the graph are routed orthogonally, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.IsUsingOctilinearEdgeRoutes(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Determines whether or not most of the edges of the graph are routed octilinear.</para>
      </summary>
      <remarks>
        <para>The method only considers edges marked in the given <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </remarks>
      <param name="graph">
        <para>the underlying graph</para>
      </param>
      <param name="considerEdges">
        <para>the edges to consider</para>
      </param>
      <returns>
        <para>
          <c>true</c> if most of the edges in the graph are routed octilinear, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetNodeDistance(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the distance between the centers of the two given nodes.</para>
      </summary>
      <param name="graph">
        <para>the graph to which the nodes belong</para>
      </param>
      <param name="node1">
        <para>the first node</para>
      </param>
      <param name="node2">
        <para>the second node</para>
      </param>
      <returns>
        <para>the distance between the nodes' centers</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetPathLength(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the length of the path of the given edge.</para>
      </summary>
      <remarks>
        <para>The path starts at the source point, traverses through all control points and ends at the target point.</para>
      </remarks>
      <param name="graph">
        <para>the graph to which the edge belongs</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the length of the edge's path</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ReverseEdgeLayout(yWorks.Layout.IEdgeLayout)">
      <summary>
        <para>Reverses the layout of an edge.</para>
      </summary>
      <remarks>
        <para>The order of the control points is reversed and source and target point are swapped.</para>
      </remarks>
      <param name="el">
        <para>the layout information of an edge</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ResetPaths(yWorks.Layout.LayoutGraph,System.Boolean)">
      <summary>
        <para>Assigns a trivial path which has no control points to all edges in the specified graph.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="resetPorts">
        <para>
          <c>true</c> if the ports of the edges should be set to the center of the corresponding nodes, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ResetPath(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,System.Boolean)">
      <summary>
        <para>Assigns a trivial path which has no control points to the specified edge.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="resetPorts">
        <para>
          <c>true</c> if the ports of the edge should be set to the center of the corresponding nodes, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.RemoveDuplicateBends(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Removes successive bends that have the same coordinates from all edges in the graph.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.RemoveDuplicateBends(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Removes successive bends that have the same coordinates from the given edge.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.MoveEdge(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,System.Double,System.Double)">
      <summary>
        <para>Moves all control points of the given edge by the vector <c>(dx,dy)</c>.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="dx">
        <para>the horizontal distance to move</para>
      </param>
      <param name="dy">
        <para>the vertical distance to move</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.MoveEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeCursor,System.Double,System.Double)">
      <summary>
        <para>Moves the control points of all edges accessible through the given <see cref="T:yWorks.Algorithms.IEdgeCursor" /> by the vector <c>(dx,dy)</c>.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="edges">
        <para>the edges to be moved</para>
      </param>
      <param name="dx">
        <para>the horizontal distance to move</para>
      </param>
      <param name="dy">
        <para>the vertical distance to move</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.MoveNode(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,System.Double,System.Double)">
      <summary>
        <para>Moves the given node by the vector <c>(dx,dy)</c>.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="dx">
        <para>the horizontal distance to move</para>
      </param>
      <param name="dy">
        <para>the vertical distance to move</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.MoveNodes(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeCursor,System.Double,System.Double)">
      <summary>
        <para>Moves all nodes accessible through the given <see cref="T:yWorks.Algorithms.INodeCursor" /> by the vector <c>(dx,dy)</c>.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="nodes">
        <para>the nodes to be moved</para>
      </param>
      <param name="dx">
        <para>the horizontal distance to move</para>
      </param>
      <param name="dy">
        <para>the vertical distance to move</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.MoveSubgraph(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeCursor,System.Double,System.Double)">
      <summary>
        <para>Moves the subgraph induced by the edges accessible through the given <see cref="T:yWorks.Algorithms.IEdgeCursor" /> by the vector <c>(dx,dy)</c>.</para>
      </summary>
      <param name="graph">
        <para>the graph that contains the subgraph</para>
      </param>
      <param name="edges">
        <para>the edges that induce the subgraph</para>
      </param>
      <param name="dx">
        <para>the horizontal distance to move</para>
      </param>
      <param name="dy">
        <para>the vertical distance to move</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.MoveSubgraph(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeCursor,System.Double,System.Double)">
      <summary>
        <para>Moves the subgraph induced by the nodes accessible through the given <see cref="T:yWorks.Algorithms.INodeCursor" /> by the vector <c>(dx,dy)</c>.</para>
      </summary>
      <param name="graph">
        <para>the graph that contains the subgraph</para>
      </param>
      <param name="nodes">
        <para>the nodes that induce the subgraph</para>
      </param>
      <param name="dx">
        <para>the horizontal distance to move</para>
      </param>
      <param name="dy">
        <para>the vertical distance to move</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeCursor,yWorks.Algorithms.IEdgeCursor)">
      <summary>
        <para>Returns the bounding box of the nodes and edges accessible through the given cursors.</para>
      </summary>
      <remarks>
        <para>In this case, the bounding box is the smallest paraxial rectangle which contains the given nodes and the control points as well as the source and target points of all edges.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the nodes and edges</para>
      </param>
      <param name="nodes">
        <para>the nodes to include in the bounding box</para>
      </param>
      <param name="edges">
        <para>the edges to include in the bounding box</para>
      </param>
      <returns>
        <para>the bounding box containing the given nodes and edges</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeCursor)" />
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeCursor)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the bounding box of the given node.</para>
      </summary>
      <remarks>
        <para>In this case, the bounding box is the smallest paraxial rectangle which contains the given node. It is identical to the node's bounds.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the node</para>
      </param>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the bounding box of the node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetNodeLayout(System.Object)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeCursor)">
      <summary>
        <para>Returns the bounding box of the nodes accessible through the given cursor.</para>
      </summary>
      <remarks>
        <para>In this case, the bounding box is the smallest paraxial rectangle which contains the given nodes.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the nodes</para>
      </param>
      <param name="nodes">
        <para>the nodes to include in the bounding box</para>
      </param>
      <returns>
        <para>the bounding box containing the given nodes</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetNodeLayout(System.Object)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the bounding box of the given edge.</para>
      </summary>
      <remarks>
        <para>In this case, the bounding box is the smallest paraxial rectangle which contains the control points as well as the absolute coordinates of the source and target point of the edge.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the edge</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the bounding box of the edge</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetSourcePointAbs(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetTargetPointAbs(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetLayout(yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeCursor)">
      <summary>
        <para>Returns the bounding box of the edges accessible through the given cursor.</para>
      </summary>
      <remarks>
        <para>In this case, the bounding box is the smallest paraxial rectangle which contains the control points as well as the absolute coordinates of the source and target points of all given edges.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the edges</para>
      </param>
      <param name="edges">
        <para>the edges to include in the bounding box</para>
      </param>
      <returns>
        <para>the bounding box containing the given edges</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetSourcePointAbs(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetTargetPointAbs(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetLayout(yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeCursor,yWorks.Algorithms.IEdgeCursor,System.Boolean)">
      <summary>
        <para>Returns the bounding box of the nodes and edges accessible through the given cursors, optionally including node labels and edge labels.</para>
      </summary>
      <remarks>
        <para>In this case, the bounding box is the smallest paraxial rectangle which contains the given nodes and the control points as well as the source and target points of all edges. If labels should be included, it also contains their boxes.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the given nodes and edges</para>
      </param>
      <param name="nodes">
        <para>the nodes to include in the bounding box</para>
      </param>
      <param name="edges">
        <para>the edges to include in the bounding box</para>
      </param>
      <param name="includeLabels">
        <para>
          <c>true</c> if labels of nodes and edges should be included, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>the bounding box of the given nodes and edges</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeCursor,yWorks.Algorithms.IEdgeCursor,System.Boolean,System.Boolean,System.Boolean)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetBoundingBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeCursor,yWorks.Algorithms.IEdgeCursor,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
        <para>Returns the bounding box of the nodes and edges accessible through the given cursors, optionally including node labels, edge labels or <see cref="T:yWorks.Layout.NodeHalo" />s.</para>
      </summary>
      <remarks>
        <para>In this case, the bounding box is the smallest paraxial rectangle which contains the given nodes and the control points as well as the source and target points of all edges. If node or edge labels should be included, it also contains their boxes. <see cref="T:yWorks.Layout.NodeHalo" />s can also extend the bounding box if desired.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the given nodes and edges</para>
      </param>
      <param name="nodes">
        <para>the nodes to include in the bounding box</para>
      </param>
      <param name="edges">
        <para>the edges to include in the bounding box</para>
      </param>
      <param name="includeNodeLabels">
        <para>
          <c>true</c> if labels of nodes should be included, <c>false</c> otherwise</para>
      </param>
      <param name="includeEdgeLabels">
        <para>
          <c>true</c> if labels of edges should be included, <c>false</c> otherwise</para>
      </param>
      <param name="includeHalos">
        <para>
          <c>true</c> if <see cref="T:yWorks.Layout.NodeHalo" />s should be included, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>the bounding box of the given nodes and edges</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetLabelPlacement(yWorks.Layout.INodeLabelLayoutModel,yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)">
      <summary>
        <para>Returns the upper-left corner of the paraxial bounding box of the given node label as encoded by the specified model parameter.</para>
      </summary>
      <remarks>
        <para>The parameter describes the abstract position of the label within the specified model. The parameter must have been generated by that model.</para>
      </remarks>
      <param name="model">
        <para>the <see cref="T:yWorks.Layout.INodeLabelLayoutModel" /> used for placing the label</para>
      </param>
      <param name="labelSize">
        <para>the size of the label</para>
      </param>
      <param name="nodeLayout">
        <para>the layout of the node to which the label belongs</para>
      </param>
      <param name="param">
        <para>the model parameter</para>
      </param>
      <returns>
        <para>the upper-left corner of the label's bounding box</para>
      </returns>
      <seealso cref="M:yWorks.Layout.INodeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.INodeLayout,System.Object)" />
      <seealso cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.BoundingBox" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetLabelPlacement(yWorks.Layout.IEdgeLabelLayoutModel,yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)">
      <summary>
        <para>Returns the upper-left corner of the paraxial bounding box of the given edge label as encoded by the specified model parameter.</para>
      </summary>
      <remarks>
        <para>The parameter describes the abstract position of the label within the specified model. The parameter must have been generated by that model.</para>
      </remarks>
      <param name="model">
        <para>the <see cref="T:yWorks.Layout.IEdgeLabelLayoutModel" /> used for placing the label</para>
      </param>
      <param name="labelSize">
        <para>the size of the label that should be placed</para>
      </param>
      <param name="edgeLayout">
        <para>the layout of the edge to which the label belongs</para>
      </param>
      <param name="sourceLayout">
        <para>the layout of the edge's source node</para>
      </param>
      <param name="targetLayout">
        <para>the layout of the edge's target node</para>
      </param>
      <param name="param">
        <para>the model parameter</para>
      </param>
      <returns>
        <para>the upper-left corner of the label's bounding box</para>
      </returns>
      <seealso cref="M:yWorks.Layout.IEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" />
      <seealso cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.BoundingBox" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ResetPorts(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Sets the ports of all edges in the graph to the center of the nodes.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetSourcePointRel(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetTargetPointRel(yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.YPoint)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ClipEdgePathOnBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the path of an edge clipped on the bounding box of the source and target node.</para>
      </summary>
      <remarks>
        <para>On the clipped edge, the source and target port will be located at the border of the corresponding node.</para>
      </remarks>
      <param name="graph">
        <para>the graph to which the edge belongs</para>
      </param>
      <param name="edge">
        <para>the clipped edge</para>
      </param>
      <returns>
        <para>the clipped path of the edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ClipEdgePathOnBounds(yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Double)">
      <summary>
        <para>Returns the path of an edge clipped on insets of the bounding box of the source and target node.</para>
      </summary>
      <remarks>
        <para>On the clipped edge, the source and target port will be located inside the node with an inset to the border of the corresponding node.</para>
      </remarks>
      <param name="edge">
        <para>the clipped edge</para>
      </param>
      <param name="source">
        <para>the source of the edge</para>
      </param>
      <param name="target">
        <para>the target of the edge</para>
      </param>
      <param name="inset">
        <para>the inset of the node</para>
      </param>
      <returns>
        <para>the clipped path of the edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ClipPathOnBounds(yWorks.Algorithms.Geometry.YPointPath,yWorks.Algorithms.Geometry.YRectangle,yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Returns the path of a given edge path clipped on the given bounding boxes of the source and target node.</para>
      </summary>
      <param name="path">
        <para>the path that will be clipped</para>
      </param>
      <param name="sourceBox">
        <para>the box of the source node that the given path should be clipped at</para>
      </param>
      <param name="targetBox">
        <para>the box of the target node that the given path should be clipped at</para>
      </param>
      <returns>
        <para>the path clipped on the given nodes boxes</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.IsEdgeOutsideNodes(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Checks whether or not the path of an edge is outside the bounding box of the source and target node.</para>
      </summary>
      <remarks>
        <para>The edge is outside the nodes if its control points as well as the source and target point are not inside the nodes' bounding boxes.</para>
      </remarks>
      <param name="graph">
        <para>the graph to which the edge belongs</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge is outside the nodes, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.IsEdgeOutsideNodes(yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Double)">
      <summary>
        <para>Checks whether or not the path of an edge is outside the bounding box of the source and target node, considering the given halo.</para>
      </summary>
      <remarks>
        <para>The edge is outside the nodes if its control points as well as the source and target point are not inside the nodes' bounding boxes.</para>
        <para>The nodes can be enlarged by a halo to check if the edge keeps some distance to the nodes.</para>
      </remarks>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="source">
        <para>the source of the edge</para>
      </param>
      <param name="target">
        <para>the target of the edge</para>
      </param>
      <param name="halo">
        <para>the halo for the nodes</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge is outside the nodes, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ClipEdgesOnBounds(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Clips the path of all edges in the graph on the bounding box of their source and target points.</para>
      </summary>
      <remarks>
        <para>On a clipped edge, the source and target port will be located at the border of the corresponding node.</para>
      </remarks>
      <param name="graph">
        <para>the graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ClipEdgeOnBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ClipEdgeOnBounds(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Clips the path of the given edge on the bounding box of the source and target points.</para>
      </summary>
      <remarks>
        <para>On a clipped edge, the source and target port will be located at the border of the corresponding node.</para>
      </remarks>
      <param name="graph">
        <para>the graph to which the edge belongs</para>
      </param>
      <param name="edge">
        <para>the edge to clip</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.EdgeLayoutString(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns a <see cref="T:System.String" /> representation of the path of the given edge.</para>
      </summary>
      <param name="graph">
        <para>the graph to which the edge belongs</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the <see cref="T:System.String" /> that contains all control points of the edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.RoundNodeLayout(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Rounds the location and size of the given node to integer values.</para>
      </summary>
      <param name="graph">
        <para>the graph to which the node belongs</para>
      </param>
      <param name="node">
        <para>the node whose values are rounded</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.RoundEdgeLayout(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Rounds the locations of the control points and ports of the given edge to integer values.</para>
      </summary>
      <param name="graph">
        <para>the graph to which the edge belongs</para>
      </param>
      <param name="edge">
        <para>the edge whose values are rounded</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.RoundLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Rounds coordinates and sizes in the layout of an entire graph to integer values.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.RoundNodeLayout(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.RoundEdgeLayout(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.RouteEdgesParallel(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,yWorks.Algorithms.Edge,System.Double,System.Boolean,System.Double,System.Double)">
      <summary>
        <para>Routes two edges which are incident to the same nodes in parallel, optionally joining the end points.</para>
      </summary>
      <remarks>
        <para>The second edge gets a path that is parallel to the path of the first (leading) edge.</para>
      </remarks>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="edge1">
        <para>the leading edge</para>
      </param>
      <param name="edge2">
        <para>the edge to be adjusted</para>
      </param>
      <param name="lineDistance">
        <para>the distance between the two edges</para>
      </param>
      <param name="joinEnds">
        <para>
          <c>true</c> if the edges should share their end points (the ones of the leading edge), <c>false</c> otherwise</para>
      </param>
      <param name="absJoinDist">
        <para>the absolute distance between the end points and the beginning of the parallel segment routing if the ends are joined</para>
      </param>
      <param name="relJoinDist">
        <para>the relative distance, measured relative to the length of the first/last segments if the ends are joined</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.RouteEdgesParallel(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,yWorks.Algorithms.EdgeList,System.Double,System.Boolean,System.Boolean,System.Double,System.Double)">
      <summary>
        <para>Routes a list of edges which are incident to the same nodes in parallel, optionally joining the end points.</para>
      </summary>
      <remarks>
        <para>All edges get a path that is parallel to the path of the first (leading) edge.</para>
        <para>The position of the leading edge may be adjusted if there is an odd number of parallel edges. It will be moved from the center to achieve a more symmetric port assignment.</para>
      </remarks>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="edge">
        <para>the leading edge</para>
      </param>
      <param name="edges">
        <para>the list of edges that will be aligned with the leading edge</para>
      </param>
      <param name="lineDistance">
        <para>the distance between two edges</para>
      </param>
      <param name="adjustE1">
        <para>
          <c>true</c> if the leading edge should be adjusted if the size of list is odd, <c>false</c> otherwise</para>
      </param>
      <param name="joinEnds">
        <para>
          <c>true</c> if the edges should share their end points (the ones of the leading edge), <c>false</c> otherwise</para>
      </param>
      <param name="absJoinDist">
        <para>the absolute distance between the end points and the beginning of the parallel segment routing if the ends are joined</para>
      </param>
      <param name="relJoinDist">
        <para>the relative distance, measured relative to the length of the first/last segments if the ends are joined</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.RouteSelfLoop(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Routes a self-loop.</para>
      </summary>
      <remarks>
        <para>For a self-loop edge, source and target are identical. The path of the self-loop will start at the top of the node, go around the upper-left corner and end at the left side of the node.</para>
      </remarks>
      <param name="graph">
        <para>the graph to which the edge belongs</para>
      </param>
      <param name="edge">
        <para>the self-loop</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.AssignReverseLayout(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,yWorks.Algorithms.Edge)">
      <summary>
        <para>Applies the reversed layout of the first edge to the second edge.</para>
      </summary>
      <param name="graph">
        <para>the graph to which both edges belong</para>
      </param>
      <param name="edge1">
        <para>the edge which adopts the points</para>
      </param>
      <param name="edge2">
        <para>the template</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.GetNodePositions(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Returns a <see cref="T:System.String" /> representation of all node positions in the graph.</para>
      </summary>
      <param name="graph">
        <para>the graph</para>
      </param>
      <returns>
        <para>the <see cref="T:System.String" /> containing all node locations</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraph.GetLocation(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleGrid(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double)">
      <summary>
        <para>Reassigns the bounds of the rectangles in a grid to fit in a large rectangle with an aspect ratio close to the specified aspect ratio.</para>
      </summary>
      <remarks>
        <para>The aspect ratio must be greater than <c>0</c>.</para>
      </remarks>
      <param name="rectangles">
        <para>the rectangles whose coordinates will be modified</para>
      </param>
      <param name="finalRect">
        <para>the exact dimension will be placed in this rectangle</para>
      </param>
      <param name="aspectRatio">
        <para>the preferred aspect ratio of the grid</para>
      </param>
      <returns>
        <para>the dimension of the grid</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given aspect ratio is less than or equal to zero</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleMultiRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,System.Double,System.Boolean,yWorks.Layout.MultiRowConstraint,yWorks.Layout.RowAlignment)">
      <summary>
        <para>Reassigns the bounds of the rectangles in multiple rows to fit the preferred width and height.</para>
      </summary>
      <remarks>
        <para>The rectangles will be placed within this bound, arranged in rows, where each row may be split into more sub-rows. This often leads to more compact results than provided by the procedure used in <see cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,yWorks.Layout.RowAlignment)" />. A row will be subdivided into more rows, if two successive rectangles to be placed in the row could be placed stacked within this row without making the row larger in height.</para>
        <para>The preferred width and height should be greater than <c>0</c>, otherwise the nodes are not arranged.</para>
      </remarks>
      <param name="rectangles">
        <para>the rectangles to arrange (coordinates will be assigned)</para>
      </param>
      <param name="finalRect">
        <para>the exact resulting dimension will be stored in this rectangle</para>
      </param>
      <param name="preferredWidth">
        <para>the preferred width of the result rectangle</para>
      </param>
      <param name="preferredHeight">
        <para>the preferred height of the result rectangle</para>
      </param>
      <param name="compaction">
        <para>
          <c>true</c> if the algorithm tries to always minimize the resulting dimension, whilst respecting the given constraints, <c>false</c> otherwise</para>
      </param>
      <param name="constraintMode">
        <para>the width or height constraints to consider</para>
      </param>
      <param name="alignment">
        <para>the alignment inside a row</para>
      </param>
      <returns>
        <para>the number of rows used</para>
      </returns>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleMultiRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,System.Double,System.Boolean,yWorks.Layout.MultiRowConstraint,yWorks.Layout.RowAlignment)" />
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.ArrangeRectangleRows(yWorks.Algorithms.Geometry.Rectangle2D[],yWorks.Algorithms.Geometry.Rectangle2D,System.Double,yWorks.Layout.RowAlignment)">
      <summary>
        <para>Reassigns the bounds of the rectangles to fit in a large rectangle with an aspect ratio close to the specified aspect ratio.</para>
      </summary>
      <remarks>
        <para>This is achieved by arranging the rectangles in rows.</para>
        <para>The aspect ratio must be greater than <c>0</c>.</para>
      </remarks>
      <param name="rectangles">
        <para>the rectangles whose coordinates will be modified</para>
      </param>
      <param name="finalRect">
        <para>the exact dimension of the resulting rectangle</para>
      </param>
      <param name="aspectRatio">
        <para>the preferred aspect ratio of the resulting rectangle</para>
      </param>
      <param name="alignment">
        <para>one of the valid row alignments</para>
      </param>
      <returns>
        <para>the number of used rows</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the aspect ratio is <c>0</c> or less</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.PathIntersectsRect(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,yWorks.Algorithms.Geometry.Rectangle2D)">
      <summary>
        <para>Checks whether or not the path of the given edge intersects the interior of a given rectangular area.</para>
      </summary>
      <param name="graph">
        <para>the graph to which the edge belongs</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="rect">
        <para>the rectangular area to check for intersection</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge path intersects with the given rectangle, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.AlignNodeLayouts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList,yWorks.Algorithms.Node,System.Boolean,yWorks.Layout.NodeAlignment)">
      <summary>
        <para>Aligns the specified nodes either vertically or horizontally according to the specified node alignment mode.</para>
      </summary>
      <remarks>
        <para>For vertical arrangements, nodes are either <see cref="F:yWorks.Layout.NodeAlignment.Leading">top-aligned</see>, <see cref="F:yWorks.Layout.NodeAlignment.Centered">center-aligned</see>, <see cref="F:yWorks.Layout.NodeAlignment.Trailing">bottom-aligned</see>, or <see cref="F:yWorks.Layout.NodeAlignment.Distributed">vertically distributed</see>.</para>
        <para>For horizontal arrangements, nodes are either <see cref="F:yWorks.Layout.NodeAlignment.Leading">left-aligned</see>, <see cref="F:yWorks.Layout.NodeAlignment.Centered">center-aligned</see>, <see cref="F:yWorks.Layout.NodeAlignment.Trailing">right-aligned</see>, or <see cref="F:yWorks.Layout.NodeAlignment.Distributed">horizontally distributed</see>.</para>
        <para>In this context, <em>distributed</em> means that the specified nodes are placed in such a way that the projections of their bounds onto the vertical or horizontal coordinate axis do not overlap. For example, after vertically distributing nodes, <c>(n1.y + n1.height) &lt;= n2.y</c> for two consecutively placed nodes <c>n1</c> and <c>n2</c>.</para>
      </remarks>
      <param name="graph">
        <para>the graph that contains the specified nodes</para>
      </param>
      <param name="nodes">
        <para>the subset of the specified graph's nodes that is arranged</para>
      </param>
      <param name="referenceNode">
        <para>if <c>null</c>, the common coordinate for aligning the specified nodes is calculated as the the vertical minimum (top-aligned), the vertical center, the vertical maximum (bottom-aligned), the horizontal minimum (left-aligned), the horizontal center, or the horizontal maximum (right-aligned) of the bounds of the specified nodes; otherwise the appropriate coordinate of the given reference node's bounds is used as common coordinate for aligning the specified nodes. The reference node is ignored when <see cref="F:yWorks.Layout.NodeAlignment.Distributed">distributing</see> nodes.</para>
      </param>
      <param name="vertical">
        <para>
          <c>true</c> if nodes should be aligned (or distributed) according to their y-coordinates; otherwise nodes are aligned (or distributed) according to their x-coordinates.</para>
      </param>
      <param name="mode">
        <para>one of the valid alignment modes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutGraphUtilities.AutoFlipBox(yWorks.Algorithms.Geometry.YOrientedRectangle)">
      <summary>
        <para>Flips the orientation of a given rectangle, if its up vector points downward <c>(</c><see cref="P:yWorks.Algorithms.Geometry.YOrientedRectangle.UpY">upY</see><c> &gt; 0)</c>.</para>
      </summary>
      <remarks>
        <para>That means, it rotates the rectangle by <c>180</c> degrees without changing the rectangle's center.</para>
      </remarks>
      <param name="rect">
        <para>the given rectangle</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given rectangle was flipped, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.LayoutMultiplexer">
      <summary>
        <para>A <see cref="T:yWorks.Layout.LayoutMultiplexer" /> delegates its layout calls to a core layout algorithm that is dynamically chosen at runtime by inspecting the nodes of the input graph.</para>
      </summary>
      <remarks>
        <para>If a <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with the given graph using the look-up key <see cref="F:yWorks.Layout.LayoutMultiplexer.LayoutDpKey" />, it is used for retrieving the <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> objects that are stored for the graph's nodes. If no such <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered, this layout stage's <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> (if any) is used for the layout calculation of all nodes.</para>
        <para>Note that the first non-<c>null</c> <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> instance retrieved from the <see cref="T:yWorks.Algorithms.IDataProvider" /> is used for all nodes.</para>
        <para>The main purpose of this class is to enable the use of individual layout algorithms for different components (when used as the core layout algorithm of <see cref="T:yWorks.Layout.ComponentLayout" />) or for the contents of group nodes (when used as the core layout algorithm of <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" />).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.LayoutMultiplexer.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.LayoutMultiplexer" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.LayoutMultiplexer.LayoutDpKey">
      <summary>
        <para>A data provider key for assigning layout algorithms to the nodes.</para>
      </summary>
      <remarks>
        <para>At runtime, the layout algorithms are determined and applied to the current graph. The first non-<c>null</c> <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> instance is used for the whole graph.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.LayoutMultiplexer.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Retrieves and invokes the <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> that is assigned to the graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutMultiplexer.getCoreLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Returns the core layout algorithm associated with the nodes contained in the given graph.</para>
      </summary>
      <remarks>
        <para>This implementation looks up the layout algorithm in the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the key <see cref="F:yWorks.Layout.LayoutMultiplexer.LayoutDpKey" />. The first non-<c>null</c> <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> instance found for a node of the given graph will be returned by this method. If no algorithm is registered at all, it will fall back to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">default core layout algorithm</see>.</para>
        <para>This method is called in <see cref="M:yWorks.Layout.LayoutMultiplexer.ApplyLayout(yWorks.Layout.LayoutGraph)" /> and may be overridden to implement a different way of selecting the <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>the according layout algorithm</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.LayoutStageBase">
      <summary>
        <para>Abstract base class implementing <see cref="T:yWorks.Layout.ILayoutStage" /> that handles the management of the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>Subclasses of this stage can use the provided methods, such that the management of the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> does not need to be considered anymore.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.MultiStageLayout" />
    </member>
    <member name="M:yWorks.Layout.LayoutStageBase.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ILayoutStage" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.LayoutStageBase.CoreLayout">
      <summary>
        <para>Gets or sets the core layout algorithm that is wrapped by this stage.</para>
      </summary>
      <value>
        <para>the core layout routine</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.LayoutStageBase.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Invokes the layout process of the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>Overriding classes may call this method during <see cref="M:yWorks.Layout.ILayoutAlgorithm.ApplyLayout(yWorks.Layout.LayoutGraph)" /> to delegate arranging the graph to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. They can add pre- and post-processing code before and after this call.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.LayoutStageBase.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <param name="graph" />
    </member>
    <member name="T:yWorks.Layout.MinimumNodeSizeStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.MinimumNodeSizeStage" /> enforces a given minimum width/height of the nodes of a graph during the layout process.</para>
      </summary>
      <remarks>
        <para>It temporarily enlarges nodes whose width/height is below the specified minimum values.</para>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> is especially useful to prevent that the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> has to handle zero-sized nodes or nodes with negative sizes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.MinimumNodeSizeStage.#ctor(yWorks.Layout.ILayoutAlgorithm,System.Double,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.MinimumNodeSizeStage" /> instance using the given <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> along with a specific minimum width and height for the nodes.</para>
      </summary>
      <param name="coreLayouter">
        <para>the core layout routine</para>
      </param>
      <param name="minWidth">
        <para>the minimum width of nodes that should be enforced</para>
      </param>
      <param name="minHeight">
        <para>the minimum height of nodes that should be enforced</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.MinimumNodeSizeStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.MinimumNodeSizeStage" /> instance using the given <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>The nodes will be enlarged to be at least <c>1</c> wide and <c>1</c> high.</para>
      </remarks>
      <param name="coreLayouter">
        <para>the core routine</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.MinimumNodeSizeStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Resizes all nodes that are smaller than the specified minimum size to that minimum size, executes the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and restores the original sizes afterwards.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.MultiStageLayout">
      <summary>
        <para>An abstract base class for layout algorithms that provides services to simplify and decompose the input graph before it is passed to the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">core layout algorithm</see> itself.</para>
      </summary>
      <remarks>
        <para>Subclasses of this layout algorithm have to provide implementations for the abstract method <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" />. It invokes the actual layout routine of this layout algorithm.</para>
        <para>
          <h2>Concept</h2>
        </para>
        <para>This class provides a configurable pipeline that contains <see cref="T:yWorks.Layout.ILayoutStage" />s that add preprocessing steps and/or postprocessing steps to the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see>. <see cref="T:yWorks.Layout.MultiStageLayout" /> provides some predefined <see cref="T:yWorks.Layout.ILayoutStage" />s, that simplify the input graph for the layout algorithm and complement the result. It is also possible to add custom <see cref="T:yWorks.Layout.ILayoutStage" />s which are executed <see cref="M:yWorks.Layout.MultiStageLayout.PrependStage(yWorks.Layout.ILayoutStage)">before</see> or <see cref="M:yWorks.Layout.MultiStageLayout.AppendStage(yWorks.Layout.ILayoutStage)">after the predefined ones</see>.</para>
        <para>Each <see cref="T:yWorks.Layout.ILayoutStage" /> in the pipeline wraps its successor. When the layout pipeline is processed, the preprocessing code of the preceding <see cref="T:yWorks.Layout.ILayoutStage" /> is executed before the code in the current <see cref="T:yWorks.Layout.ILayoutStage" /> while the postprocessing code is executed afterwards.</para>
        <para>The pipeline of predefined <see cref="T:yWorks.Layout.ILayoutStage" />s of <see cref="T:yWorks.Layout.MultiStageLayout" /> (when all are activated) causes the following sequence of steps:</para>
        <list type="number">
          <item>Hides the group nodes.</item>
          <item>Hides all except for the induced subgraph.</item>
          <item>Decomposes the graph into its connected components. Performs steps 4-12 on each component.</item>
          <item>Prepares for label placement.</item>
          <item>Prepares the layout for an orientation change.</item>
          <item>Hides self-loops.</item>
          <item>Hides parallel edges.</item>
          <item>Invokes the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see> on the simplified graph.</item>
          <item>Un-hides and routes parallel edges.</item>
          <item>Un-hides and routes self-loops.</item>
          <item>Completes orientation change of the layout.</item>
          <item>Assigns label positions.</item>
          <item>Arranges the connected components of the graph.</item>
          <item>Un-hides non-induced subgraph.</item>
          <item>Un-hides the group nodes.</item>
        </list>
        <para>In order to take effect, a stage that is not already activated by default needs to be activated using the corresponding method, e.g., <see cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled" />. Vice versa, a stage can also be deactivated, if necessary.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.MultiStageLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.MultiStageLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Invokes the core layout algorithm.</para>
      </summary>
      <remarks>
        <para>This method should be implemented by subclasses in order to perform the layout routine of the layout algorithm.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.MultiStageLayout.CheckNodeSize(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Checks the sizes of the nodes to be non-zero.</para>
      </summary>
      <param name="g">
        <para>The graph to check.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.MultiStageLayout.PrependStage(yWorks.Layout.ILayoutStage)">
      <summary>
        <para>Prepends the given <see cref="T:yWorks.Layout.ILayoutStage" /> to the layout pipeline.</para>
      </summary>
      <remarks>
        <para>Stages that are added with this method will be invoked at the very beginning of the layout pipeline. This means before all previously prepended <see cref="T:yWorks.Layout.ILayoutStage" />s, all predefined stages, and all appended <see cref="T:yWorks.Layout.ILayoutStage" />s.</para>
      </remarks>
      <param name="stage">
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance to be added</para>
      </param>
      <seealso cref="M:yWorks.Layout.MultiStageLayout.RemoveStage(yWorks.Layout.ILayoutStage)" />
      <seealso cref="M:yWorks.Layout.MultiStageLayout.AppendStage(yWorks.Layout.ILayoutStage)" />
    </member>
    <member name="M:yWorks.Layout.MultiStageLayout.AppendStage(yWorks.Layout.ILayoutStage)">
      <summary>
        <para>Appends the given <see cref="T:yWorks.Layout.ILayoutStage" /> to the layout pipeline.</para>
      </summary>
      <remarks>
        <para>Stages that are added with this method will be invoked at the very end of the layout pipeline. This means after all prepended <see cref="T:yWorks.Layout.ILayoutStage" />s, all predefined stages, and all previously appended <see cref="T:yWorks.Layout.ILayoutStage" />s, but just before the invocation of the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see>.</para>
      </remarks>
      <param name="stage">
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance to be added</para>
      </param>
      <seealso cref="M:yWorks.Layout.MultiStageLayout.RemoveStage(yWorks.Layout.ILayoutStage)" />
      <seealso cref="M:yWorks.Layout.MultiStageLayout.PrependStage(yWorks.Layout.ILayoutStage)" />
    </member>
    <member name="M:yWorks.Layout.MultiStageLayout.RemoveStage(yWorks.Layout.ILayoutStage)">
      <summary>
        <para>Removes the given <see cref="T:yWorks.Layout.ILayoutStage" /> from the layout pipeline.</para>
      </summary>
      <remarks>
        <para>This method can only remove <see cref="T:yWorks.Layout.ILayoutStage" />s that have been previously added using <see cref="M:yWorks.Layout.MultiStageLayout.AppendStage(yWorks.Layout.ILayoutStage)" /> or <see cref="M:yWorks.Layout.MultiStageLayout.PrependStage(yWorks.Layout.ILayoutStage)" />. Predefined <see cref="T:yWorks.Layout.ILayoutStage" />s can be deactivated separately.</para>
      </remarks>
      <param name="stage">
        <para>a <see cref="T:yWorks.Layout.ILayoutStage" /> to be removed from the layout pipeline</para>
      </param>
      <seealso cref="M:yWorks.Layout.MultiStageLayout.PrependStage(yWorks.Layout.ILayoutStage)" />
      <seealso cref="M:yWorks.Layout.MultiStageLayout.AppendStage(yWorks.Layout.ILayoutStage)" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SubgraphLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LabelingEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.Labeling">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutStage" /> that places the labels of the input graph.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LabelingEnabled" />
      <seealso cref="T:yWorks.Layout.Labeling.GenericLabeling" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutStage" /> that routes self-loops.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutStage" /> that routes parallel edges.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouterEnabled" />
      <seealso cref="T:yWorks.Layout.ParallelEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.ComponentLayout">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutStage" /> that arranges the connected components of an input graph.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.SubgraphLayout">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutStage" /> that constrains the layout process to a subgraph of the input graph.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SubgraphLayoutEnabled" />
      <seealso cref="T:yWorks.Layout.SubgraphLayout" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.HideGroupsStage">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutStage" /> that hides the group nodes of the input graph.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled" />
      <seealso cref="T:yWorks.Layout.Grouping.HideGroupsStage" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.OrientationLayout">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of a computed layout.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of the layout is activated.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> may be deactivated if the orientation is irrelevant for the layout or if the core layout algorithm already handles the layout orientation by itself.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the stage that modifies the orientation is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">
      <summary>
        <para>Gets or sets the main orientation of the layout.</para>
      </summary>
      <remarks>
        <para>This is a convenience method that configures the <see cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout">orientation layout stage</see>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified orientation does not match a default layout orientation</para>
      </exception>
      <value>
        <para>one of the default layout orientations</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> should be deactivated if the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see> handles self-loops by itself.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.LabelingEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for placing the labels of the input graph is activated.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> may be activated to apply a generic labeling algorithm to the input graph. It will then try to find the best locations for the labels in the layout calculated by the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see>. When the stage is deactivated, the labels are ignored or placed by an integrated labeling of the layout algorithm.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the stage responsible for placing the labels is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.Labeling" />
      <seealso cref="T:yWorks.Layout.Labeling.GenericLabeling" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for hiding group nodes is activated.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> should be deactivated if the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see> handles group nodes itself.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the stage used for hiding group nodes is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStage" />
      <seealso cref="T:yWorks.Layout.Grouping.HideGroupsStage" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for arranging the components of the graph is activated.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> should be deactivated if the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see> is able to handle several connected components.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the stage that arranges the graph components is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouterEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing parallel edges is activated.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> should be deactivated if the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see> handles parallel edges itself.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing parallel edges is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouter" />
      <seealso cref="T:yWorks.Layout.ParallelEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.MultiStageLayout.SubgraphLayoutEnabled">
      <summary>
        <para>Gets or sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for constraining the layout process to a subgraph of the input graph is activated.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> may be activated if the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see> should be applied only to a specific part of the graph. The remaining graph will stay unchanged.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the stage that constrains the input graph to a subgraph is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SubgraphLayout" />
      <seealso cref="T:yWorks.Layout.SubgraphLayout" />
    </member>
    <member name="M:yWorks.Layout.MultiStageLayout.DisableAllStages">
      <summary>
        <para>Deactivates all predefined <see cref="T:yWorks.Layout.ILayoutStage" />s so that upon <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> only the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see> will be executed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.MultiStageLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates a layout for the given graph and applies it directly to the graph.</para>
      </summary>
      <remarks>
        <para>This method executes all activated <see cref="T:yWorks.Layout.ILayoutStage" />s in the layout pipeline as well as the <see cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">layout algorithm</see>.</para>
      </remarks>
      <param name="layoutGraph">
        <para>the input graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.MultiStageLayout.AppendStage(yWorks.Layout.ILayoutStage)" />
      <seealso cref="M:yWorks.Layout.MultiStageLayout.PrependStage(yWorks.Layout.ILayoutStage)" />
      <seealso cref="M:yWorks.Layout.MultiStageLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="T:yWorks.Layout.Multipage.DefaultElementFactory">
      <summary>
        <para>This class is a default implementation of interface <see cref="T:yWorks.Layout.Multipage.IElementFactory" />.</para>
      </summary>
      <seealso cref="T:yWorks.Layout.Multipage.IElementFactory" />
    </member>
    <member name="M:yWorks.Layout.Multipage.DefaultElementFactory.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Multipage.DefaultElementFactory" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateConnectorEdge(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object,System.Boolean)">
      <param name="context" />
      <param name="connector" />
      <param name="opposite" />
      <param name="origEdgeId" />
      <param name="atTarget" />
    </member>
    <member name="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateConnectorNode(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.YList,System.Object)">
      <param name="context" />
      <param name="edgeIds" />
      <param name="representedNodeId" />
    </member>
    <member name="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateProxyReferenceNode(yWorks.Layout.Multipage.LayoutContext,System.Object)">
      <param name="context" />
      <param name="referringProxyId" />
    </member>
    <member name="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateProxyNode(yWorks.Layout.Multipage.LayoutContext,System.Object)">
      <param name="context" />
      <param name="origNodeId" />
    </member>
    <member name="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateProxyReferenceEdge(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object)">
      <param name="context" />
      <param name="proxyReference" />
      <param name="opposite" />
      <param name="referencingCopyId" />
    </member>
    <member name="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateProxyEdge(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object,System.Object)">
      <param name="context" />
      <param name="proxyNode" />
      <param name="opposite" />
      <param name="replacingEdgeId" />
      <param name="origNodeId" />
    </member>
    <member name="M:yWorks.Layout.Multipage.DefaultElementFactory.GetDefaultNodeSize(yWorks.Layout.Multipage.LayoutContext,System.Object,System.SByte)">
      <summary>
        <para>Returns the default size for nodes created by this factory.</para>
      </summary>
      <remarks>
        <para>This method is called from <see cref="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateConnectorNode(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.YList,System.Object)" />, <see cref="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateProxyReferenceNode(yWorks.Layout.Multipage.LayoutContext,System.Object)" />, and/or <see cref="M:yWorks.Layout.Multipage.DefaultElementFactory.CreateProxyNode(yWorks.Layout.Multipage.LayoutContext,System.Object)" />. It must return a non-<c>null</c> size with positive width and height.</para>
        <para>Subclasses may implement this method to use custom size values.</para>
      </remarks>
      <param name="context">
        <para>an object providing relevant layout information, for example, the current graph as well as various information about the graph elements</para>
      </param>
      <param name="id">
        <para>the element ID</para>
      </param>
      <param name="type">
        <para>the type of the node to be created</para>
      </param>
      <returns>
        <para>the default size of the new node</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Multipage.EdgeType">
      <seealso cref="P:yWorks.Layout.Multipage.IEdgeInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Multipage.EdgeType.Normal">
      <summary>
        <para>An edge type that specifies a normal edge.</para>
        <para>An edge is called <i>normal</i> if it does not belong to any other type.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.IEdgeInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Multipage.EdgeType.Connector">
      <summary>
        <para>An edge type that specifies a connector edge.</para>
        <para>An edge is called <i>connector</i> if it is connected to a connector node (a node of <see cref="P:yWorks.Layout.Multipage.INodeInfo.Type">type</see> <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" />), i.e., it represents an edge of the input graph whose endpoints lie on different pages.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.IEdgeInfo.RepresentedEdge" />
      <seealso cref="P:yWorks.Layout.Multipage.IEdgeInfo.Type" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Connector" />
    </member>
    <member name="F:yWorks.Layout.Multipage.EdgeType.ProxyReference">
      <summary>
        <para>An edge type that specifies a proxy reference edge.</para>
        <para>An edge is called <i>proxy reference</i> if it is connected to a proxy reference node (a node of <see cref="P:yWorks.Layout.Multipage.INodeInfo.Type">type</see> <see cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference" />), i.e., a node that refers to a proxy of an original node lying on another page.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.IEdgeInfo.Type" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference" />
    </member>
    <member name="F:yWorks.Layout.Multipage.EdgeType.Proxy">
      <summary>
        <para>An edge type that specifies a proxy edge.</para>
        <para>An edge is called <i>proxy</i> if it is connected to a proxy node (a node of <see cref="P:yWorks.Layout.Multipage.INodeInfo.Type">type</see> <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />), i.e., a node that is a proxy of an original node lying on another page.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.IEdgeInfo.Type" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />
    </member>
    <member name="T:yWorks.Layout.Multipage.GroupingMode">
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.GroupingMode" />
    </member>
    <member name="F:yWorks.Layout.Multipage.GroupingMode.Ignore">
      <summary>
        <para>Node grouping specifier used when group nodes should be ignored.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.GroupingMode" />
    </member>
    <member name="F:yWorks.Layout.Multipage.GroupingMode.OriginalNodesOnly">
      <summary>
        <para>Node grouping specifier used when only original nodes should be assigned to group nodes. Hence, connector and proxy nodes (see <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" /> and <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />) are never assigned to group nodes even though the associated node lies within a group.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.GroupingMode" />
    </member>
    <member name="F:yWorks.Layout.Multipage.GroupingMode.AllNodes">
      <summary>
        <para>Node grouping specifier used when special nodes like, e.g., connector and proxy nodes (see <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" /> and <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />) should be assigned to group nodes, too.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.GroupingMode" />
    </member>
    <member name="T:yWorks.Layout.Multipage.EdgeBundleModes">
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.EdgeBundleModeMask" />
    </member>
    <member name="F:yWorks.Layout.Multipage.EdgeBundleModes.DistinguishMultiEdges">
      <summary>
        <para>Edge bundle mode constant that specifies that all multi-edges (edges with same endpoints) should be distinguished. Hence, if such edges connect two nodes on different pages, a separate connector pair (see <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" />) is used for each of them.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.EdgeBundleModeMask" />
    </member>
    <member name="F:yWorks.Layout.Multipage.EdgeBundleModes.DistinguishDirections">
      <summary>
        <para>Edge bundle mode constant that specifies that multi-edges (edges with same endpoints) should be distinguished if they have different directions. Hence, two edges with the same endpoints may share a connector pair (see <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" />) if they point in the same direction (i.e., both have the same source and target node).</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.EdgeBundleModeMask" />
    </member>
    <member name="F:yWorks.Layout.Multipage.EdgeBundleModes.DistinguishTypes">
      <summary>
        <para>Edge bundle mode constant that specifies that multi-edges (edges with same endpoints) should be distinguished if they are of different (user specified) type, see <see cref="F:yWorks.Layout.Multipage.MultiPageLayout.EdgeTypeDpKey" />. Hence, two edges with the same endpoints and same type may share a connector pair (see <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" />).</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.EdgeBundleModeMask" />
      <seealso cref="F:yWorks.Layout.Multipage.MultiPageLayout.EdgeTypeDpKey" />
    </member>
    <member name="T:yWorks.Layout.Multipage.NodeType">
      <seealso cref="P:yWorks.Layout.Multipage.INodeInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Multipage.NodeType.Normal">
      <summary>
        <para>A node type that specifies a normal node.</para>
        <para>A node is called <i>normal</i> if it does not belong to any other type.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.INodeInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Multipage.NodeType.Group">
      <summary>
        <para>A node type that specifies a group node.</para>
        <para>A <i>group</i> node is a node that may contain other nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.INodeInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Multipage.NodeType.Proxy">
      <summary>
        <para>A node type that specifies a proxy node.</para>
        <para>A <i>proxy</i> node is a copy of a <see cref="F:yWorks.Layout.Multipage.NodeType.Normal">normal node</see>. It is created by the algorithm if a normal node and its neighbors or associated <see cref="F:yWorks.Layout.Multipage.NodeType.Connector">connectors</see> do not fit onto a single page. Hence, in such cases, the neighbors/connectors associated with a normal node may be distributed among different proxy nodes associated with this node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.INodeInfo.Type" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Normal" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference" />
    </member>
    <member name="F:yWorks.Layout.Multipage.NodeType.ProxyReference">
      <summary>
        <para>A node type that specifies a proxy reference node.</para>
        <para>For each <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy">proxy node</see> there is exactly one matching proxy reference node. The reference node refers to the proxy and is either connected to the <see cref="F:yWorks.Layout.Multipage.NodeType.Normal">normal node</see> associated with this proxy or one of its other proxy nodes (a normal node may be associated with multiple proxy nodes). Hence, for a node connected to a proxy reference node there always exists a copy located on another page.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.INodeInfo.Type" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />
    </member>
    <member name="F:yWorks.Layout.Multipage.NodeType.Connector">
      <summary>
        <para>A node type that specifies a connector node.</para>
        <para>Each edge of the input graph that connects two nodes <c>v</c> and <c>w</c> that are placed on different pages is split by a pair of matching connector nodes (one for each of the two pages). One of the connector nodes is connected to <c>v</c> and the other to <c>w</c>. Hence, each connector represents a jump mark to the matching connector and guarantees that no information is lost as it would be the case if such edges are simply removed.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.INodeInfo.Type" />
    </member>
    <member name="T:yWorks.Layout.Multipage.IEdgeInfo">
      <summary>
        <para>A class that holds all information associated with an edge.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Multipage.IEdgeInfo.Id">
      <summary>
        <para>Gets the unique ID of the associated edge.</para>
      </summary>
      <value>
        <para>the ID of the associated edge</para>
      </value>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetEdgeInfo(yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Layout.Multipage.IElementInfoManager.GetEdgeInfo(yWorks.Algorithms.Edge)" />
    </member>
    <member name="P:yWorks.Layout.Multipage.IEdgeInfo.Type">
      <summary>
        <para>Gets the type of the associated edge.</para>
      </summary>
      <value>
        <para>the type of the associated edge</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Multipage.IEdgeInfo.RepresentedEdge">
      <summary>
        <para>Gets the original edge associated with this <see cref="T:yWorks.Layout.Multipage.IEdgeInfo" />.</para>
      </summary>
      <remarks>
        <para>More precisely, for edges of <see cref="P:yWorks.Layout.Multipage.IEdgeInfo.Type">type</see> <see cref="F:yWorks.Layout.Multipage.EdgeType.Connector" />, this method returns the edge of the input graph that was split by the connector edge. Otherwise, it returns <c>null</c>.</para>
      </remarks>
      <value>
        <para>the original edge if the type of the edge is <see cref="F:yWorks.Layout.Multipage.EdgeType.Connector" />, <c>null</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.Multipage.EdgeType.Connector" />
    </member>
    <member name="T:yWorks.Layout.Multipage.IEdgeLabelInfo">
      <summary>
        <para>A class that holds all information related to an edge label.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Multipage.IEdgeLabelInfo.Id">
      <summary>
        <para>Gets the unique ID of the associated edge label.</para>
      </summary>
      <value>
        <para>the ID of the associated edge label</para>
      </value>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetEdgeLabelInfo(yWorks.Layout.IEdgeLabelLayout)" />
      <seealso cref="M:yWorks.Layout.Multipage.IElementInfoManager.GetEdgeLabelInfo(yWorks.Layout.IEdgeLabelLayout)" />
    </member>
    <member name="T:yWorks.Layout.Multipage.IElementFactory">
      <summary>
        <para>Factory used by class <see cref="T:yWorks.Layout.Multipage.MultiPageLayout" /> to create special nodes and edges.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementFactory.CreateConnectorNode(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.YList,System.Object)">
      <summary>
        <para>Callback method for creating a node of type <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" />.</para>
      </summary>
      <param name="context">
        <para>an object providing relevant layout information, for example, the current graph as well as various information about the graph elements</para>
      </param>
      <param name="edgesIds">
        <para>a <see cref="T:yWorks.Algorithms.YList">list</see> that contains the IDs of edges that are split by this connector</para>
      </param>
      <param name="representedNodeId">
        <para>the ID of the node that is represented by this connector</para>
      </param>
      <returns>
        <para>the created connector node</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Connector" />
      <seealso cref="M:yWorks.Layout.Multipage.LayoutContext.CreateNode(System.Object)" />
      <seealso cref="P:yWorks.Layout.Multipage.INodeInfo.RepresentedNode" />
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementFactory.CreateProxyReferenceNode(yWorks.Layout.Multipage.LayoutContext,System.Object)">
      <summary>
        <para>Callback method for creating a node of type <see cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference" />.</para>
      </summary>
      <param name="context">
        <para>an object providing relevant layout information, for example, the current graph as well as various information about the graph elements</para>
      </param>
      <param name="referringProxyId">
        <para>the ID of the proxy to which the created node refers</para>
      </param>
      <returns>
        <para>the new proxy reference node</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference" />
      <seealso cref="M:yWorks.Layout.Multipage.LayoutContext.CreateNode(System.Object)" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementFactory.CreateProxyNode(yWorks.Layout.Multipage.LayoutContext,System.Object)">
      <summary>
        <para>Callback method for creating a node of type <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />.</para>
      </summary>
      <param name="context">
        <para>an object providing relevant layout information, for example, the current graph as well as various information about the graph elements</para>
      </param>
      <param name="origNodeId">
        <para>the ID of the node for which a proxy has to be created</para>
      </param>
      <returns>
        <para>the created proxy node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Multipage.LayoutContext.CreateNode(System.Object)" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementFactory.CreateConnectorEdge(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object,System.Boolean)">
      <summary>
        <para>Callback method for creating an edge of type <see cref="F:yWorks.Layout.Multipage.EdgeType.Connector" />.</para>
      </summary>
      <remarks>
        <para>Such an edge connects the given <see cref="F:yWorks.Layout.Multipage.NodeType.Connector">connector</see> and opposite node.</para>
      </remarks>
      <param name="context">
        <para>an object providing relevant layout information, for example, the current graph as well as various information about the graph elements</para>
      </param>
      <param name="connector">
        <para>the endpoint of the edge that represents the connector node</para>
      </param>
      <param name="opposite">
        <para>the other endpoint of the edge</para>
      </param>
      <param name="origEdgeId">
        <para>the ID of the edge that is split by the connector edge</para>
      </param>
      <param name="atTarget">
        <para>
          <c>true</c> if the connector node is the target of the edge, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>the created connector edge</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Multipage.EdgeType.Connector" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Connector" />
      <seealso cref="M:yWorks.Layout.Multipage.LayoutContext.CreateEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object)" />
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementFactory.CreateProxyReferenceEdge(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object)">
      <summary>
        <para>Callback method for creating an edge of type <see cref="F:yWorks.Layout.Multipage.EdgeType.ProxyReference" />.</para>
      </summary>
      <remarks>
        <para>Such an (undirected) edge should connect the given <see cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference">proxy reference</see> and opposite node.</para>
      </remarks>
      <param name="context">
        <para>an object providing relevant layout information, for example, the current graph as well as various information about the graph elements</para>
      </param>
      <param name="proxyReference">
        <para>the endpoint of the edge that represents the proxy reference node</para>
      </param>
      <param name="opposite">
        <para>the other endpoint of the new edge</para>
      </param>
      <param name="referencingCopyId">
        <para>the ID of the proxy node that is referenced by the proxy reference node</para>
      </param>
      <returns>
        <para>the created proxy reference edge</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Multipage.EdgeType.ProxyReference" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference" />
      <seealso cref="M:yWorks.Layout.Multipage.LayoutContext.CreateEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object)" />
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementFactory.CreateProxyEdge(yWorks.Layout.Multipage.LayoutContext,yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object,System.Object)">
      <summary>
        <para>Callback method for creating an edge of type <see cref="F:yWorks.Layout.Multipage.EdgeType.Proxy" />.</para>
      </summary>
      <remarks>
        <para>Such an edge should connect the given <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy">proxy</see> and opposite node.</para>
      </remarks>
      <param name="context">
        <para>an object providing relevant layout information, for example, the current graph as well as various information about the graph elements</para>
      </param>
      <param name="proxyNode">
        <para>the endpoint of the edge that represents the proxy node</para>
      </param>
      <param name="opposite">
        <para>the other endpoint of the new edge</para>
      </param>
      <param name="replacingEdgeId">
        <para>the ID of the related edge that is connected to the original node</para>
      </param>
      <param name="origNodeId">
        <para>the ID of the original node to which the proxy node refers</para>
      </param>
      <returns>
        <para>the created proxy edge</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Multipage.EdgeType.Proxy" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />
      <seealso cref="M:yWorks.Layout.Multipage.LayoutContext.CreateEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object)" />
    </member>
    <member name="T:yWorks.Layout.Multipage.IElementInfoManager">
      <summary>
        <para>Interface that offers access to the information objects of graph elements.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementInfoManager.GetNodeInfo(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the node information object of the given node.</para>
      </summary>
      <param name="node">
        <para>the node for which the information object should be returned</para>
      </param>
      <returns>
        <para>the node information object of the given node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementInfoManager.GetEdgeInfo(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the edge information object of the given edge.</para>
      </summary>
      <param name="edge">
        <para>the edge for which the information object should be returned</para>
      </param>
      <returns>
        <para>the edge information object of the given edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementInfoManager.GetNodeLabelInfo(yWorks.Layout.INodeLabelLayout)">
      <summary>
        <para>Returns the node label layout information object of the given node label layout.</para>
      </summary>
      <param name="nodeLabelLayout">
        <para>the node label layout for which the information object should be returned</para>
      </param>
      <returns>
        <para>the node label information object of the given node label layout</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Multipage.IElementInfoManager.GetEdgeLabelInfo(yWorks.Layout.IEdgeLabelLayout)">
      <summary>
        <para>Returns the edge label information object of the given edge label layout.</para>
      </summary>
      <param name="edgeLabelLayout">
        <para>the edge label layout for which the information object should be returned</para>
      </param>
      <returns>
        <para>the edge label information object of the given edge label layout</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Multipage.ILayoutCallback">
      <summary>
        <para>Callback that is invoked when a <see cref="T:yWorks.Layout.Multipage.MultiPageLayout" /> has calculated a new multi-page layout.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Multipage.ILayoutCallback.LayoutDone(yWorks.Layout.Multipage.MultiPageLayoutResult)">
      <summary>
        <para>Invoked from <see cref="M:yWorks.Layout.Multipage.MultiPageLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> when a new multi-page layout has been calculated.</para>
      </summary>
      <param name="result">
        <para>the result of the layout calculation</para>
      </param>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="T:yWorks.Layout.Multipage.INodeInfo">
      <summary>
        <para>This interface offers access to information associated with a node.</para>
      </summary>
      <remarks>
        <para>The information can be either obtained from <see cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetNodeInfo(yWorks.Algorithms.Node)" /> or <see cref="M:yWorks.Layout.Multipage.LayoutContext.GetNodeInfo(yWorks.Algorithms.Node)" />.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Multipage.INodeInfo.RepresentedNode">
      <summary>
        <para>Gets the node of the input graph that is represented by the node associated with this <see cref="T:yWorks.Layout.Multipage.INodeInfo">info object</see>.</para>
      </summary>
      <remarks>
        <para>Note that, for the special nodes inserted to guarantee that no information is lost, there are no corresponding nodes in the input graph. Hence, special nodes are mapped to common nodes in the following way:</para>
        <list type="bullet">
          <item>A <see cref="F:yWorks.Layout.Multipage.NodeType.Connector">connector node</see> is mapped to the common node connected to the matching connector.</item>
          <item>A <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy">proxy node</see> is mapped to the associated common node (i.e., the proxy is a copy of that node).</item>
          <item>A <see cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference">proxy reference node</see> is not mapped to any node, and, thus this method returns <c>null</c> for such nodes.</item>
        </list>
      </remarks>
      <value>
        <para>the represented node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Multipage.INodeInfo.PageNo">
      <summary>
        <para>Gets the page number of the <see cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetPage(System.Int32)">page graph</see> that contains the node associated with this <see cref="T:yWorks.Layout.Multipage.INodeInfo">info object</see>.</para>
      </summary>
      <value>
        <para>the page of the associated node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Multipage.INodeInfo.Type">
      <summary>
        <para>Gets the type of the node associated with this <see cref="T:yWorks.Layout.Multipage.INodeInfo">info object</see>.</para>
      </summary>
      <value>
        <para>the type of the node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Multipage.INodeInfo.Id">
      <summary>
        <para>Gets the unique ID of the node associated with this <see cref="T:yWorks.Layout.Multipage.INodeInfo">info object</see>.</para>
      </summary>
      <value>
        <para>the ID of the node</para>
      </value>
      <seealso cref="F:yWorks.Layout.Multipage.MultiPageLayout.NodeIdDpKey" />
    </member>
    <member name="P:yWorks.Layout.Multipage.INodeInfo.ReferencingNode">
      <summary>
        <para>Gets the node that refers to the one associated with this <see cref="T:yWorks.Layout.Multipage.INodeInfo">info object</see>.</para>
      </summary>
      <remarks>
        <para>More precisely, if the node associated with this info object</para>
        <list type="bullet">
          <item>is a <see cref="F:yWorks.Layout.Multipage.NodeType.Connector">connector node</see>, this method returns the matching connector node,</item>
          <item>is a <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy">proxy node</see>, it returns the corresponding <see cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference">proxy reference node</see>,</item>
          <item>is a <see cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference">proxy reference node</see>, it returns the corresponding <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy">proxy node</see>,</item>
          <item>or otherwise, it returns <c>null</c>.</item>
        </list>
      </remarks>
      <value>
        <para>the referencing node</para>
      </value>
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Connector" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference" />
    </member>
    <member name="T:yWorks.Layout.Multipage.INodeLabelInfo">
      <summary>
        <para>A class that holds all information related to a node label.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Multipage.INodeLabelInfo.Id">
      <summary>
        <para>Gets the unique ID of the associated node label.</para>
      </summary>
      <value>
        <para>the ID of the associated node label</para>
      </value>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetNodeLabelInfo(yWorks.Layout.INodeLabelLayout)" />
      <seealso cref="M:yWorks.Layout.Multipage.IElementInfoManager.GetNodeLabelInfo(yWorks.Layout.INodeLabelLayout)" />
    </member>
    <member name="T:yWorks.Layout.Multipage.LayoutContext">
      <summary>
        <para>This class represents the layout context.</para>
      </summary>
      <remarks>
        <para>It provides several methods to access data as well as adding and removing elements.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.CreateEdge(yWorks.Algorithms.Node,yWorks.Algorithms.Node,System.Object)">
      <summary>
        <para>All methods of the <see cref="T:yWorks.Layout.Multipage.IElementFactory" /> have to use this method to create an edge.</para>
      </summary>
      <param name="source">
        <para>the source of the edge</para>
      </param>
      <param name="target">
        <para>the target of the edge</para>
      </param>
      <param name="sameDataElementId">
        <para>the ID of the edge whose data should be copied to the created edge (or <c>null</c> if no data should be copied)</para>
      </param>
      <returns>
        <para>the created edge</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Multipage.IElementFactory" />
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.CreateNode(System.Object)">
      <summary>
        <para>All methods of the <see cref="T:yWorks.Layout.Multipage.IElementFactory" /> have to use this method to create a node.</para>
      </summary>
      <param name="sameDataElementId">
        <para>the ID of the node whose data should be copied to the created node (or <c>null</c> if no data should be copied)</para>
      </param>
      <returns>
        <para>the created node</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Multipage.IElementFactory" />
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.AddNodeLabel(yWorks.Layout.INodeLabelLayout,yWorks.Algorithms.Node)">
      <summary>
        <para>Adds a label to a given node.</para>
      </summary>
      <param name="label">
        <para>the label that should be added to the given node</para>
      </param>
      <param name="labeledElement">
        <para>the node to which the label should be added</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.AddEdgeLabel(yWorks.Layout.IEdgeLabelLayout,yWorks.Algorithms.Edge)">
      <summary>
        <para>Adds a label to a given edge.</para>
      </summary>
      <param name="label">
        <para>the label that should be added to the given edge</para>
      </param>
      <param name="labeledElement">
        <para>the edge to which the label should be added</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.RemoveNodeLabel(yWorks.Layout.INodeLabelLayout,yWorks.Algorithms.Node)">
      <summary>
        <para>Removes a label from a given node.</para>
      </summary>
      <param name="label">
        <para>the label that should be removed</para>
      </param>
      <param name="labeledElement">
        <para>the node owning the label</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.RemoveEdgeLabel(yWorks.Layout.IEdgeLabelLayout,yWorks.Algorithms.Edge)">
      <summary>
        <para>Removes a label from a given edge.</para>
      </summary>
      <param name="label">
        <para>the label that should be removed</para>
      </param>
      <param name="labeledElement">
        <para>the edge owning the label</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Multipage.LayoutContext.Graph">
      <summary>
        <para>Gets the relevant graph.</para>
      </summary>
      <value>
        <para>the relevant graph</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Multipage.LayoutContext.Layout">
      <summary>
        <para>Gets the layouter object that belongs to this layout context.</para>
      </summary>
      <value>
        <para>the layouter object that belongs to this layout context</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.GetPageNode(System.Object)">
      <summary>
        <para>Returns the node of a page graph (a graph that represents the result of the multi-page layout) with the given ID or <c>null</c> if there is no such node.</para>
      </summary>
      <param name="id">
        <para>the ID of the node that should be returned</para>
      </param>
      <returns>
        <para>the node of a page graph with the given ID or <c>null</c> if there is no such node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.GetPageEdge(System.Object)">
      <summary>
        <para>Returns the edge of a page graph (a graph that represents the result of the multi-page layout) with the given ID or <c>null</c> if there is no such edge.</para>
      </summary>
      <param name="id">
        <para>the ID of the edge that should be returned</para>
      </param>
      <returns>
        <para>the edge of a page graph with the given ID or <c>null</c> if there is no such edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.GetOriginalNode(System.Object)">
      <summary>
        <para>Returns the node of the input graph with the given ID or <c>null</c> if there is no such node.</para>
      </summary>
      <param name="id">
        <para>the ID of the node that should be returned</para>
      </param>
      <returns>
        <para>the node of the input graph with the given ID or <c>null</c> if there is no such node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.GetOriginalEdge(System.Object)">
      <summary>
        <para>Returns the edge of the input graph with the given ID or <c>null</c> if there is no such edge.</para>
      </summary>
      <param name="id">
        <para>the ID of the edge that should be returned</para>
      </param>
      <returns>
        <para>the edge of the input graph with the given ID or <c>null</c> if there is no such edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.GetEdgeLabelInfo(yWorks.Layout.IEdgeLabelLayout)">
      <param name="edgeLabelLayout" />
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.GetNodeLabelInfo(yWorks.Layout.INodeLabelLayout)">
      <param name="nodeLabelLayout" />
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.GetNodeInfo(yWorks.Algorithms.Node)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Layout.Multipage.LayoutContext.GetEdgeInfo(yWorks.Algorithms.Edge)">
      <param name="edge" />
    </member>
    <member name="T:yWorks.Layout.Multipage.MultiPageLayout">
      <summary>
        <para>This layout algorithm subdivides the input graph into several <see cref="T:yWorks.Layout.LayoutGraph" />s (called page graphs) such that the layout (calculated by the specified <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>) of each graph fits the <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.MaximumPageSize">specified maximum page size</see>.</para>
      </summary>
      <remarks>
        <para>The algorithm adds special nodes to guarantee that no information is lost when splitting edges that connect nodes placed on different pages (for more details take a look at the concept described below). </para>
        <para>The input graph.</para>
        <para />
        <para>The input graph is subdivided into two pages with size <c>500x500</c>. Circular nodes denote the so-called <see cref="F:yWorks.Layout.Multipage.NodeType.Connector">connectors</see> that split edges to nodes placed on other pages. The label of a connector corresponds to that of the opposite node of the split edge.</para>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>This multi-page layout algorithm subdivides the input graph into several smaller ones and applies existing layout algorithms to each of them. Hence, its layout style heavily depends on the selected <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> used for each single page. Furthermore, the algorithm uses several refinement steps to produce more compact results.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>Similar to the layout style, the supported feature set mainly depends on the features supported by the specified <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. Note that due to the underlying approach of the <see cref="T:yWorks.Layout.Multipage.MultiPageLayout" /> it doesn't support <see cref="T:yWorks.Layout.Grid.PartitionGrid" />s. Furthermore, while the <see cref="T:yWorks.Layout.Multipage.MultiPageLayout" /> is able to support groups (see <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.GroupingMode" />), it doesn't support edges incident to group nodes.</para>
        <para>
          <h2>Concept</h2>
        </para>
        <para>To guarantee that no information is lost, this layout algorithm replaces edges between nodes on different pages by so-called <see cref="F:yWorks.Layout.Multipage.NodeType.Connector">connector nodes</see>. Furthermore, it may replicate nodes (the clones are called <see cref="F:yWorks.Layout.Multipage.NodeType.Proxy">proxy nodes</see>) and insert special nodes to refer to such nodes (so-called <see cref="F:yWorks.Layout.Multipage.NodeType.ProxyReference">proxy reference nodes</see>).</para>
        <para>Unlike other yFiles layout algorithms, <see cref="T:yWorks.Layout.Multipage.MultiPageLayout" /> does not modify its input graph but returns its result as a <see cref="T:yWorks.Layout.Multipage.MultiPageLayoutResult" />. To be able to profit as much as possible from existing layout support, this layout algorithm implements the <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> interface, although method <see cref="M:yWorks.Layout.ILayoutAlgorithm.ApplyLayout(yWorks.Layout.LayoutGraph)">doLayout</see> does not specify a return value. Therefore, client code has to <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.LayoutCallback">register</see> a <see cref="T:yWorks.Layout.Multipage.ILayoutCallback" /> that is invoked when the algorithm has calculated a new multi-page result.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Multipage.MultiPageLayout.NodeClusterIdDpKey">
      <summary>
        <para>A data provider key for assigning a cluster ID to common (non-group) nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.StrictClusterSeparation" />
    </member>
    <member name="F:yWorks.Layout.Multipage.MultiPageLayout.NodeIdDpKey">
      <summary>
        <para>A data provider key for mapping each node of the input graph to a unique ID.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Multipage.MultiPageLayout.EdgeIdDpKey">
      <summary>
        <para>A data provider key for mapping each edge of the input graph to a unique ID.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Multipage.MultiPageLayout.EdgeLabelIdDpKey">
      <summary>
        <para>A data provider key for mapping each edge label of the input graph to a unique ID.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Multipage.MultiPageLayout.NodeLabelIdDpKey">
      <summary>
        <para>A data provider key for mapping each node label of the input graph to a unique ID.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Multipage.MultiPageLayout.EdgeTypeDpKey">
      <summary>
        <para>A data provider key for specifying the type of multi-edges.</para>
      </summary>
      <remarks>
        <para>If <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.EdgeBundleModeMask" /> &amp; <see cref="F:yWorks.Layout.Multipage.EdgeBundleModes.DistinguishTypes" /> == 1, multi-edges (edges with same endpoints) associated with different types (objects) are distinguished, i.e., they are split by different connector pairs (see <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" />).</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Multipage.EdgeBundleModes.DistinguishTypes" />
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.EdgeBundleModeMask" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Multipage.MultiPageLayout" /> instance.</para>
      </summary>
      <param name="core">
        <para>the layout algorithm used for a single page</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.StrictClusterSeparation">
      <summary>
        <para>Gets or sets whether or not the algorithm should separate nodes with different <see cref="F:yWorks.Layout.Multipage.MultiPageLayout.NodeClusterIdDpKey">cluster IDs</see>.</para>
      </summary>
      <remarks>
        <para>More precisely, if this option is enabled, the algorithm doesn't place nodes with different cluster IDs onto the same page. Otherwise, such a placement is possible.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the algorithm separates nodes with different cluster IDs, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.Multipage.MultiPageLayout.NodeClusterIdDpKey" />
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.LabelingEnabled">
      <summary>
        <para>Gets or sets whether or not the given <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.Labeling">labeling algorithm</see> places the labels of the input graph.</para>
      </summary>
      <remarks>
        <para>If this option is disabled, the labels are either ignored or placed by the integrated labeling approach of the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the given label layouter places the labels, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.Labeling" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayout.CreateElementFactory">
      <summary>
        <para>This method creates the <see cref="T:yWorks.Layout.Multipage.IElementFactory">element factory</see> for multi-page layouts.</para>
      </summary>
      <remarks>
        <para>It is called once from <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.ElementFactory" /> if no factory has been explicitly set using <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.ElementFactory" />. By default, this method returns an instance of <see cref="T:yWorks.Layout.Multipage.DefaultElementFactory" />.</para>
        <para>Subclasses may create a custom implementation of the element factory.</para>
      </remarks>
      <returns>
        <para>the created element factory</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.ElementFactory" />
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.ElementFactory" />
      <seealso cref="T:yWorks.Layout.Multipage.IElementFactory" />
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.ElementFactory">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Multipage.IElementFactory">element factory</see> for creating special nodes and edges in a multi-page layout.</para>
      </summary>
      <remarks>
        <para>If no element factory is set explicitly (see method <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.ElementFactory" />), a new instance is created and set by method <see cref="M:yWorks.Layout.Multipage.MultiPageLayout.CreateElementFactory" /> during the first layout run.</para>
      </remarks>
      <value>
        <para>the element factory for creating special nodes and edges</para>
      </value>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayout.CreateElementFactory" />
      <seealso cref="T:yWorks.Layout.Multipage.IElementFactory" />
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.LayoutCallback">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Multipage.ILayoutCallback">callback</see> that is notified upon completion of multi-page layout calculation runs.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Multipage.ILayoutCallback" /> instance that is notified</para>
      </value>
      <seealso cref="T:yWorks.Layout.Multipage.ILayoutCallback" />
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.EdgeBundleModeMask">
      <summary>
        <para>Gets or sets the bit mask for defining edge bundles.</para>
      </summary>
      <remarks>
        <para>All multi-edges (edges with same endpoints) belonging to the same edge bundle are split by the same connector pair (see <see cref="F:yWorks.Layout.Multipage.NodeType.Connector" />).</para>
      </remarks>
      <value>
        <para>the bit mask for defining edge bundles</para>
      </value>
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Connector" />
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.GroupingMode">
      <summary>
        <para>Gets or sets how to handle special nodes (like connector and proxy nodes) with respect to groups.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified group mode is unknown</para>
      </exception>
      <value>
        <para>the current node grouping specifier</para>
      </value>
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Connector" />
      <seealso cref="F:yWorks.Layout.Multipage.NodeType.Proxy" />
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.MaximumDuration">
      <summary>
        <para>Gets or sets the preferred time limit (in milliseconds) for the layout algorithm.</para>
      </summary>
      <remarks>
        <para>The specified value has to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the preferred time limit is negative</para>
      </exception>
      <value>
        <para>the preferred time limit</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.Labeling">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutStage" /> that places the labels of the input graph.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.LabelingEnabled" />
      <seealso cref="T:yWorks.Layout.Labeling.GenericLabeling" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates a new multi-page layout for the specified graph.</para>
      </summary>
      <remarks>
        <para>This method calls <see cref="M:yWorks.Layout.Multipage.MultiPageLayout.calculateLayout(yWorks.Layout.LayoutGraph)" /> and notifies the registered <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.LayoutCallback">layout callback</see> of the calculated result.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayout.calculateLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates a new multi-page layout for the specified graph.</para>
      </summary>
      <remarks>
        <para>Unlike method <see cref="M:yWorks.Layout.Multipage.MultiPageLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" />, this method ignores the registered <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.LayoutCallback">layout callback</see> and directly returns the calculated <see cref="T:yWorks.Layout.Multipage.MultiPageLayoutResult" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>an instance of <see cref="T:yWorks.Layout.Multipage.MultiPageLayoutResult" /> that represents the result of the layout run</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if for one of the keys <see cref="F:yWorks.Layout.Multipage.MultiPageLayout.NodeIdDpKey" />, <see cref="F:yWorks.Layout.Multipage.MultiPageLayout.EdgeIdDpKey" />, <see cref="F:yWorks.Layout.Multipage.MultiPageLayout.NodeLabelIdDpKey" /> and <see cref="F:yWorks.Layout.Multipage.MultiPageLayout.EdgeLabelIdDpKey" /> no <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with the given graph</para>
      </exception>
      <seealso cref="T:yWorks.Layout.Multipage.MultiPageLayoutResult" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayout.RemoveConnectorPair(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.YList,yWorks.Layout.Multipage.LayoutContext)">
      <summary>
        <para>This method is called during a postprocessing step that reduces the number of connectors.</para>
      </summary>
      <remarks>
        <para>A pair of connectors can be removed if both connector nodes are placed on the same page. The method removes both connector nodes and restores the original edges by calling <see cref="M:yWorks.Layout.Multipage.MultiPageLayout.RouteRestoredEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.Geometry.YRectangle)" />.</para>
        <para>Subclasses may implement a custom remove/restore strategy.</para>
      </remarks>
      <param name="connector1">
        <para>the first connector of the connector pair</para>
      </param>
      <param name="connector2">
        <para>the second connector of the connector pair</para>
      </param>
      <param name="originalEdgeIds">
        <para>the IDs of the original edges that have to be restored</para>
      </param>
      <param name="context">
        <para>the current layout context</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the removal of the connector pair was successful, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayout.RouteRestoredEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.Geometry.YRectangle)" />
    </member>
    <member name="P:yWorks.Layout.Multipage.MultiPageLayout.MaximumPageSize">
      <summary>
        <para>Gets or sets the maximum size of a single page.</para>
      </summary>
      <remarks>
        <para>The layout algorithm subdivides the input graph such that each part is placed on a different page that fits the specified maximum size.</para>
        <para>Both the specified width and height have to be positive.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified width or height is not positive</para>
      </exception>
      <value>
        <para>the maximum size for a single page</para>
      </value>
      <seealso cref="P:yWorks.Layout.Multipage.MultiPageLayout.MaximumDuration" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayout.ApplyIncrementalLayout(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider,yWorks.Layout.Multipage.LayoutContext)">
      <summary>
        <para>This method is called to further improve the layout results.</para>
      </summary>
      <remarks>
        <para>The marked nodes have to be placed without changing the coordinates of the fixed (non-marked) elements and without exceeding the specified maximum page size. Furthermore, the basic layout properties should be maintained.</para>
        <para>Subclasses may implement a custom layout strategy for this step.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="incrementalNodesDP">
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a boolean value indicating whether or not a node is marked; the positions of the non-marked nodes are not allowed to change</para>
      </param>
      <param name="context">
        <para>the current layout context</para>
      </param>
      <seealso cref="T:yWorks.Layout.Multipage.LayoutContext" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayout.RouteRestoredEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>This method is called whenever some single edges have to be routed without changing the position of nodes (e.g., by <see cref="M:yWorks.Layout.Multipage.MultiPageLayout.RemoveConnectorPair(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.YList,yWorks.Layout.Multipage.LayoutContext)" /> to route the restored edges).</para>
      </summary>
      <remarks>
        <para>It has to guarantee that the routes are fully contained within the given bounding rectangle.</para>
        <para>Subclasses may implement a custom routing strategy for the restored edges.</para>
      </remarks>
      <param name="graph">
        <para>the relevant graph</para>
      </param>
      <param name="selectedEdgesDP">
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns a boolean value indicating whether or not an edge should be rerouted</para>
      </param>
      <param name="boundingRectangle">
        <para>the edge routes should be fully contained within this rectangle</para>
      </param>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayout.RemoveConnectorPair(yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Algorithms.YList,yWorks.Layout.Multipage.LayoutContext)" />
    </member>
    <member name="T:yWorks.Layout.Multipage.MultiPageLayoutResult">
      <summary>
        <para>This class represents the result of a layout run of <see cref="T:yWorks.Layout.Multipage.MultiPageLayout" />.</para>
      </summary>
      <remarks>
        <para>A layout run subdivides the input graph into several <see cref="T:yWorks.Layout.LayoutGraph" />s (called page graphs) such that the layout of each graph fits the <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.MaximumPageSize">specified maximum page size</see>. This class provides access to the different page graphs (see method <see cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetPage(System.Int32)" />).</para>
        <para>An instance of this class can be either obtained by calling <see cref="M:yWorks.Layout.Multipage.MultiPageLayout.calculateLayout(yWorks.Layout.LayoutGraph)" /> or <see cref="M:yWorks.Layout.Multipage.MultiPageLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" />. In the latter case, a <see cref="T:yWorks.Layout.Multipage.ILayoutCallback" /> has to be <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.LayoutCallback">set</see> before starting the layout run.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayoutResult.PageCount">
      <summary>
        <para>Returns the number of pages available in this <see cref="T:yWorks.Layout.Multipage.MultiPageLayoutResult" />.</para>
      </summary>
      <remarks>
        <para>Each page contains a <see cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetPage(System.Int32)">page graph</see> whose layout fits the <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.MaximumPageSize">specified maximum page size</see>.</para>
      </remarks>
      <returns>
        <para>the number of available pages</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetPage(System.Int32)" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetPage(System.Int32)">
      <summary>
        <para>Returns the page graph associated with the given page number.</para>
      </summary>
      <remarks>
        <para>A <i>page graph</i> is a subgraph of the input graph whose layout fits the <see cref="P:yWorks.Layout.Multipage.MultiPageLayout.MaximumPageSize">specified maximum page size</see>.</para>
      </remarks>
      <param name="pageNo">
        <para>the given page number</para>
      </param>
      <returns>
        <para>the page graph associated with the given page number</para>
      </returns>
      <exception cref="T:System.IndexOutOfRangeException">
        <para>if <c>pageNo &gt;= pageCount</c> or <c>pageNo &lt; 0</c></para>
      </exception>
      <seealso cref="M:yWorks.Layout.Multipage.MultiPageLayoutResult.PageCount" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetEdgeInfo(yWorks.Algorithms.Edge)">
      <param name="edge" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetNodeInfo(yWorks.Algorithms.Node)">
      <param name="node" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetNodeLabelInfo(yWorks.Layout.INodeLabelLayout)">
      <param name="nodeLabelLayout" />
    </member>
    <member name="M:yWorks.Layout.Multipage.MultiPageLayoutResult.GetEdgeLabelInfo(yWorks.Layout.IEdgeLabelLayout)">
      <param name="edgeLabelLayout" />
    </member>
    <member name="T:yWorks.Layout.NodeHalo">
      <summary>
        <para>A <see cref="T:yWorks.Layout.NodeHalo" /> specifies a rectangular area around a specific node.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> that supports <see cref="T:yWorks.Layout.NodeHalo" />s, keeps this area clear of graph elements, except the node labels of this specific node and the adjacent segments of its edges. All minimum distances to this node, which are used in the layout calculation, e.g., minimum first segment length, will be extended by the halo size.</para>
        <para>This class defines a key used for registering a <see cref="T:yWorks.Algorithms.IDataProvider" /> that provides <see cref="T:yWorks.Layout.NodeHalo" />s for all nodes of the input graph. <see cref="T:yWorks.Layout.NodeHalo" />-aware layout algorithms like <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> look for <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with this key to retrieve <see cref="T:yWorks.Layout.NodeHalo" /> information.</para>
        <para>The following layouters support <see cref="T:yWorks.Layout.NodeHalo" />s with different restrictions:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Orthogonal.CompactOrthogonalLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Tree.TreeLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Tree.ClassicTreeLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Organic.OrganicLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Labeling.GenericLabeling" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Circular.CircularLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Tree.BalloonLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.SelfLoopRouter" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Radial.RadialLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.ComponentLayout" />
          </item>
        </list>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.NodeHalo.NodeHaloDpKey">
      <summary>
        <para>A data provider key for assigning halos for the nodes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.NodeHalo.ZeroHalo">
      <summary>
        <para>A constant holding a <see cref="T:yWorks.Layout.NodeHalo" /> with zero size on each side.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.NodeHalo.top">
      <summary>
        <para>The <see cref="T:yWorks.Layout.NodeHalo" /> size at the top side of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.NodeHalo.left">
      <summary>
        <para>The <see cref="T:yWorks.Layout.NodeHalo" /> size at the left side of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.NodeHalo.bottom">
      <summary>
        <para>The <see cref="T:yWorks.Layout.NodeHalo" /> size at the bottom side of the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.NodeHalo.right">
      <summary>
        <para>The <see cref="T:yWorks.Layout.NodeHalo" /> size at the right side of the node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.NodeHalo.Create(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.NodeHalo" /> with the specified values.</para>
      </summary>
      <remarks>
        <para>The values must not be negative, <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" />.</para>
      </remarks>
      <param name="top">
        <para>the <see cref="T:yWorks.Layout.NodeHalo" /> size at the top side of the node</para>
      </param>
      <param name="left">
        <para>the <see cref="T:yWorks.Layout.NodeHalo" /> size at the left side of the node</para>
      </param>
      <param name="bottom">
        <para>the <see cref="T:yWorks.Layout.NodeHalo" /> size at the bottom side of the node</para>
      </param>
      <param name="right">
        <para>the <see cref="T:yWorks.Layout.NodeHalo" /> size at the right side of the node</para>
      </param>
      <returns>
        <para>the newly created <see cref="T:yWorks.Layout.NodeHalo" /></para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if one of the values is negative, <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" /></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.NodeHalo.Create(System.Double)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.NodeHalo" /> object with the specified value on each side of the node.</para>
      </summary>
      <remarks>
        <para>The value must not be negative, <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" />.</para>
      </remarks>
      <param name="value">
        <para>the halo size at each side of the node</para>
      </param>
      <returns>
        <para>the newly created <see cref="T:yWorks.Layout.NodeHalo" /></para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the value is negative, <see cref="F:System.Double.NaN" /> or <see cref="F:System.Double.PositiveInfinity" /></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.NodeHalo.HasHalos(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Checks whether or not the given graph contains <see cref="T:yWorks.Layout.NodeHalo" /> information.</para>
      </summary>
      <remarks>
        <para>This method looks for a <see cref="T:yWorks.Algorithms.IDataProvider" /> that has been registered with the given graph using <see cref="F:yWorks.Layout.NodeHalo.NodeHaloDpKey" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if a <see cref="T:yWorks.Algorithms.IDataProvider" /> has been registered with the according key, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.NodeHalo.GetHalo(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.NodeHalo" /> associated with the given node.</para>
      </summary>
      <remarks>
        <para>If no such <see cref="T:yWorks.Layout.NodeHalo" /> is available, this method returns a <see cref="F:yWorks.Layout.NodeHalo.ZeroHalo" />.</para>
      </remarks>
      <param name="graph">
        <para>the graph containing the given node</para>
      </param>
      <param name="node">
        <para>the node whose <see cref="T:yWorks.Layout.NodeHalo" /> will be determined</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.NodeHalo" /> of the given node if available, otherwise a <see cref="F:yWorks.Layout.NodeHalo.ZeroHalo" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.NodeHalo.GetHaloBox(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Returns a <see cref="T:yWorks.Algorithms.Geometry.YRectangle" /> instance with the bounds of the given node including its <see cref="T:yWorks.Layout.NodeHalo" />.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Algorithms.Geometry.YRectangle" /> is located at the position of the node.</para>
        <para>If the node does not have a <see cref="T:yWorks.Layout.NodeHalo" /> assigned, this box has the same size as the node.</para>
      </remarks>
      <param name="graph">
        <para>the graph containing the given node</para>
      </param>
      <param name="node">
        <para>the node whose <see cref="T:yWorks.Layout.NodeHalo" /> will be determined</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.YRectangle" /> instance with the bounds of the given node including its <see cref="T:yWorks.Layout.NodeHalo" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.NodeHalo.Equals(System.Object)">
      <param name="o" />
    </member>
    <member name="M:yWorks.Layout.NodeHalo.GetHashCode" />
    <member name="T:yWorks.Layout.NodeLabelCandidate">
      <summary>
        <para>A <see cref="T:yWorks.Layout.NodeLabelCandidate" /> describes one valid placement for a node label considering the label model.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.NodeLabelCandidate.#ctor(yWorks.Algorithms.Geometry.YOrientedRectangle,System.Object,yWorks.Layout.INodeLabelLayout,System.Boolean)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.NodeLabelCandidate" /> described by its box, model parameter and internal flag.</para>
      </summary>
      <param name="labelBox">
        <para>the box that specifies the candidate's size and position</para>
      </param>
      <param name="param">
        <para>the parameters of the label model associated with this candidate</para>
      </param>
      <param name="owner">
        <para>the label associated with the candidate</para>
      </param>
      <param name="internal">
        <para>
          <c>true</c> if the candidate is allowed to overlap with its owner, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.NodeLabelCandidate.#ctor(yWorks.Algorithms.Geometry.YPoint,yWorks.Algorithms.Geometry.YDimension,System.Object,yWorks.Layout.INodeLabelLayout,System.Boolean)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.NodeLabelCandidate" /> described by location, size, model parameter and internal flag.</para>
      </summary>
      <param name="pos">
        <para>the location of the upper left corner of the candidate</para>
      </param>
      <param name="size">
        <para>the size of the candidate</para>
      </param>
      <param name="param">
        <para>the parameters of the label model associated with this candidate</para>
      </param>
      <param name="owner">
        <para>the label associated with the candidate</para>
      </param>
      <param name="internal">
        <para>
          <c>true</c> if the candidate is allowed to overlap with its owner, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.NormalizeGraphElementOrderStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.NormalizeGraphElementOrderStage" /> normalizes the order of the elements within a graph to ensure the same order for multiple layout invocations.</para>
      </summary>
      <remarks>
        <para>Among other factors, the results produced by layout algorithms usually depend on the order of the nodes and edges within a graph. Unfortunately, useful operations such as hiding or unhiding elements from a graph or simply invoking layout algorithms on a graph will have the potential side effect of changing that order.</para>
        <para>With this <see cref="T:yWorks.Layout.ILayoutStage" /> it is possible to establish a predefined order of nodes and edges within a graph to avoid non-deterministic layout behavior. Defining the order of nodes and edges is done by associating each node or edge in the graph with a <see cref="T:System.IComparable" /> value using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the key <see cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.NodeComparableDpKey" /> or <see cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.EdgeComparableDpKey" />, respectively.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.NormalizeGraphElementOrderStage.NodeComparableDpKey">
      <summary>
        <para>A data provider key for defining a (global) order for nodes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.NormalizeGraphElementOrderStage.EdgeComparableDpKey">
      <summary>
        <para>A data provider key for defining a (global) order for edges.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.NormalizeGraphElementOrderStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.NormalizeGraphElementOrderStage" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.NormalizeGraphElementOrderStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Enforces the specified <see cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.NodeComparableDpKey">order of nodes</see> and <see cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.EdgeComparableDpKey">order of edges</see> before invoking the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <exception cref="T:System.InvalidOperationException">
        <para>if there is no <see cref="T:yWorks.Algorithms.IDataProvider" /> registered for one of the keys <see cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.NodeComparableDpKey" /> and <see cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.EdgeComparableDpKey" /></para>
      </exception>
      <seealso cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.NodeComparableDpKey" />
      <seealso cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.EdgeComparableDpKey" />
    </member>
    <member name="M:yWorks.Layout.NormalizeGraphElementOrderStage.FillComparableMapFromGraph(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataMap,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Assigns comparable values for each node and edge.</para>
      </summary>
      <remarks>
        <para>The compared values are induced from the current ordering of the nodes and edges within the given graph.</para>
        <para>This is a convenient method to fill the given <see cref="T:yWorks.Algorithms.IDataMap" />s which can then be registered with the graph with keys <see cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.NodeComparableDpKey" /> and <see cref="F:yWorks.Layout.NormalizeGraphElementOrderStage.EdgeComparableDpKey" /> and used for several layout calculations.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="comparableNodeMap">
        <para>the map that will be filled with comparable values for the nodes</para>
      </param>
      <param name="comparableEdgeMap">
        <para>the map that will be filled with comparable values for the edges</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Organic.ClassicOrganicLayout">
      <summary>
        <para>A layout algorithm that arranges graphs in an organic fashion, using a force-directed drawing approach.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>The organic layout style is characterized by a natural distribution of nodes. It is well suited to exhibit clusters and symmetric properties of a graph. Nodes are placed in a space-saving manner, close to their adjacent nodes. Distances between neighbors and edge lengths are highly uniform and edges are drawn as straight-line segments without bends.</para>
        <para>Organic diagrams are well suited for visualizing relations in large networks, for example, in bioinformatics, enterprise networking, social networks visualization, mesh visualization or system management.</para>
        <para> Organic layout obtained using default settings  Organic layout exposing symmetries of the graph structure <h2>Concept</h2></para>
        <para>This algorithm uses a force-directed approach to place the nodes of the input graph. The graph is modeled as a physical system with forces acting on it. Nodes are considered as electrically charged particles with mutually repulsive forces. Edges are modeled as springs that attract adjacent nodes. A good diagram is obtained from an equilibrium state of the system, i.e., the nodes are rearranged based on the physical forces until the system reaches a (local) minimum of the sum of the forces.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>The <see cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.ActivateTreeBeautifier">tree beautifier</see> feature activates a special layout style for subgraphs with a tree structure. These subgraphs will be arranged using an algorithm dedicated to tree graphs and incorporated into the main organic diagram.</para>
        <para>Several parameters for the internal force-directed drawing algorithm can be modified. For example, the <see cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.Repulsion">repulsion</see>, <see cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.Attraction">attraction</see> and <see cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.InitialTemperature">initial temperature</see> can be controlled. This allows experts to configure and fine-tune the algorithm with respect to their needs.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Organic.ClassicOrganicLayout.AffectedNodesDpKey">
      <summary>
        <para>A data provider key for marking the nodes that are part of the current scope.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.Scope" />
    </member>
    <member name="F:yWorks.Layout.Organic.ClassicOrganicLayout.FixedGroupNodesDpKey">
      <summary>
        <para>A data provider key for marking group nodes as fixed.</para>
      </summary>
      <remarks>
        <para>The content of a fixed group node will not be changed by this algorithm but be treated as fixed.</para>
        <para>The groups marked as fixed will be considered for the <see cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupNodePolicy">group node policy</see> settings <see cref="F:yWorks.Layout.Organic.GroupsPolicy.Fixed" /> and <see cref="F:yWorks.Layout.Organic.GroupsPolicy.Layout" />. When <see cref="F:yWorks.Layout.Organic.GroupsPolicy.Ignore" /> is chosen, the data provider registered with this key will be ignored.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupNodePolicy" />
      <seealso cref="F:yWorks.Layout.Organic.GroupsPolicy.Fixed" />
      <seealso cref="F:yWorks.Layout.Organic.GroupsPolicy.Layout" />
    </member>
    <member name="F:yWorks.Layout.Organic.ClassicOrganicLayout.PreferredEdgeLengthDpKey">
      <summary>
        <para>A data provider key for defining an individual preferred length for each edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Organic.ClassicOrganicLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Organic.ClassicOrganicLayout" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.MultiThreadingAllowed">
      <summary>
        <para>Gets or sets whether or not the layout algorithm may use multi-threading to reduce the running time.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if multi-threading is used, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.Repulsion">
      <summary>
        <para>Gets or sets the node repulsion value.</para>
      </summary>
      <remarks>
        <para>The repulsion influences the forces between nodes. A higher repulsion value can lead to more compact drawings, whereas a lower repulsion value potentially enlarges drawings.</para>
        <para>The repulsion is defined to range from <c>0</c> to <c>2</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the repulsion value is negative or greater than <c>2</c></para>
      </exception>
      <value>
        <para>the node repulsion value from the interval <c>[0,2]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.Attraction">
      <summary>
        <para>Gets or sets the edge attraction value.</para>
      </summary>
      <remarks>
        <para>The attraction influences the attractive force associated with edges. A higher attraction value can lead to more compact drawings, whereas a lower value potentially enlarges drawings.</para>
        <para>The attraction is defined to range from <c>0</c> to <c>2</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the attraction value is negative or greater than <c>2</c></para>
      </exception>
      <value>
        <para>the edge attraction value from the interval <c>[0,2]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupBoundsCalculator">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance used for calculating the size of group nodes.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupNodeCompactness">
      <summary>
        <para>Gets or sets the compactness of group nodes.</para>
      </summary>
      <remarks>
        <para>The compactness ranges from <c>0</c> to <c>1</c> where <c>0</c> results in group nodes not affecting the overall layout too much while <c>1</c> forces nodes in the same group to be clustered tightly.</para>
        <para>The compactness values needs to lie within <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if compactness value does not lie within the interval <c>[0,1]</c></para>
      </exception>
      <value>
        <para>the compactness value for group nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupNodePolicy">
      <summary>
        <para>Gets or sets the policy for the handling of group nodes.</para>
      </summary>
      <remarks>
        <para>The group policy defines whether this algorithm <see cref="F:yWorks.Layout.Organic.GroupsPolicy.Ignore">ignores</see> groups, leaves them <see cref="F:yWorks.Layout.Organic.GroupsPolicy.Fixed">fixed</see> or actively <see cref="F:yWorks.Layout.Organic.GroupsPolicy.Layout">arranges</see> them.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given policy is unknown</para>
      </exception>
      <value>
        <para>one of the predefined group node policies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.InitialTemperature">
      <summary>
        <para>Gets or sets the initial temperature for the force-directed layout process.</para>
      </summary>
      <remarks>
        <para>The algorithm starts with an initial temperature. During the iterations of the layout process, this temperature decreases and if it reaches a certain limit, the process terminates. This limit can be controlled using <see cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.FinalTemperature" />.</para>
        <para>The initial temperature will be multiplied by the <see cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.PreferredEdgeLength">preferred edge length</see> and then assigned as the actual initial heat of nodes.</para>
      </remarks>
      <value>
        <para>the initial temperature value</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.FinalTemperature" />
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.FinalTemperature">
      <summary>
        <para>Gets or sets the absolute, final temperature value, which will cause the algorithm to stop if the average temperature falls under this value.</para>
      </summary>
      <remarks>
        <para>The algorithm starts with an initial temperature. During the iterations of the layout process, this temperature decreases.</para>
      </remarks>
      <value>
        <para>the final temperature value</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.InitialTemperature" />
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.Deterministic">
      <summary>
        <para>Gets or sets whether or not the deterministic mode of the layout algorithm is enabled.</para>
      </summary>
      <remarks>
        <para>In deterministic mode, the layout algorithm will yield the same results if the exact same input and same settings are given as input.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the layout algorithm operates in deterministic mode, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.ActivateTreeBeautifier">
      <summary>
        <para>Gets or sets whether or not to arrange subtrees of the input graph in a special, optimized tree style.</para>
      </summary>
      <remarks>
        <para>Subtrees will be arranged in a <see cref="T:yWorks.Layout.Tree.BalloonLayout">balloon-like fashion</see>.</para>
        <para>If this feature is disabled, subgraphs with a tree structure are arranged using the same style as for the rest of the graph.</para>
        <para>In case that the input graph is a <see cref="M:yWorks.Algorithms.Trees.IsRootedTree(yWorks.Algorithms.Graph)">tree</see> and this feature is enabled, the whole graph will be drawn in a tree-like style.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if subtrees are arranged in an special way, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.GravityFactor">
      <summary>
        <para>Gets or sets the gravity factor whose magnitude determines the strength of the force towards the barycenter of the graph.</para>
      </summary>
      <remarks>
        <list type="bullet">
          <item>A high gravity factor value leads to layouts with nodes clustered around the barycenter of the graph.</item>
          <item>A low gravity factor value stretches the outskirts of the graph far away from the barycenter.</item>
        </list>
      </remarks>
      <value>
        <para>the gravity factor</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.Scope">
      <summary>
        <para>Gets or sets the scope that determines which nodes are placed by this algorithm.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given scope is unknown</para>
      </exception>
      <value>
        <para>one of the predefined scopes</para>
      </value>
      <seealso cref="F:yWorks.Layout.Organic.ClassicOrganicLayout.AffectedNodesDpKey" />
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.InitialPlacement">
      <summary>
        <para>Gets or sets the strategy for the initial placement of nodes.</para>
      </summary>
      <remarks>
        <para>The initial placement has an influence on the final result, because this force-directed algorithm starts with some positions and then uses forces between nodes to finally aim for a stable result drawing.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given initial placement mode is unknown</para>
      </exception>
      <value>
        <para>one of the predefined initial placement modes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.MaximumDuration">
      <summary>
        <para>Gets or sets the maximum duration in milliseconds that this layout algorithm is allowed to run.</para>
      </summary>
      <remarks>
        <para>The duration needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified duration has a negative value</para>
      </exception>
      <value>
        <para>the non-negative duration in milliseconds</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.IterationFactor">
      <summary>
        <para>Gets or sets the iteration factor which influences the maximum number of optimization iterations the algorithm may perform.</para>
      </summary>
      <value>
        <para>the iteration factor influencing the maximum number of allowed iterations</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.PreferredEdgeLength">
      <summary>
        <para>Gets or sets the default preferred edge length.</para>
      </summary>
      <remarks>
        <para>The default preferred edge length will be used for edges that don't have an individual length preference defined via a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Organic.ClassicOrganicLayout.PreferredEdgeLengthDpKey" />.</para>
        <para>The preferred edge length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified edge length is negative</para>
      </exception>
      <value>
        <para>the non-negative preferred edge length</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.ConsiderNodeSizes">
      <summary>
        <para>Gets or sets whether or not to consider node sizes during layout calculation.</para>
      </summary>
      <remarks>
        <para>If this feature is disabled, overlaps between nodes (e.g. due to large node sizes) may occur.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the sizes of nodes are taken into account, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ClassicOrganicLayout.OrientationLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of the layout is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that modifies the orientation is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="M:yWorks.Layout.Organic.ClassicOrganicLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates an organic arrangement of the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.ClassicOrganicLayout.Dispose">
      <summary>
        <para>Frees internal resources which were in use during a previous algorithm run.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Organic.InitialPlacement">
      <summary>
        <para>Enum constants that specify the initial placement for the <see cref="T:yWorks.Layout.Organic.ClassicOrganicLayout" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.InitialPlacement" />
    </member>
    <member name="F:yWorks.Layout.Organic.InitialPlacement.Random">
      <summary>
        <para>Initial placement strategy for starting with randomly chosen node locations.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.InitialPlacement" />
    </member>
    <member name="F:yWorks.Layout.Organic.InitialPlacement.Zero">
      <summary>
        <para>Initial placement strategy for starting with all node location coordinates set to <c>0</c>.</para>
        <para>This strategy is best if the initial placement should be maximally neutral, ignoring the existing layout of the input graph.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.InitialPlacement" />
    </member>
    <member name="F:yWorks.Layout.Organic.InitialPlacement.AsIs">
      <summary>
        <para>Initial placement strategy for starting with the node locations as they are in the input graph.</para>
        <para>This strategy is best if the existing layout should change as little as possible.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.InitialPlacement" />
    </member>
    <member name="T:yWorks.Layout.Organic.GroupsPolicy">
      <summary>
        <para>Enum constants that specify how groups are handled by the <see cref="T:yWorks.Layout.Organic.OrganicLayout" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupNodePolicy" />
    </member>
    <member name="F:yWorks.Layout.Organic.GroupsPolicy.Layout">
      <summary>
        <para>Group handling policy for considering and arranging the nodes contained in a group such that their togetherness is highlighted.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupNodePolicy" />
    </member>
    <member name="F:yWorks.Layout.Organic.GroupsPolicy.Fixed">
      <summary>
        <para>Group handling policy for keeping the relative positions of nodes that belong to the same group fixed.</para>
        <para>The fixed groups will be taken into account when placing the other nodes of the graph.</para>
        <para>By registering a <see cref="T:yWorks.Algorithms.IDataProvider" /> with key <see cref="F:yWorks.Layout.Organic.ClassicOrganicLayout.FixedGroupNodesDpKey" />, the individual group nodes can be marked as fixed or not fixed. If there is no data provider registered with the mentioned key, then all group nodes of the graph will be treated as fixed.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupNodePolicy" />
    </member>
    <member name="F:yWorks.Layout.Organic.GroupsPolicy.Ignore">
      <summary>
        <para>Group handling policy for completely ignoring group nodes during the layout process.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.GroupNodePolicy" />
    </member>
    <member name="T:yWorks.Layout.Organic.Scope">
      <summary>
        <para>Enum constants that specify the scope for the <see cref="T:yWorks.Layout.Organic.OrganicLayout" /> and <see cref="T:yWorks.Layout.Organic.ClassicOrganicLayout" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.Scope" />
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.Scope" />
    </member>
    <member name="F:yWorks.Layout.Organic.Scope.All">
      <summary>
        <para>Scope mode indicating that the algorithm should place <em>all</em> nodes of the graph.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.Scope" />
    </member>
    <member name="F:yWorks.Layout.Organic.Scope.MainlySubset">
      <summary>
        <para>Scope mode indicating that the algorithm should <em>mainly</em> place a subset of nodes.</para>
        <para>The subset is determined by a boolean value returned by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Organic.ClassicOrganicLayout.AffectedNodesDpKey" />. Nodes that don't belong to the subset may be moved to a certain degree but will keep their relative positions to the other nodes outside the subset.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.Scope" />
      <seealso cref="F:yWorks.Layout.Organic.ClassicOrganicLayout.AffectedNodesDpKey" />
    </member>
    <member name="F:yWorks.Layout.Organic.Scope.Subset">
      <summary>
        <para>Scope mode indicating that the algorithm should <em>only</em> place a subset of nodes.</para>
        <para>The subset is determined by a boolean value returned by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Organic.ClassicOrganicLayout.AffectedNodesDpKey" />. Nodes not being part of the subset will remain at their location.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ClassicOrganicLayout.Scope" />
      <seealso cref="F:yWorks.Layout.Organic.ClassicOrganicLayout.AffectedNodesDpKey" />
    </member>
    <member name="T:yWorks.Layout.Organic.HorizontalOverlapCriterion">
      <summary>
        <para>Enum constants that specify the Horizontal overlap criterion for the <see cref="T:yWorks.Layout.Organic.ShuffleLayout" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ShuffleLayout.HorizontalOverlapCriterion" />
    </member>
    <member name="F:yWorks.Layout.Organic.HorizontalOverlapCriterion.IntersectionBox">
      <summary>
        <para>Horizontal overlap criterion defining an overlap as horizontal if the overlapping area is greater in height than in width.</para>
        <para>Otherwise, if the overlap area's width is greater than or equal to its height, an overlap will be categorized as vertical.</para>
        <para>The area of an overlap is defined as the rectangle where two nodes intersect with each other.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ShuffleLayout.HorizontalOverlapCriterion" />
    </member>
    <member name="F:yWorks.Layout.Organic.HorizontalOverlapCriterion.NodeCenter">
      <summary>
        <para>Horizontal overlap criterion categorizing an overlap as horizontal if the center-to-center difference between the overlapping nodes is greater in horizontal direction (x-coordinates) than in vertical direction (y-coordinates).</para>
        <para>Otherwise, if the center-to-center difference between two overlapping nodes is greater in vertical direction (y-coordinates), the corresponding overlap is categorized as vertical. The same applies if the differences in vertical and horizontal direction are equal.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ShuffleLayout.HorizontalOverlapCriterion" />
    </member>
    <member name="F:yWorks.Layout.Organic.HorizontalOverlapCriterion.LessMovement">
      <summary>
        <para>Horizontal overlap criterion categorizing an overlap as horizontal if the required movement for solving the overlap is shorter in horizontal direction than in vertical direction.</para>
        <para>Otherwise, an overlap will be categorized as vertical.</para>
        <para>This criterion tries to avoid moving nodes too much because the direction for resolving overlaps will be chosen such that the shorter movement is preferred.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.ShuffleLayout.HorizontalOverlapCriterion" />
    </member>
    <member name="T:yWorks.Layout.Organic.ChainSubstructureStyle">
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ChainSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.ChainSubstructureStyle.None">
      <summary>
        <para>Substructure style specifier for chains that indicates that the algorithm does not handle such structures in a special way.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ChainSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.ChainSubstructureStyle.Rectangular">
      <summary>
        <para>Substructure style specifier for chains that leads to a compact (rotated) rectangular layout style for chains.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ChainSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.ChainSubstructureStyle.StraightLine">
      <summary>
        <para>Substructure style specifier for chains that leads to a straight-line layout style for chains.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ChainSubstructureStyle" />
    </member>
    <member name="T:yWorks.Layout.Organic.StarSubstructureStyle">
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.StarSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.StarSubstructureStyle.None">
      <summary>
        <para>Substructure style specifier for stars that indicates that the algorithm does not handle such structures in a special way.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.StarSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.StarSubstructureStyle.Radial">
      <summary>
        <para>Substructure style specifier for stars that leads to a radial layout style for stars where the root is placed in the middle.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.StarSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.StarSubstructureStyle.SeparatedRadial">
      <summary>
        <para>Substructure style specifier for stars that leads to a radial layout style for stars where the root is placed on the outside (separated from the nodes with degree one).</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.StarSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.StarSubstructureStyle.Circular">
      <summary>
        <para>Substructure style specifier for stars that leads to a circular layout style for stars where the root is placed in the middle. In contrast to the radial layout style, all nodes (except the root) are placed on a single cycle.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.StarSubstructureStyle" />
    </member>
    <member name="T:yWorks.Layout.Organic.ParallelSubstructureStyle">
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ParallelSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.ParallelSubstructureStyle.None">
      <summary>
        <para>Substructure style specifier for parallel structures that indicates that the algorithm does not handle such structures in a special way.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ParallelSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.ParallelSubstructureStyle.Rectangular">
      <summary>
        <para>Substructure style specifier for parallel structures that leads to a (rotated) rectangular layout style for the inner nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ParallelSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.ParallelSubstructureStyle.Radial">
      <summary>
        <para>Substructure style specifier for parallel structures that leads to a radial layout style for the inner nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ParallelSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.ParallelSubstructureStyle.StraightLine">
      <summary>
        <para>Substructure style specifier for parallel structures that places the inner nodes on a straight-line.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ParallelSubstructureStyle" />
    </member>
    <member name="T:yWorks.Layout.Organic.CycleSubstructureStyle">
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.CycleSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.CycleSubstructureStyle.None">
      <summary>
        <para>Substructure style specifier for cycle structures that indicates that the algorithm does not handle such structures in a special way.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.CycleSubstructureStyle" />
    </member>
    <member name="F:yWorks.Layout.Organic.CycleSubstructureStyle.Circular">
      <summary>
        <para>Substructure style specifier for cycle structures that leads to a circular layout style.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.CycleSubstructureStyle" />
    </member>
    <member name="T:yWorks.Layout.Organic.GroupNodeMode">
      <summary>
        <para>Enum constants that specify how group nodes are handled by the <see cref="T:yWorks.Layout.Organic.OrganicLayout" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Organic.GroupNodeMode.Normal">
      <summary>
        <para>A mode constant for placing and resizing the group nodes and their content by the layout algorithm. The size of the group is adjusted to the space that is needed by the placement of its contained nodes.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.GroupNodeModeDpKey" />
    </member>
    <member name="F:yWorks.Layout.Organic.GroupNodeMode.FixBounds">
      <summary>
        <para>A mode constant for placing the group nodes and their content with respect to the original bounds of the group node. The bounds of the group nodes are treated as fixed and cannot be exceeded by the content of the group nodes.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.GroupNodeModeDpKey" />
    </member>
    <member name="F:yWorks.Layout.Organic.GroupNodeMode.FixContents">
      <summary>
        <para>A mode constant for placing group nodes with fixed content. Although these particular group nodes can move like all other ordinary group nodes, their content remains fixed relative to the position of the group node.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.GroupNodeModeDpKey" />
    </member>
    <member name="T:yWorks.Layout.Organic.InteractiveOrganicLayout">
      <summary>
        <para>This algorithm arranges graphs in an organic fashion and offers special functionality to interact with the graph while the algorithm is running.</para>
      </summary>
      <remarks>
        <para>Besides the organic graph arrangement, this algorithm enables to immediately visualize changes made to a graph. Changes can be committed and the layout will be locally updated. That way, live interactions with an adapting graph layout are possible. Another advantage is that it is not necessary to compute a completely new layout if only small changes were made.</para>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>This algorithm supports the organic layout style which is characterized by a natural distribution of nodes. It is well suited to exhibit clusters and symmetric properties of a graph. Nodes are placed in a space-saving manner and distances between neighbors are highly uniform. Edges maintain uniform lengths too and are routed with straight-line segments without bends.</para>
        <para>Organic diagrams are well suited for visualizing relations in large networks, for example, in bioinformatics, enterprise networking, social networks visualization, mesh visualization or system management.</para>
        <para> Organic layout obtained using this algorithm <h2>Concept</h2></para>
        <para>The internal basis for computing actual layouts is a force-directed approach placing the nodes of the input graph. The graph is modeled as a physical system with appropriate forces acting on it. Nodes are considered as electrically charged particles with mutually repulsive forces. Edges are modeled as forces that attract adjacent nodes. A good diagram is obtained from an equilibrium state of the system, i.e., the nodes are rearranged based on the physical forces until the system reaches a (local) minimum of the sum of the forces.</para>
        <para>
          <see cref="T:yWorks.Layout.Organic.InteractiveOrganicLayout" /> is designed to run in a thread on its own. This allows for creating interactive user interfaces where the layout algorithm runs while users interact with the graph. The algorithm can then react to changes by immediately adapting the layout. <br /> However, the algorithm can also be executed in a single-threaded mode using <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayoutSingleThreaded(yWorks.Layout.LayoutGraph)" />. A <see cref="T:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext">Context</see> instance provides the necessary methods to control the layout calculation.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>Several update methods allow to indicate <em>lightweight</em> changes on the graph, for example, <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" /> for node location updates. These updates will be scheduled and executed at a specific point within the life-cycle of the layout algorithm. They are ideally suited for usage in interactive scenarios, where users, for example, change node positions via mouse-dragging.</para>
        <para>Method <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.AddStructureUpdate(System.EventHandler,System.EventArgs)" /> allows to schedule a custom <see cref="T:System.EventHandler" /> instance that is executed in a synchronized context and can safely update the structure of the graph.</para>
        <para>
          <h2>Usage Hints</h2>
        </para>
        <para>It is easiest to start the algorithm in its own thread using <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayout(yWorks.Layout.LayoutGraph)" />. Furthermore, it is strongly recommended to start it by passing a copy of the original graph (i.e. a <see cref="T:yWorks.Layout.CopiedLayoutGraph" /> instance) as parameter to the mentioned method.</para>
        <para>Importantly, <b>changes will not be automatically applied</b> to the input graph. Updates can be scheduled via various methods (e.g. <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" />). The whole layout will then internally be adjusted accordingly and changes are stored as intermediate results. Such intermediate results can be <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions">committed</see> in order to apply them to the actual graph.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.#ctor">
      <summary>
        <para>Creates a new instance of the <see cref="T:yWorks.Layout.Organic.InteractiveOrganicLayout" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.DisableAllStages">
      <summary>
        <para>Disables all predefined <see cref="T:yWorks.Layout.ILayoutStage" />s so that upon <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> only the internal organic layout algorithm will be executed.</para>
      </summary>
      <remarks>
        <para>This method is called upon construction of this class so that by default additional <see cref="T:yWorks.Layout.ILayoutStage" />s are deactivated. This method may be overridden if the additional stages should stay active (e.g. override the method and return silently).</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.MultiStageLayout.DisableAllStages" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates an organic layout for the given input graph, however, the layout is <b>not automatically applied</b> to the graph.</para>
      </summary>
      <remarks>
        <para>Changes have to be <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions">committed</see> to update the graph with the actual calculated positions.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayout(yWorks.Layout.LayoutGraph)" />
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayoutSingleThreaded(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Starts the <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">layout process</see> calculating an organic layout for the input graph in a new, separate <see cref="T:System.Threading.Thread" />.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>the <see cref="T:System.Threading.Thread" /> instance that has been created and started and in which the layout algorithm is running</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" />
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayoutSingleThreaded(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayoutSingleThreaded(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext">context object</see> that provides methods to <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext.StartLayout(System.Int64)">continue</see> and <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext.StopLayout">stop</see> the layout calculation for running this layout algorithm in a single-threaded environment.</para>
      </summary>
      <remarks>
        <para>
          <em>Usage:</em> Call <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext.StartLayout(System.Int64)">doLayout(long)</see> on the created instance to run the actual layout calculation for some specified period of time, whenever the layout should be recalculated. To actually transfer the changes, <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> should be called subsequently.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext">context instance</see> to control layout calculation</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext" />
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" />
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayout(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions">
      <summary>
        <para>Writes calculated intermediate locations of nodes and edges to the actual graph.</para>
      </summary>
      <remarks>
        <para>Update methods like <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" /> schedule changes which cause that the whole layout will internally be adjusted. All adjustments are stored as intermediate results. This method immediately transfers all these intermediate results to the actual input graph.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)">
      <summary>
        <para>Writes calculated intermediate locations of nodes and edges to the actual graph and returns the largest movement value.</para>
      </summary>
      <remarks>
        <para>Update methods like <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" /> schedule changes which cause that the whole layout will internally be adjusted. All adjustments are stored as intermediate results. This method smoothly transfers all these intermediate results to the actual input graph.</para>
        <para>Positions are, however, <b>not transferred directly</b> (use <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> if that is intended). Instead, the nodes are moved towards the calculated position. The movement is restricted to the given maximum distance.</para>
        <para>The movement will be calculated as <em>(movement) = (factor) * (distance between calculated and actual location)</em></para>
        <para>The returned largest movement can be used for estimating the difference between calculated layout and actual positions. If the return value is <c>0</c>, the calculated layout was completely transferred.</para>
      </remarks>
      <param name="maxMovement">
        <para>the maximum distance a node will be moved</para>
      </param>
      <param name="factor">
        <para>a factor that determines the node movement</para>
      </param>
      <returns>
        <para>the largest movement value or <c>0</c>, if the calculated layout has been transferred completely</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.WakeUp">
      <summary>
        <para>Wakes up the algorithm with the effect that it will restart/continue the layout calculation.</para>
      </summary>
      <remarks>
        <para>This method is useful if the layouter is <see cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Sleeping">sleeping</see> but should be notified of changes (e.g. due to user interaction).</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Sleeping" />
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.LastWakeupTime">
      <summary>
        <para>Gets the time when the last wake-up, that is, call to <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.WakeUp" />, occurred.</para>
      </summary>
      <remarks>
        <para>The time is defined in terms of the difference between the current time and midnight, January 1, 1970 UTC, measured in milliseconds.</para>
      </remarks>
      <value>
        <para>the time in milliseconds when the last call to <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.WakeUp" /> occurred</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.AddStructureUpdate(System.EventHandler,System.EventArgs)">
      <summary>
        <para>Schedules an update for the structure of the graph, which will automatically be executed at a later point in the life-cycle of this algorithm.</para>
      </summary>
      <remarks>
        <para>The given <see cref="T:System.EventHandler" /> will be queued and executed at a specific time. The <see cref="T:System.EventHandler" /> can make structural changes (e.g. removal/creation of edges or nodes). They will be synchronized with the rest of the layout algorithm.</para>
      </remarks>
      <param name="handler">
        <para>The handler delegate that will be invoked using <c>null</c> as the sender and <paramref name="args" /> as the event arguments</para>
      </param>
      <param name="args">
        <para>The event argument that will be piped to the <paramref name="handler" /> invocation.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.Stop">
      <summary>
        <para>Stops the layout algorithm.</para>
      </summary>
      <remarks>
        <para>In contrast to <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StopAndWait" />, the algorithm terminates immediately and will not wait until the ongoing layout calculation is finished.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Stopped" />
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StopAndWait" />
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Stopped">
      <summary>
        <para>Gets whether or not this layout algorithm has stopped.</para>
      </summary>
      <remarks>
        <para>If the algorithm has stopped, it terminated all its layout calculations. It is not <see cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Running">running</see> anymore and can not be restarted/continued by calling <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.WakeUp" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the layout algorithm has stopped, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Sleeping">
      <summary>
        <para>Gets whether or not this layout algorithm is currently sleeping.</para>
      </summary>
      <remarks>
        <para>Sleeping indicates that the algorithm has not <see cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Stopped">stopped</see> yet but is waiting (i.e. doing nothing). It can be notified to continue its work using <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.WakeUp" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this algorithm is currently sleeping, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.WakeUp" />
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Running">
      <summary>
        <para>Gets whether or not this layout algorithm is currently running.</para>
      </summary>
      <remarks>
        <para>The algorithm is running if the layout process is still active, the algorithm has not <see cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Stopped">stopped</see> yet and is not <see cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Sleeping">sleeping</see>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this algorithm is currently running, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.WorkingRatio">
      <summary>
        <para>Gets or sets the working ratio which defines the amount of processor time this algorithm tries to get.</para>
      </summary>
      <remarks>
        <para>A working ratio value of <c>1</c> means that the algorithm will try to run as fast as possible. Lower values will lead to small breaks after each internal round.</para>
        <para>The ratio needs to be a value in <c>(0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given ratio is not in <c>(0,1]</c>.</para>
      </exception>
      <value>
        <para>the working ratio value</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.PreferredEdgeLength">
      <summary>
        <para>Gets or sets the default preferred edge length.</para>
      </summary>
      <remarks>
        <para>This length does not define the actual absolute length of edges, but the layout algorithm considers the specified preference where possible.</para>
        <para>The preferred edge length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified edge length is negative</para>
      </exception>
      <value>
        <para>the preferred edge length</para>
      </value>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetPreferredEdgeLength(yWorks.Algorithms.Edge,System.Double)" />
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.PreferredNodeDistance">
      <summary>
        <para>Gets or sets the preferred distance between nodes.</para>
      </summary>
      <remarks>
        <para>The minimum node distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified minimum node distance is negative</para>
      </exception>
      <value>
        <para>the non-negative preferred distance between nodes</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetPreferredEdgeLength(yWorks.Algorithms.Edge,System.Double)">
      <summary>
        <para>Schedules an update for the preferred length of the given edge.</para>
      </summary>
      <remarks>
        <para>This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be committed to the graph while the algorithm is running using methods <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> or <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)" />.</para>
      </remarks>
      <param name="edge">
        <para>the edge whose preferred length should be updated</para>
      </param>
      <param name="newEdgeLength">
        <para>the new preferred edge length</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetInertia(yWorks.Algorithms.Node,System.Double)">
      <summary>
        <para>Schedules an update for the inertia of the given node.</para>
      </summary>
      <remarks>
        <para>The inertia is defined to be a value from the interval <c>[0,1]</c>.</para>
        <list type="bullet">
          <item>
            <c>1.0</c>: The node will not move.</item>
          <item>
            <c>0.5</c>: The node will only move half as far as it would with an inertia of <c>0.0</c>.</item>
          <item>
            <c>0.0</c>: The node will move as fast as possible.</item>
        </list>
        <para>This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be committed to the graph while the algorithm is running using methods <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> or <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)" />.</para>
      </remarks>
      <param name="node">
        <para>the node whose inertia to set</para>
      </param>
      <param name="inertia">
        <para>an inertia value between <c>0</c> and <c>1</c></para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given inertia value is negative or greater than <c>1</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)">
      <summary>
        <para>Schedules an update for the center location of the given node.</para>
      </summary>
      <remarks>
        <para>This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be committed to the graph while the algorithm is running using methods <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> or <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)" />.</para>
      </remarks>
      <param name="node">
        <para>the node that should be updated</para>
      </param>
      <param name="x">
        <para>the desired x-coordinate of the given node</para>
      </param>
      <param name="y">
        <para>the desired y-coordinate of the given node</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetRadius(yWorks.Algorithms.Node,System.Double)">
      <summary>
        <para>Schedules an update for the radius of the given node.</para>
      </summary>
      <remarks>
        <para>This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be committed to the graph while the algorithm is running using methods <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> or <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)" />.</para>
      </remarks>
      <param name="node">
        <para>the node whose radius should be updated</para>
      </param>
      <param name="radius">
        <para>the desired radius for the given node</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetStress(yWorks.Algorithms.Node,System.Double)">
      <summary>
        <para>Schedules an update for the stress value of the given node.</para>
      </summary>
      <remarks>
        <para>The stress value indicates how far a node will possibly move. The higher the stress of a node is, the farther it may move.</para>
        <para>This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be committed to the graph while the algorithm is running using methods <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> or <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)" />.</para>
        <para>The stress value is defined to be a value from the interval <c>[0,1]</c>.</para>
      </remarks>
      <param name="node">
        <para>the node whose stress value should be updated</para>
      </param>
      <param name="stress">
        <para>a stress value from the interval <c>[0,1]</c></para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given stress value is negative or greater than <c>1</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.GetStress(yWorks.Algorithms.Node)">
      <summary>
        <para>Polls the current stress value of a given node.</para>
      </summary>
      <remarks>
        <para>The stress value indicates how far a node will possibly move. The higher the stress of a node is, the farther it may move.</para>
        <para>The stress value is defined to be a value from the interval <c>[0,1]</c>.</para>
      </remarks>
      <param name="node">
        <para>the node for which the stress value should be polled</para>
      </param>
      <returns>
        <para>the stress value of the given node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetStress(yWorks.Algorithms.Node,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenterX(yWorks.Algorithms.Node,System.Double)">
      <summary>
        <para>Schedules an update for the center location's x-coordinate of the given node.</para>
      </summary>
      <remarks>
        <para>This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be committed to the graph while the algorithm is running using methods <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> or <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)" />.</para>
      </remarks>
      <param name="node">
        <para>the node that should be updated</para>
      </param>
      <param name="x">
        <para>the desired x-coordinate of the given node</para>
      </param>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenterY(yWorks.Algorithms.Node,System.Double)" />
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenterY(yWorks.Algorithms.Node,System.Double)">
      <summary>
        <para>Schedules an update for the center location's y-coordinate of the given node.</para>
      </summary>
      <remarks>
        <para>This method can be used while layout calculation is in progress (e.g. for interactive layout scenarios). However, the change will <b>not directly be applied</b> to the graph itself but only stored internally as an intermediate result. Scheduled updates can be committed to the graph while the algorithm is running using methods <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions" /> or <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositionsSmoothly(System.Double,System.Double)" />.</para>
      </remarks>
      <param name="node">
        <para>the node that should be updated</para>
      </param>
      <param name="y">
        <para>the desired y-coordinate of the given node</para>
      </param>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenterX(yWorks.Algorithms.Node,System.Double)" />
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.GetCenter(yWorks.Algorithms.Node)">
      <summary>
        <para>Polls the current coordinates of the center of the given node.</para>
      </summary>
      <remarks>
        <para>The returned coordinates do not necessarily correspond to the actual location of the node in the input graph. They may only be intermediate results stored in the algorithm. This will be the case if scheduled updates were not yet completely <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions">committed</see> to the actual graph.</para>
      </remarks>
      <param name="node">
        <para>the node for which the center should be polled</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Algorithms.Geometry.YPoint" /> representing the center location of the given node, or <c>null</c> if nothing about the node is known</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenter(yWorks.Algorithms.Node,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.GetCenterX(yWorks.Algorithms.Node)">
      <summary>
        <para>Polls the current x-coordinate of the center location of the given node.</para>
      </summary>
      <remarks>
        <para>The returned coordinate is not necessarily the actual x-coordinate of the node in the input graph but only an intermediate result stored in the algorithm. This will be the case if scheduled updates were not yet completely <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions">committed</see> to the actual graph.</para>
      </remarks>
      <param name="node">
        <para>the node for which the x-coordinate should be polled</para>
      </param>
      <returns>
        <para>the x-coordinate of the center location of the given node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenterX(yWorks.Algorithms.Node,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.GetCenterY(yWorks.Algorithms.Node)">
      <summary>
        <para>Polls the current y-coordinate of the center location of the given node.</para>
      </summary>
      <remarks>
        <para>The returned coordinate is not necessarily the actual y-coordinate of the node in the input graph but only an intermediate result stored in the algorithm. This will be the case if scheduled updates were not yet completely <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.CommitPositions">committed</see> to the actual graph.</para>
      </remarks>
      <param name="node">
        <para>the node for which the y-coordinate should be polled</para>
      </param>
      <returns>
        <para>the y-coordinate of the center location of the given node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SetCenterY(yWorks.Algorithms.Node,System.Double)" />
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.MaximumDuration">
      <summary>
        <para>Gets or sets the maximum duration in milliseconds that this algorithm is allowed to run.</para>
      </summary>
      <remarks>
        <para>The duration needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified maximum duration has a negative value</para>
      </exception>
      <value>
        <para>the maximum duration in milliseconds</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.QualityTimeRatio">
      <summary>
        <para>Gets or sets the ratio of layout quality versus running time.</para>
      </summary>
      <remarks>
        <para>The larger the ratio, the better the quality of the resulting layout but the longer it may take to perform the layout calculation.</para>
        <para>The value needs to lie within <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified ratio is outside the interval <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a value between <c>0.0</c> (low quality, fast) and <c>1.0</c> (high quality, slow)</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SyncStructure">
      <summary>
        <para>Synchronizes the structure of the graph copy with the original graph.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if the currently handled graph is not of type <see cref="T:yWorks.Layout.CopiedLayoutGraph" /></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.SyncStructure(System.Boolean)">
      <summary>
        <para>Synchronizes the structure of the graph copy with the original graph.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if the currently handled graph is not of type <see cref="T:yWorks.Layout.CopiedLayoutGraph" /></para>
      </exception>
      <param name="block" />
    </member>
    <member name="P:yWorks.Layout.Organic.InteractiveOrganicLayout.OutputRestriction">
      <summary>
        <para>Gets or sets an <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> which restricts the area for the layout result of this algorithm.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> instance for restricting the area of the layout</para>
      </value>
      <seealso cref="T:yWorks.Layout.Organic.OutputRestriction" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StopAndWait">
      <summary>
        <para>Stops a previously <see cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayout(yWorks.Layout.LayoutGraph)">started</see> algorithm and then blocks until the current layout calculation is completed.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.Stopped" />
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.Stop" />
    </member>
    <member name="T:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext" /> provides control over the layout calculation in the case of single-threaded algorithm execution.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Organic.InteractiveOrganicLayout.StartLayoutSingleThreaded(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext.StartLayout(System.Int64)">
      <summary>
        <para>Starts the layout calculation, continuing where it has stopped before and allowing a certain maximum duration in milliseconds.</para>
      </summary>
      <param name="duration">
        <para>the duration in milliseconds the layout calculation is allowed to run</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.InteractiveOrganicLayout.ISingleThreadContext.StopLayout">
      <summary>
        <para>Stops the layout calculation.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Organic.OrganicLayout">
      <summary>
        <para>This layout algorithm arranges graphs in an organic fashion.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The organic layout style is characterized by a natural distribution of nodes that exhibits clusters and symmetric properties of the graph. Nodes are placed space-saving, close to their adjacent nodes. Edges maintain uniform lengths and are routed with straight-line segments without bends.</para>
        <para>Organic diagrams are commonly used for visualizing relations in large networks for example in bioinformatics, enterprise networking, visualizing social networks, mesh visualization or system management.</para>
        <para> Organic Layout obtained with default settings  Organic Layout exhibiting symmetric properties <h2>Concept</h2> <see cref="T:yWorks.Layout.Organic.OrganicLayout" /> uses a force-directed approach to place the nodes of the input graph. According to this approach, the graph is modeled as a physical system with appropriate forces acting on it. Nodes are considered as electrically charged particles with mutually repulsive forces. Edges are modeled as springs that attract adjacent nodes. A good diagram is obtained from an equilibrium state of the system, i.e., the nodes are rearranged based on the physical forces until the system reaches a (local) minimum of the sum of the forces. <h2>Features</h2></para>
        <para>The ratio between the layout quality and the running time is conveniently adjustable. Another way to decrease the running time is to execute the layout algorithm <see cref="P:yWorks.Layout.Organic.OrganicLayout.MultiThreadingAllowed">multi-threaded</see>.</para>
        <para>This layout algorithm is able to consider a <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> structure. However, for common nodes (i.e. non-group nodes) it only considers single partition cells. Furthermore, the layout algorithm will throw a <see cref="T:yWorks.Algorithms.InvalidGraphStructureException" /> if there is a partition grid and the descendants of a group node are assigned to different partition grid cells or if there are group nodes that are associated with a group node mode other than <see cref="F:yWorks.Layout.Organic.GroupNodeMode.Normal" />.</para>
        <para>Although overlaps between edges and nodes are avoided, this layout algorithm doesn't guarantee that they won't appear in the resulting layout. To avoid overlaps, it is possible to route the edges afterwards using an edge routing algorithm, e.g., <see cref="T:yWorks.Layout.Router.OrganicEdgeRouter" />.</para>
        <para>The algorithm is also able to detect certain types of substructures in a graph (i.e., <see cref="P:yWorks.Layout.Organic.OrganicLayout.ChainSubstructureStyle">chains</see>, <see cref="P:yWorks.Layout.Organic.OrganicLayout.StarSubstructureStyle">stars</see>, <see cref="P:yWorks.Layout.Organic.OrganicLayout.CycleSubstructureStyle">cycles</see> and <see cref="P:yWorks.Layout.Organic.OrganicLayout.ParallelSubstructureStyle">parallel structures</see>) and arrange these structures with special-purpose layout styles. Using substructure styles ensures that the corrsponding structures are easily recognized in the graph.</para>
        <para> Organic Layout without applying specific layout styles to substructures  Organic Layout of the same graph applying specific layout styles to the detected substructures</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Organic.OrganicLayout.EdgeDirectednessDpKey">
      <summary>
        <para>A data provider key for specifying the directedness of edges.</para>
      </summary>
      <remarks>
        <para>Generally, the organic layout algorithm doesn't consider the edge direction. Nevertheless, this <see cref="T:yWorks.Algorithms.IDataProvider" /> allows the user to specify hints on the directedness of edges. More precisely, a value of <c>1</c> indicates that the edge should be considered to be directed from source to target, a value of <c>-1</c> that it is directed from target to source, and a value of <c>0</c> means that it is undirected.</para>
        <para>Currently, the specified values are only considered during the detection of special substructures, see <see cref="P:yWorks.Layout.Organic.OrganicLayout.ChainSubstructureStyle" />, <see cref="P:yWorks.Layout.Organic.OrganicLayout.CycleSubstructureStyle" />, <see cref="P:yWorks.Layout.Organic.OrganicLayout.ParallelSubstructureStyle" /> and <see cref="P:yWorks.Layout.Organic.OrganicLayout.StarSubstructureStyle" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Organic.OrganicLayout.AffectedNodesDpKey">
      <summary>
        <para>A data provider key for marking the nodes that are part of the relevant subset.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.Scope" />
    </member>
    <member name="F:yWorks.Layout.Organic.OrganicLayout.GroupNodeModeDpKey">
      <summary>
        <para>A data provider key for assigning individual modes for all group nodes.</para>
      </summary>
      <remarks>
        <para>The modes specify how a group's content is handled and if it is resized during layout calculation.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Organic.OrganicLayout.PreferredEdgeLengthDpKey">
      <summary>
        <para>A data provider key for defining an individual preferred length for each edge.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.MultiThreadingAllowed">
      <summary>
        <para>Gets or sets whether or not the layout algorithm may use multi-threading to reduce the running time.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if multi-threading is used, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.GroupNodeCompactness">
      <summary>
        <para>Gets or sets the compactness of group nodes.</para>
      </summary>
      <remarks>
        <para>The compactness ranges from <c>0</c> to <c>1</c> where <c>0</c> results in group nodes not affecting the overall layout too much while <c>1</c> forces nodes in the same group to be clustered tightly.</para>
        <para>The values need to lie in <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if specified compactness value is outside the interval <c>[0,1]</c></para>
      </exception>
      <value>
        <para>groupNodeCompactness the compactness value for group nodes</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.AutomaticGroupNodeCompaction" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.AutomaticGroupNodeCompaction">
      <summary>
        <para>Gets or sets whether or not group nodes are compacted automatically.</para>
      </summary>
      <remarks>
        <para>When enabled, the compactness factor is determined automatically, i.e. it only depends on the general compactness specified by option <see cref="P:yWorks.Layout.Organic.OrganicLayout.CompactnessFactor" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if automatic group node compaction is enabled, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.GroupNodeCompactness" />
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.CompactnessFactor" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.ClusterNodes">
      <summary>
        <para>Gets or sets whether or not a clustering algorithm should be applied to the input graph.</para>
      </summary>
      <remarks>
        <para>When this option is enabled, the following steps are performed during the layout:</para>
        <list type="number">
          <item>A clustering algorithm is applied to the input graph.</item>
          <item>All nodes of the same cluster are put into a newly created group node.</item>
          <item>The layout is applied to the modified graph.</item>
          <item>Group nodes denoting clusters (inserted during step <c>2</c>) are removed.</item>
        </list>
        <para>The user can also specify customized clusters by defining appropriate groups.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if a clustering algorithm is used, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.MaximumDuration" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.ClusteringQuality">
      <summary>
        <para>Gets or sets the quality measure of the clustering algorithm.</para>
      </summary>
      <remarks>
        <para>The higher the value, the higher the clustering quality.</para>
        <para>The value needs to lie in <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified quality measure is outside the interval <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a value from interval <c>[0,1]</c></para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.ClusterNodes" />
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.MaximumDuration" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not to reserve space for node labels during layout calculation.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the labels of nodes are taken into account, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Organic.OrganicLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.GroupBoundsCalculator">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance used for calculating the size of group nodes.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.SmartComponentLayout">
      <summary>
        <para>Gets or sets whether or not this instance should configure the <see cref="T:yWorks.Layout.ComponentLayout" /> to respect subsets of nodes.</para>
      </summary>
      <remarks>
        <para>When only a subset of nodes is placed by the layout algorithm, the fixed nodes will keep their locations even if they reside in different components.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if <see cref="T:yWorks.Layout.ComponentLayout" /> should be configured for subsets, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.Scope" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.NodeEdgeOverlapAvoided">
      <summary>
        <para>Gets or sets whether or not the layout algorithm tries to avoid node/edge overlaps.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the layout algorithm tries to avoid node/edge overlaps, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.NodeOverlapsAllowed" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.OrientationLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of the layout is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that modifies the orientation is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicLayout.configureComponentLayout(yWorks.Layout.LayoutGraph,yWorks.Layout.ComponentLayout)">
      <summary>
        <para>Configures the given <see cref="T:yWorks.Layout.ComponentLayout" /> to take fixed nodes in components into account.</para>
      </summary>
      <remarks>
        <para>Components that contain fixed nodes will not be rearranged.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Organic.OrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the actual layout is calculated. It may be overridden in order to manually configure the <see cref="T:yWorks.Layout.ComponentLayout" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layouter">
        <para>the <see cref="T:yWorks.Layout.ComponentLayout" /> instance to reconfigure</para>
      </param>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.SmartComponentLayout" />
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates an organic arrangement of the graph.</para>
      </summary>
      <remarks>
        <para>In contrast to <see cref="M:yWorks.Layout.Organic.OrganicLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" />, graph and layouter are prepared for an independent layout run.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicLayout.DisposeComponentLayout(yWorks.Layout.LayoutGraph,yWorks.Layout.ComponentLayout)">
      <summary>
        <para>Disposes of the <see cref="T:yWorks.Layout.ComponentLayout" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Organic.OrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> after the actual layout is calculated. It may be overridden in order to revert a custom configuration made in <see cref="M:yWorks.Layout.Organic.OrganicLayout.configureComponentLayout(yWorks.Layout.LayoutGraph,yWorks.Layout.ComponentLayout)" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="layouter">
        <para>the <see cref="T:yWorks.Layout.ComponentLayout" /> to reset</para>
      </param>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.SmartComponentLayout" />
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates an organic arrangement of the graph.</para>
      </summary>
      <remarks>
        <para>In contrast to <see cref="M:yWorks.Layout.Organic.OrganicLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" />, graph and algorithm are not prepared specifically. This method should only be called directly when using <see cref="T:yWorks.Layout.Organic.OrganicLayout" /> as a <see cref="T:yWorks.Layout.ILayoutStage" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.QualityTimeRatio">
      <summary>
        <para>Gets or sets the ratio of layout quality versus running time.</para>
      </summary>
      <remarks>
        <para>The larger the ratio, the better the quality of the resulting layout but the longer it may take to perform the layout calculation.</para>
        <para>The value needs to lie within <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified ratio is outside the interval <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a value between <c>0.0</c> (low quality, fast) and <c>1.0</c> (high quality, slow)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.MaximumDuration">
      <summary>
        <para>Gets or sets the maximum duration in milliseconds that this layout algorithm is allowed to run.</para>
      </summary>
      <remarks>
        <para>The duration needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified duration has a negative value</para>
      </exception>
      <value>
        <para>a non-negative duration in milliseconds</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.Scope">
      <summary>
        <para>Gets or sets the scope that determines which nodes are placed by this algorithm.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given scope is unknown</para>
      </exception>
      <value>
        <para>one of the predefined scopes</para>
      </value>
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.AffectedNodesDpKey" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.ChainSubstructureStyle">
      <summary>
        <para>Gets or sets the style specifier for chain substructures.</para>
      </summary>
      <remarks>
        <para>A chain is a simple edge path where the degree of the nodes is less than or equal to <c>2</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given style is unknown</para>
      </exception>
      <value>
        <para>one of the predefined styles for chain substructures</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.Scope" />
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.EdgeDirectednessDpKey" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.CycleSubstructureStyle">
      <summary>
        <para>Gets or sets the style specifier for cycle substructures.</para>
      </summary>
      <remarks>
        <para>A cycle is a simple edge path where the first and last node are identical. The algorithm only considers cycles where the number of edges connecting nodes of the cycle with the remaining nodes is less than or equal to <c>2</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given style is unknown</para>
      </exception>
      <value>
        <para>one of the predefined styles for cycle substructures</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.Scope" />
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.EdgeDirectednessDpKey" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.ParallelSubstructureStyle">
      <summary>
        <para>Gets or sets the style specifier for parallel substructures.</para>
      </summary>
      <remarks>
        <para>A parallel structure consists of a set of nodes (called the inner nodes) such that all nodes have degree two and are connected to the same pair of neighbors (called the outer nodes).</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given style is unknown</para>
      </exception>
      <value>
        <para>one of the predefined styles for parallel substructures</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.Scope" />
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.EdgeDirectednessDpKey" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.StarSubstructureStyle">
      <summary>
        <para>Gets or sets the style specifier for star substructures.</para>
      </summary>
      <remarks>
        <para>A star consists of a set of degree one nodes that are all connected to the same node (called the root of the star).</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given style is unknown</para>
      </exception>
      <value>
        <para>one of the predefined styles for star substructures</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.Scope" />
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.EdgeDirectednessDpKey" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.CompactnessFactor">
      <summary>
        <para>Gets or sets the compactness factor for the layout algorithm.</para>
      </summary>
      <remarks>
        <para>Smaller values result in less compact drawings, greater values result in more compact drawings.</para>
        <para>The compactness value needs to lie in <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is outside the interval <c>[0,1]</c></para>
      </exception>
      <value>
        <para>the compactness value in <c>[0,1]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.PreferredEdgeLength">
      <summary>
        <para>Gets or sets the default preferred edge length.</para>
      </summary>
      <remarks>
        <para>If there is no specific preferred edge length assigned to an edge, this default preferred edge length is used.</para>
        <para>The preferred edge length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified edge length is negative</para>
      </exception>
      <value>
        <para>a non-negative edge length</para>
      </value>
      <seealso cref="F:yWorks.Layout.Organic.OrganicLayout.PreferredEdgeLengthDpKey" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.PreferredMinimumNodeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum preferred distance between nodes and edges when node-edge overlaps are not allowed.</para>
      </summary>
      <remarks>
        <para>The minimum preferred distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>a non-negative minimum preferred distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.ConsiderNodeSizes">
      <summary>
        <para>Gets or sets whether or not to consider node sizes during layout calculation.</para>
      </summary>
      <remarks>
        <para>If this option is enabled, the circumcircles of the nodes are used. If it is disabled, points will be used instead.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the sizes of nodes are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.Deterministic">
      <summary>
        <para>Gets or sets whether or not the deterministic mode of this algorithm is enabled.</para>
      </summary>
      <remarks>
        <para>In deterministic mode, the layout algorithm will yield the same results if the exact same input and same settings are given as input.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this algorithm works deterministically, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the minimum node distance that this algorithm should enforce between all pairs of nodes.</para>
      </summary>
      <remarks>
        <para>The minimum node distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified minimum node distance is negative</para>
      </exception>
      <value>
        <para>a non-negative minimum distance between nodes that are not connected by an edge</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.NodeOverlapsAllowed" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.NodeOverlapsAllowed">
      <summary>
        <para>Gets or sets whether or not overlaps between nodes are allowed.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node overlaps are allowed, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.MinimumNodeDistance" />
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.Scope" />
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicLayout.OutputRestriction">
      <summary>
        <para>Gets or sets the area restriction for the result of the layout algorithm.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Organic.OutputRestriction" /></para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Organic.OrganicPartitionGridLayoutStage">
      <summary>
        <para>This layout stage enables support for handling a graph with a <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> structure.</para>
      </summary>
      <remarks>
        <para>
          <h2>Concept</h2>
        </para>
        <para>Before executing the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>, this stage prepares the grid structure of the graph accordingly, e.g., by hiding top-level grid nodes. Then, the core layout algorithm is applied to the graph. Finally, the grid is restored, configured and positioned such that it is consistent with the layout computed by the core algorithm.</para>
        <para>Information about the <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> structure is retrieved from a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph using key <see cref="F:yWorks.Layout.Grid.PartitionGrid.PartitionGridDpKey" />.</para>
        <para>
          <h2>Usage</h2>
        </para>
        <para>When using <see cref="T:yWorks.Layout.Organic.OrganicLayout" />, this stage will automatically be used, if required. It is not necessary to append this stage manually to <see cref="T:yWorks.Layout.Organic.OrganicLayout" />.</para>
        <para>Appending this stage can be useful to add support for <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see> structures to other <see cref="T:yWorks.Layout.ILayoutAlgorithm" />s.</para>
        <para>The stage can be appended to all algorithms of type <see cref="T:yWorks.Layout.MultiStageLayout" /> by using method <see cref="M:yWorks.Layout.MultiStageLayout.AppendStage(yWorks.Layout.ILayoutStage)" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Grid.PartitionGrid" />
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicPartitionGridLayoutStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Organic.OrganicPartitionGridLayoutStage" /> with the given layout algorithm as <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>the core layout algorithm</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicPartitionGridLayoutStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates the layout according to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>, while considering an existing <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see> structure defined for the graph.</para>
      </summary>
      <remarks>
        <para>If there is no <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> defined for the graph, only the core layout algorithm will be executed.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <exception cref="T:yWorks.Algorithms.InvalidGraphStructureException">
        <para>if the graph has group nodes whose content spans multiple grid cells or if the associated <see cref="F:yWorks.Layout.Organic.OrganicLayout.GroupNodeModeDpKey">group node mode data</see> is equal to <see cref="F:yWorks.Layout.Organic.GroupNodeMode.FixContents" /> or <see cref="F:yWorks.Layout.Organic.GroupNodeMode.FixBounds" />.</para>
      </exception>
    </member>
    <member name="T:yWorks.Layout.Organic.OrganicRemoveOverlapsStage">
      <summary>
        <para>This layout stage removes node overlaps while changes to the original layout structure are avoided and a specified minimum node distance is guaranteed.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>Unlike the overlap removal approach implemented by <see cref="T:yWorks.Layout.Organic.RemoveOverlapsStage" />, this stage tries to keep the original layout structure, i.e., it tries to keep the geometric distances between the nodes.</para>
        <para>The strategy for removing overlaps is similar to the layout strategy used by organic (force-directed) layout algorithms (e.g. <see cref="T:yWorks.Layout.Organic.OrganicLayout" />). Therefore, this stage is especially well suited to remove node overlaps in undirected graph drawings with straight-line edges, as produced by organic layout approaches.</para>
        <para> A graph containing overlaps (left) and the result after applying this layout stage <h2>Features</h2></para>
        <para>It is possible to define a <see cref="P:yWorks.Layout.Organic.OrganicRemoveOverlapsStage.MinimumNodeDistance">minimum distance</see> between nodes. This feature allows to not only remove overlaps but forces nodes to keep the specified distance to other nodes.</para>
        <para>Nodes can be marked as <em>fixed</em>. Such nodes will not be moved during the overlap removal process. A <see cref="T:yWorks.Algorithms.IDataProvider" /> with key <see cref="F:yWorks.Layout.Organic.OrganicRemoveOverlapsStage.FixedNodeDpKey" /> can be registered to mark the fixed nodes.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Organic.OrganicRemoveOverlapsStage.FixedNodeDpKey">
      <summary>
        <para>A data provider key for marking nodes as fixed.</para>
      </summary>
      <remarks>
        <para>A node marked as fixed will not be moved by this algorithm but stay at its current position.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicRemoveOverlapsStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Organic.OrganicRemoveOverlapsStage" /> with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicRemoveOverlapsStage.MaximumDuration">
      <summary>
        <para>Gets or sets the maximum duration in milliseconds that this layout stage is allowed to run.</para>
      </summary>
      <remarks>
        <para>This maximum time does not include the time required for the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
        <para>The duration needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified duration has a negative value</para>
      </exception>
      <value>
        <para>the non-negative maximum duration in milliseconds</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.OrganicRemoveOverlapsStage.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance to be kept between any two nodes of the graph.</para>
      </summary>
      <remarks>
        <para>Due to this distance not only nodes that overlap will be moved to resolve the overlap, but also nodes which are too close to each other with respect to this distance will be displaced.</para>
        <para>The distance needs to be a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum node distance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Organic.OrganicRemoveOverlapsStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Removes node overlaps and displaces nodes of the given graph such that they keep the specified <see cref="P:yWorks.Layout.Organic.OrganicRemoveOverlapsStage.MinimumNodeDistance">minimum distance</see> to each other.</para>
      </summary>
      <remarks>
        <para>If a <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> is specified, it will be executed first.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Organic.OutputRestriction">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Organic.OutputRestriction" />s restrict the output area and the shape of a layout in conjunction with organic layout algorithms such as <see cref="T:yWorks.Layout.Organic.OrganicLayout" /> or <see cref="T:yWorks.Layout.Organic.InteractiveOrganicLayout" />.</para>
      </summary>
      <remarks>
        <para>In consequence, all nodes need to be placed inside a specific restricted area.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.OutputRestriction" />
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.OutputRestriction" />
    </member>
    <member name="F:yWorks.Layout.Organic.OutputRestriction.None">
      <summary>
        <para>This <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> does not restrict the output by any means.</para>
      </summary>
      <remarks>
        <para>It is a no-op that can be used when the output area and shape of a layout should be unrestricted.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.OutputRestriction" />
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.OutputRestriction" />
    </member>
    <member name="M:yWorks.Layout.Organic.OutputRestriction.CreateRectangularCageRestriction(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> that confines the layout to a rectangular area.</para>
      </summary>
      <remarks>
        <para>This <em>restriction rectangle</em> is defined by the given coordinates and size values.</para>
        <para>The values for height and width of the rectangle need to be greater than zero.</para>
      </remarks>
      <param name="x">
        <para>the x-coordinate of the restriction rectangle's upper-left corner</para>
      </param>
      <param name="y">
        <para>the y-coordinate of the restriction rectangle's upper-left corner</para>
      </param>
      <param name="w">
        <para>width of the restriction rectangle</para>
      </param>
      <param name="h">
        <para>height of the restriction rectangle</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> confining the layout to a rectangular area</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given width or height is less than or equal to zero</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.OutputRestriction" />
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.OutputRestriction" />
    </member>
    <member name="M:yWorks.Layout.Organic.OutputRestriction.CreateCircularCageRestriction(System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> that confines the layout result to a circle.</para>
      </summary>
      <remarks>
        <para>The actual <em>restriction circle</em> is defined by the given coordinates and radius.</para>
        <para>The radius of the restriction circle needs to be greater than zero.</para>
      </remarks>
      <param name="x">
        <para>the x-coordinate of the restriction circle's center</para>
      </param>
      <param name="y">
        <para>the y-coordinate of the restriction circle's center</para>
      </param>
      <param name="radius">
        <para>the radius of the restriction circle</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> confining the layout to a circular area</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given radius is less than or equal to zero</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.OutputRestriction" />
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.OutputRestriction" />
    </member>
    <member name="M:yWorks.Layout.Organic.OutputRestriction.CreateEllipticalCageRestriction(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> that confines the layout result to an elliptical area.</para>
      </summary>
      <remarks>
        <para>The <em>restriction ellipse</em> is defined by its bounding box specified by the given coordinates and size values.</para>
        <para>The main axes of the ellipse are parallel to the coordinate axes.</para>
        <para>The values for height and width of the ellipse's bounding box need to be greater than zero.</para>
      </remarks>
      <param name="x">
        <para>the x-coordinate of the bounding box's upper left corner</para>
      </param>
      <param name="y">
        <para>the y-coordinate of the bounding box's upper left corner</para>
      </param>
      <param name="w">
        <para>the width of the bounding box</para>
      </param>
      <param name="h">
        <para>the height of the bounding box</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> confining the layout to an elliptical area</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given width or height is <c>0</c> or negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.OutputRestriction" />
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.OutputRestriction" />
    </member>
    <member name="M:yWorks.Layout.Organic.OutputRestriction.CreateAspectRatioRestriction(System.Double)">
      <summary>
        <para>Creates an <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> that confines the layout result to a rectangular area which roughly complies with the given <em>aspect ratio</em>.</para>
      </summary>
      <remarks>
        <para>The aspect ratio is defined as the ratio between the width and the height of a layout.</para>
        <list type="bullet">
          <item>aspect ratio 1: width and height of the layout should be equal</item>
          <item>aspect ratio between 0 and 1: the height of a layout should be greater than its width</item>
          <item>aspect ratio larger than 1: the width of a layout should be greater than its height</item>
        </list>
        <para>The aspect ratio needs to be strictly positive.</para>
      </remarks>
      <param name="ratio">
        <para>the preferred aspect ratio of the output</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Organic.OutputRestriction" /> imposing the given aspect ratio on the layout</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given aspect ratio is <c>0</c> or negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Organic.OrganicLayout.OutputRestriction" />
      <seealso cref="P:yWorks.Layout.Organic.InteractiveOrganicLayout.OutputRestriction" />
    </member>
    <member name="T:yWorks.Layout.Organic.RecursiveShuffleLayout">
      <summary>
        <para>This algorithm recursively removes node overlaps from a graph with a hierarchic group structure.</para>
      </summary>
      <remarks>
        <para>Basically, this algorithm combines a <see cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" /> with a specific customizable <see cref="P:yWorks.Layout.Organic.RecursiveShuffleLayout.ShuffleLayout">shuffle algorithm</see> as its <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. The shuffle algorithm will be recursively applied to all groups of the input graph to remove node overlaps.</para>
        <para> Input graph (left) and result (right) after executing this algorithm with default settings</para>
        <para>Since this algorithm is a <see cref="T:yWorks.Layout.ILayoutStage" />, a <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> can be specified. In consequence, this algorithm will perform its work after the core algorithm was executed.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Organic.ShuffleLayout" />
      <seealso cref="T:yWorks.Layout.Grouping.RecursiveGroupLayout" />
    </member>
    <member name="M:yWorks.Layout.Organic.RecursiveShuffleLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Organic.RecursiveShuffleLayout" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Organic.RecursiveShuffleLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Removes all node overlaps in the given graph, after executing the specified <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Organic.RecursiveShuffleLayout.GroupBoundsCalculator">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance that computes the sizes of all group nodes.</para>
      </summary>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Grouping.IGroupBoundsCalculator" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.RecursiveShuffleLayout.ShuffleLayout">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> instance that is used for removing node overlaps.</para>
      </summary>
      <remarks>
        <para>This instance will be applied recursively to all group nodes of the graph.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> instance for removing node overlaps</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Organic.RemoveOverlapsStage">
      <summary>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> removes node overlaps and guarantees a certain minimum distance between nodes.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> This stage only removes overlaps between nodes of the input graph. To do so, overlapping nodes will be moved apart. Results often look like a <em>stretched</em> version of the original graph.  A graph containing overlaps (left) and the result after the overlap removal <h2>Features</h2></para>
        <para>It is possible to define a <see cref="P:yWorks.Layout.Organic.RemoveOverlapsStage.MinimumNodeDistance">minimum distance</see> between nodes. This feature allows to not only remove overlaps but forces nodes to keep a specified distance to other nodes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Organic.RemoveOverlapsStage.#ctor(System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Organic.RemoveOverlapsStage" /> instance with a given <see cref="P:yWorks.Layout.Organic.RemoveOverlapsStage.MinimumNodeDistance">minimum node distance</see>.</para>
      </summary>
      <remarks>
        <para>The minimum node distance needs to be non-negative.</para>
      </remarks>
      <param name="minimumNodeDistance">
        <para>a non-negative minimum distance value</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given distance is negative</para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.Organic.RemoveOverlapsStage.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance to be kept between any two nodes of the graph.</para>
      </summary>
      <remarks>
        <para>Due to this distance not only nodes that overlap will be moved to resolve the overlap, but also nodes which are too close to each other with respect to this distance will be displaced.</para>
        <para>The minimum node distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum node distance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Organic.RemoveOverlapsStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Removes node overlaps and displaces nodes of the given graph such that they keep the specified <see cref="P:yWorks.Layout.Organic.RemoveOverlapsStage.MinimumNodeDistance">minimum distance</see> to each other.</para>
      </summary>
      <remarks>
        <para>If a <see cref="P:yWorks.Layout.Organic.RemoveOverlapsStage.CoreLayout">core layout algorithm</see> is specified, it will be executed first.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Organic.ShuffleLayout">
      <summary>
        <para>This layout algorithm removes overlaps between nodes in a graph.</para>
      </summary>
      <remarks>
        <para>
          <em>Note:</em> The usage of <see cref="T:yWorks.Layout.Organic.RemoveOverlapsStage" /> instead of this class is recommended for most use cases involving the mere removal of overlaps. That stage offers a more powerful strategy to do the task.</para>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>The style of results often resembles the look of tiles which have been dropped onto each other, where tiles correspond to nodes of the graph. The reason is that overlapping nodes are moved in order to resolve the overlap. During this process, several nodes moving in the same direction may be stacked next to or above each other.</para>
        <para>This algorithm does not route the edges of the input graph - edges might although be stretched due to the node movement.</para>
        <para> Example with overlaps (left) and after executing the shuffle layout (right)  Example with overlaps (left) and after executing the shuffle layout (right) <h2>Concept</h2> Nodes overlapping with other nodes will be moved in horizontal or vertical direction in order to remove overlaps. The concept behind this removal step is based on a famous Russian arcade game. <h2>Features</h2></para>
        <para>This layout stage can also be <see cref="M:yWorks.Layout.Organic.ShuffleLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">executed</see> on its own, without specifying a <see cref="P:yWorks.Layout.Organic.ShuffleLayout.CoreLayout">core layout algorithm</see>.</para>
        <para>A minimum distance between nodes can be specified such that not only overlaps will be removed but nodes will keep this specified distance to other nodes. This distance can be defined separately for each node using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Organic.ShuffleLayout.MinimumDistanceDpKey" />. The minimum distance can also be specified globally via <see cref="P:yWorks.Layout.Organic.ShuffleLayout.MinimumNodeDistance" />.</para>
        <para>To specify that specific nodes should not be moved, they can be marked as fixed using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Organic.ShuffleLayout.FixedNodeDpKey" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Organic.ShuffleLayout.MinimumDistanceDpKey">
      <summary>
        <para>A data provider key for specifying a minimum distance for each node.</para>
      </summary>
      <remarks>
        <para>The default minimum distance specified by <see cref="P:yWorks.Layout.Organic.ShuffleLayout.MinimumNodeDistance" /> will be ignored for a node if the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key contains a valid minimum distance for that node.</para>
        <para>Minimum distance values need to be greater than <c>0</c>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Organic.ShuffleLayout.FixedNodeDpKey">
      <summary>
        <para>A data provider key for marking nodes as fixed.</para>
      </summary>
      <remarks>
        <para>A node marked as fixed will not be moved by this algorithm but stay at its current position.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Organic.ShuffleLayout.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Organic.ShuffleLayout" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Organic.ShuffleLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Performs the overlap removal (shuffle) algorithm on the given graph, after the <see cref="P:yWorks.Layout.Organic.ShuffleLayout.CoreLayout">core layout algorithm</see> was applied to it.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Organic.ShuffleLayout.HorizontalOverlapCriterion">
      <summary>
        <para>Gets or sets the criterion for marking an overlap as horizontal.</para>
      </summary>
      <remarks>
        <para>This criterion influences how overlaps will be resolved. If an overlap is considered horizontal, it will <em>preferably</em> be solved by moving nodes horizontally, else vertically.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given criterion is unknown</para>
      </exception>
      <value>
        <para>one of the predefined overlap criteria</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ShuffleLayout.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the default minimum distance that has to be obeyed between any two nodes.</para>
      </summary>
      <remarks>
        <para>This default distance will be considered for a node if the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Organic.ShuffleLayout.MinimumDistanceDpKey" /> does not contain a valid, positive distance for that node. If there is no <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the mentioned key, then this default distance will be applied to all nodes.</para>
        <para>The minimum distance needs to be a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum node distance</para>
      </value>
      <seealso cref="F:yWorks.Layout.Organic.ShuffleLayout.MinimumDistanceDpKey" />
    </member>
    <member name="P:yWorks.Layout.Organic.ShuffleLayout.SimpleMode">
      <summary>
        <para>Gets or sets whether or not the simple, fast layout mode of this algorithm is active.</para>
      </summary>
      <remarks>
        <para>Enabling this mode, the overlap removal step will be executed using a simpler and less sophisticated approach. All overlaps will only be solved by moving nodes vertically. The algorithm will not try to figure out which direction might be better for overlap removal.</para>
        <para>The runtime will improve, but results may be of lower quality when using this mode.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the simple and fast layout mode is enabled, <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.ShuffleLayout.BarycenterMode">
      <summary>
        <para>Gets or sets whether or not the barycenter mode is used for node shuffling when removing overlaps.</para>
      </summary>
      <remarks>
        <para>If this mode is active, the overlap removal step will be executed two times for each direction, once with the normal node ordering and once with the reversed ordering. Finally, the barycenter between both results will be used for assigning the node coordinates.</para>
        <para>Activating the barycenter mode allows more symmetric results for some graphs. However, the runtime might increase.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the barycenter placement mode is active <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Organic.SplitEdgeStage">
      <summary>
        <para>This layout stage replaces edges by a path of <em>split-edges</em> with a specified length before it calls a <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>
          <h2>Concept</h2>
        </para>
        <para>Each edge segment (or only segments that belong to a particular subset of edges) in the input graph will be split up into several segments such that all segments have a maximum length defined by the specified <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.SplitSegmentLength">split segment length</see>. If an edge segment is already shorter than the split segment length, then it will not be split up.</para>
        <para>At each split location, a dummy node (the so-called <em>split-node</em>) will be inserted. Split-nodes inserted for the same original edge and the actual source and target node of the original edge will be connected by so called <em>split-edges</em>. In consequence, the original source and target node are not connected by a single edge but by a path consisting of split-edges. Furthermore, all edges are simple straight lines.</para>
        <para>After this replacement step, the <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.CoreLayout">core layout algorithm</see> will be invoked.</para>
        <para>When the core layout algorithm has finished, the split-nodes will be removed from the graph and the original edge will be restored. The coordinates of the bends will be the center-coordinates of the corresponding split-node.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>The <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.SplitNodesDpKey" /> can be used by the <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.CoreLayout">core layout algorithm</see> to determine whether or not a certain node is a split-node that was created by this stage. This information may be useful when providing a custom core layout algorithm which should handle split-nodes in a different way than normal nodes. If no <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with this key, this information is dropped.</para>
        <para>By registering a <see cref="T:yWorks.Algorithms.IDataProvider" /> with key <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.AffectedEdgesDpKey" />, the subset of edges that should be split by this layout stage can be specified. If no <see cref="T:yWorks.Algorithms.IDataProvider" /> with this key is registered, all edges of the input graph will be split by the layout stage.</para>
        <para>The amount of split-nodes replacing a single original edge can be controlled via the <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.SplitSegmentLength">split segment length</see>. The smaller the value, the more split-nodes this stage will insert.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Organic.SplitEdgeStage.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Organic.SplitEdgeStage" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Organic.SplitEdgeStage.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key to determine which edges are to be split by this layout stage.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with this key, all edges will be split.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for marking edges that should be split</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.SplitEdgeStage.SplitNodesDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for marking the nodes that were created by splitting edges, i.e., the split-nodes.</para>
      </summary>
      <remarks>
        <para>The information provided by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key is useful for the <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.CoreLayout">core layout algorithm</see> to know whether or not some node is a (dummy) split-node. After <see cref="M:yWorks.Layout.Organic.SplitEdgeStage.ApplyLayout(yWorks.Layout.LayoutGraph)" /> finishes, the split-nodes will have been removed and this information will not be available anymore.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for marking newly created split-nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.SplitEdgeStage.SplitSegmentLength">
      <summary>
        <para>Gets or sets the maximum length for a <em>split-edge</em>.</para>
      </summary>
      <remarks>
        <para>The length of the original edge path divided by the given split segment length yields the number of nodes on the new path.</para>
        <para>The split segment length must be a strictly positive value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given split segment length is smaller than or equal to zero</para>
      </exception>
      <value>
        <para>the split segment length</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Organic.SplitEdgeStage.SplitNodeSize">
      <summary>
        <para>Gets or sets the size of the split-nodes that are inserted when splitting edges.</para>
      </summary>
      <remarks>
        <para>The given size will be used for defining the height and the width of the split-nodes.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given size is negative</para>
      </exception>
      <value>
        <para>the size the inserted split nodes will have</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Organic.SplitEdgeStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Replaces the edges of the given graph by a path of split-edges, executes the <see cref="P:yWorks.Layout.Organic.SplitEdgeStage.CoreLayout">core layout algorithm</see> and restores the original edges, introducing bends at the locations of the split-nodes.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.OrientationLayout">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.OrientationLayout" /> is a <see cref="T:yWorks.Layout.ILayoutStage" /> that changes the orientation of the layout.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> There are four orientations that can be used for a layout. These orientations can exist with or without mirroring at the x-axis or y-axis.</para>
        <para>Changing the layout orientation is useful for layout styles that show a main direction.</para>
        <para />
        <para>
          <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" /> layout</para>
        <para />
        <para>
          <see cref="F:yWorks.Layout.LayoutOrientation.BottomToTop" /> layout with <see cref="F:yWorks.Layout.MirrorModes.BottomToTop">mirroring</see></para>
        <para />
        <para>
          <see cref="F:yWorks.Layout.LayoutOrientation.LeftToRight" /> layout</para>
        <para />
        <para>
          <see cref="F:yWorks.Layout.LayoutOrientation.RightToLeft" /> layout</para>
        <para>
          <h2>Concept</h2> <see cref="T:yWorks.Layout.OrientationLayout" /> performs three basic steps.</para>
        <list type="number">
          <item>Preparation: The sizes and locations of nodes and edge bends as well as labels and <see cref="T:yWorks.Layout.PortConstraint" />s are transformed to the <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" /> orientation.</item>
          <item>Delegation: The <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> is invoked and calculates the layout for orientation <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" />.</item>
          <item>Completion: The result of the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> is rotated and mirrored to fit the desired layout orientation.</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>
          <see cref="T:yWorks.Layout.OrientationLayout" /> can either be used as a <see cref="T:yWorks.Layout.ILayoutStage" /> wrapping a <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see>. Then it will change the orientation of the result of the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. <br /> If no <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> is specified, <see cref="T:yWorks.Layout.OrientationLayout" /> can work alone. It will just change the orientation of the layout without arranging nodes and edges.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.OrientationLayout" /> instance using the given <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>the core layout routine</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.OrientationLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.#ctor(yWorks.Layout.LayoutOrientation)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.OrientationLayout" /> instance using the given orientation.</para>
      </summary>
      <param name="orientation">
        <para>the orientation specifier</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the specified orientation is unknown</para>
      </exception>
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="P:yWorks.Layout.OrientationLayout.Orientation">
      <summary>
        <para>Gets or sets the main direction of the layout.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified orientation is unknown</para>
      </exception>
      <value>
        <para>of the valid orientation specifiers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.OrientationLayout.MirrorMode">
      <summary>
        <para>Gets or sets the mirror mask that defines which orientations this <see cref="T:yWorks.Layout.OrientationLayout" /> shall mirror.</para>
      </summary>
      <remarks>
        <para>
          <see cref="P:yWorks.Layout.OrientationLayout.Orientation">Setting a layout orientation</see> can be seen as rotating the graph by <c>90</c>, <c>180</c> or <c>270</c> degrees. Afterwards the graph can be mirrored at the x-axis (for horizontal layout orientations) or y-axis (for vertical layout orientations).</para>
        <para>Which directions are mirrored can be defined by the given mask. It can combine several mirrored directions with a logical <c>or</c>-operation.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown mask is specified</para>
      </exception>
      <value>
        <para>the mask that determines which layout orientations are mirrored</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.OrientationLayout.HorizontalOrientation">
      <summary>
        <para>Gets whether or not the current orientation is horizontal.</para>
      </summary>
      <remarks>
        <para>The orientation is horizontal if it is <see cref="F:yWorks.Layout.LayoutOrientation.LeftToRight" /> or <see cref="F:yWorks.Layout.LayoutOrientation.RightToLeft" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if a horizontal orientation is currently used, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="P:yWorks.Layout.OrientationLayout.ConsiderEdgeLabels">
      <summary>
        <para>Gets or sets whether or not the position of the edge labels should be changed during orientation change.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the position of the edge labels are changed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Prepares the graph for orientation change before calling the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and finishes the orientation change afterwards.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.IsOrientationMirrored(yWorks.Layout.LayoutOrientation)">
      <summary>
        <para>Returns whether or not this <see cref="T:yWorks.Layout.OrientationLayout" /> instance will mirror the graph for a given layout orientation.</para>
      </summary>
      <remarks>
        <para>Horizontal orientations get mirrored at the x-axis while vertical orientations are mirrored at the y-axis.</para>
      </remarks>
      <param name="orientation">
        <para>the layout orientation for which to check the mirror state</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the layout algorithm will mirror the graph at the corresponding axis for the given layout orientation, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
      <seealso cref="P:yWorks.Layout.OrientationLayout.MirrorMode" />
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.PrepareOrientationChange(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Prepares the layout for the desired orientation.</para>
      </summary>
      <remarks>
        <para>It will rotate and mirror the coordinates and bounds of the graph layout such that the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> can perform its calculations assuming the canonical <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" /> orientation.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.OrientationLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before invoking the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. It might be overridden to extend the preparations to custom layout features.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.OrientationLayout.CompleteOrientationChange(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.CompleteOrientationChange(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Applies the desired orientation to the graph.</para>
      </summary>
      <remarks>
        <para>It performs the inverse coordinate transformation that has been applied to the layout by method <see cref="M:yWorks.Layout.OrientationLayout.PrepareOrientationChange(yWorks.Layout.LayoutGraph)" />.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.OrientationLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> after invoking the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. It may be overridden to extend the orientation change to custom layout features.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <seealso cref="M:yWorks.Layout.OrientationLayout.PrepareOrientationChange(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.Transform(yWorks.Algorithms.Geometry.YPoint,System.Boolean)">
      <summary>
        <para>Transforms the given point during the preparation or completion step.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.OrientationLayout.PrepareOrientationChange(yWorks.Layout.LayoutGraph)" /> and <see cref="M:yWorks.Layout.OrientationLayout.CompleteOrientationChange(yWorks.Layout.LayoutGraph)" /> to get the according point location.</para>
      </remarks>
      <param name="point">
        <para>the original/calculated point</para>
      </param>
      <param name="prepare">
        <para>
          <c>true</c> if this method is called during preparation, <c>false</c> if it is called during completion</para>
      </param>
      <returns>
        <para>the transformed point</para>
      </returns>
      <seealso cref="M:yWorks.Layout.OrientationLayout.PrepareOrientationChange(yWorks.Layout.LayoutGraph)" />
      <seealso cref="M:yWorks.Layout.OrientationLayout.CompleteOrientationChange(yWorks.Layout.LayoutGraph)" />
      <seealso cref="M:yWorks.Layout.OrientationLayout.PrepareTransform(yWorks.Algorithms.Geometry.YPoint)" />
      <seealso cref="M:yWorks.Layout.OrientationLayout.CompleteTransform(yWorks.Algorithms.Geometry.YPoint)" />
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.PrepareTransform(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Transforms the given point during preparation.</para>
      </summary>
      <remarks>
        <para>The point is transformed so it matches the <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" /> orientation.</para>
      </remarks>
      <param name="point">
        <para>the original point</para>
      </param>
      <returns>
        <para>the transformed point</para>
      </returns>
      <seealso cref="M:yWorks.Layout.OrientationLayout.PrepareOrientationChange(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.CompleteTransform(yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Transforms the given point during completion.</para>
      </summary>
      <remarks>
        <para>The point is transformed from <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" /> orientation to the desired orientation.</para>
      </remarks>
      <param name="point">
        <para>the calculated point</para>
      </param>
      <returns>
        <para>the transformed point</para>
      </returns>
      <seealso cref="M:yWorks.Layout.OrientationLayout.CompleteOrientationChange(yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.CreateOrientedInsets(yWorks.Algorithms.Geometry.Insets)">
      <summary>
        <para>Creates <see cref="T:yWorks.Algorithms.Geometry.Insets" /> that are a geometric transformation of the given <see cref="T:yWorks.Algorithms.Geometry.Insets" />.</para>
      </summary>
      <remarks>
        <para>The transform will correspond to the currently set orientation.</para>
      </remarks>
      <param name="insets">
        <para>the original insets</para>
      </param>
      <returns>
        <para>the oriented insets</para>
      </returns>
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.CreateOrientedNodeHalo(yWorks.Layout.NodeHalo)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.NodeHalo" /> that is a geometric transformation of the given <see cref="T:yWorks.Layout.NodeHalo" />.</para>
      </summary>
      <remarks>
        <para>The transform will correspond to the currently set orientation.</para>
      </remarks>
      <param name="halo">
        <para>the original <see cref="T:yWorks.Layout.NodeHalo" /></para>
      </param>
      <returns>
        <para>the oriented <see cref="T:yWorks.Layout.NodeHalo" /></para>
      </returns>
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="M:yWorks.Layout.OrientationLayout.CreateOrientedNodeSize(yWorks.Algorithms.Geometry.YDimension)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Algorithms.Geometry.YDimension" /> that is a geometric transformation of the given size.</para>
      </summary>
      <remarks>
        <para>The transform will correspond to the currently set orientation.</para>
      </remarks>
      <param name="nodeSize">
        <para>the original node size</para>
      </param>
      <returns>
        <para>the oriented node size</para>
      </returns>
      <seealso cref="P:yWorks.Layout.OrientationLayout.Orientation" />
    </member>
    <member name="T:yWorks.Layout.Orthogonal.CompactOrthogonalLayout">
      <summary>
        <para>This layout algorithm arranges a graph in a compact, orthogonal fashion.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>This layout algorithm is a variant of <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" /> that tries to arrange nodes in a more compact way. It allows to specify a desired aspect ratio for the bounds of the calculated layout. Nodes of a given graph are arranged such that each edge is drawn as an alternating sequence of horizontal and vertical segments.</para>
        <para>
          <see cref="T:yWorks.Layout.Orthogonal.CompactOrthogonalLayout" /> is well suited for small and medium-sized sparse graphs and produces compact drawings with no overlapping nodes, few crossings and few bends. It is also especially suitable for printing the diagram on a paper of predefined size. As a disadvantage, this algorithm will usually produce less elegant edge routes than the ones of <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" />.</para>
        <para>Application domains of orthogonal drawings are software engineering, project management, function call graphs and object-oriented class diagrams.</para>
        <para> Sample output of the layout algorithm with aspect ratio <c>1.0</c> <h2>Concept</h2></para>
        <para>This algorithm is implemented as a <see cref="T:yWorks.Layout.PartitionLayout" /> and applies the following steps:</para>
        <list type="bullet">
          <item>Divides the graph into smaller partitions using the partition finder instance created by <see cref="M:yWorks.Layout.PartitionLayout.CreateEdgeBetweennessPartitionFinder(System.Int32,System.Int32)" />.</item>
          <item>Arranges the nodes of each graph partition using <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" />.</item>
          <item>Arranges the partitions themselves in a compact manner using the partition placer instance created by <see cref="M:yWorks.Layout.PartitionLayout.CreateComponentPartitionPlacer(yWorks.Layout.ComponentLayout)" />.</item>
          <item>Routes the edges between partitions (inter-edges) using the router instance created by <see cref="M:yWorks.Layout.PartitionLayout.CreateChannelInterEdgeRouter(yWorks.Layout.Router.ChannelEdgeRouter)" />.</item>
        </list>
        <para>Each of these steps can be individually configured and/or replaced. To do so, use methods <see cref="P:yWorks.Layout.PartitionLayout.PartitionFinder" />, <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout" />, <see cref="P:yWorks.Layout.PartitionLayout.PartitionPlacer" /> and <see cref="P:yWorks.Layout.PartitionLayout.InterEdgeRouter" />, respectively.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>The aspect ratio of the resulting layout bounds, i.e., the ratio of width/height of the layout, can be configured using <see cref="P:yWorks.Layout.Orthogonal.CompactOrthogonalLayout.AspectRatio" />. <see cref="T:yWorks.Layout.Orthogonal.CompactOrthogonalLayout" /> tries to reach this preferred value. However, depending on the actual graph structure, this may not always be possible.</para>
        <para>Octilinear routing of edges can be supported by appending <see cref="T:yWorks.Layout.Router.Polyline.PolylineLayoutStage" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Orthogonal.CompactOrthogonalLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Orthogonal.CompactOrthogonalLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.CompactOrthogonalLayout.GridSpacing">
      <summary>
        <para>Gets or sets the equidistant spacing between the horizontal and vertical grid lines.</para>
      </summary>
      <remarks>
        <para>Each node will be placed on a grid point. Edges will be routed such that their segments lie on grid lines, if the endpoints of the edges allow to place the ports accordingly.</para>
        <para>The grid spacing has to be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the grid spacing is negative or zero</para>
      </exception>
      <value>
        <para>the grid spacing</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.CompactOrthogonalLayout.AspectRatio">
      <summary>
        <para>Gets or sets the desired aspect ratio (i.e.</para>
      </summary>
      <remarks>
        <para>the quotient width/height) of the resulting layout bounds.</para>
        <para>The aspect ratio needs to be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given aspect ratio is less than or equal to zero</para>
      </exception>
      <value>
        <para>the desired aspect ratio</para>
      </value>
      <seealso cref="P:yWorks.Layout.PartitionLayout.PartitionPlacer" />
      <seealso cref="M:yWorks.Layout.PartitionLayout.CreateComponentPartitionPlacer(yWorks.Layout.ComponentLayout)" />
    </member>
    <member name="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor">
      <summary>
        <para>This class provides layout information for the edges of the graph.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> is used by <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" /> to determine the routing details for the edges (e.g. the segment length).</para>
        <para>An <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> can be specified individually for each edge by using a <see cref="T:yWorks.Algorithms.IDataProvider" /> which maps from an <see cref="T:yWorks.Algorithms.Edge" /> to an <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance. The <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with the graph with key <see cref="F:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLayoutDescriptorDpKey" />.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLayoutDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> with the default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor.MinimumFirstSegmentLength">
      <summary>
        <para>Gets or sets the minimum length of the first segment of the edge path (at the source node).</para>
      </summary>
      <remarks>
        <para>The minimum length must be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length of the first segment is negative</para>
      </exception>
      <value>
        <para>the minimum length of the first segment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor.MinimumLastSegmentLength">
      <summary>
        <para>Gets or sets the minimum length of the last segment of the edge path (at the target node).</para>
      </summary>
      <remarks>
        <para>The minimum length must be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length of the last segment is negative</para>
      </exception>
      <value>
        <para>the minimum length of the last segment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor.MinimumSegmentLength">
      <summary>
        <para>Gets or sets the minimum segment length of an edge.</para>
      </summary>
      <remarks>
        <para>The minimum length must be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum length is negative</para>
      </exception>
      <value>
        <para>the minimum segment length</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor.CreateCopy">
      <summary>
        <para>Creates a copy of this <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance.</para>
      </summary>
      <returns>
        <para>a copy of this <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Orthogonal.LayoutStyle">
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Orthogonal.LayoutStyle.Normal">
      <summary>
        <para>A layout style that produces orthogonal edges while maintaining the original node size.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Orthogonal.LayoutStyle.Uniform">
      <summary>
        <para>A layout style that produces orthogonal edges and nodes of uniform size.</para>
        <para>Before calculating the layout, all nodes will be assigned equal sizes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Orthogonal.LayoutStyle.Box">
      <summary>
        <para>A layout style that modifies the size of nodes to minimize the overall number of bends.</para>
        <para>The layout algorithm will enlarge nodes based on the number and position of their neighbors in order to minimize the number of required bends. The segments of all edges are either horizontal or vertical.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Orthogonal.LayoutStyle.Mixed">
      <summary>
        <para>A layout style that produces non-orthogonal edges and resizes the nodes to a small uniform size.</para>
        <para>This layout style resembles <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.Box" />, but it resizes all nodes to equal size.</para>
        <para>It introduces additional bends into some edges and routes the last edge segment of these edges non-orthogonally to their adjacent nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Orthogonal.LayoutStyle.NormalTree">
      <summary>
        <para>A layout style similar to <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.Normal" /> that is best-suited for tree-like structures.</para>
        <para>Larger subtrees are processed using a specialized tree layout algorithm which arranges all directed subtree structures in an optimized way.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Orthogonal.LayoutStyle.FixedMixed">
      <summary>
        <para>A layout style similar to <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.Mixed" /> that maintains the original node size.</para>
        <para>This style introduces additional bends into some edges and routes the last edge segment of these edges non-orthogonally to their adjacent nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Orthogonal.LayoutStyle.FixedBox">
      <summary>
        <para>A layout style similar to <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.Box" /> that maintains the original node size.</para>
        <para>Nodes will be placed at the same positions as with <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.FixedMixed" />, but edges will be routed strictly orthogonally.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="T:yWorks.Layout.Orthogonal.OrthogonalLayout">
      <summary>
        <para>This layout algorithm arranges graphs in an orthogonal fashion.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>This layout algorithm arranges the nodes of a given graph such that each edge is drawn as an alternating sequence of horizontal and vertical segments.</para>
        <para>It produces compact drawings with no overlapping nodes, few crossings and few bends and is well suited for small and medium-sized sparse graphs.</para>
        <para>Orthogonal drawings are common in engineering applications since they are able to provide clear representations of complex networks that can also be optimal with respect to diverse objective functions such as bend minimization or area minimization. Application domains of orthogonal drawings include software engineering, database schema representation, system management, knowledge representation, VLSI circuits and floor planning applications.</para>
        <para> Orthogonal layout with default settings</para>
        <para>This algorithm also optionally supports <see cref="F:yWorks.Layout.Orthogonal.OrthogonalLayout.DirectedEdgeDpKey">directed edge drawings</see> (although not in combination with hierarchically nested graphs or the non-default <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle">layout styles</see>). Application domains of directed orthogonal drawings include, for example, software engineering, database schema and system management.</para>
        <para> Sample output of <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" /> with default settings. Marked edges are considered as directed and the layout orientation is top-to-bottom.  Sample output of <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" /> with edge grouping. All edges are considered directed and the layout orientation is left-to-right.</para>
        <para>Also this algorithm supports hierarchically nested graphs (although not in combination with the directed edge drawings, the <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.FromSketchMode">from sketch</see> option, or the non-default <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle">layout styles</see>) feature:</para>
        <para> Orthogonal layout of a grouped graph with default settings  Orthogonal layout of a graph with nested groups <h2>Concept</h2> The orthogonal layout algorithm is based on the topology-shape-metrics approach and runs in three phases:</para>
        <list type="bullet">
          <item>
            <term>Planarization</term>
            <description>A planar embedding is computed.</description>
          </item>
          <item>
            <term>Orthogonalization</term>
            <description>The bends and the angles are computed.</description>
          </item>
          <item>
            <term>Compaction</term>
            <description>The coordinates for the nodes and edges are determined.</description>
          </item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>There exist several different layout styles that the orthogonal layout algorithm supports depending on whether or not the edges should be routed completely orthogonal, or whether or not the original size of the nodes should be maintained. Such layout styles are <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.Normal" />, <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.Uniform" />, <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.Box" />, <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.NormalTree" />, <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.Mixed" />, <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.FixedBox" />, <see cref="F:yWorks.Layout.Orthogonal.LayoutStyle.FixedMixed" /> and can be applied using <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />.</para>
        <para>
          <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" /> is able to consider edge label data when arranging a graph. This means that the layout algorithm will determine the positions of the nodes and edges such that the edge labels do not overlap with the rest of the layout. Integrated edge labeling can be activated using method <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.IntegratedEdgeLabeling" />.</para>
        <para>
          <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instances can be used for specifying individual information (e.g. distances) for each edge in the graph. The descriptors are bound to the graph using <see cref="T:yWorks.Algorithms.IDataProvider" />s registered with key <see cref="F:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLayoutDescriptorDpKey" />. If there is no descriptor assigned to some edges, a default descriptor will be used. To set default descriptors, use <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLayoutDescriptor" />.</para>
        <para>
          <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" /> tries to optimize diverse objective functions such as bend minimization, number of edge crossings, edge length minimization or face maximization. These settings can be enabled using the corresponding methods <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.OptimizePerceivedBends" />, <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.CrossingReduction" />, <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLengthReduction" />, and <see cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.FaceMaximization" />, respectively. The drawback when these settings are enabled is that the running time of the algorithm may be drastically increased.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLayoutDescriptorDpKey">
      <summary>
        <para>A data provider key for providing layout information for each edge.</para>
      </summary>
      <remarks>
        <para>If no edge layout descriptor is mapped for an edge, a default edge layout descriptor will be obtained using method <see cref="M:yWorks.Layout.Orthogonal.OrthogonalLayout.CreateEdgeLayoutDescriptor" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle" />
    </member>
    <member name="F:yWorks.Layout.Orthogonal.OrthogonalLayout.DirectedEdgeDpKey">
      <summary>
        <para>A data provider key for marking edges which should be routed such that they point to the main layout orientation.</para>
      </summary>
      <remarks>
        <para>The main layout orientation can be set using method <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Orthogonal.OrthogonalLayout.CreateEdgeLayoutDescriptor">
      <summary>
        <para>Returns a new <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance that will be used during the various phases of the layout algorithm to determine the drawing details of the edges of the graph.</para>
      </summary>
      <remarks>
        <para>This method may be overridden to create a new <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance with different configuration settings.</para>
      </remarks>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLayoutDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance used for all those edges that do not have a specific layout descriptor assigned.</para>
      </summary>
      <remarks>
        <para>By default, this method will return an <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance created with <see cref="M:yWorks.Layout.Orthogonal.OrthogonalLayout.CreateEdgeLayoutDescriptor" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Orthogonal.EdgeLayoutDescriptor" /> instance</para>
      </value>
      <seealso cref="F:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLayoutDescriptorDpKey" />
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the layout algorithm considers node labels when calculating node positions to avoid overlaps.</para>
      </summary>
      <remarks>
        <para>This method is a convenience method that assures that the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see> is of type <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> and <see cref="P:yWorks.Layout.LabelLayoutTranslator.TranslateNodeLabels" /> is set to <c>true</c>.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>if no properly configured <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> is registered even though this property was enabled earlier (can happen when manually specifying the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see>).</para>
      </exception>
      <value>
        <para>
          <c>true</c> if the layout algorithm takes the node labels into account, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.IntegratedEdgeLabeling">
      <summary>
        <para>Gets or sets whether or not the layout algorithm preserves space and places edge labels.</para>
      </summary>
      <remarks>
        <para>To define the desired placement for each label add a <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> on <see cref="T:yWorks.Layout.IEdgeLabelLayout" />.</para>
        <para>This method also assures that the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see> is of type <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> and <see cref="P:yWorks.Layout.LabelLayoutTranslator.TranslateEdgeLabels" /> is set to <c>true</c>.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>if no properly configured <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> is registered even though integrated labeling was enabled earlier (can happen when manually specifying the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">labeling algorithm</see>).</para>
      </exception>
      <value>
        <para>
          <c>true</c> if integrated edge labeling is enabled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Orthogonal.OrthogonalLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Orthogonal.OrthogonalLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.Randomization">
      <summary>
        <para>Gets or sets whether or not a randomization strategy should be performed.</para>
      </summary>
      <remarks>
        <para>The randomization will increase the overall layout quality with high probability. The drawback is that the running time of the layout algorithm may increase.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if randomization is performed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.AlignDegreeOneNodes">
      <summary>
        <para>Gets or sets whether or not degree-one nodes that have the same neighbor should be aligned.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the degree-one nodes are aligned, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.FaceMaximization">
      <summary>
        <para>Gets or sets whether or not one face of the embedding of the graph should be maximized.</para>
      </summary>
      <remarks>
        <para>An embedding of a graph is uniquely specified by the cyclic order of edges incident to the same node in a graph drawing.</para>
        <para>In any planar drawing of a planar graph, the edges divide the plane into different regions called faces. If one of these faces (the outer face) gets maximized, all other faces will be more compact.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if a face of the embedding is maximized, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Orthogonal.OrthogonalLayout.Randomization" />
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.CrossingReduction">
      <summary>
        <para>Gets or sets whether or not the number of edge crossings should be reduced.</para>
      </summary>
      <remarks>
        <para>The layout algorithm will try to significantly reduce the number of crossings in a post-processing step.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the number of crossings is reduced, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.OptimizePerceivedBends">
      <summary>
        <para>Gets or sets whether or not the number of perceived bends should be minimized.</para>
      </summary>
      <remarks>
        <para>A perceived bend is not an actual bend but it is created when a helical arrangement of chains of nodes occurs.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the number of perceived bends is minimized, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.GridSpacing">
      <summary>
        <para>Gets or sets the equidistant spacing between the horizontal and vertical grid lines.</para>
      </summary>
      <remarks>
        <para>Each node will be placed on a grid point. Edges will be routed such that all segments but the first and last one lie on grid lines. (The first and last segments of an edge may or may not lie on grid lines.) Edges consisting of a single segment always lie on grid lines.</para>
        <para>The grid spacing has to be greater than <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the grid spacing is negative</para>
      </exception>
      <value>
        <para>the grid spacing</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.LayoutStyle">
      <summary>
        <para>Gets or sets the layout style for this layout algorithm.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown layout style is given</para>
      </exception>
      <value>
        <para>one of the predefined layout styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.EdgeLengthReduction">
      <summary>
        <para>Gets or sets whether or not the overall edge length should be optimized.</para>
      </summary>
      <remarks>
        <para>The algorithm will try to significantly reduce the length of some edges.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the overall edge length minimization is reduced, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.FromSketchMode">
      <summary>
        <para>Gets or sets whether or not the existing drawing should be used as a sketch of the resulting orthogonal layout.</para>
      </summary>
      <remarks>
        <para>The layout algorithm will try to orthogonalize the given sketch without making too many modifications with respect to the original drawing.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the existing drawing is used as a sketch, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.ComponentLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for arranging the components of the graph is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that arranges the graph components is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.HideGroupsStageEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for hiding group nodes is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage used for hiding group nodes is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStage" />
      <seealso cref="T:yWorks.Layout.Grouping.HideGroupsStage" />
    </member>
    <member name="P:yWorks.Layout.Orthogonal.OrthogonalLayout.OrientationLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of the layout is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that modifies the orientation is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="M:yWorks.Layout.Orthogonal.OrthogonalLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates an orthogonal layout for the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Orthogonal.OrthogonalLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates an orthogonal layout for the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.ParallelEdgeRouter">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.ParallelEdgeRouter" /> is a <see cref="T:yWorks.Layout.ILayoutStage" /> that routes parallel edges which connect the same pair of nodes in a graph.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The edge paths of parallel edges consist of parallel segments. At the end points, the edges can either still be parallel or <see cref="P:yWorks.Layout.ParallelEdgeRouter.JoinEnds">joined in one point</see>. </para>
        <para>The master edge determining the routing is highlighted</para>
        <para>
          <h2>Concept</h2> <see cref="T:yWorks.Layout.ParallelEdgeRouter" /> performs four basic steps:</para>
        <list type="number">
          <item>Remove all parallel edges from the input graph, leaving one master edge in the graph</item>
          <item>Invoke the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> on the graph without parallel edges</item>
          <item>Reinsert all previously removed edges</item>
          <item>Route the parallel edges</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>
          <see cref="T:yWorks.Layout.ParallelEdgeRouter" /> can either be used as a <see cref="T:yWorks.Layout.ILayoutStage" /> wrapping a <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> which cannot handle parallel edges. Then it will hide the parallel edges from this <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and take over the routing of them. <br /> If no <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> is specified, <see cref="T:yWorks.Layout.ParallelEdgeRouter" /> can work alone. It will route only the parallel edges and keep the remaining graph unchanged.</para>
        <para>Parallel edges can either be all edges between the same two nodes, ignoring the direction, or edges are only considered parallel if they share the same source node and target node. Hence, they share the same <see cref="P:yWorks.Layout.ParallelEdgeRouter.DirectedMode">direction</see>.</para>
        <para>To make sure that the ports of all parallel edges are on the end nodes, the first and last segments can be <see cref="P:yWorks.Layout.ParallelEdgeRouter.JoinEnds">joined</see>. However, these segments won't be parallel.</para>
        <para>There are two ways to define the distance between two parallel edges. First, an absolute distance can be <see cref="P:yWorks.Layout.ParallelEdgeRouter.LineDistance">defined</see>. Parallel segments will keep this distance. Second, the distance can be <see cref="P:yWorks.Layout.ParallelEdgeRouter.AdaptiveLineDistances">determined relative to the node bounds</see>. Depending on the size of the nodes and the number of parallel edges between them, the distance between parallel edges is adjusted. This will keep the edges straight in most cases.</para>
        <para>It is possible to select <see cref="F:yWorks.Layout.ParallelEdgeRouter.LeadingEdgeDpKey">custom master edges</see>. All edges that are parallel to the selected edges will be temporarily removed.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.ParallelEdgeRouter.AffectedEdgesDpKey">
      <summary>
        <para>A data provider key for marking edges that will be routed.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.ParallelEdgeRouter.LeadingEdgeDpKey">
      <summary>
        <para>A data provider key for specifying the master edges.</para>
      </summary>
      <remarks>
        <para>Marked edges won't be removed for the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. All edges parallel to the master edges will get parallel paths.</para>
        <para>If no leading edge is specified for a bundle of parallel edges, it will be determined automatically. If there is more than one leading edge, the first one is chosen.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.ParallelEdgeRouter.hiddenEdges">
      <summary>
        <para>Holds the list of parallel edges that are hidden from the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.ParallelEdgeRouter.parallelEdges">
      <summary>
        <para>
          <see cref="T:yWorks.Algorithms.IEdgeMap" /> that associates a hidden edge with the unique parallel edge not hidden from the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.ParallelEdgeRouter.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ParallelEdgeRouter" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
      <seealso cref="P:yWorks.Layout.LayoutStageBase.CoreLayout" />
    </member>
    <member name="P:yWorks.Layout.ParallelEdgeRouter.DirectedMode">
      <summary>
        <para>Gets or sets whether or not the direction of edges should be considered.</para>
      </summary>
      <remarks>
        <para>In directed mode, only edges that share the same source and target node will be routed in parallel. Edges that connect to the same nodes but in different directions won't be considered parallel.</para>
        <para>In undirected mode, all edges connecting the same pair of nodes will be routed in parallel.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the direction of parallel edges must be the same, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.ParallelEdgeRouter.AdaptiveLineDistances">
      <summary>
        <para>Gets or sets whether or not the distances between parallel edges should be determined automatically according to the sizes of their source and target nodes.</para>
      </summary>
      <remarks>
        <para>If enabled, the distances between edges are chosen such that all parallel edges can be drawn as straight lines and still connect to the nodes' bounds.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the distances are determined according to the nodes' bounds, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.LineDistance" />
    </member>
    <member name="P:yWorks.Layout.ParallelEdgeRouter.LineDistance">
      <summary>
        <para>Gets or sets the distance between two adjacent edge paths that run in parallel.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is less than <c>0</c></para>
      </exception>
      <value>
        <para>the distance between two parallel edges</para>
      </value>
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.AdaptiveLineDistances" />
    </member>
    <member name="M:yWorks.Layout.ParallelEdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Delegates the arrangement of nodes and edges to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and routes the parallel edges.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.ParallelEdgeRouter.LayoutParallelEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Assigns a layout to all parallel edges.</para>
      </summary>
      <remarks>
        <para>The layout for each parallel edge follows the layout of the master edge which was not removed from the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
        <para>This method is called when the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> is finished. It may be overridden to introduce a custom routing for parallel edges.</para>
      </remarks>
      <param name="graph">
        <para>the graph after the core layout</para>
      </param>
      <param name="parallelEdges">
        <para>the map that provides all parallel edges for each master edge</para>
      </param>
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.JoinEnds" />
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.AdaptiveLineDistances" />
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.AdjustLeadingEdge" />
    </member>
    <member name="M:yWorks.Layout.ParallelEdgeRouter.FindAndHideParallelEdges(yWorks.Algorithms.Graph)">
      <summary>
        <para>Hides all parallel edges leaving a master edge in the graph.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.ParallelEdgeRouter" /> detects parallel edges of the given graph. From each set of parallel edges it hides all but one edge from the given graph.</para>
        <para>This method is called before invoking the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. It may be overridden to change the selection of leading edges. Hidden edges should be stored in <see cref="F:yWorks.Layout.ParallelEdgeRouter.hiddenEdges" /> to enable un-hiding later on.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.DirectedMode" />
      <seealso cref="F:yWorks.Layout.ParallelEdgeRouter.AffectedEdgesDpKey" />
    </member>
    <member name="P:yWorks.Layout.ParallelEdgeRouter.JoinEnds">
      <summary>
        <para>Gets or sets whether or not to join end points of parallel edges.</para>
      </summary>
      <remarks>
        <para>If enabled, all edges end with non-parallel segments that connect at the same point to the node. Otherwise, all segments of the edges are parallel. In this case, some edges may not connect to the nodes' bounds.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if edges are joined at the ends, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.AbsJoinEndDistance" />
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.RelJoinEndDistance" />
    </member>
    <member name="P:yWorks.Layout.ParallelEdgeRouter.AbsJoinEndDistance">
      <summary>
        <para>Gets or sets the absolute distance from the end point of the joined lines to the first parallel segments.</para>
      </summary>
      <remarks>
        <para>The absolute distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the absolute distance from the end point to the first/last bend of parallel edges</para>
      </value>
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.JoinEnds" />
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.RelJoinEndDistance" />
    </member>
    <member name="P:yWorks.Layout.ParallelEdgeRouter.RelJoinEndDistance">
      <summary>
        <para>Gets or sets the relative distance from the end point of the joined lines to the first parallel segments.</para>
      </summary>
      <remarks>
        <para>The length is relative to the corresponding original segment's length. It needs to have a value in the interval <c>[0,1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified relative distance is less than <c>0</c> or greater than <c>1</c></para>
      </exception>
      <value>
        <para>the relative distance from the end point to the first/last bend of parallel edges</para>
      </value>
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.JoinEnds" />
      <seealso cref="P:yWorks.Layout.ParallelEdgeRouter.AbsJoinEndDistance" />
    </member>
    <member name="P:yWorks.Layout.ParallelEdgeRouter.AdjustLeadingEdge">
      <summary>
        <para>Gets or sets whether or not to adjust the leading edge to obtain more symmetric results.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the leading edge is adjusted, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Partial.EdgeRoutingStrategy">
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Orthogonal">
      <summary>
        <para>A routing strategy that produces orthogonal routes for partial edges and inter-edges.</para>
        <para>A route of an edge is called <i>orthogonal</i> if it only consists of vertical and horizontal segments.</para>
        <para>
          <i>Inter-edges</i> are edges between fixed and partial nodes as well as edges between different subgraph components.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Straightline">
      <summary>
        <para>A routing strategy that produces straight-line routes for partial edges and inter-edges.</para>
        <para>
          <i>Inter-edges</i> are edges between fixed and partial nodes as well as edges between different subgraph components.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Automatic">
      <summary>
        <para>Automatically chooses a suitable routing strategy for partial edges and inter-edges by analyzing the routes of the fixed edges. If, for example, all fixed edges have orthogonal edge routes, inter-edges will be routed orthogonally, too.</para>
        <para>
          <i>Inter-edges</i> are edges between fixed and partial nodes as well as edges between different subgraph components.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Organic">
      <summary>
        <para>A routing strategy that produces organic routes for partial edges and inter-edges.</para>
        <para>
          <i>Inter-edges</i> are edges between fixed and partial nodes as well as edges between different subgraph components.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Octilinear">
      <summary>
        <para>A routing strategy that produces octilinear routes for partial edges and inter-edges.</para>
        <para>A route of an edge is called <i>octilinear</i> if the slope of each segment is a multiple of <c>45</c> degrees.</para>
        <para>
          <i>Inter-edges</i> are edges between fixed and partial nodes as well as edges between different subgraph components.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="T:yWorks.Layout.Partial.ComponentAssignmentStrategy">
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Single">
      <summary>
        <para>A component assignment strategy that assigns each partial node to a separate subgraph component.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Connected">
      <summary>
        <para>A component assignment strategy where the subgraph components correspond to the connected components of the graph induced by the partial elements.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Clustering">
      <summary>
        <para>A component assignment strategy where the subgraph components correspond to the clusters computed by a clustering algorithm based on <see cref="M:yWorks.Algorithms.Groups.EdgeBetweennessClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Boolean,System.Int32,System.Int32,yWorks.Algorithms.IDataProvider)">edge betweenness centrality</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />
    </member>
    <member name="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Customized">
      <summary>
        <para>A component assignment strategy where the subgraph components are defined by the user. Two partial nodes are considered to be in the same component if the <see cref="T:yWorks.Algorithms.IDataProvider" /> associated with key <see cref="F:yWorks.Layout.Partial.PartialLayout.ComponentIdDpKey" /> returns the same object for both of them.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Partial.PartialLayout.ComponentIdDpKey" />
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />
    </member>
    <member name="T:yWorks.Layout.Partial.SubgraphPlacement">
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.SubgraphPlacement" />
    </member>
    <member name="F:yWorks.Layout.Partial.SubgraphPlacement.Barycenter">
      <summary>
        <para>A positioning strategy which tries to place each subgraph component close to the barycenter of its graph neighbors.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.SubgraphPlacement" />
    </member>
    <member name="F:yWorks.Layout.Partial.SubgraphPlacement.FromSketch">
      <summary>
        <para>A positioning strategy which tries to place each subgraph component close to its original position.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.SubgraphPlacement" />
    </member>
    <member name="T:yWorks.Layout.Partial.LayoutOrientation">
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
    </member>
    <member name="F:yWorks.Layout.Partial.LayoutOrientation.TopToBottom">
      <summary>
        <para>Layout orientation specifier where the algorithm tries to place partial nodes (subgraph components) such that each predecessor of a node <c>v</c> is placed above <c>v</c> and each successor below <c>v</c>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
    </member>
    <member name="F:yWorks.Layout.Partial.LayoutOrientation.BottomToTop">
      <summary>
        <para>Layout orientation specifier where the algorithm tries to place partial nodes (subgraph components) such that each predecessor of a node <c>v</c> is placed below <c>v</c> and each successor above <c>v</c>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
    </member>
    <member name="F:yWorks.Layout.Partial.LayoutOrientation.LeftToRight">
      <summary>
        <para>Layout orientation specifier where the algorithm tries to place partial nodes (subgraph components) such that each predecessor of a node <c>v</c> is placed to the left of <c>v</c> and each successor to the right of <c>v</c>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
    </member>
    <member name="F:yWorks.Layout.Partial.LayoutOrientation.RightToLeft">
      <summary>
        <para>Layout orientation specifier where the algorithm tries to place partial nodes (subgraph components) such that each predecessor of a node <c>v</c> is placed to the right of <c>v</c> and each successor to the left of <c>v</c>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
    </member>
    <member name="F:yWorks.Layout.Partial.LayoutOrientation.AutoDetect">
      <summary>
        <para>Layout orientation specifier where the algorithm automatically detects the layout orientation.</para>
        <para>The algorithm analyzes the flow direction of fixed edges in the current drawing. If there is no common flow direction, the results are the same as for <see cref="F:yWorks.Layout.Partial.LayoutOrientation.None" />. Otherwise, the layout orientation is either <see cref="F:yWorks.Layout.Partial.LayoutOrientation.TopToBottom" />, <see cref="F:yWorks.Layout.Partial.LayoutOrientation.BottomToTop" />, <see cref="F:yWorks.Layout.Partial.LayoutOrientation.LeftToRight" /> or <see cref="F:yWorks.Layout.Partial.LayoutOrientation.RightToLeft" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
    </member>
    <member name="F:yWorks.Layout.Partial.LayoutOrientation.None">
      <summary>
        <para>Layout orientation specifier where the layout orientation is completely ignored.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
    </member>
    <member name="T:yWorks.Layout.Partial.PartialLayout">
      <summary>
        <para>This class represents a partial layout algorithm which changes the coordinates for a given set of graph elements (called partial elements) only.</para>
      </summary>
      <remarks>
        <para>The location and size of the remaining elements (called fixed elements) is not allowed to be changed. <h2>Layout Style</h2></para>
        <para>This partial layout algorithm offers a kind of generic partial layout support for other existing layout algorithms. Hence, its layout style heavily depends on the selected <see cref="P:yWorks.Layout.Partial.PartialLayout.CoreLayout">core layout algorithm</see> as well as the specified <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRouter">edge router</see> or <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy">edge routing strategy</see>.</para>
        <para>The partial layout is suitable for applications where users may incrementally add new elements to an existing drawing. The added elements should be arranged so that they fit best possible into the given diagram without making any changes to the already existing layout. Hence, the so-called mental map of the existing drawing is preserved.</para>
        <para> The input graph where marked nodes denote the partial elements that were incrementally added to the existing diagram.  The result of a partial layout run with <see cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy">component assignment strategy</see> set to <see cref="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Single" /> and with <see cref="P:yWorks.Layout.Partial.PartialLayout.ConsiderNodeAlignment">node alignment</see> enabled. <h2>Features</h2></para>
        <para>Similar to the layout style, the supported feature set mainly depends on the features supported by the specified <see cref="P:yWorks.Layout.Partial.PartialLayout.CoreLayout">core layout algorithm</see> as well as the specified <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRouter">edge router</see> or <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy">edge routing strategy</see>. The internal step that <see cref="M:yWorks.Layout.Partial.PartialLayout.PlaceSubgraphs(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[])">places the components</see> can handle group nodes as well as minimum distance constraints. Furthermore, it is able to consider node labels.</para>
        <para>
          <h2>Concept</h2> The layout algorithm tries to place the partial elements such that the resulting drawing (including the fixed elements) has a good quality with respect to common graph drawing aesthetics.</para>
        <para>The layout algorithm handles each selected graph element as partial element. For this, it looks up the <see cref="T:yWorks.Algorithms.IDataProvider" /> keys <see cref="F:yWorks.Layout.Partial.PartialLayout.AffectedNodesDpKey" /> and <see cref="F:yWorks.Layout.Partial.PartialLayout.AffectedEdgesDpKey" />. Partial node elements can be assigned to the so-called <i>subgraph components</i>. During the layout process each subgraph induced by the nodes of a component is first laid out using the specified <see cref="P:yWorks.Layout.Partial.PartialLayout.CoreLayout">core layout algorithm</see>. Then, the different components are placed one-by-one onto the drawing area such that the number of overlaps among graph elements is small. The user can specify different objectives for finding 'good' positions for subgraph components (see <see cref="P:yWorks.Layout.Partial.PartialLayout.SubgraphPlacement" />), e.g., <see cref="F:yWorks.Layout.Partial.SubgraphPlacement.Barycenter" /> specifies that the component should be placed close to the barycenter of its graph neighbors and <see cref="F:yWorks.Layout.Partial.SubgraphPlacement.FromSketch" /> specifies that the component should be placed close to its original position.</para>
        <para>Method <see cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" /> allows to specify the strategy that assigns partial nodes to subgraph components. Possible values are <see cref="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Clustering" />, <see cref="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Connected" />, <see cref="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Single" /> and <see cref="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Customized" />. The last value allows to use a customized component assignment. Note that nodes of a component cannot be assigned to different group nodes.</para>
        <para>Furthermore, the user can specify the edge routing strategy (see <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />) that is used for routing partial edges and edges between different subgraph components (so-called <i>inter-edges</i>). Possible values are <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Organic" />, <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Orthogonal" />, <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Straightline" />, <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Octilinear" /> and <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Automatic" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Partial.PartialLayout.AffectedNodesDpKey">
      <summary>
        <para>A data provider key for marking partial nodes.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Partial.PartialLayout.AffectedEdgesDpKey" />
    </member>
    <member name="F:yWorks.Layout.Partial.PartialLayout.DirectedEdgesDpKey">
      <summary>
        <para>A data provider key for specifying the edges that should be considered to be directed.</para>
      </summary>
      <remarks>
        <para>If a layout orientation is specified (i.e., <see cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" /> is not <see cref="F:yWorks.Layout.Partial.LayoutOrientation.None" />), the algorithm tries to route directed edges such that they adhere to that orientation.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
    </member>
    <member name="F:yWorks.Layout.Partial.PartialLayout.AffectedEdgesDpKey">
      <summary>
        <para>A data provider key for marking partial edges.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Partial.PartialLayout.AffectedNodesDpKey" />
    </member>
    <member name="F:yWorks.Layout.Partial.PartialLayout.RouteEdgeDpKey">
      <summary>
        <para>A data provider key for obtaining the edges that should be routed by the edge router.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRouter" />
    </member>
    <member name="F:yWorks.Layout.Partial.PartialLayout.ComponentIdDpKey">
      <summary>
        <para>A data provider key for defining custom subgraph components.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Partial.ComponentAssignmentStrategy.Customized" />
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />
    </member>
    <member name="M:yWorks.Layout.Partial.PartialLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Partial.PartialLayout" /> which uses the specified <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> instance as the core layout algorithm.</para>
      </summary>
      <remarks>
        <para>This instance is applied to each subgraph component, see <see cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />.</para>
      </remarks>
      <param name="subgraphLayouter">
        <para>the layout algorithm that is applied to the subgraph components</para>
      </param>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.CoreLayout">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> instance that is applied to each subgraph component.</para>
      </summary>
      <remarks>
        <para>More precisely, during the layout process each subgraph induced by the (partial) nodes of a component (see <see cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy" />) is first laid out using this instance.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> instance that is applied to each subgraph component</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.MaximumDuration">
      <summary>
        <para>Gets or sets the preferred time limit (in milliseconds) for the layout algorithm.</para>
      </summary>
      <remarks>
        <para>The specified value has to be greater than or equal to <c>0</c>. If the value is <see cref="F:System.Int32.MaxValue" />, the time is not limited.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the maximum duration is negative</para>
      </exception>
      <value>
        <para>the preferred time limit</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.RouteInterEdgesImmediately">
      <summary>
        <para>Gets or sets whether or not edges between different subgraph components should be routed immediately.</para>
      </summary>
      <remarks>
        <para>If this option is enabled, edges are routed during the placement of the subgraph components, i.e., immediately after a component is placed, its edges to other already placed components are routed. Otherwise, these edges are routed in a separate step after placing all subgraph components. Hence, while enabling this option usually leads to shorter edge routes, the placement of subgraph components is less compact.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if edges between different subgraph components are routed immediately, <c>false</c> otherwise.</para>
      </value>
      <seealso cref="M:yWorks.Layout.Partial.PartialLayout.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)" />
      <seealso cref="M:yWorks.Layout.Partial.PartialLayout.PlaceSubgraphs(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[])" />
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.ComponentCompaction">
      <summary>
        <para>Gets or sets whether or not a subgraph component may be placed within another subgraph component.</para>
      </summary>
      <remarks>
        <para>Enabling this option leads to more compact layout results but requires more runtime.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if a subgraph component may be placed within another subgraph component, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.ResizeFixedGroups">
      <summary>
        <para>Gets or sets whether or not fixed (non-partial) group nodes may be resized.</para>
      </summary>
      <remarks>
        <para>Enabling this option may lead to better results if there are fixed group nodes, since there is more space for the partial elements.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if fixed group nodes may be resized, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.SubgraphPlacement">
      <summary>
        <para>Gets or sets the objective used for finding 'good' positions for subgraph components.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified strategy does not match one of the predefined positioning strategies</para>
      </exception>
      <value>
        <para>one of the predefined positioning strategies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two adjacent nodes.</para>
      </summary>
      <remarks>
        <para>The specified value has to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.ConsiderNodeAlignment">
      <summary>
        <para>Gets or sets whether or not partial nodes should be aligned.</para>
      </summary>
      <remarks>
        <para>If this option is enabled, the algorithm tries to align the center of partial nodes with other nodes.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if nodes are aligned, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy">
      <summary>
        <para>Gets or sets the strategy that assigns partial nodes to subgraph components.</para>
      </summary>
      <remarks>
        <para>The specified core layouter (see <see cref="P:yWorks.Layout.Partial.PartialLayout.CoreLayout" />) independently calculates the layout for each such subgraph component.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified strategy does not match one of the predefined assignment strategies.</para>
      </exception>
      <value>
        <para>one of the predefined assignment strategies</para>
      </value>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.CoreLayout" />
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.OptimizeOrientation">
      <summary>
        <para>Gets or sets whether or not a postprocessing step should be applied to reduce the number of directed edges that do not comply with the specified layout orientation.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this postprocessing step is applied, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation" />
      <seealso cref="F:yWorks.Layout.Partial.PartialLayout.DirectedEdgesDpKey" />
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.EdgeRouter">
      <summary>
        <para>Gets or sets the custom edge router instance that is used for partial edges and edges between different subgraph components (so-called inter-edges).</para>
      </summary>
      <value>
        <para>the custom edge router instance that is used for partial edges and edges between different subgraph components</para>
      </value>
      <seealso cref="F:yWorks.Layout.Partial.PartialLayout.RouteEdgeDpKey" />
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy">
      <summary>
        <para>Gets or sets the routing strategy that is used for partial edges and edges between different subgraph components (so-called inter-edges).</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified strategy does not match one of the predefined routing strategies</para>
      </exception>
      <value>
        <para>one of the predefined edge routing strategies</para>
      </value>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.LayoutOrientation">
      <summary>
        <para>Gets or sets the layout orientation that is considered during the placement of partial elements.</para>
      </summary>
      <remarks>
        <para>More precisely, the algorithm tries to place each <see cref="P:yWorks.Layout.Partial.PartialLayout.ComponentAssignmentStrategy">subgraph component</see> such that each predecessor of a component's node <c>v</c> is placed before <c>v</c> and each successor after <c>v</c> with respect to the layout orientation.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified orientation does not match one of the predefined orientations</para>
      </exception>
      <value>
        <para>one of the predefined layout orientations</para>
      </value>
      <seealso cref="F:yWorks.Layout.Partial.PartialLayout.DirectedEdgesDpKey" />
    </member>
    <member name="P:yWorks.Layout.Partial.PartialLayout.AllowMirroring">
      <summary>
        <para>Gets or sets whether or not subgraph components are mirrored to improve the layout quality.</para>
      </summary>
      <remarks>
        <para>If enabled, the algorithm checks for each component which of the four possible mirrorings minimizes the edge length.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if subgraph components are mirrored, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Partial.PartialLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>This method calculates the partial layout.</para>
      </summary>
      <remarks>
        <para>It calls the following methods:</para>
        <list type="number">
          <item>
            <see cref="M:yWorks.Layout.Partial.PartialLayout.RouteEdgesBetweenFixedElements(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Partial.PartialLayout.LayoutSubgraph(yWorks.Layout.LayoutGraph)" /> for each subgraph component</item>
          <item>
            <see cref="M:yWorks.Layout.Partial.PartialLayout.PlaceSubgraphs(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[])" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Partial.PartialLayout.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)" />
          </item>
        </list>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Partial.PartialLayout.LayoutSubgraph(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>This method is called during the <see cref="M:yWorks.Layout.Partial.PartialLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">layout process</see> and calculates the layout for the given subgraph component using the specified <see cref="P:yWorks.Layout.Partial.PartialLayout.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>It is called once for each subgraph component.</para>
        <para>Subclasses may implement a custom layout strategy or add some additional data.</para>
      </remarks>
      <param name="subGraph">
        <para>the subgraph component</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Partial.PartialLayout.PlaceSubgraphs(yWorks.Layout.LayoutGraph,yWorks.Algorithms.NodeList[])">
      <summary>
        <para>This method is called during the <see cref="M:yWorks.Layout.Partial.PartialLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">layout process</see> and places the subgraph components one-by-one onto the drawing area.</para>
      </summary>
      <remarks>
        <para>Therefore, it considers the <see cref="P:yWorks.Layout.Partial.PartialLayout.SubgraphPlacement">specified objective</see> for finding a suitable position.</para>
        <para>Subclasses may implement a custom placement strategy or add some additional data. However, they must not modify the given subgraph component lists.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="subgraphComponents">
        <para>each entry contains a <see cref="T:yWorks.Algorithms.NodeList" /> that induces a subgraph component</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Partial.PartialLayout.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)">
      <summary>
        <para>This method is called during the <see cref="M:yWorks.Layout.Partial.PartialLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">layout process</see> and routes all inter-edges.</para>
      </summary>
      <remarks>
        <para>
          <i>Inter-edges</i> are edges between different subgraph components including edges between fixed and partial elements. For the routing, this method uses the edge router instance set with method <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRouter" />. If no edge router was specified by the user, it uses an internal edge router with routing strategy <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />.</para>
        <para>Subclasses may implement a custom routing strategy or add some additional data.</para>
      </remarks>
      <param name="graph">
        <para>the relevant subgraph</para>
      </param>
      <param name="interEdges">
        <para>the <see cref="T:yWorks.Algorithms.EdgeList">list of inter-edges</see> to be routed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Partial.PartialLayout.RouteEdgesBetweenFixedElements(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList)">
      <summary>
        <para>This method is called during the <see cref="M:yWorks.Layout.Partial.PartialLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">layout process</see> and routes all partial edges that connect two fixed elements.</para>
      </summary>
      <remarks>
        <para>It either uses a <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRouter">custom edge router</see> or an internal edge router that produces routes according to the specified <see cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy">routing strategy</see>.</para>
        <para>Subclasses may implement a custom routing strategy or add some additional data.</para>
      </remarks>
      <param name="graph">
        <para>the subgraph of the input graph induced by the fixed nodes</para>
      </param>
      <param name="partialEdges">
        <para>the <see cref="T:yWorks.Algorithms.EdgeList">list of partial edges</see> to be routed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Partial.PartialLayout.ConfigureEdgeRouter(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>This method is called each time when edges are routed with an edge router.</para>
      </summary>
      <remarks>
        <para>Subclasses may modify the configuration of the given edge router instance.</para>
        <para>The type of the given instance depends on the edge routing strategy, i.e., if the routing strategy is set to <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Octilinear" /> or <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Orthogonal" /> it's an instance of <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />, if the routing strategy is set to <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Organic" /> it's an instance of <see cref="T:yWorks.Layout.Organic.OrganicLayout" />, and, if the routing strategy is set to <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Straightline" /> it's an instance of a private <see cref="T:yWorks.Layout.Router.StraightLineEdgeRouter" />. If the edge routing strategy is set to <see cref="F:yWorks.Layout.Partial.EdgeRoutingStrategy.Automatic" />, the layout algorithm chooses one of the above strategies that best fits the routing style of the fixed edges.</para>
      </remarks>
      <param name="edgeRouter">
        <para>the instance used for routing the edges</para>
      </param>
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRouter" />
      <seealso cref="P:yWorks.Layout.Partial.PartialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="T:yWorks.Layout.PartitionLayout">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.PartitionLayout" /> provides a framework for layouts that are based on a divide and conquer approach.</para>
      </summary>
      <remarks>
        <para>
          <h2>Concept</h2> The approach can be subdivided into four stages:</para>
        <list type="number">
          <item>The input graph is partitioned into smaller units. Implementations of this phase can be set using method <see cref="P:yWorks.Layout.PartitionLayout.PartitionFinder" />.</item>
          <item>Optionally, the layout algorithm arranges each partition. Implementations of this phase can be set using method <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout" />.</item>
          <item>The graph partitions are arranged next to each other keeping their layout. Implementations of this phase can be set using method <see cref="P:yWorks.Layout.PartitionLayout.PartitionPlacer" />.</item>
          <item>Edges that connect nodes in different graph partitions will be routed. Implementations of this phase can be set using method <see cref="P:yWorks.Layout.PartitionLayout.InterEdgeRouter" /></item>
        </list>
      </remarks>
    </member>
    <member name="T:yWorks.Layout.PartitionLayout.IPartitionFinder">
      <summary>
        <para>A <see cref="T:yWorks.Layout.PartitionLayout.IPartitionFinder" /> is responsible for partitioning the input graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.IPartitionFinder.FindPartitions(yWorks.Layout.LayoutGraph,yWorks.Algorithms.INodeMap)">
      <summary>
        <para>Returns a partition ID for each node of an input graph.</para>
      </summary>
      <remarks>
        <para>Nodes that share a common partition ID are considered to belong to the same partition.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="partitionIDMap">
        <para>the map that is filled with the resulting partition IDs</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.PartitionLayout.IPartitionPlacer">
      <summary>
        <para>A <see cref="T:yWorks.Layout.PartitionLayout.IPartitionPlacer" /> is responsible for arranging the graph partitions.</para>
      </summary>
      <remarks>
        <para>Arranging a graph partition usually involves applying a coordinate translation to all elements that belong to the partition in order to generate a non-overlapping node arrangement.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.IPartitionPlacer.PlacePartitions(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Arranges the graph while taking partition IDs and inter-edge information into account.</para>
      </summary>
      <remarks>
        <para>Edges which connect nodes that belong to two different partitions are called inter-edges</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="partitionIDDP">
        <para>the partition ID for each node in the graph</para>
      </param>
      <param name="interEdgeDP">
        <para>the map which marks inter-edges</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.PartitionLayout.IInterEdgeRouter">
      <summary>
        <para>An <see cref="T:yWorks.Layout.PartitionLayout.IInterEdgeRouter" /> is responsible for routing inter-edges.</para>
      </summary>
      <remarks>
        <para>An inter-edge is an edge that connects nodes that belong to different partitions.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.IInterEdgeRouter.RouteInterEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Routes inter-edges of the partitioned graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="partitionIDDP">
        <para>the partition ID for each node in the graph</para>
      </param>
      <param name="interEdgeDP">
        <para>the map that marks inter-edges</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.PartitionLayout.IInterEdgeRouter.RouteInterEdgesOnly">
      <summary>
        <para>Gets or sets whether or not to route inter-edges only.</para>
      </summary>
      <remarks>
        <para>Inter-edges are edges that connect nodes from different partitions. If this feature is disabled, all edges are routed by this routing algorithm.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if only inter-edges are routed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.PartitionLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Arranges and places independent partitions in the graph.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if the <see cref="P:yWorks.Layout.PartitionLayout.PartitionFinder">partition finder</see> is <c>null</c></para>
      </exception>
      <param name="graph" />
    </member>
    <member name="P:yWorks.Layout.PartitionLayout.PartitionFinder">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.PartitionLayout.IPartitionFinder" /> instance that is responsible for partitioning the input graph.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.PartitionLayout.IPartitionFinder" /> that is used</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PartitionLayout.PartitionPlacer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.PartitionLayout.IPartitionPlacer" /> instance that is responsible for arranging the graph partitions.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.PartitionLayout.IPartitionPlacer" /> that is used</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PartitionLayout.InterEdgeRouter">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.PartitionLayout.IInterEdgeRouter" /> instance that is responsible for inter-edge routing.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.PartitionLayout.IInterEdgeRouter" /> that is used</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.CreateChannelInterEdgeRouter(yWorks.Layout.Router.ChannelEdgeRouter)">
      <summary>
        <para>Creates an inter-edge router that is based on <see cref="T:yWorks.Layout.Router.ChannelEdgeRouter" />.</para>
      </summary>
      <param name="router">
        <para>The router instance to use for the edge routing. If not specified, a internal instance is used.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.CreatePolylineInterEdgeRouter(yWorks.Layout.Router.Polyline.EdgeRouter)">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.PartitionLayout.PolylineInterEdgeRouter" /> routes inter-edges using <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />.</para>
      </summary>
      <param name="router">
        <para>The router instance to use for the edge routing. If not specified, a internal instance is used.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.CreateEdgeBetweennessPartitionFinder(System.Int32,System.Int32)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.PartitionLayout.IPartitionFinder" /> that uses <see cref="M:yWorks.Algorithms.Groups.EdgeBetweennessClustering(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap,System.Boolean,System.Int32,System.Int32,yWorks.Algorithms.IDataProvider)" /> as strategy for finding graph partitions.</para>
      </summary>
      <param name="minimumPartitionCount">
        <para>The minimum number of partitions the result should have.</para>
      </param>
      <param name="maximumPartitionCount">
        <para>The maximum number of partitions the result should have.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.PartitionLayout.CreateComponentPartitionPlacer(yWorks.Layout.ComponentLayout)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.PartitionLayout.IPartitionPlacer" /> that uses <see cref="T:yWorks.Layout.ComponentLayout" /> to place the partitions.</para>
      </summary>
      <param name="componentLayout">
        <para>An optional <see cref="T:yWorks.Layout.ComponentLayout" /> to use.</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.PortCalculator">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.PortCalculator" /> adjusts the final port assignments after a layout has been calculated.</para>
      </summary>
      <remarks>
        <para>This can be useful if the port assignment calculated by the layout algorithm is insufficient. This stage uses <see cref="T:yWorks.Algorithms.IDataProvider" /> instances registered with the graph using the keys defined in the <see cref="T:yWorks.Layout.IIntersectionCalculator" /> interface to calculate the new port offsets.</para>
        <para>For each edge in the graph, <see cref="T:yWorks.Layout.IIntersectionCalculator" />s are retrieved from these <see cref="T:yWorks.Algorithms.IDataProvider" />s. If such an <see cref="T:yWorks.Layout.IIntersectionCalculator" /> is assigned, it will provide the intersection point of the edge and the node. Then this point is added to the <see cref="T:yWorks.Layout.IEdgeLayout" />.</para>
        <para>For this layout stage to work properly, use <see cref="M:yWorks.Layout.CompositeLayoutStage.PrependStage(yWorks.Layout.ILayoutStage)" /> or <see cref="M:yWorks.Layout.MultiStageLayout.PrependStage(yWorks.Layout.ILayoutStage)" /> to add this layout stage and register appropriate <see cref="T:yWorks.Algorithms.IDataProvider" />s with the graph using the keys defined in <see cref="T:yWorks.Layout.IIntersectionCalculator" />.</para>
        <para>Note that this class will not change the coordinates of a port if it is associated with a strong port constraint.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.IIntersectionCalculator" />
      <seealso cref="F:yWorks.Layout.IntersectionCalculatorKeys.SourceIntersectionCalculatorDpKey" />
      <seealso cref="F:yWorks.Layout.IntersectionCalculatorKeys.TargetIntersectionCalculatorDpKey" />
      <seealso cref="T:yWorks.Layout.PortConstraint" />
    </member>
    <member name="M:yWorks.Layout.PortCalculator.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.PortCalculator" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.PortCalculator.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Adjusts the ports after invoking the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.PortCalculator.CalculatePorts(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Performs the actual port calculation on the specified graph instance.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="F:yWorks.Layout.PortCalculator.Eps">
      <summary>
        <para>EPSILON used by <see cref="M:yWorks.Layout.PortCalculator.EqualsEps(System.Double,System.Double,System.Double,System.Double)" />.</para>
      </summary>
      <remarks>
        <para>By default this is <c>0.2d</c>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.PortCalculator.EqualsEps(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Determines whether two points are equal.</para>
      </summary>
      <remarks>
        <para>This implementation uses <see cref="F:yWorks.Layout.PortCalculator.Eps" /> to add some tolerance to the comparison. It is called by <see cref="M:yWorks.Layout.PortCalculator.CalculatePorts(yWorks.Layout.LayoutGraph)" /> and may be overridden to change the accuracy/tolerance of the comparison.</para>
      </remarks>
      <param name="x1">
        <para>the x-coordinate of the first point</para>
      </param>
      <param name="y1">
        <para>the y-coordinate of the first point</para>
      </param>
      <param name="x2">
        <para>the x-coordinate of the second point</para>
      </param>
      <param name="y2">
        <para>the y-coordinate of the second point</para>
      </param>
      <returns>
        <para>
          <c>true</c> if both points are considered equal, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.PortCalculator.CalculatePorts(yWorks.Layout.LayoutGraph)" />
      <seealso cref="F:yWorks.Layout.PortCalculator.Eps" />
    </member>
    <member name="T:yWorks.Layout.PortCandidate">
      <summary>
        <para>This class represents a candidate port on which edges can be connected to their source and/or target node.</para>
      </summary>
      <remarks>
        <para>The notion of <see cref="T:yWorks.Layout.PortCandidate" />s extends the one of <see cref="T:yWorks.Layout.PortConstraint" />s. In contrast to <see cref="T:yWorks.Layout.PortConstraint" />s, they can be associated with both edges and nodes. Moreover, more than one <see cref="T:yWorks.Layout.PortCandidate" /> can be specified for an edge or a node.</para>
        <para>
          <b>Edge</b> <see cref="T:yWorks.Layout.PortCandidate" />s can be introduced to define specific sides or exact locations on which a given edge can be connected to its source or target node. <br /> Information about edge <see cref="T:yWorks.Layout.PortCandidate" />s is held by <see cref="T:yWorks.Algorithms.IDataProvider" />s that are registered with the graph using keys <see cref="F:yWorks.Layout.PortCandidate.SourcePortCandidateCollectionDpKey" /> (to specify <see cref="T:yWorks.Layout.PortCandidate" />s for an edge on the source node) and <see cref="F:yWorks.Layout.PortCandidate.TargetPortCandidateCollectionDpKey" /> (to specify <see cref="T:yWorks.Layout.PortCandidate" />s for an edge on the target node). The <see cref="T:yWorks.Algorithms.IDataProvider" />s hold a <see cref="T:System.Collections.Generic.ICollection`1">collection</see> of <see cref="T:yWorks.Layout.PortCandidate" />s for each edge.</para>
        <para>
          <b>Node</b> <see cref="T:yWorks.Layout.PortCandidate" />s determine available ports on the nodes to which edges can be connected. This means that an edge of the graph can be connected to any of these node ports (unless edge <see cref="T:yWorks.Layout.PortCandidate" />s are specified too). <br /> To register and define node <see cref="T:yWorks.Layout.PortCandidate" />s refer to <see cref="T:yWorks.Layout.PortCandidateSet" />.</para>
        <para>A <see cref="T:yWorks.Layout.PortCandidate" /> is described by the following attributes:</para>
        <list type="bullet">
          <item>Offsets: The X-offset (Y-offset) determines the horizontal (vertical) distance of the <see cref="T:yWorks.Layout.PortCandidate" /> relative to the center of the node.</item>
          <item>Fixed or free: Fixed <see cref="T:yWorks.Layout.PortCandidate" />s are defined using exact coordinates, whereas coordinates of free candidates are selected arbitrarily.</item>
          <item>Direction: Corresponds to the incoming or outgoing directions of the edges when connecting to a target or source node, respectively.</item>
          <item>Penalty cost: Represents the cost of usage of a <see cref="T:yWorks.Layout.PortCandidate" />. During the processing of an edge by a layout or routing algorithm, candidates of lower cost will be considered first.</item>
        </list>
        <para>If candidates are defined for nodes as well as for edges and if they should be properly matched by layout algorithms (i.e. detected as the same candidate), then it is important that the same <see cref="T:yWorks.Layout.PortCandidate" /> instance is registered. It does not suffice to register candidates with the same parameter values.</para>
        <para> Example of using edge port candidates. Edge port candidates are colored uniquely based on the edge with which they are associated.</para>
        <para>Not all layout and routing algorithms are able to handle <see cref="T:yWorks.Layout.PortCandidate" />s. Major layout algorithms that obey them are <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />, <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />, <see cref="T:yWorks.Layout.Router.ChannelEdgeRouter" /> and <see cref="T:yWorks.Layout.Router.BusRouter" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.PortCandidate.SourcePortCandidateCollectionDpKey">
      <summary>
        <para>A data provider key for specifying source port candidates for each edge.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortCandidate.TargetPortCandidateCollectionDpKey">
      <summary>
        <para>A data provider key for specifying target port candidates for each edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.IsInDirection(yWorks.Layout.PortDirections)">
      <summary>
        <para>Returns whether or not this <see cref="T:yWorks.Layout.PortCandidate" /> lies in the given direction.</para>
      </summary>
      <param name="directionMask">
        <para>one of the default direction specifiers</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this <see cref="T:yWorks.Layout.PortCandidate" /> lies in the given direction, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.PortCandidate.Direction">
      <summary>
        <para>Gets the direction of this <see cref="T:yWorks.Layout.PortCandidate" />.</para>
      </summary>
      <remarks>
        <para>If the direction is required to be calculated with respect to the actual <see cref="P:yWorks.Layout.OrientationLayout.Orientation">layout orientation</see>, <see cref="M:yWorks.Layout.PortCandidate.GetDirectionForLayoutOrientation(yWorks.Layout.LayoutOrientation)" /> should be used instead.</para>
      </remarks>
      <value>
        <para>the direction of this <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </value>
      <seealso cref="M:yWorks.Layout.PortCandidate.GetDirectionForLayoutOrientation(yWorks.Layout.LayoutOrientation)" />
    </member>
    <member name="P:yWorks.Layout.PortCandidate.Fixed">
      <summary>
        <para>Gets whether or not this <see cref="T:yWorks.Layout.PortCandidate" /> is fixed.</para>
      </summary>
      <remarks>
        <para>Fixed <see cref="T:yWorks.Layout.PortCandidate" />s are defined using exact coordinates, whereas coordinates of free candidates are selected arbitrarily.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this <see cref="T:yWorks.Layout.PortCandidate" /> is fixed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortCandidate.XOffset">
      <summary>
        <para>Gets the X-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the center of the corresponding node.</para>
      </summary>
      <remarks>
        <para>The X-offset encodes the horizontal distance of the port relative to the center of a node. If the <see cref="T:yWorks.Layout.PortCandidate" /> is not <see cref="P:yWorks.Layout.PortCandidate.Fixed">fixed</see> (i.e., free), the X-offset is zero.</para>
      </remarks>
      <value>
        <para>the X-offset of this <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortCandidate.YOffset">
      <summary>
        <para>Gets the Y-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the center of the corresponding node.</para>
      </summary>
      <remarks>
        <para>The Y-offset encodes the vertical distance of the port relative to the center of a node. If the <see cref="T:yWorks.Layout.PortCandidate" /> is not <see cref="P:yWorks.Layout.PortCandidate.Fixed">fixed</see> (i.e., free), the Y-offset is zero.</para>
      </remarks>
      <value>
        <para>the Y-offset of this <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.CreateCandidate(yWorks.Layout.PortDirections)">
      <summary>
        <para>Factory method that creates a free <see cref="T:yWorks.Layout.PortCandidate" /> instance with the given direction and zero cost of usage.</para>
      </summary>
      <param name="directionMask">
        <para>any combination of the default direction specifiers</para>
      </param>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.PortCandidate" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.CreateCandidate(yWorks.Layout.PortDirections,System.Double)">
      <summary>
        <para>Factory method that creates a free <see cref="T:yWorks.Layout.PortCandidate" /> instance with the given direction and cost of usage.</para>
      </summary>
      <param name="directionMask">
        <para>any combination of the default direction specifiers</para>
      </param>
      <param name="cost">
        <para>the penalty cost for using this <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </param>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.PortCandidate" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.CreateCandidate(System.Double,System.Double,yWorks.Layout.PortDirections,System.Double)">
      <summary>
        <para>Factory method that creates a fixed <see cref="T:yWorks.Layout.PortCandidate" /> instance with the given cost of usage, direction and offset values.</para>
      </summary>
      <param name="directionMask">
        <para>any combination of the default direction specifiers</para>
      </param>
      <param name="xOffset">
        <para>the X-offset relative to the center of the node</para>
      </param>
      <param name="yOffset">
        <para>the Y-offset relative to the center of the node</para>
      </param>
      <param name="cost">
        <para>the penalty cost for using this <see cref="T:yWorks.Layout.PortCandidate" /> instance</para>
      </param>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.PortCandidate" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.CreateCandidate(yWorks.Layout.PortConstraint)">
      <summary>
        <para>Factory method that returns a free <see cref="T:yWorks.Layout.PortCandidate" /> instance with zero cost of usage and the direction specified by the <see cref="P:yWorks.Layout.PortConstraint.Side">side</see> of the given <see cref="T:yWorks.Layout.PortConstraint" />.</para>
      </summary>
      <param name="fromPortConstraint">
        <para>the <see cref="T:yWorks.Layout.PortConstraint" /> whose <see cref="P:yWorks.Layout.PortConstraint.Side">side</see> should be used as direction</para>
      </param>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.PortCandidate" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.GetHashCode">
      <summary>
        <para>Returns a hash code value for this <see cref="T:yWorks.Layout.PortCandidate" /> instance based on the internal attributes.</para>
      </summary>
      <returns>
        <para>a hash code value</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.ToPortConstraint">
      <summary>
        <para>A utility method that converts the current <see cref="T:yWorks.Layout.PortCandidate" /> instance to a <see cref="T:yWorks.Layout.PortConstraint" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Layout.PortConstraint.Side">side</see> of the created <see cref="T:yWorks.Layout.PortConstraint" /> matches the <see cref="P:yWorks.Layout.PortCandidate.Direction">direction</see> of this <see cref="T:yWorks.Layout.PortCandidate" />.</para>
        <para>If this <see cref="T:yWorks.Layout.PortCandidate" /> is <see cref="P:yWorks.Layout.PortCandidate.Fixed">fixed</see>, the resulting <see cref="T:yWorks.Layout.PortConstraint" /> will be <see cref="P:yWorks.Layout.PortConstraint.Strong">strong</see>.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.PortConstraint" /> that matches this <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.ToPortConstraintForLayoutOrientation(yWorks.Layout.LayoutOrientation)">
      <summary>
        <para>A utility method that converts the current <see cref="T:yWorks.Layout.PortCandidate" /> instance to a <see cref="T:yWorks.Layout.PortConstraint" /> with respect to the given <see cref="P:yWorks.Layout.OrientationLayout.Orientation">layout orientation</see>.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Layout.PortConstraint.Side">side</see> of the created <see cref="T:yWorks.Layout.PortConstraint" /> is the <see cref="P:yWorks.Layout.PortCandidate.Direction">direction</see> of this <see cref="T:yWorks.Layout.PortCandidate" /> interpreted for the given orientation.</para>
        <para>If this <see cref="T:yWorks.Layout.PortCandidate" /> is <see cref="P:yWorks.Layout.PortCandidate.Fixed">fixed</see>, the resulting <see cref="T:yWorks.Layout.PortConstraint" /> will be <see cref="P:yWorks.Layout.PortConstraint.Strong">strong</see>.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.PortConstraint" /> that matches this <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the given orientation</para>
      </returns>
      <param name="layoutOrientation" />
    </member>
    <member name="M:yWorks.Layout.PortCandidate.Equals(System.Object)">
      <summary>
        <para>Returns whether or not this <see cref="T:yWorks.Layout.PortCandidate" /> is equal to another <see cref="T:yWorks.Layout.PortCandidate" /> based on their internal attributes.</para>
      </summary>
      <param name="other">
        <para>the reference <see cref="T:yWorks.Layout.PortCandidate" /> object with which to compare</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this object is the same as the <see cref="T:yWorks.Layout.PortCandidate" /> argument, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.PortCandidate.Cost">
      <summary>
        <para>Gets the penalty cost for using this <see cref="T:yWorks.Layout.PortCandidate" /> instance.</para>
      </summary>
      <value>
        <para>the penalty cost of this <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.GetDirectionForLayoutOrientation(yWorks.Layout.LayoutOrientation)">
      <summary>
        <para>Returns the direction of this <see cref="T:yWorks.Layout.PortCandidate" /> instance with respect to the given <see cref="P:yWorks.Layout.OrientationLayout.Orientation">layout orientation</see>.</para>
      </summary>
      <remarks>
        <para>If the direction mask is not required to be calculated with respect to the actual <see cref="P:yWorks.Layout.OrientationLayout.Orientation">layout orientation</see>, <see cref="P:yWorks.Layout.PortCandidate.Direction" /> should be used instead.</para>
      </remarks>
      <returns>
        <para>the direction of this <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the given layout orientation</para>
      </returns>
      <seealso cref="P:yWorks.Layout.PortCandidate.Direction" />
      <param name="layoutOrientation" />
    </member>
    <member name="M:yWorks.Layout.PortCandidate.GetXOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)">
      <summary>
        <para>Returns the X-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the center of the corresponding node for the given <see cref="P:yWorks.Layout.OrientationLayout.Orientation">layout orientation</see> and <see cref="P:yWorks.Layout.OrientationLayout.MirrorMode">mirror mask</see>.</para>
      </summary>
      <remarks>
        <para>The X-offset encodes the horizontal distance of the port relative to the center of a node. If the <see cref="T:yWorks.Layout.PortCandidate" /> is not <see cref="P:yWorks.Layout.PortCandidate.Fixed">fixed</see> (i.e., free), the X-offset is equal to zero.</para>
      </remarks>
      <param name="layoutOrientation">
        <para>the layout orientation</para>
      </param>
      <param name="mirrorMask">
        <para>the mirror mask</para>
      </param>
      <returns>
        <para>the X-offset of the port with respect to the given orientation and mirror mask</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.GetYOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation,yWorks.Layout.MirrorModes)">
      <summary>
        <para>Returns the Y-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the center of the corresponding node for the given <see cref="P:yWorks.Layout.OrientationLayout.Orientation">layout orientation</see> and <see cref="P:yWorks.Layout.OrientationLayout.MirrorMode">mirror mask</see>.</para>
      </summary>
      <remarks>
        <para>The Y-offset encodes the vertical distance of the port relative to the center of a node. If the <see cref="T:yWorks.Layout.PortCandidate" /> is not <see cref="P:yWorks.Layout.PortCandidate.Fixed">fixed</see> (i.e., free), the Y-offset is equal to zero.</para>
      </remarks>
      <param name="layoutOrientation">
        <para>the layout orientation</para>
      </param>
      <param name="mirrorMask">
        <para>the mirror mask</para>
      </param>
      <returns>
        <para>the Y-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the given orientation and mirror mask</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.GetXOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation)">
      <summary>
        <para>Returns the X-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the center of the corresponding node for the given <see cref="P:yWorks.Layout.OrientationLayout.Orientation">layout orientation</see>.</para>
      </summary>
      <remarks>
        <para>The X-offset encodes the horizontal distance of the port relative to the center of a node. If the <see cref="T:yWorks.Layout.PortCandidate" /> is not <see cref="P:yWorks.Layout.PortCandidate.Fixed">fixed</see> (i.e., free), the X-offset is equal to zero.</para>
      </remarks>
      <param name="layoutOrientation">
        <para>the layout orientation</para>
      </param>
      <returns>
        <para>the X-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the given layout orientation</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.GetYOffsetForLayoutOrientation(yWorks.Layout.LayoutOrientation)">
      <summary>
        <para>Returns the Y-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the center of the corresponding node for the given <see cref="P:yWorks.Layout.OrientationLayout.Orientation">layout orientation</see>.</para>
      </summary>
      <remarks>
        <para>The Y-offset encodes the vertical distance of the port relative to the center of a node. If the <see cref="T:yWorks.Layout.PortCandidate" /> is not <see cref="P:yWorks.Layout.PortCandidate.Fixed">fixed</see> (i.e., free), the Y-offset is equal to zero.</para>
      </remarks>
      <param name="layoutOrientation">
        <para>the layout orientation</para>
      </param>
      <returns>
        <para>the Y-offset of the <see cref="T:yWorks.Layout.PortCandidate" /> with respect to the given layout orientation</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidate.ToString">
      <summary>
        <para>Returns a string representation of this <see cref="T:yWorks.Layout.PortCandidate" /> instance.</para>
      </summary>
      <returns>
        <para>a string representation of the <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.PortCandidateSet">
      <summary>
        <para>This class associates <see cref="T:yWorks.Layout.PortCandidate" />s with the nodes of a graph.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.PortCandidate" />s defined on nodes specify sides or even exact locations at which edges can be connected. This means that an edge can be connected to any of the available node ports (unless edge <see cref="T:yWorks.Layout.PortCandidate" />s are specified too). Each node <see cref="T:yWorks.Layout.PortCandidate" /> has a capacity, i.e., a maximum number of edges allowed to connect to it.</para>
        <para>Information about <see cref="T:yWorks.Layout.PortCandidate" />s on nodes is held by a <see cref="T:yWorks.Algorithms.IDataProvider" /> that stores a <see cref="T:yWorks.Layout.PortCandidateSet" /> for each node and is registered with the graph using key <see cref="F:yWorks.Layout.PortCandidateSet.NodePortCandidateSetDpKey" />.</para>
        <para>The <see cref="T:yWorks.Layout.PortCandidate" />s are retrieved from the <see cref="T:yWorks.Layout.PortCandidateSet" /> through a <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" /> that holds the information about the actual <see cref="T:yWorks.Layout.PortCandidate" />. This object is also used for retrieving the best candidate from a <see cref="T:yWorks.Layout.PortCandidateSet" /> based on the cost (lower costs are considered first) and the available capacity of each candidate. Custom searching for the best <see cref="T:yWorks.Layout.PortCandidate" /> can be achieved by implementing <see cref="T:yWorks.Layout.PortCandidateSet.ICandidateMatcher" /> interface.</para>
        <para> Example of node port candidates. Circular ports represent node port candidates on source nodes of each edge. Square and rectangular ports are possible port candidates on the target node. Rectangular ports have zero cost of usage and unit capacity whereas square rectangles have unit cost and capacity.</para>
        <para>Not all layout and routing algorithms are able to handle <see cref="T:yWorks.Layout.PortCandidate" />s. Major layout algorithms that obey them are <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />, <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />, <see cref="T:yWorks.Layout.Router.ChannelEdgeRouter" /> and <see cref="T:yWorks.Layout.Router.BusRouter" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.PortCandidateSet.NodePortCandidateSetDpKey">
      <summary>
        <para>A data provider key for specifying a port candidate set for each node.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.#ctor">
      <summary>
        <para>Creates a new empty <see cref="T:yWorks.Layout.PortCandidateSet" /> instance.</para>
      </summary>
      <remarks>
        <para>Addition of <see cref="T:yWorks.Layout.PortCandidate" />s to this <see cref="T:yWorks.Layout.PortCandidateSet">set</see> can be performed using <see cref="M:yWorks.Layout.PortCandidateSet.Add(yWorks.Layout.PortCandidate,System.Int32)" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.Add(yWorks.Layout.PortCandidate,System.Int32)">
      <summary>
        <para>Adds a <see cref="T:yWorks.Layout.PortCandidate" /> with the given capacity to this <see cref="T:yWorks.Layout.PortCandidateSet" />.</para>
      </summary>
      <remarks>
        <para>The capacity value defines the maximum number of edges allowed to connect to the candidate. If no limitation for this number exists, <see cref="F:System.Int32.MaxValue" /> can be used.</para>
        <para>The capacity must be greater than zero.</para>
      </remarks>
      <param name="p">
        <para>the <see cref="T:yWorks.Layout.PortCandidate" /> to add</para>
      </param>
      <param name="connections">
        <para>the capacity of the given port</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given capacity is less than or equal to zero</para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.PortCandidateSet.ConnectionCount">
      <summary>
        <para>Gets the total number of connections allowed by the <see cref="T:yWorks.Layout.PortCandidate" />s described by this <see cref="T:yWorks.Layout.PortCandidateSet" /> or <see cref="F:System.Int32.MaxValue" /> if the number is unbounded.</para>
      </summary>
      <value>
        <para>the number of connections allowed by this <see cref="T:yWorks.Layout.PortCandidateSet" /></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.Remove(yWorks.Layout.PortCandidateSet.IEntry)">
      <summary>
        <para>Removes the given <see cref="T:yWorks.Layout.PortCandidateSet.IEntry">entry</see> from the list of candidate entries.</para>
      </summary>
      <param name="entry">
        <para>the entry to remove</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.PortCandidateSet.Entries">
      <summary>
        <para>Gets an <see cref="T:System.Collections.Generic.IEnumerator`1" /> over the list of candidate <see cref="T:yWorks.Layout.PortCandidateSet.IEntry">entries</see> of this <see cref="T:yWorks.Layout.PortCandidateSet" />.</para>
      </summary>
      <value>
        <para>an <see cref="T:System.Collections.Generic.IEnumerator`1" /> over the list of <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" />s</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.CreateMatcher">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.PortCandidateSet.ICandidateMatcher" /> that retrieves <see cref="T:yWorks.Layout.PortCandidateSet.IEntry">entries</see> from this <see cref="T:yWorks.Layout.PortCandidateSet" />.</para>
      </summary>
      <remarks>
        <para>Each next best matching candidate is determined based on its cost, its current available capacity and based on whether or not its direction is consistent with the desired one.</para>
        <para>This method may be overridden to support custom implementations of <see cref="T:yWorks.Layout.PortCandidateSet.ICandidateMatcher" />.</para>
      </remarks>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.PortCandidateSet.ICandidateMatcher" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.PortCandidateSet.ICandidateMatcher">
      <summary>
        <para>A <see cref="T:yWorks.Layout.PortCandidateSet.ICandidateMatcher" /> retrieves the best matching <see cref="T:yWorks.Layout.PortCandidateSet.IEntry">entries</see> from a <see cref="T:yWorks.Layout.PortCandidateSet" />.</para>
      </summary>
      <remarks>
        <para>How well a candidate is matching can be decided based on its cost, its currently available capacity, its offsets or whether or not its direction is consistent with the desired one.</para>
        <para>To use custom implementations of this interface, method <see cref="M:yWorks.Layout.PortCandidateSet.CreateMatcher" /> should be overridden.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate(yWorks.Algorithms.Edge,System.Boolean,System.Double,System.Double,yWorks.Layout.PortDirections)">
      <summary>
        <para>Returns the next best matching <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" /> for the given parameters.</para>
      </summary>
      <param name="edge">
        <para>the edge for which to find a candidate</para>
      </param>
      <param name="source">
        <para>
          <c>true</c> if the given edge connects to its source node, <c>false</c> otherwise</para>
      </param>
      <param name="xOffset">
        <para>the preferred X-offset of the port relative to the center of the node</para>
      </param>
      <param name="yOffset">
        <para>the preferred Y-offset of the port relative to the center of the node</para>
      </param>
      <param name="directionMask">
        <para>any combination of default directions defined in <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </param>
      <returns>
        <para>a matching <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate(yWorks.Algorithms.Edge,System.Boolean,yWorks.Layout.PortDirections)">
      <summary>
        <para>Returns the next best matching <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" /> for the given parameters.</para>
      </summary>
      <param name="edge">
        <para>the edge for which to find a candidate</para>
      </param>
      <param name="source">
        <para>
          <c>true</c> if the given edge connects to its source node, <c>false</c> otherwise</para>
      </param>
      <param name="directionMask">
        <para>any combination of default directions defined in <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </param>
      <returns>
        <para>a matching <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.ICandidateMatcher.FindMatchingCandidate">
      <summary>
        <para>Returns the next best matching <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" />.</para>
      </summary>
      <returns>
        <para>a matching <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.GetCost(yWorks.Layout.PortCandidateSet.IEntry,yWorks.Algorithms.Edge,System.Boolean,System.Double,System.Double)">
      <summary>
        <para>Calculates the penalty cost for the usage of the given <see cref="T:yWorks.Layout.PortCandidateSet.IEntry">entry</see> and the given parameters.</para>
      </summary>
      <remarks>
        <para>The cost is equal to the <see cref="P:yWorks.Layout.PortCandidate.Cost">cost of usage</see> of the <see cref="P:yWorks.Layout.PortCandidateSet.IEntry.PortCandidate">associated port candidate</see>.</para>
        <para>This method may be overridden to customize the calculation of the cost of usage of an <see cref="T:yWorks.Layout.PortCandidateSet.IEntry">entry</see>.</para>
      </remarks>
      <param name="entry">
        <para>the entry for which the cost is computed</para>
      </param>
      <param name="edge">
        <para>the edge that will connect to the <see cref="T:yWorks.Layout.PortCandidate" /> associated with the entry</para>
      </param>
      <param name="source">
        <para>
          <c>true</c> if the given edge connects to its source node, <c>false</c> otherwise</para>
      </param>
      <param name="xOffset">
        <para>the preferred X-offset of the port relative to the center of the node</para>
      </param>
      <param name="yOffset">
        <para>the preferred Y-offset of the port relative to the center of the node</para>
      </param>
      <returns>
        <para>the penalty cost for the usage of the given <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortCandidateSet.GetPriority(yWorks.Layout.PortCandidateSet.IEntry,yWorks.Algorithms.Edge,System.Boolean)">
      <summary>
        <para>Calculates the priority of the given <see cref="T:yWorks.Layout.PortCandidateSet.IEntry">entry</see>.</para>
      </summary>
      <remarks>
        <para>Higher priority means that the entry will be considered earlier by a <see cref="T:yWorks.Layout.PortCandidateSet.ICandidateMatcher" />.</para>
        <para>This method may be overridden to customize the calculation of the priority of <see cref="T:yWorks.Layout.PortCandidateSet.IEntry">entries</see>.</para>
      </remarks>
      <param name="entry">
        <para>the entry for which the cost is computed</para>
      </param>
      <param name="edge">
        <para>the edge that will connect to the <see cref="T:yWorks.Layout.PortCandidate" /> associated with the entry</para>
      </param>
      <param name="source">
        <para>
          <c>true</c> if the given edge connects to its source node, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>the priority of the given <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.PortCandidateSet.IEntry">
      <summary>
        <para>This interface represents an entry of a <see cref="T:yWorks.Layout.PortCandidateSet" /> and provides access to the actual <see cref="T:yWorks.Layout.PortCandidate" /> instance and the maximum number of edges allowed to connect to it.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.PortCandidateSet.IEntry.PortCandidate">
      <summary>
        <para>Gets the actual <see cref="T:yWorks.Layout.PortCandidate" /> associated with this <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" />.</para>
      </summary>
      <value>
        <para>the associated <see cref="T:yWorks.Layout.PortCandidate" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortCandidateSet.IEntry.Connections">
      <summary>
        <para>Gets the maximum number of edges allowed to connect to the <see cref="T:yWorks.Layout.PortCandidate" /> associated with this <see cref="T:yWorks.Layout.PortCandidateSet.IEntry" />.</para>
      </summary>
      <remarks>
        <para>
          <see cref="F:System.Int32.MaxValue" /> indicates that the number of connections is unbounded.</para>
      </remarks>
      <value>
        <para>the capacity of the associated <see cref="T:yWorks.Layout.PortCandidate" /></para>
      </value>
    </member>
    <member name="T:yWorks.Layout.PortConstraint">
      <summary>
        <para>A <see cref="T:yWorks.Layout.PortConstraint" /> represents a constraint for the source or target port of an edge path.</para>
      </summary>
      <remarks>
        <para>It determines the location at which an edge path can be connected to its source and/or target node. There exist two different types of <see cref="T:yWorks.Layout.PortConstraint" />s:</para>
        <list type="bullet">
          <item>
            <b>Weak</b> <see cref="T:yWorks.Layout.PortConstraint" />s determine the side of the node to which an edge can be connected.</item>
          <item>
            <b>Strong</b> <see cref="T:yWorks.Layout.PortConstraint" />s determine the exact coordinates of the point to which an edge path can be connected. These coordinates are determined at the time the edge is processed by a layout or routing algorithm and are always interpreted relative to a node's center.</item>
        </list>
        <para> Sample output of <em>weak</em> port constraints. For both edges, source port constraints are associated with side <see cref="F:yWorks.Layout.PortSide.East" /> while target port constraints are associated with side <see cref="F:yWorks.Layout.PortSide.West" />. Red rectangles indicate that edges can be connected to any point of these sides. Black rectangles represent the selected ports.  Sample output of <em>strong</em> port constraints. For both edges, source port constraints are associated with side <see cref="F:yWorks.Layout.PortSide.East" /> while target port constraints are associated with side <see cref="F:yWorks.Layout.PortSide.West" />. Black rectangles indicate the exact points on the corresponding sides of the nodes to which edges can be connected.</para>
        <para>Information about <see cref="T:yWorks.Layout.PortConstraint" />s is held by <see cref="T:yWorks.Algorithms.IDataProvider" />s that are registered with the graph using keys <see cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" /> (to specify <see cref="T:yWorks.Layout.PortConstraint" />s for an edge on its source node) and <see cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" /> (to specify <see cref="T:yWorks.Layout.PortConstraint" />s for an edge on its target node).</para>
        <para>Not all layout and routing algorithms are able to handle <see cref="T:yWorks.Layout.PortConstraint" />s. Major layout algorithms that obey them are <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" />, <see cref="T:yWorks.Layout.Tree.TreeLayout" />, <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />, <see cref="T:yWorks.Layout.Router.ChannelEdgeRouter" /> and <see cref="T:yWorks.Layout.Router.BusRouter" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.PortConstraintKeys" />
    </member>
    <member name="P:yWorks.Layout.PortConstraint.Strong">
      <summary>
        <para>Gets whether or not this <see cref="T:yWorks.Layout.PortConstraint" /> instance represents a strong constraint.</para>
      </summary>
      <remarks>
        <para>A strong <see cref="T:yWorks.Layout.PortConstraint" /> determines the exact coordinates where the edge path's end should be located.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if this <see cref="T:yWorks.Layout.PortConstraint" /> is strong, <c>false</c> if it is a weak one</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortConstraint.Side">
      <summary>
        <para>Gets the side of the node to which an edge should connect.</para>
      </summary>
      <value>
        <para>one of the default side specifiers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortConstraint.AtNorth">
      <summary>
        <para>Gets whether or not this <see cref="T:yWorks.Layout.PortConstraint" /> instance is associated with side <see cref="F:yWorks.Layout.PortSide.North" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the associated side is <see cref="F:yWorks.Layout.PortSide.North" />, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortConstraint.AtSouth">
      <summary>
        <para>Gets whether or not this <see cref="T:yWorks.Layout.PortConstraint" /> instance is associated with side <see cref="F:yWorks.Layout.PortSide.South" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the associated side is <see cref="F:yWorks.Layout.PortSide.South" />, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortConstraint.AtEast">
      <summary>
        <para>Gets whether or not this <see cref="T:yWorks.Layout.PortConstraint" /> instance is associated with side <see cref="F:yWorks.Layout.PortSide.East" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the associated side is <see cref="F:yWorks.Layout.PortSide.East" />, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortConstraint.AtWest">
      <summary>
        <para>Gets whether or not this <see cref="T:yWorks.Layout.PortConstraint" /> instance is associated with side <see cref="F:yWorks.Layout.PortSide.West" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the associated side is <see cref="F:yWorks.Layout.PortSide.West" />, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PortConstraint.AtAnySide">
      <summary>
        <para>Gets whether or not this <see cref="T:yWorks.Layout.PortConstraint" /> instance is associated with side <see cref="F:yWorks.Layout.PortSide.Any" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the associated side is <see cref="F:yWorks.Layout.PortSide.Any" />, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.HasPC(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Checks whether or not there exist source or target <see cref="T:yWorks.Layout.PortConstraint" />s associated with the given edge.</para>
      </summary>
      <remarks>
        <para>To retrieve the <see cref="T:yWorks.Algorithms.IDataProvider" />s that hold information about source or target <see cref="T:yWorks.Layout.PortConstraint" />s, keys <see cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" /> and <see cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" /> are used.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="e">
        <para>the edge</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge has source or target <see cref="T:yWorks.Layout.PortConstraint" />s, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.HasSPC(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Checks whether or not there exist source <see cref="T:yWorks.Layout.PortConstraint" />s associated with the given edge.</para>
      </summary>
      <remarks>
        <para>To retrieve the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds information about source <see cref="T:yWorks.Layout.PortConstraint" />s, key <see cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" /> is used.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="e">
        <para>the edge</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge has source <see cref="T:yWorks.Layout.PortConstraint" />s, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.HasTPC(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Checks whether or not there exist target <see cref="T:yWorks.Layout.PortConstraint" />s associated with the given edge.</para>
      </summary>
      <remarks>
        <para>To retrieve the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds information about target <see cref="T:yWorks.Layout.PortConstraint" />s, key <see cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" /> is used.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="e">
        <para>the edge</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the edge has target <see cref="T:yWorks.Layout.PortConstraint" />s, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.GetSPC(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the source <see cref="T:yWorks.Layout.PortConstraint" /> associated with the given edge.</para>
      </summary>
      <remarks>
        <para>To retrieve the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds information about source <see cref="T:yWorks.Layout.PortConstraint" />s, key <see cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" /> is used.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="e">
        <para>the edge</para>
      </param>
      <returns>
        <para>the source <see cref="T:yWorks.Layout.PortConstraint" /> of the given edge or <c>null</c> if there is none</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.GetTPC(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the target <see cref="T:yWorks.Layout.PortConstraint" /> associated with the given edge.</para>
      </summary>
      <remarks>
        <para>To retrieve the <see cref="T:yWorks.Algorithms.IDataProvider" /> that holds information about target <see cref="T:yWorks.Layout.PortConstraint" />s, key <see cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" /> is used.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="e">
        <para>the edge</para>
      </param>
      <returns>
        <para>the target <see cref="T:yWorks.Layout.PortConstraint" /> of the given edge or <c>null</c> if there is none</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.GetHashCode">
      <summary>
        <para>Returns a hash code value for this <see cref="T:yWorks.Layout.PortConstraint" /> instance based on whether it is a strong constraint or not and the side attribute.</para>
      </summary>
      <returns>
        <para>a hash code value</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.Equals(System.Object)">
      <summary>
        <para>Returns whether or not this <see cref="T:yWorks.Layout.PortConstraint" /> is equal to another <see cref="T:yWorks.Layout.PortConstraint" /> based on whether they are both strong constraints or not and the side attribute.</para>
      </summary>
      <param name="other">
        <para>the reference <see cref="T:yWorks.Layout.PortConstraint" /> object with which to compare</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this <see cref="T:yWorks.Layout.PortConstraint" /> is equal to the given <see cref="T:yWorks.Layout.PortConstraint" /> argument, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.Create(yWorks.Layout.PortSide,System.Boolean)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.PortConstraint" /> that constrains the edge to connect to the given side of a node and that can be either strong or weak.</para>
      </summary>
      <remarks>
        <para>If the <see cref="T:yWorks.Layout.PortConstraint" /> is strong, the layout or routing algorithm should use the port coordinates of this constraint.</para>
      </remarks>
      <param name="side">
        <para>one of the default side specifiers</para>
      </param>
      <param name="strong">
        <para>
          <c>true</c> if this <see cref="T:yWorks.Layout.PortConstraint" /> is strong, <c>false</c> otherwise</para>
      </param>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.PortConstraint" /> instance</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown side is given</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.PortConstraint.ToString">
      <summary>
        <para>Returns a <see cref="T:System.String" /> representation of this <see cref="T:yWorks.Layout.PortConstraint" /> instance.</para>
      </summary>
      <returns>
        <para>a <see cref="T:System.String" /> representation of the <see cref="T:yWorks.Layout.PortConstraint" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.PortConstraintConfigurator">
      <summary>
        <para>The <see cref="T:yWorks.Layout.PortConstraintConfigurator" /> provides the possibility to create <see cref="T:yWorks.Layout.PortConstraint" />s according to the initial connecting side of an edge.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.PortConstraintConfigurator.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.PortConstraintConfigurator" /> instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.PortConstraintConfigurator.CreatePortConstraintFromSketch(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,System.Boolean,System.Boolean)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.PortConstraint" /> for the given edge.</para>
      </summary>
      <remarks>
        <para>The side of the constraint is set up according to the current drawing of the edge within the given graph.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="source">
        <para>
          <c>true</c> if a source <see cref="T:yWorks.Layout.PortConstraint" /> for the given edge will be created, <c>false</c> for a target <see cref="T:yWorks.Layout.PortConstraint" /></para>
      </param>
      <param name="strong">
        <para>
          <c>true</c> if a strong <see cref="T:yWorks.Layout.PortConstraint" /> is created, <c>false</c> for a weak <see cref="T:yWorks.Layout.PortConstraint" /></para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.PortConstraint" /> for the given edge whose side is retrieved from the initial drawing</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.PortConstraintConfigurator.CreatePortConstraintsFromSketch(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeMap,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Creates weak <see cref="T:yWorks.Layout.PortConstraint" />s for all edges of the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="spcMap">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be used for storing the source <see cref="T:yWorks.Layout.PortConstraint" />s of the edges</para>
      </param>
      <param name="tpcMap">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be used for storing the target <see cref="T:yWorks.Layout.PortConstraint" />s of the edges</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.PortConstraintConfigurator.CreatePortConstraintsFromSketch(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeCursor,yWorks.Algorithms.IEdgeMap,System.Boolean,yWorks.Algorithms.IEdgeMap,System.Boolean)">
      <summary>
        <para>Creates <see cref="T:yWorks.Layout.PortConstraint" />s for some edges of the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="ec">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeCursor" /> that provides access to the edges for which to create <see cref="T:yWorks.Layout.PortConstraint" />s</para>
      </param>
      <param name="spcMap">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be used for storing the source <see cref="T:yWorks.Layout.PortConstraint" />s of the edges</para>
      </param>
      <param name="strongSP">
        <para>
          <c>true</c> if strong source <see cref="T:yWorks.Layout.PortConstraint" />s should be assigned, <c>false</c> otherwise</para>
      </param>
      <param name="tpcMap">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that will be used for storing the target <see cref="T:yWorks.Layout.PortConstraint" />s of the edges</para>
      </param>
      <param name="strongTP">
        <para>
          <c>true</c> if strong target <see cref="T:yWorks.Layout.PortConstraint" />s should be assigned, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.PortConstraintKeys">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.PortConstraintKeys" /> are used for associating <see cref="T:yWorks.Algorithms.IDataProvider">DataProviders</see> that contain constraints for the edges of the input graph.</para>
      </summary>
      <remarks>
        <para>These constraints can either be <see cref="T:yWorks.Layout.PortConstraint" />s or edge groups. <see cref="T:yWorks.Layout.PortConstraint" />s force the edges to start/end on specified sides of the node. They may also restrict ports of edges to certain coordinates. Edge groups will bundle edges at a common source or target. They will start at the same coordinates and may share parts of their edge routes.</para>
        <para>Layout algorithms that support <see cref="T:yWorks.Layout.PortConstraint" />s or edge groups will access the <see cref="T:yWorks.Algorithms.IDataProvider" />s using the provided keys.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey">
      <summary>
        <para>A data provider key for providing source constraints for edges in the input graph.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey">
      <summary>
        <para>A data provider key for providing target constraints for edges in the input graph.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey">
      <summary>
        <para>A data provider key for assigning source group information for edges of the input graph.</para>
      </summary>
      <remarks>
        <para>Edges sharing a source group identifier will share a common bus near the source or at a common source node if possible.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey">
      <summary>
        <para>A data provider key for assigning target group information for edges of the input graph.</para>
      </summary>
      <remarks>
        <para>Edges sharing a target group identifier will share a common bus near the target or at a common target node if possible.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.PortConstraintKeys.SourcePortGroupIdDpKey">
      <summary>
        <para>A data provider key for assigning port group ids to the edges' source.</para>
      </summary>
      <remarks>
        <para>All edges with the same port id at a node will share the same port location. However, they will be routed independently.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.PortConstraintKeys.TargetPortGroupIdDpKey">
      <summary>
        <para>A data provider key for assigning port group ids to the edges' target.</para>
      </summary>
      <remarks>
        <para>All edges with the same port id at a node will share the same port location. However, they will be routed independently.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Layout.PortPlacementStage">
      <summary>
        <para>The <see cref="T:yWorks.Layout.PortPlacementStage" /> assigns edges to the ports specified by <see cref="T:yWorks.Layout.PortConstraint" />s or <see cref="T:yWorks.Layout.PortCandidate" />s after calling the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>It can be used for adjusting ports for layout algorithms that cannot handle <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
        <para>If <see cref="T:yWorks.Layout.PortCandidate" />s are assigned for edges and nodes, this stage tries to match them. When there is no match, the <see cref="T:yWorks.Layout.PortCandidate" /> with the lowest costs specified for the edge is chosen. While <see cref="T:yWorks.Layout.PortConstraint" />s are also matched to <see cref="T:yWorks.Layout.PortCandidate" />s at nodes and edges, it is not recommended to mix them because they belong to different concepts.</para>
        <para>Furthermore, option <see cref="P:yWorks.Layout.PortPlacementStage.PathCorrection" /> allows to specify whether the edge path should be corrected after correcting a port.</para>
        <para>It is recommended that the <see cref="T:yWorks.Layout.PortPlacementStage" /> is prepended to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> in order to be able to process all the edges and especially, self-loops and parallel edges. Note that edges that might be hidden by other <see cref="T:yWorks.Layout.ILayoutStage" />s cannot be handled by <see cref="T:yWorks.Layout.PortPlacementStage" />.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.PortConstraint" />
      <seealso cref="T:yWorks.Layout.PortCandidate" />
      <seealso cref="T:yWorks.Layout.PortCandidateSet" />
      <seealso cref="P:yWorks.Layout.PortPlacementStage.PathCorrection" />
    </member>
    <member name="M:yWorks.Layout.PortPlacementStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.PortPlacementStage" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.PortPlacementStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Corrects the ports of the edges considering <see cref="T:yWorks.Layout.PortConstraint" />s and <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.PortPlacementStage.PathCorrection">
      <summary>
        <para>Gets or sets whether or not this <see cref="T:yWorks.Layout.ILayoutStage" /> corrects the edge paths after moving the port to the location specified by a <see cref="T:yWorks.Layout.PortConstraint" /> or <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
      </summary>
      <remarks>
        <para>If path correction is enabled, the edge will be rerouted within a specific area around its source/target node. Outside this area, it will keep the route that was calculated by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. If this feature is disabled, only the ports are moved which may be more suitable for initially straight edges.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if edge paths are corrected, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.PreferredPlacementDescriptor">
      <summary>
        <para>A <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> provides placement information for automatic edge labeling.</para>
      </summary>
      <remarks>
        <para>It provides several options that influence the label placement in generic labeling algorithms and layout algorithms that support integrated label placement.</para>
        <para>The preferred placement can describe multiple locations. For some options, like the <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.PlaceAlongEdge">placement along the edge</see>, it is possible to have a combination of the valid values. These values can be connected with a logical <c>or</c>-operation.</para>
        <para>The following options describe the preferred placement:</para>
        <list type="bullet">
          <item>the placement along the edge</item>
          <item>the side of the edge</item>
          <item>the reference of the side</item>
          <item>the rotation angle of the label</item>
          <item>the reference for the rotation angle</item>
          <item>the rotation behavior for label on the right side of the edge</item>
          <item>the angle offset for label on the right side of the edge</item>
          <item>the distance between the label and its edge segment</item>
        </list>
        <para>The <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> will be immutable after <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.Freeze" /> is called.</para>
        <para>A <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> must be set for each label and will be retrieved by the layout algorithms calling <see cref="P:yWorks.Layout.IEdgeLabelLayout.PreferredPlacementDescriptor" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.PreferredPlacementDescriptor.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.PreferredPlacementDescriptor.#ctor(yWorks.Layout.PreferredPlacementDescriptor)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> instance that copies the given descriptor.</para>
      </summary>
      <param name="descriptor">
        <para>the <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> that is copied</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.PlaceAlongEdge">
      <summary>
        <para>Gets or sets the preferred placement along the edge.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this instance is <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">immutable</see></para>
      </exception>
      <value>
        <para>one of the valid positions along the edge</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge">
      <summary>
        <para>Gets or sets the preferred side of the edge.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this instance is <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">immutable</see></para>
      </exception>
      <value>
        <para>one of the valid sides of the edge</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.SideReference">
      <summary>
        <para>Gets or sets how to interpret the preferred side as given by <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this instance is <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">immutable</see></para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>if the specified side reference is invalid</para>
      </exception>
      <value>
        <para>any combination of the valid side references</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.Angle">
      <summary>
        <para>Gets or sets the angle (in radians) for the label rotation.</para>
      </summary>
      <remarks>
        <para>How this angle is applied depends on the <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleReference">angle reference</see>, the <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleRotationOnRightSide">rotation</see> and the <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleOffsetOnRightSide">offset</see> for labels on the right side of the edge.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>if this instance is <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">immutable</see></para>
      </exception>
      <value>
        <para>the angle in radians</para>
      </value>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleReference" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleRotationOnRightSide" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.AngleOffsetOnRightSide" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.AngleReference">
      <summary>
        <para>Gets or sets the reference of the angle given by <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.Angle" />.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this instance is <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">immutable</see></para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is not a valid angle reference</para>
      </exception>
      <value>
        <para>any combination of valid angle references</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.AngleRotationOnRightSide">
      <summary>
        <para>Gets or sets how the angle is applied to labels on the right side in respect of the labels of the left side of the edge.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this instance is <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">immutable</see></para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is not a valid angle rotation</para>
      </exception>
      <value>
        <para>any combination of valid rotation directions</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.AngleOffsetOnRightSide">
      <summary>
        <para>Gets or sets the angle offset for labels that are placed on the right side of the edge.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this instance is <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">immutable</see></para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is not valid angle offset</para>
      </exception>
      <value>
        <para>any combination of valid offsets (<c>0</c> or <c>180</c> degrees)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.DistanceToEdge">
      <summary>
        <para>Gets or sets the preferred distance between a label and the corresponding edge segment.</para>
      </summary>
      <remarks>
        <para>If the given distance is <c>&lt; 0</c>, the distance is not fixed, i.e., it is chosen by the automatic labeling algorithm.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>if this instance is <see cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">immutable</see></para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>if the specified value is infinite or <c>NaN</c></para>
      </exception>
      <value>
        <para>preferred distance between a label and the corresponding edge segment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAtSource">
      <summary>
        <para>Gets whether or not one of the preferred placement locations for this label is at source.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if at source is a possible placement for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelPlacements.AtSource" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAtCenter">
      <summary>
        <para>Gets whether or not one of the preferred placement locations for this label is at center.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if at center is a possible placement for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelPlacements.AtCenter" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAtTarget">
      <summary>
        <para>Gets whether or not one of the preferred placements for this label is at target.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if at target is a possible placement for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelPlacements.AtTarget" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAtSourcePort">
      <summary>
        <para>Gets whether or not one of the preferred placements for this label is at the source port.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if at source port is a possible placement for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelPlacements.AtSourcePort" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAtTargetPort">
      <summary>
        <para>Gets whether or not one of the preferred placements for this label is at the target port.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if at target port is a possible placement for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelPlacements.AtTargetPort" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsLeftOfEdge">
      <summary>
        <para>Gets whether or not one of the preferred sides for this label is left of the edge.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if left of the edge is a possible side for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelPlacements.LeftOfEdge" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsOnEdge">
      <summary>
        <para>Gets whether or not one of the preferred sides for this label is on the edge.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if on the edge is a possible side for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelPlacements.OnEdge" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsRightOfEdge">
      <summary>
        <para>Gets whether or not one of the preferred sides for this label is right of the edge.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if right of the edge is a possible side for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelPlacements.RightOfEdge" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAngleAbsolute">
      <summary>
        <para>Gets whether or not one of the angle interpretations is absolute.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if absolute angle interpretation is a possible angle interpretation for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelAngleReferences.Absolute" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAngleRelativeToEdgeFlow">
      <summary>
        <para>Gets whether or not one of the angle interpretation is relative to the edge slope.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if angle interpretation relative to the edge slope is a possible angle interpretation for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelAngleReferences.RelativeToEdgeFlow" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAngleOnRightSideCoRotating">
      <summary>
        <para>Gets whether or not one of the angle interpretations is to rotate the angle of labels that are right of the edge co-rotating with the labels left of or centered on the edge, i.e., the angle of all labels is interpreted clockwise.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if co-rotating angle interpretation for right-side edges is a possible angle interpretation for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.IsRightOfEdge" />
      <seealso cref="F:yWorks.Layout.LabelAngleOnRightSideRotations.Clockwise" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAngleOnRightSideCounterRotating">
      <summary>
        <para>Gets whether or not one of the angle interpretations is to rotate the angle of labels that are right of the edge counter-rotating with the labels left of or centered on the edge, i.e., the angle of labels left or centered on edge is interpreted clockwise while the angle of labels right of edge is interpreted counter-clockwise.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if counter-rotating angle interpretation for right-side edges is a possible angle interpretation for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.IsRightOfEdge" />
      <seealso cref="F:yWorks.Layout.LabelAngleOnRightSideRotations.CounterClockwise" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAngleOffsetOnRightSideZero">
      <summary>
        <para>Gets whether or not one of the angle interpretations is to add no angle offset to labels that are right of the edge.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if adding no angle offset for right-side edges is a possible angle interpretation for this label, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.IsRightOfEdge" />
      <seealso cref="F:yWorks.Layout.LabelAngleOnRightSideOffsets.None" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsAngleOffsetOnRightSide180">
      <summary>
        <para>Gets whether or not one of the angle interpretations is to add an angle offset of <c>180</c> degrees to labels that are right of the edge.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if adding an angle offset of <c>180</c> degrees for right-side edges is a possible angle interpretation for this label, <c>false</c> otherwise.</para>
      </value>
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.IsRightOfEdge" />
      <seealso cref="F:yWorks.Layout.LabelAngleOnRightSideOffsets.Semi" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsSideRelativeToEdgeFlow">
      <summary>
        <para>Gets whether or not the preferred side specified by <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" /> is interpreted relative to the edge flow.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the preferred side is interpreted relative to the edge flow, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelSideReferences.RelativeToEdgeFlow" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsSideAbsoluteWithLeftInNorth">
      <summary>
        <para>Gets whether or not the preferred side specified by <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" /> is interpreted absolute, and on horizontal segments, labels with preferred side <see cref="F:yWorks.Layout.LabelPlacements.LeftOfEdge" /> are placed above the segment.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the preferred side is interpreted absolute, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelSideReferences.AbsoluteWithLeftInNorth" />
    </member>
    <member name="P:yWorks.Layout.PreferredPlacementDescriptor.IsSideAbsoluteWithRightInNorth">
      <summary>
        <para>Gets whether or not the preferred side specified by <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" /> is interpreted absolute, and on horizontal segments, labels with preferred side <see cref="F:yWorks.Layout.LabelPlacements.RightOfEdge" /> are placed above the segment.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the preferred side is interpreted absolute, <c>false</c> otherwise</para>
      </value>
      <seealso cref="F:yWorks.Layout.LabelSideReferences.AbsoluteWithRightInNorth" />
    </member>
    <member name="M:yWorks.Layout.PreferredPlacementDescriptor.ToString" />
    <member name="M:yWorks.Layout.PreferredPlacementDescriptor.Equals(System.Object)">
      <param name="o" />
    </member>
    <member name="M:yWorks.Layout.PreferredPlacementDescriptor.GetHashCode" />
    <member name="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen">
      <summary>
        <para>Returns whether or not this is an immutable instance of <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" />.</para>
      </summary>
      <remarks>
        <para>If this instance is immutable, all <c>setter</c> methods will throw an <see cref="T:System.InvalidOperationException" /> when invoked.</para>
      </remarks>
      <returns>
        <para>
          <c>true</c> if this instance is immutable, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.PreferredPlacementDescriptor.Freeze" />
    </member>
    <member name="M:yWorks.Layout.PreferredPlacementDescriptor.Freeze">
      <summary>
        <para>Makes this <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> instance immutable.</para>
      </summary>
      <remarks>
        <para>If this instance is immutable, all <c>setter</c> methods will throw an <see cref="T:System.InvalidOperationException" /> when invoked.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen" />
    </member>
    <member name="M:yWorks.Layout.PreferredPlacementDescriptor.NewSharedInstance(yWorks.Layout.LabelPlacements)">
      <summary>
        <para>Returns an immutable descriptor instance for the specified placement.</para>
      </summary>
      <remarks>
        <para>Descriptor instances returned by this method will use default values for all properties but <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.PlaceAlongEdge">placement along edge</see> and <see cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge">side of edge</see>.</para>
      </remarks>
      <param name="placement">
        <para>a combination of valid placements along the edge and valid sides of the edge</para>
      </param>
      <returns>
        <para>an immutable descriptor instance for the specified placement</para>
      </returns>
      <seealso cref="M:yWorks.Layout.PreferredPlacementDescriptor.IsFrozen" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.PlaceAlongEdge" />
      <seealso cref="P:yWorks.Layout.PreferredPlacementDescriptor.SideOfEdge" />
    </member>
    <member name="T:yWorks.Layout.Radial.CenterNodesPolicy">
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.CenterNodesPolicy" />
    </member>
    <member name="F:yWorks.Layout.Radial.CenterNodesPolicy.Directed">
      <summary>
        <para>Specifier for a center nodes policy which chooses all nodes with in-degree equal to <c>0</c> as center nodes. If no node with this property is present, an arbitrary node will be selected.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.CenterNodesPolicy" />
      <seealso cref="M:yWorks.Algorithms.Trees.GetRoot(yWorks.Algorithms.Graph)" />
    </member>
    <member name="F:yWorks.Layout.Radial.CenterNodesPolicy.Centrality">
      <summary>
        <para>Specifier for a center nodes policy which chooses the node with the highest centrality as center node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.CenterNodesPolicy" />
      <seealso cref="M:yWorks.Algorithms.Trees.GetCenterRoot(yWorks.Algorithms.Graph)" />
    </member>
    <member name="F:yWorks.Layout.Radial.CenterNodesPolicy.WeightedCentrality">
      <summary>
        <para>Specifier for a center nodes policy which chooses the node with the highest weighted centrality as center node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.CenterNodesPolicy" />
      <seealso cref="M:yWorks.Algorithms.Trees.GetWeightedCenterNode(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)" />
    </member>
    <member name="F:yWorks.Layout.Radial.CenterNodesPolicy.Custom">
      <summary>
        <para>Specifier for a center nodes policy which uses center nodes specified by the user. The center nodes have to be specified using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the <see cref="P:yWorks.Layout.Radial.RadialLayout.CenterNodesDpKey">according key</see>. The <see cref="T:yWorks.Algorithms.IDataProvider" /> returns <c>true</c> for nodes that should be placed in the center.</para>
        <para>If there exists more than one center node, they will be placed on the innermost circle while the center position stays empty.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.CenterNodesPolicy" />
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.CenterNodesDpKey" />
    </member>
    <member name="T:yWorks.Layout.Radial.LayeringStrategy">
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.LayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Radial.LayeringStrategy.Bfs">
      <summary>
        <para>Specifier for a layering strategy that uses breadth first search (BFS) to determine a layering for the graph. All edges will span at most one layer in the resulting drawing. Edges between nodes that belong to the same layer are possible.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.LayeringStrategy" />
    </member>
    <member name="F:yWorks.Layout.Radial.LayeringStrategy.Hierarchical">
      <summary>
        <para>Specifier for a layering strategy that uses an optimal hierarchical layering strategy. The layer distance of an edge is the absolute difference between the layer numbers of its source and target node. Layer assignment will be done such that the overall sum of the layer distances of all edges in the layout is minimal.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.LayeringStrategy" />
    </member>
    <member name="T:yWorks.Layout.Radial.EdgeRoutingStrategy">
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="F:yWorks.Layout.Radial.EdgeRoutingStrategy.Polyline">
      <summary>
        <para>Specifier for an edge routing strategy that will route edges with polyline segments from source to target with one bend on each spanned circle.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="F:yWorks.Layout.Radial.EdgeRoutingStrategy.Arc">
      <summary>
        <para>Specifier for an edge routing strategy that will route edges as arcs. The source and target of an edge as well as one bend on each spanned circle are used as main control points. An easing function is applied in order to calculate additional control points between the polar coordinates of the main control points.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.EdgeRoutingStrategy" />
    </member>
    <member name="T:yWorks.Layout.Radial.RadialLayout">
      <summary>
        <para>This layout algorithm arranges graphs in a radial fashion.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The nodes are distributed into circles (layers) around a common center based on predefined <see cref="P:yWorks.Layout.Radial.RadialLayout.LayeringStrategy">layering strategies</see>. Some potential applications include visualization of social networks, data clustering and bioinformatics.  Sample output of the layout algorithm with default settings and one center node  Sample output of the layout algorithm with straight-line edges and five center nodes using <see cref="F:yWorks.Layout.Radial.CenterNodesPolicy.Custom" /> policy <h2>Concept</h2> The layout algorithm creates a virtual tree structure for the input graph whose root node is placed in the center of the circles. All children of a tree node are placed on a higher layer (i.e. on a circle of larger radius) than their parent. A sector is calculated for each node such that the sector of each child node in the virtual tree is a sub-sector of its parent's sector. The radii of the circles are calculated based on the sizes of the sectors required to accommodate each whole subtree. <h2>Features</h2></para>
        <para>There are different <see cref="P:yWorks.Layout.Radial.RadialLayout.CenterNodesPolicy">center nodes policies</see> that can be applied in order to determine the nodes that will be placed in the center (single center node) or on the innermost circle (more than one center node). The distribution of the nodes to the circles is specified by a <see cref="P:yWorks.Layout.Radial.RadialLayout.LayeringStrategy">layering strategy</see>.</para>
        <para>The edges are routed based on the <see cref="P:yWorks.Layout.Radial.RadialLayout.EdgeRoutingStrategy">edge routing strategy</see>. Note that the edge routing cannot always prevent node-edge overlaps.</para>
        <para>The minimum distance between nodes of the same circle is specified using <see cref="P:yWorks.Layout.Radial.RadialLayout.MinimumNodeToNodeDistance" />. If there are too many nodes assigned to a circle, the radius of the particular circle will be increased until all nodes fit onto it.</para>
        <para>The distance between consecutive layers is specified using <see cref="P:yWorks.Layout.Radial.RadialLayout.LayerSpacing" />. The radii of the circles are a multiple of this spacing value. If the layer spacing is <c>0</c>, the radii are chosen such that all nodes fit on their corresponding circles. A minimum layer distance is specified by <see cref="P:yWorks.Layout.Radial.RadialLayout.MinimumLayerDistance" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Radial.RadialLayout.NodeInfoDpKey">
      <summary>
        <para>A data acceptor key for publishing the circle ID and sector data.</para>
      </summary>
      <remarks>
        <para>For each node, the ID of the circle and data regarding the circular sector on which it was placed will be stored.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.MinimumNodeToNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two neighboring nodes of the same circle.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum distance is negative</para>
      </exception>
      <value>
        <para>a non-negative distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.LayerSpacing">
      <summary>
        <para>Gets or sets the spacing between two consecutive circles (layers).</para>
      </summary>
      <remarks>
        <para>The spacing is a non-negative value, where <c>0</c> means that no spacing is considered.</para>
        <para>The radius of each circle will be a multiple of this value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the spacing value is negative</para>
      </exception>
      <value>
        <para>the spacing value</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.MinimumLayerDistance">
      <summary>
        <para>Gets or sets the minimum distance between two circles.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum layer distance is negative</para>
      </exception>
      <value>
        <para>the non-negative distance between two circles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.MaximumChildSectorAngle">
      <summary>
        <para>Gets or sets the maximum sector angle around a node within which the node's children will be placed.</para>
      </summary>
      <remarks>
        <para>Based on the location of a given node, the sector of its children that lie on the next outer layer is described by this angle. The vertex of the angle is located in the center of the node while its sides point away from the inner circles. The child nodes are placed inside this angle. If there is not enough space, the radius of the child circle is increased.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the sector angle is negative or greater than <c>360</c> degrees</para>
      </exception>
      <value>
        <para>the maximum sector angle in degrees from the interval <c>[0,360]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.MinimumBendAngle">
      <summary>
        <para>Gets or sets the minimum bend angle (in degrees) between two adjacent edge segments.</para>
      </summary>
      <remarks>
        <para>The minimum bend angle is defined to be a value between <c>0</c> and <c>90</c> degrees.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum bend angle is negative or greater than <c>90</c></para>
      </exception>
      <value>
        <para>an angle from the interval <c>[0,90]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.CenterNodesPolicy">
      <summary>
        <para>Gets or sets the policy that determines which nodes are selected as roots of the (virtual) tree for the layout process and are set in the center of the circles.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an invalid center node policy is given</para>
      </exception>
      <value>
        <para>one of the predefined center node policies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.CenterNodesDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key used for looking up the selected nodes that should be placed in the center.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for the selection of center nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.LayeringStrategy">
      <summary>
        <para>Gets or sets the layering strategy that determines how nodes are distributed into different layers.</para>
      </summary>
      <remarks>
        <para>All nodes of a given layer will be placed on the same circle.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an invalid layering strategy is set</para>
      </exception>
      <value>
        <para>one of the predefined layering strategies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.EdgeRoutingStrategy">
      <summary>
        <para>Gets or sets the edge routing strategy.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an invalid edge routing strategy is set</para>
      </exception>
      <value>
        <para>the edge routing strategy</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not node labels are taken into account when calculating node positions.</para>
      </summary>
      <remarks>
        <para>Thereby, possible node/node label or node label/node label overlaps are prevented.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if node labels are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.OrientationLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of the layout is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that modifies the orientation is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="M:yWorks.Layout.Radial.RadialLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Radial.RadialLayout" /> instance with the default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Radial.RadialLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates a radial arrangement for the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.EdgeBundling">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.EdgeBundling" /> instance that defines the settings of the edge bundling feature.</para>
      </summary>
      <remarks>
        <para>The specified <see cref="T:yWorks.Layout.EdgeBundling" /> defines global bundling properties. Settings for individual edges can be defined by assigning an <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> to an edge using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey" />.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.EdgeBundling" /> instance defining the edge bundling setup</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Radial.RadialLayout.NodeInfo">
      <summary>
        <para>Info object used for retrieving information about each node from the layout algorithm.</para>
      </summary>
      <remarks>
        <para>The information can be retrieved by registering with the graph a <see cref="T:yWorks.Algorithms.IDataProvider" /> (which should also implement the <see cref="T:yWorks.Algorithms.IDataAcceptor" /> interface) using key <see cref="F:yWorks.Layout.Radial.RadialLayout.NodeInfoDpKey" />. The layout algorithm will return a <see cref="T:yWorks.Layout.Radial.RadialLayout.NodeInfo" /> object with appropriately filled fields for each <see cref="T:yWorks.Algorithms.Node" /> when the layout is calculated.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Radial.RadialLayout.NodeInfo.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Radial.RadialLayout.NodeInfo" /> instance.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.NodeInfo.CircleIndex">
      <summary>
        <para>Gets the index of the circle the node is placed on.</para>
      </summary>
      <remarks>
        <para>The circles used by the <see cref="T:yWorks.Layout.Radial.RadialLayout" /> are indexed from the innermost to the outermost circle. Index <c>0</c> represents the center, i.e. the circle with radius <c>0</c>.</para>
      </remarks>
      <value>
        <para>the index of the circle the node is placed on</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.NodeInfo.Radius">
      <summary>
        <para>Gets the radius of the circle the node is placed on.</para>
      </summary>
      <value>
        <para>the radius of the circle the node is placed on</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.NodeInfo.CenterOffset">
      <summary>
        <para>Gets the offset from the center of the circle, the node is placed on, to the center of the node.</para>
      </summary>
      <value>
        <para>the offset from the center of the circle, the node is placed on, to the center of the node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.NodeInfo.SectorStart">
      <summary>
        <para>Gets the start angle in degrees of the sector the node is placed in.</para>
      </summary>
      <remarks>
        <para>The angle refers to a counter-clockwise rotation starting at the 3o'clock position.</para>
      </remarks>
      <value>
        <para>the start angle in degrees of the sector the node is placed in</para>
      </value>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.NodeInfo.SectorSize" />
    </member>
    <member name="P:yWorks.Layout.Radial.RadialLayout.NodeInfo.SectorSize">
      <summary>
        <para>Gets the size in degrees of the sector the node is placed in.</para>
      </summary>
      <value>
        <para>the size in degrees of the sector the node is placed in</para>
      </value>
      <seealso cref="P:yWorks.Layout.Radial.RadialLayout.NodeInfo.SectorStart" />
    </member>
    <member name="T:yWorks.Layout.RemoveCollinearBendsStage">
      <summary>
        <para>The <see cref="T:yWorks.Layout.RemoveCollinearBendsStage" /> removes all collinear bends found in a graph.</para>
      </summary>
      <remarks>
        <para>The algorithm traverses each edge path from source to target and removes for each triple of consecutive collinear bends the middle one.</para>
        <para>A collinear bend forms a straight line with its preceding bend and its subsequent bend. The angle between the connecting edge segments is either <c>0</c> or <c>180</c> degrees.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.RemoveCollinearBendsStage.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.RemoveCollinearBendsStage" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.RemoveCollinearBendsStage.Scale">
      <summary>
        <para>Gets or sets the scale that defines how accurate the algorithm is when it comes to comparing the coordinates of two bends.</para>
      </summary>
      <remarks>
        <para>This value determines how the values of the coordinates are rounded. If rounded coordinates lead to a collinear bend, this bend will be removed.</para>
        <para>The scaling factor needs to be positive.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified factor is less than or equal to <c>0</c></para>
      </exception>
      <value>
        <para>the scale</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.RemoveCollinearBendsStage.RemoveStraightOnly">
      <summary>
        <para>Gets or sets whether the algorithm removes only collinear bends which lie in the middle of their neighbors or all collinear bends.</para>
      </summary>
      <remarks>
        <para>In the first case, the angle at the middle bend must be <c>180</c> degrees, while in the second case, the angle can be either <c>180</c> degrees or <c>0</c> degrees.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if only bends with <c>180</c> degrees are removed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.RemoveCollinearBendsStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Removes collinear bends of the edges in the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.ReverseEdgesStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.ReverseEdgesStage" /> selectively reverses edges in a graph, while keeping the layout and label positions of the reversed edges as close to the pre-reversal layout and positions as possible.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.ReverseEdgesStage.AffectedEdgesDpKey">
      <summary>
        <para>A data provider key for selecting edges for reversal.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.ReverseEdgesStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.ReverseEdgesStage" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
      <seealso cref="P:yWorks.Layout.LayoutStageBase.CoreLayout" />
    </member>
    <member name="M:yWorks.Layout.ReverseEdgesStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Reverses all <em>selected</em> edges before calling the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and restores the original edge direction after the core layout algorithm has finished.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.ReverseEdgesStage.ReverseEdges(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Reverses <em>selected</em> edges in the specified graph.</para>
      </summary>
      <remarks>
        <para>
          <em>Selected</em> edges are marked in a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.ReverseEdgesStage.AffectedEdgesDpKey" />.</para>
        <para>Implementation detail: This method calls <see cref="M:yWorks.Layout.ReverseEdgesStage.ReverseEdge(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)" /> in order to reverse a <em>selected</em> edge.</para>
      </remarks>
      <param name="graph">
        <para>the graph in which to reverse edges.</para>
      </param>
      <seealso cref="F:yWorks.Layout.ReverseEdgesStage.AffectedEdgesDpKey" />
      <seealso cref="M:yWorks.Layout.ReverseEdgesStage.ReverseEdge(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)" />
    </member>
    <member name="M:yWorks.Layout.ReverseEdgesStage.ReverseEdge(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Reverses the specified edge in the specified graph.</para>
      </summary>
      <remarks>
        <para>The layout of the specified edge is reversed as specified in <see cref="M:yWorks.Layout.LayoutGraphUtilities.ReverseEdgeLayout(yWorks.Layout.IEdgeLayout)" />. Moreover, the positions of all labels associated with the specified edge are adjusted to match the pre-reversal position as closely as possible. (Depending on a label's model it might not always be possible to achieve an exact match.)</para>
      </remarks>
      <param name="graph">
        <para>the graph to which the specified edge belongs</para>
      </param>
      <param name="edge">
        <para>the edge to be reversed</para>
      </param>
      <seealso cref="M:yWorks.Layout.LayoutGraphUtilities.ReverseEdgeLayout(yWorks.Layout.IEdgeLayout)" />
    </member>
    <member name="M:yWorks.Layout.ReverseEdgesStage.FindReversedTreeEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.IDataAcceptor)">
      <summary>
        <para>Marks edges in a tree-structured graph component that need to be reversed to make the specified node the root of the tree component.</para>
      </summary>
      <remarks>
        <para>Only edges in the graph component to which the specified node belongs will be marked.</para>
      </remarks>
      <param name="graph">
        <para>the graph to which the specified node belongs</para>
      </param>
      <param name="root">
        <para>the node to be considered the root of its tree component</para>
      </param>
      <param name="reversedEdges">
        <para>a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> to mark edges for reversal</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the specified root node is <c>null</c> or does not belong to the specified graph</para>
      </exception>
      <seealso cref="F:yWorks.Layout.ReverseEdgesStage.AffectedEdgesDpKey" />
    </member>
    <member name="T:yWorks.Layout.Router.BusDescriptor">
      <summary>
        <para>A descriptor for bus-related information to be associated with an edge.</para>
      </summary>
      <remarks>
        <para>It consists of a bus ID defining the bus of the associated edge, two optional edge group IDs for specifying the edge grouping at the source and target side, respectively, and an optional boolean flag to mark the edge as fixed.</para>
        <para>Every object except <c>null</c> can be used as a valid bus ID. Every edge of ID <c>null</c> forms a group of its own. Also, every object except <c>null</c> can be used as a valid edge group ID. If there is no group ID defined for an edge or if <c>null</c> is set, a default group ID is used. Therefore, all such edges ending at the same node belong to the same group.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Router.BusRouter.EdgeDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Router.BusDescriptor.#ctor(System.Object)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.BusDescriptor" /> for the specified bus ID which is marked as not fixed and uses the default edge group IDs.</para>
      </summary>
      <param name="busID">
        <para>the ID of the bus to which the associated edge belongs</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.BusDescriptor.#ctor(System.Object,System.Object,System.Object)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.BusDescriptor" /> for the specified parameters and marks it as not fixed.</para>
      </summary>
      <param name="busID">
        <para>the ID of the bus to which the associated edge belongs</para>
      </param>
      <param name="sourceGroupID">
        <para>the group ID of the source side</para>
      </param>
      <param name="targetGroupID">
        <para>the group ID of the target side</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.BusDescriptor.#ctor(System.Object,System.Boolean)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.BusDescriptor" /> for the specified parameters and default group IDs.</para>
      </summary>
      <param name="busID">
        <para>the ID of the bus to which the associated edge belongs</para>
      </param>
      <param name="fixed">
        <para>
          <c>true</c> if associated edge is fixed, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.BusDescriptor.#ctor(System.Object,System.Boolean,System.Object,System.Object)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.BusDescriptor" /> for the specified parameters.</para>
      </summary>
      <param name="busID">
        <para>the ID of the bus to which the associated edge belongs</para>
      </param>
      <param name="fixed">
        <para>
          <c>true</c> if associated edge is fixed, <c>false</c> otherwise</para>
      </param>
      <param name="sourceGroupID">
        <para>the group ID of the source side</para>
      </param>
      <param name="targetGroupID">
        <para>the group ID of the target side</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.BusDescriptor.Equals(System.Object)">
      <summary>
        <para>Indicates whether or not some other object is "equal to" this one.</para>
      </summary>
      <param name="obj">
        <para>the reference object with which to compare</para>
      </param>
      <returns>
        <para>
          <c>true</c> if all corresponding parameters are equal, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.BusDescriptor.GetHashCode">
      <summary>
        <para>Returns a hash code value for this <see cref="T:yWorks.Layout.Router.BusDescriptor" /> instance.</para>
      </summary>
      <returns>
        <para>a hash code value</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.BusDescriptor.BusId">
      <summary>
        <para>Gets or sets the bus ID.</para>
      </summary>
      <remarks>
        <para>Edges associated with <see cref="T:yWorks.Layout.Router.BusDescriptor">descriptor instances</see> having the same bus ID belong to a common bus. Every edge associated with ID <c>null</c> forms a group of its own.</para>
      </remarks>
      <value>
        <para>the bus ID</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusDescriptor.SourceGroupId">
      <summary>
        <para>Gets or sets the group ID for the source side of the edge.</para>
      </summary>
      <remarks>
        <para>Edges incident to the same node <c>v</c> but associated with different group IDs at this endpoint, use separate bus connections at <c>v</c>.</para>
      </remarks>
      <value>
        <para>the group ID for the source side</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusDescriptor.TargetGroupId">
      <summary>
        <para>Gets or sets the group ID for the target side of the edge.</para>
      </summary>
      <remarks>
        <para>Edges incident to the same node <c>v</c> but associated with different group IDs at this endpoint, use separate bus connections at <c>v</c>.</para>
      </remarks>
      <value>
        <para>the group ID for the target side</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusDescriptor.Fixed">
      <summary>
        <para>Gets or sets whether or not the associated edge is fixed.</para>
      </summary>
      <remarks>
        <para>The algorithm doesn't change the route of fixed edges but tries to prevent overlaps with non-fixed edges.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the associated edge is fixed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.BusDescriptor.ToString">
      <summary>
        <para>Returns a string representation consisting of the bus ID, the fixed flag, and both group IDs.</para>
      </summary>
      <returns>
        <para>a string representation consisting of the bus ID, the fixed flag, and both group IDs</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.BusRepresentations">
      <summary>
        <para>This class provides helper methods to convert between buses given by complete subgraphs and buses represented by specific <em>hub</em> nodes.</para>
      </summary>
      <remarks>
        <para>In a representation by means of hubs, each connected subgraph induced by hubs establishes a bus. All regular nodes (non-hubs) which are connected to hubs of the same component are end-nodes of the same bus. In other words, nodes which are reachable on paths consisting of only hubs belong to the same bus. Of course, a node can be an end-node of more than one bus.</para>
        <para>Since a bus models a group of nodes in which every node is connected to every other node, it can be represented as a complete subgraph of these nodes. To distinguish buses in this representation, each edge must be associated with a unique ID which identifies the bus to which it is associated. This is the representation expected by <see cref="T:yWorks.Layout.Router.BusRouter" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.BusRepresentations.SourceIdDpKey">
      <summary>
        <para>A data acceptor key to transfer a user-defined object from each original edge to the respective newly created edge.</para>
      </summary>
      <remarks>
        <para>Since there is no one-to-one mapping between original and new edges, the data provider of this key is responsible for the edges whose source endpoint is a regular node.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.BusRepresentations.TargetIdDpKey">
      <summary>
        <para>A data acceptor key to transfer a user-defined object from each original edge to the respective newly created edge.</para>
      </summary>
      <remarks>
        <para>Since there is no one-to-one mapping between original and new edges, the data provider of this key is responsible for the edges whose target endpoint is a regular node.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.BusRepresentations.ToEdgeLists(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Calculates for every bus represented by hubs a list of all of its edges.</para>
      </summary>
      <param name="graph">
        <para>the graph where buses are represented by means of hubs</para>
      </param>
      <param name="hubMarker">
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> which marks hub nodes</para>
      </param>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.EdgeList" />s where each list contains all edges of a bus</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.BusRepresentations.ReplaceHubsBySubgraph(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataAcceptor)">
      <summary>
        <para>Changes the representation of buses from hubs to complete subgraphs.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Layout.Router.BusRepresentations.ReplaceHubsBySubgraph(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList[],yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataAcceptor)" />.</para>
      </remarks>
      <param name="graph">
        <para>the graph of the bus</para>
      </param>
      <param name="hubMarker">
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> that marks hub nodes</para>
      </param>
      <param name="descriptorAcceptor">
        <para>a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> for storing the created bus descriptors</para>
      </param>
      <returns>
        <para>a list of the created edges</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.BusRepresentations.ReplaceHubsBySubgraph(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList[],yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataAcceptor)" />
      <seealso cref="M:yWorks.Layout.Router.BusRepresentations.ToEdgeLists(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="M:yWorks.Layout.Router.BusRepresentations.ReplaceHubsBySubgraph(yWorks.Layout.LayoutGraph,yWorks.Algorithms.EdgeList[],yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataAcceptor)">
      <summary>
        <para>Changes the representation of buses from hubs to complete subgraphs by creating new edges between regular nodes and removing the hubs.</para>
      </summary>
      <remarks>
        <para>This method respects multiple connections of nodes and creates appropriate <see cref="T:yWorks.Layout.Router.BusDescriptor" />s consisting of the bus ID as well as source and target group IDs.</para>
        <para>The path of each new edge follows the route defined by the component of the hubs. If the subgraph of hubs is not a tree, these paths are ambiguous. In this case, an arbitrary tree is computed from the hub's subgraph which defines all the paths.</para>
      </remarks>
      <param name="graph">
        <para>the graph of the bus</para>
      </param>
      <param name="hubEdgesLists">
        <para>an array of <see cref="T:yWorks.Algorithms.EdgeList" />s each containing the edges of a bus</para>
      </param>
      <param name="hubMarker">
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> that marks hub nodes</para>
      </param>
      <param name="fixedMarker">
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> that marks fixed edges</para>
      </param>
      <param name="descriptorAcceptor">
        <para>a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> for storing the created bus descriptors</para>
      </param>
      <returns>
        <para>a list of the created edges</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.BusRepresentations.ReplaceSubgraphByHubs(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeCursor,yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataAcceptor)">
      <summary>
        <para>Changes the representation of buses from complete subgraphs to hubs by replacing intersection points by hubs.</para>
      </summary>
      <remarks>
        <para>The edges of the given graph must form an orthogonal, cycle-free bus, otherwise an <see cref="T:System.InvalidOperationException" /> is thrown.</para>
      </remarks>
      <param name="graph">
        <para>the graph where each bus is represented by a complete subgraph of the corresponding nodes</para>
      </param>
      <param name="edgeCursor">
        <para>an <see cref="T:yWorks.Algorithms.IEdgeCursor" /> of the regular edges</para>
      </param>
      <param name="descriptorProvider">
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> that provides a <see cref="T:yWorks.Layout.Router.BusDescriptor" /> for each edge</para>
      </param>
      <param name="busIDAcceptor">
        <para>an optional <see cref="T:yWorks.Algorithms.IDataAcceptor" /> that stores the bus ID for each new edge</para>
      </param>
      <exception cref="T:System.InvalidOperationException">
        <para>if the path of an edge is not orthogonal or if some paths form a cycle</para>
      </exception>
    </member>
    <member name="T:yWorks.Layout.Router.BusRouter">
      <summary>
        <para>An edge routing algorithm which routes edges of a graph in an orthogonal bus-style.</para>
      </summary>
      <remarks>
        <para>Carefully observe that the resulting representation, with many edge segments drawn on top of each other, leaves little room for a sensible interpretation of edge direction.</para>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>Edge segments are bundled to buses. A bus is a segment shared by multiple edges to which shorter segments that connect to actual nodes are attached. Buses and all other segments are routed orthogonally.</para>
        <para>A bus can, for example, be created in parts of a diagram where each node is connected to each other node. There are no cycles induced by any two edge paths of the same bus, that is, the combination of all edge routes looks like an orthogonal tree.</para>
        <para>The algorithm tries to produce routes where the edges share as much of their paths as possible. It yields long line segments (so-called <b>backbone segments</b>) where ideally all but the first and last segments of all edge paths are drawn on top of each other (forming a <b>bus</b>), with short connections branching off to the nodes (<b>bus connections</b>). These short connections bundle the respective first or last segments of a node's incident edges.</para>
        <para>This algorithm will not modify positions or sizes of nodes in any way, but will route the edges of the graph.</para>
        <para> Bus-style edge routing with default settings  Edge routing sample including four different buses <h2>Concept</h2></para>
        <para>The algorithm uses a two-phase process:</para>
        <list type="number">
          <item>
            <b>Backbone Selection</b>: a set of suitable initial backbone segments is determined.</item>
          <item>
            <b>Routing and Recombination</b>: each initial backbone segment is connected to all other backbone segments and to each node by using orthogonal edge paths. Then, the resulting structure is reduced to the most optimal structure where backbone segments are long and connections to the nodes are short.</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>To determine which edges belong to a common bus, a mapping that assigns a bus ID to each edge must be specified using <see cref="T:yWorks.Layout.Router.BusDescriptor" />s. A <see cref="T:yWorks.Algorithms.IDataProvider" /> holding <see cref="T:yWorks.Layout.Router.BusDescriptor" /> instances is expected to be registered with the graph using the <see cref="F:yWorks.Layout.Router.BusRouter.EdgeDescriptorDpKey">descriptor key</see>. In the absence of an individual bus ID for an edge, a bus consisting only of the single edge is created.</para>
        <para>This algorithm supports <see cref="T:yWorks.Layout.PortConstraint" />s as well as <see cref="T:yWorks.Layout.PortCandidate" />s to control where edges should connect to nodes.</para>
        <para>Note that if edges of the same bus connect to a common node but have inconsistent or contradicting port constraints/candidates, then any of these constraints/candidates can determine the actual location of the common port. The same applies for edges that, in addition, belong to the same edge group.</para>
        <para>Also, the cardinality defined with a <see cref="T:yWorks.Layout.PortCandidateSet" /> object is interpreted in terms of different bus IDs (group IDs) instead of number of edges.</para>
        <para>This algorithm supports incremental edge routing, that is, extending or updating an already existing bus-style representation. This is useful to rearrange existing edges or to include additional edges in an existing bus. <br /> Incremental routing is supported by denoting so-called fixed edges using the <see cref="P:yWorks.Layout.Router.BusDescriptor.Fixed">corresponding BusDescriptor property</see>. The paths of edges which are not marked as fixed are calculated by the algorithm. The structure induced by the fixed edges must be orthogonal and cycle-free.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.BusRouter.EdgeDescriptorDpKey">
      <summary>
        <para>A data provider key for specifying a bus descriptor object for each edge.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.Router.BusDescriptor" /> for an edge provides the edge's bus ID, its optional group IDs and whether or not the edge is fixed.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.BusRouter.DefaultAffectedEdgesDpKey">
      <summary>
        <para>A data provider key for specifying the edge subset to be routed.</para>
      </summary>
      <remarks>
        <para>This key is used if no custom key for specifying the subset is defined using <see cref="P:yWorks.Layout.Router.BusRouter.AffectedEdgesDpKey" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Router.BusRouter.Scope" />
      <seealso cref="P:yWorks.Layout.Router.BusRouter.AffectedEdgesDpKey" />
    </member>
    <member name="M:yWorks.Layout.Router.BusRouter.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.BusRouter" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.BusRouter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates bus-like routes for the edges in the given input graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the graph is not supported by this algorithm</para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.GridSpacing">
      <summary>
        <para>Gets or sets the equidistant spacing between the horizontal and vertical grid lines.</para>
      </summary>
      <remarks>
        <para>Positive values greater than <c>2</c> are allowed. Positive values less than <c>2</c> are ignored, while negative values are mapped to their absolute value.</para>
      </remarks>
      <value>
        <para>the grid spacing</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.BusRouter.GridRouting" />
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.GridRouting">
      <summary>
        <para>Gets or sets whether or not to route edge segments on grid lines only.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge segments are routed on a grid, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.MinimumDistanceToNode">
      <summary>
        <para>Gets or sets the minimum distance between edge segments and nodes.</para>
      </summary>
      <remarks>
        <para>Positive values greater than <c>2</c> are allowed. Positive values less than <c>2</c> are ignored, while negative values are mapped to their absolutes.</para>
      </remarks>
      <value>
        <para>the minimum distance between edges and nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.MinimumDistanceToEdge">
      <summary>
        <para>Gets or sets the minimum distance between any two edge segments.</para>
      </summary>
      <remarks>
        <para>The edge routing algorithm adheres to this value if possible, but reduces the distance value selectively, i.e., only for a currently processed edge, when there is not enough space to find a path with the proper value.</para>
        <para>Positive values greater than <c>4</c> are allowed. Positive values less than <c>4</c> are ignored, while negative values are mapped to their absolute values.</para>
      </remarks>
      <value>
        <para>the minimum distance between edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.CrossingCost">
      <summary>
        <para>Gets or sets the cost for each edge crossing.</para>
      </summary>
      <remarks>
        <para>A cost value of <c>n</c> means that it is more profitable for a path to change its direction <c>n</c> times rather than crossing the path of an edge. If the cost value is set to <c>0.0</c>, no global crossing optimization is performed.</para>
        <para>The cost is defined to be a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given cost value is negative</para>
      </exception>
      <value>
        <para>the non-negative cost value for each crossing</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.Rerouting">
      <summary>
        <para>Gets or sets whether or not to perform an additional step to reroute the edges such that the number of edge crossings is reduced.</para>
      </summary>
      <remarks>
        <para>This features does not guarantee that the number of crossings will be the minimal.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the rerouting feature is enabled, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.BusRouter.CrossingCost" />
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.PreferredBackboneSegmentCount">
      <summary>
        <para>Gets or sets the maximum number of selected backbone segments with the same orientation.</para>
      </summary>
      <remarks>
        <para>This setting defines the number of backbone segments of the same orientation which are computed by the backbone selection phase. The final number of backbone segments may be different due to changes in the routing and recombination phase.</para>
        <para>The number must be a value greater than or equal to <c>1</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given preferred number is smaller than <c>1</c></para>
      </exception>
      <value>
        <para>the maximum number of backbone candidates with the same orientation</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.MinimumBackboneSegmentLength">
      <summary>
        <para>Gets or sets the preferred minimum length of a backbone segment.</para>
      </summary>
      <remarks>
        <para>This number defines the minimum length of backbone segments which are computed by the backbone selection phase. Some of the final backbone segments may be shorter due to changes in the routing and recombination phase.</para>
        <para>The minimum length is defined to be a value greater than or equal to <c>1.0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum length is smaller than <c>1.0</c></para>
      </exception>
      <value>
        <para>the preferred minimum length of a backbone segment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.MinimumBusConnectionsCount">
      <summary>
        <para>Gets or sets the minimum number of bus connections a backbone segment must have.</para>
      </summary>
      <remarks>
        <para>If a backbone segment has less connections, it is removed and the affected nodes connect to another backbone segment.</para>
        <para>The minimum connection count must be a value greater than or equal to <c>1</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum count is smaller than <c>1</c></para>
      </exception>
      <value>
        <para>the minimum number of bus connections each backbone segment must have</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.RemoveCollinearBends">
      <summary>
        <para>Gets or sets whether or not collinear bends are removed from the layout.</para>
      </summary>
      <remarks>
        <para>A collinear bend is a bend that lies on a common line with its predecessor bend and successor bend.</para>
        <para>If an edge has a collinear bend, there is another edge which has a real bend at this point, i.e., the bend location is an intersection of the bus. Therefore, it may be advantageous for some applications to keep such bends.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if collinear bends are removed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> for marking edges as <em>selected</em>.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Layout.Router.BusRouter.Scope">scope</see> is set to <see cref="F:yWorks.Layout.Router.Scope.RouteAffectedEdges" />, only the edges for which the registered <see cref="T:yWorks.Algorithms.IDataProvider" /> returns <c>true</c> will be routed. All other edges will be considered to have fixed routes.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for edge selection</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.BusRouter.Scope">
      <summary>
        <para>Gets or sets the scope for this routing algorithm that determines which edges are routed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown scope is given</para>
      </exception>
      <value>
        <para>one of the predefined scope values</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.ChannelEdgeRouter">
      <summary>
        <para>This edge routing algorithm generates orthogonal routes for the edges of the graph.</para>
      </summary>
      <remarks>
        <para>Compared to the routing algorithm implemented by class <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />, this implementation is usually faster but supports less constraints and, by default, may produce node-edge overlaps.</para>
        <para>
          <h2>Layout Style</h2> Edges are routed in an orthogonal fashion, i.e., edge paths consist only of vertical and horizontal segments.</para>
        <para>During the routing process, the positions of the nodes are considered to be fixed and the routing algorithm will not modify their locations or their sizes in any way.</para>
        <para>The edge routing algorithm can be applied wherever it is required to route the edges as orthogonal segments, while keeping the positions of the nodes in the diagram fixed. Some potential applications include electric circuit design, floor planning, UML class diagrams/inheritance diagrams and navigation maps.</para>
        <para> Sample output of the orthogonal edge routing algorithm with default settings <h2>Concept</h2> This edge routing algorithm combines two strategic steps of edge routing and executes them one after the other. The first strategy is called path finder strategy and will route the edges, potentially with edge overlaps. The second strategy will then split overlapping edge segments inside their channels and distribute them according to the specific distribution strategy.</para>
        <para>The default path finding strategy is <see cref="T:yWorks.Layout.Router.OrthogonalPatternEdgeRouter" />. The default edge distribution strategy is <see cref="T:yWorks.Layout.Router.OrthogonalSegmentDistributionStage" />.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>This class itself has no special routing options except from specifying the <see cref="P:yWorks.Layout.Router.ChannelEdgeRouter.PathFinderStrategy">path finding</see> and <see cref="P:yWorks.Layout.Router.ChannelEdgeRouter.EdgeDistributionStrategy">edge distribution</see> strategy. Most of the features like minimum element distances, grid spacing and path restrictions have to be set on the used instances for the two routing steps.</para>
        <para>For incremental edge routing, <see cref="T:yWorks.Algorithms.IDataProvider" /> key <see cref="F:yWorks.Layout.Router.ChannelEdgeRouter.AffectedEdgesDpKey" /> has to be registered with the graph to mark all edges that should be routed by the algorithm. The routes of the other edges remain unchanged. If there is no such key registered, the algorithm routes all edges.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.ChannelEdgeRouter.AffectedEdgesDpKey">
      <summary>
        <para>A data provider key for marking the edges that should be routed.</para>
      </summary>
      <remarks>
        <para>If this key is not registered with the graph, the algorithm will route all edges.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.ChannelEdgeRouter.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.ChannelEdgeRouter" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.ChannelEdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Performs the orthogonal routing of the edges of the input graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.ChannelEdgeRouter.CheckNodeSize(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Checks the sizes of the nodes to be non-zero.</para>
      </summary>
      <param name="g">
        <para>The graph to check.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.ChannelEdgeRouter.PathFinderStrategy">
      <summary>
        <para>Gets or sets the strategy for the path finding step.</para>
      </summary>
      <remarks>
        <para>This step routes the edges and may produce edge overlaps which are later resolved in the <see cref="P:yWorks.Layout.Router.ChannelEdgeRouter.EdgeDistributionStrategy">edge distribution</see> step.</para>
      </remarks>
      <value>
        <para>the path finder strategy</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.ChannelEdgeRouter.EdgeDistributionStrategy">
      <summary>
        <para>Gets or sets the strategy for the edge distribution step.</para>
      </summary>
      <remarks>
        <para>This step distributes overlapping edge segments in their channel. The channel in which the segments can be distributed is defined by the surrounding graph elements.</para>
      </remarks>
      <value>
        <para>the edge distribution strategy</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Scope">
      <seealso cref="P:yWorks.Layout.Router.BusRouter.Scope" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.Scope" />
      <seealso cref="P:yWorks.Layout.Router.StraightLineEdgeRouter.Scope" />
    </member>
    <member name="F:yWorks.Layout.Router.Scope.RouteAllEdges">
      <summary>
        <para>A scope specifier which defines that all edges of the input graph will be routed.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.BusRouter.Scope" />
    </member>
    <member name="F:yWorks.Layout.Router.Scope.RouteAffectedEdges">
      <summary>
        <para>A scope specifier which defines that only the selected edges of the input graph will be routed.</para>
        <para>The selection state of an edge is determined by a boolean value returned by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="P:yWorks.Layout.Router.BusRouter.AffectedEdgesDpKey" />.</para>
        <para>All other non-selected edges will be considered to have fixed routes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.BusRouter.Scope" />
      <seealso cref="P:yWorks.Layout.Router.BusRouter.AffectedEdgesDpKey" />
      <seealso cref="F:yWorks.Layout.Router.BusRouter.DefaultAffectedEdgesDpKey" />
    </member>
    <member name="F:yWorks.Layout.Router.Scope.RouteEdgesAtAffectedNodes">
      <summary>
        <para>A scope specifier which defines that only edges incident to selected nodes will be routed.</para>
        <para>The selection state of a node is determined by a boolean value returned by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.AffectedNodesDpKey" />.</para>
        <para>All other edges that are incident to non-selected nodes will be considered to have fixed routes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.AffectedNodesDpKey" />
    </member>
    <member name="T:yWorks.Layout.Router.MonotonicPathRestriction">
      <seealso cref="P:yWorks.Layout.Router.OrthogonalEdgeRouter.MonotonicPathRestriction" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.MonotonicPathRestriction" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MonotonicPathRestriction" />
    </member>
    <member name="F:yWorks.Layout.Router.MonotonicPathRestriction.None">
      <summary>
        <para>A constant specifying that there are no monotonic edge path restrictions.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MonotonicPathRestriction" />
    </member>
    <member name="F:yWorks.Layout.Router.MonotonicPathRestriction.Vertical">
      <summary>
        <para>A constant specifying monotonic edge path restrictions for the vertical direction.</para>
        <para>This implies that each vertical edge segment is directed from the source to the target.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MonotonicPathRestriction" />
    </member>
    <member name="F:yWorks.Layout.Router.MonotonicPathRestriction.Horizontal">
      <summary>
        <para>A constant specifying monotonic edge path restrictions for the horizontal direction.</para>
        <para>This implies that each horizontal edge segment is directed from the source to the target.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MonotonicPathRestriction" />
    </member>
    <member name="F:yWorks.Layout.Router.MonotonicPathRestriction.Both">
      <summary>
        <para>A constant specifying monotonic edge path restrictions for the horizontal and vertical direction.</para>
        <para>This implies that each horizontal as well as each vertical edge segment is directed from the source to the target.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MonotonicPathRestriction" />
    </member>
    <member name="T:yWorks.Layout.Router.OrganicEdgeRouter">
      <summary>
        <para>This edge routing algorithm applies organic routes to the edges of the graph.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> Edges are routed organically, i.e. in smooth curves around the nodes observing a <see cref="P:yWorks.Layout.Router.OrganicEdgeRouter.MinimumDistance">minimum distance</see> to the nodes.</para>
        <para>During the routing process, the positions of the nodes are considered to be fixed and the router will not modify their locations or their sizes in any way.</para>
        <para>The edge routing algorithm can be applied whenever edge paths should avoid crossing any nodes in organic or cyclic layout styles.</para>
        <para> <h2>Concept</h2> The edge routing algorithm uses a force-directed approach to calculate the edge paths. Nodes are considered to be repulsive forces while edges will try to become as short as possible.</para>
        <para>Each edge is routed separately and is influenced by the nodes in a certain area around it. The algorithm will add bends to the edge path that are placed by balancing the forces.</para>
        <para>The quality of the result highly depends on how much space there is between the nodes. More precisely, the distance between each pair of nodes should be at least twice the specified <see cref="P:yWorks.Layout.Router.OrganicEdgeRouter.MinimumDistance">minimum distance</see>. If it is not necessary that the nodes keep their locations, this can be ensured using a combination of <see cref="T:yWorks.Layout.Organic.RemoveOverlapsStage" /> and <see cref="M:yWorks.Layout.Router.OrganicEdgeRouter.CreateNodeEnlargementStage">node enlargement stage</see>.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>
          <see cref="P:yWorks.Layout.Router.OrganicEdgeRouter.MinimumDistance" /> will make edges keep a custom distance to the nodes. However, if there is not enough space between the nodes, this distance may be undershot (i.e. edges will be closer to nodes).</para>
        <para>
          <see cref="T:yWorks.Layout.Router.OrganicEdgeRouter" /> is able to <see cref="P:yWorks.Layout.Router.OrganicEdgeRouter.KeepExistingBends">reuse existing bends</see>. Edges will contain those bends along with other bends added by the layout algorithm.</para>
        <para>This edge routing algorithm is realized as a <see cref="T:yWorks.Layout.ILayoutStage" /> which can be applied to a graph directly or using a <see cref="P:yWorks.Layout.Router.OrganicEdgeRouter.CoreLayout">core layout algorithm</see>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.OrganicEdgeRouter.AffectedEdgesDpKey">
      <summary>
        <para>A data provider key for selecting edges that should be routed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.OrganicEdgeRouter.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.OrganicEdgeRouter" /> instance with the default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.OrganicEdgeRouter.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.OrganicEdgeRouter" /> with the given <see cref="P:yWorks.Layout.Router.OrganicEdgeRouter.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>the core layout algorithm</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.OrganicEdgeRouter.EdgeNodeOverlapAllowed">
      <summary>
        <para>Gets or sets whether or not edges are allowed to cross nodes.</para>
      </summary>
      <remarks>
        <para>Allowing edges to overlap with nodes will produce smoother edges, because the edge paths can be closer to the nodes.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if edge-node overlaps are allowed, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.OrganicEdgeRouter.CreateNodeEnlargementStage" />
      <seealso cref="P:yWorks.Layout.Router.OrganicEdgeRouter.MinimumDistance" />
    </member>
    <member name="M:yWorks.Layout.Router.OrganicEdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Performs the organic routing of the edges of the input graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.OrganicEdgeRouter.CheckNodeSize(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Checks the sizes of the nodes to be non-zero.</para>
      </summary>
      <param name="g">
        <para>The graph to check.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.OrganicEdgeRouter.CoreLayout">
      <summary>
        <para>Gets or sets the core layout algorithm which arranges the graph before edge routing.</para>
      </summary>
      <value>
        <para>the layout algorithm that arranges the graph</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrganicEdgeRouter.MinimumDistance">
      <summary>
        <para>Gets or sets the minimum distance the algorithm should guarantee between nodes and non-incident edges.</para>
      </summary>
      <remarks>
        <para>The distance also influences how many bends are added to the path (a higher distance leads to less bends).</para>
        <para>The minimum distance is defined to be a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum distance between edges and nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrganicEdgeRouter.KeepExistingBends">
      <summary>
        <para>Gets or sets whether or not the initial bend coordinates are kept when determining the edge path.</para>
      </summary>
      <remarks>
        <para>The bends are considered as fixed nodes and stay part of the path.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the initial bend coordinates are kept, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrganicEdgeRouter.RouteAllEdges">
      <summary>
        <para>Gets or sets whether a rerouting step is performed on all edges or just on a subset where distances are violated.</para>
      </summary>
      <remarks>
        <para>If only a subset of edges is rerouted, only those edges which cross nodes or come too close to a node are included. During rerouting, more bends are added to the edges that will be influenced by the repulsive forces.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if all edges are rerouted, <c>false</c> if only a subset is rerouted</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.OrganicEdgeRouter.CreateNodeEnlargementStage">
      <summary>
        <para>Returns a <see cref="T:yWorks.Layout.ILayoutStage" /> which temporarily increases the sizes of the nodes to avoid overlaps.</para>
      </summary>
      <remarks>
        <para>The edges will keep a greater distance to the nodes. Therefore, they won't cross them.</para>
      </remarks>
      <returns>
        <para>the <see cref="T:yWorks.Layout.ILayoutStage" /> that resizes the nodes</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.OrthogonalPatternEdgeRouter">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Router.OrthogonalPatternEdgeRouter" /> routes edges orthogonally such that the resulting layout of the edges consists only of vertical and horizontal segments.</para>
      </summary>
      <remarks>
        <para>Note that the location and size of the nodes in a diagram remains unchanged.</para>
        <para>The edge router will not try to find a perfect route from source to edge (unlike to what <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" /> does) but chooses the best path out of a set of fixed paths. The best path out of these possible paths is determined by its cost. The costs may be influenced by setting several cost factors. The distance that an edge will have from its source and target node is determined by <see cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.MinimumDistance" />.</para>
        <para>The edges whose paths have to be routed can be defined registering a <see cref="T:yWorks.Algorithms.IDataProvider" /> with key <see cref="F:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.DefaultAffectedEdgesDpKey" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.DefaultAffectedEdgesDpKey">
      <summary>
        <para>A data provider key for determining which edges are routed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.OrthogonalPatternEdgeRouter" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.MonotonicPathRestriction">
      <summary>
        <para>Gets or sets the monotonic path restriction that should be applied.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified path restriction is unknown</para>
      </exception>
      <value>
        <para>one of the valid monotonic path restrictions</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Routes the edges of the given graph orthogonally.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CheckNodeSize(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Checks the sizes of the nodes to be non-zero.</para>
      </summary>
      <param name="g">
        <para>The graph to check.</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)">
      <summary>
        <para>Calculates the edge cost of a possible edge path, in order to determine which path is the best, i.e., the cheapest.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> in order to decide which path is the best. The default implementation considers the edge length, the number of bends, edge crossings, <see cref="T:yWorks.Layout.PortCandidate" />s and monotonic path restrictions. It may be overridden to apply a different set of costs or a different weighting.</para>
      </remarks>
      <param name="edge">
        <para>the edge whose costs to calculate</para>
      </param>
      <param name="path">
        <para>the edge's path</para>
      </param>
      <param name="spc">
        <para>the source <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <param name="tpc">
        <para>the target <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <returns>
        <para>the sum of all costs for this edge's path</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculatePortCandidateCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)">
      <summary>
        <para>Calculates the costs for the chosen <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)" />. The default implementation will return the <see cref="P:yWorks.Layout.PortCandidate.Cost">candidates' costs</see>. It may be overridden to change the calculation of these costs.</para>
      </remarks>
      <param name="edge">
        <para>the edge for which the costs are calculated</para>
      </param>
      <param name="path">
        <para>the path of the given edge</para>
      </param>
      <param name="spc">
        <para>the source <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <param name="tpc">
        <para>the target <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <returns>
        <para>the costs for the <see cref="T:yWorks.Layout.PortCandidate" />s</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateBendCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)">
      <summary>
        <para>Calculates the costs for all bends of the given path.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)" />. The default implementation multiplies the number of bends with the according <see cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.BendCost">costs</see>. It may be overridden to change the calculation of these costs.</para>
      </remarks>
      <param name="edge">
        <para>the edge for which the costs are calculated</para>
      </param>
      <param name="path">
        <para>the path of the given edge</para>
      </param>
      <param name="spc">
        <para>the source <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <param name="tpc">
        <para>the target <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <returns>
        <para>the costs for the bends of this path</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateSelfLoopSelfSidePenaltyCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)">
      <summary>
        <para>Calculates the extra penalty that is added to the path's cost if the edge is a self-loop and source and target ports have the same direction.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)" />. The default implementation adds costs for another bend if source and target ports share the same node side. In this manner, paths with different source and target directions are cheaper and thus preferred. The method may be overridden to change the calculation of this penalty.</para>
      </remarks>
      <param name="edge">
        <para>the edge for which the costs are calculated</para>
      </param>
      <param name="path">
        <para>the path of the given edge</para>
      </param>
      <param name="spc">
        <para>the source <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <param name="tpc">
        <para>the target <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <returns>
        <para>an extra penalty for specific self-loop paths</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateEdgeLength(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)">
      <summary>
        <para>Calculates the costs for the length of the given path.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)" />. The default implementation returns costs between <c>0</c> for short paths and <c>1</c> for long paths. Hence, it has relatively little impact on the overall costs. The method may be overridden to introduce a different weighting of the edge length.</para>
      </remarks>
      <param name="edge">
        <para>the edge for which the costs are calculated</para>
      </param>
      <param name="path">
        <para>the path of the given edge</para>
      </param>
      <param name="spc">
        <para>the source <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <param name="tpc">
        <para>the target <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <returns>
        <para>the costs for the length of the given path</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCrossingCosts(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)">
      <summary>
        <para>Calculates the overall crossing costs of the given path, including edge crossings, edge overlaps and node crossings.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.CalculateCost(yWorks.Algorithms.Edge,yWorks.Algorithms.YList,yWorks.Layout.PortCandidate,yWorks.Layout.PortCandidate)" />. The default implementation will determine overlaps and crossings between edge segments and nodes and sum up the costs. It may be overridden to use a different combination of costs.</para>
      </remarks>
      <param name="edge">
        <para>the edge for which the costs are calculated</para>
      </param>
      <param name="path">
        <para>the path of the given edge</para>
      </param>
      <param name="spc">
        <para>the source <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <param name="tpc">
        <para>the target <see cref="T:yWorks.Layout.PortCandidate" /> for this edge</para>
      </param>
      <returns>
        <para>the overall crossing costs of the given path, including edge crossings, edge overlaps and node crossings</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> which determines the edges that shall be routed by this algorithm.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Algorithms.IDataProvider" /> key is <c>null</c></para>
      </exception>
      <value>
        <para>the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> which determines the edges to be routed</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.MinimumDistance">
      <summary>
        <para>Gets or sets the minimum distance that an edge will maintain from its source and target node.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance between the edge and its source and target node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridSpacing">
      <summary>
        <para>Gets or sets the spacing of the grid on which edges are routed.</para>
      </summary>
      <remarks>
        <para>The spacing between two grid lines must be at least <c>2</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified grid spacing is less than <c>2</c></para>
      </exception>
      <value>
        <para>the spacing between two grid lines</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridRouting" />
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridOrigin">
      <summary>
        <para>Gets or sets the origin of the grid.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified point is <c>null</c></para>
      </exception>
      <value>
        <para>the origin of the grid</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridRouting" />
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridRouting">
      <summary>
        <para>Gets or sets whether or not to route the edges on a grid.</para>
      </summary>
      <remarks>
        <para>The grid can be defined using methods <see cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridOrigin" /> and <see cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridSpacing" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if edges are routed on grid, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridOrigin" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.GridSpacing" />
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.EdgeCrossingCost">
      <summary>
        <para>Gets or sets the costs for a crossing between two edges.</para>
      </summary>
      <remarks>
        <para>These costs are used for finding the best path out of the predefined paths from which the router can choose.</para>
        <para>The costs need to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified costs are negative</para>
      </exception>
      <value>
        <para>the costs for an edge crossing</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.NodeCrossingCost">
      <summary>
        <para>Gets or sets the costs for edges that cross nodes.</para>
      </summary>
      <remarks>
        <para>These costs are used for finding the best path out of the predefined paths from which the router can choose.</para>
        <para>The costs need to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified costs are negative</para>
      </exception>
      <value>
        <para>the costs for edges crossing nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.BendCost">
      <summary>
        <para>Gets or sets the costs for creating a bend on the edge's path.</para>
      </summary>
      <remarks>
        <para>These costs are used for finding the best path out of the predefined paths from which the router can choose.</para>
        <para>The costs need to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified costs are negative</para>
      </exception>
      <value>
        <para>the costs for edges crossing nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalPatternEdgeRouter.EdgeOverlapCost">
      <summary>
        <para>Gets or sets the costs for overlapping edge paths.</para>
      </summary>
      <remarks>
        <para>These costs are used for finding the best path out of the predefined paths from which the router can choose.</para>
        <para>The costs need to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified costs are negative</para>
      </exception>
      <value>
        <para>the costs for overlapping edge segments</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.OrthogonalSegmentDistributionStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Router.OrthogonalSegmentDistributionStage" /> distributes overlapping edge segments of orthogonally routed edges.</para>
      </summary>
      <remarks>
        <para>The edge segments are assigned to the so-called <i>channels</i> within which they are distributed. Those channels are defined by the surrounding graph elements.</para>
        <para>The algorithm will not distribute the segments, whose endpoints connect to a node using a port that has a strong <see cref="T:yWorks.Layout.PortConstraint" /> or a fixed <see cref="T:yWorks.Layout.PortCandidate" />.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>It is possible to define a <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistance">preferred distance</see> between distributed edge segments. This distance will only be applied if there is enough space in the according channel. In the case where there is not enough space, the preferred distance may be <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.FlexiblePreferredDistance">reduced</see> for the edges. If the layout algorithm is not allowed to reduce the preferred distance, these edges won't be distributed.</para>
        <para>Edges can be distributed on <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridRouting">grid coordinates</see>. The grid can only be considered if there is enough space in the according channel for at least as many grid lines as the number of segments. In the case where there is not enough space, the <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridSpacing">grid spacing</see> may be <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.FlexibleGridSpacing">reduced</see> in this channel. If the layout algorithm is not allowed to reduce the grid spacing, these edges won't be distributed.</para>
        <para>Method <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.LockFirstAndLastSegment" /> can be used to guarantee that the first and last segment of an edge won't be distributed. So, ports can easily be maintained without setting explicit strong <see cref="T:yWorks.Layout.PortConstraint" />s or fixed <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.DefaultAffectedEdgesDpKey">
      <summary>
        <para>A data provider key for determining which edges are distributed.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.OrthogonalSegmentDistributionStage" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Distributes overlapping orthogonal segments after the core layout has been calculated.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> which determines the edges that shall be routed by this algorithm.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Algorithms.IDataProvider" /> key is <c>null</c></para>
      </exception>
      <value>
        <para>the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> which determines the edges to route</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.FlexiblePreferredDistance">
      <summary>
        <para>Gets or sets whether or not the preferred distance between edges can be reduced if there is not enough space.</para>
      </summary>
      <remarks>
        <para>The space between the nodes restricts the distribution of the orthogonal segments while considering the <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistance">preferred distance</see>. In case this option is enabled, the layout algorithm may reduce the preferred distance, otherwise the algorithm will only distribute segments if there is enough space.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the layout algorithm is allowed to reduce the preferred distance, <c>false</c> if it should only distribute segments where there is enough space to maintain the preferred distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.FlexibleGridSpacing">
      <summary>
        <para>Gets or sets whether or not the grid spacing can be reduced if there is not enough space.</para>
      </summary>
      <remarks>
        <para>The space between the nodes limits the number of grid lines on which edges are placed. In case this option is enabled, the layout algorithm will divide the given grid spacing by <c>2</c> as long as there are not enough grid lines on which the segments can be distributed, otherwise the grid spacing remains unchanged.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the algorithm should be allowed to reduce the grid spacing, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridRouting">
      <summary>
        <para>Gets or sets whether or not the orthogonal segments are distributed on grid coordinates.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if segments are distributed on grid coordinates, <c>false</c> otherwise</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.SetGridOrigin(System.Double,System.Double)" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridSpacing" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.FlexibleGridSpacing" />
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridSpacing">
      <summary>
        <para>Gets or sets the spacing between two grid lines.</para>
      </summary>
      <remarks>
        <para>The spacing should be at least <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified spacing is negative</para>
      </exception>
      <value>
        <para>the grid spacing</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridRouting" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridRouting" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.FlexibleGridSpacing" />
    </member>
    <member name="M:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.SetGridOrigin(System.Double,System.Double)">
      <summary>
        <para>Specifies the coordinates of the origin of the grid.</para>
      </summary>
      <remarks>
        <para>The grid coordinates will be multiples of the <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridSpacing">grid spacing</see> added to this origin.</para>
      </remarks>
      <param name="offsetX">
        <para>the x-coordinate of the grid origin</para>
      </param>
      <param name="offsetY">
        <para>the y-coordinate of the grid origin</para>
      </param>
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridRouting" />
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridOriginX">
      <summary>
        <para>Gets the x-coordinate of the origin of the grid.</para>
      </summary>
      <remarks>
        <para>The grid coordinates will be multiples of the <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridSpacing">grid spacing</see> added to this origin.</para>
      </remarks>
      <value>
        <para>the x-coordinate of the grid origin</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.SetGridOrigin(System.Double,System.Double)" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridRouting" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridOriginY" />
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridOriginY">
      <summary>
        <para>Gets the y-coordinate of the origin of the grid.</para>
      </summary>
      <remarks>
        <para>The grid coordinates will be multiples of the <see cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridSpacing">grid spacing</see> added to this origin.</para>
      </remarks>
      <value>
        <para>the y-coordinate of the grid origin</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.SetGridOrigin(System.Double,System.Double)" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridRouting" />
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.GridOriginX" />
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.LockFirstAndLastSegment">
      <summary>
        <para>Gets or sets whether or not the first and last segment of an edge will be distributed.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the first and last segments won't be distributed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.PreferredDistance">
      <summary>
        <para>Gets or sets the preferred distance between each two segments.</para>
      </summary>
      <remarks>
        <para>This value also applies to the distance between a segment and the border of the containing channel.</para>
        <para>The preferred distance should be at least <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the preferred distance between two segments</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.OrthogonalSegmentDistributionStage.FlexiblePreferredDistance" />
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.CellEntrance">
      <summary>
        <para>This class describes the location and the direction from which a given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> has been entered during a path search.</para>
      </summary>
      <remarks>
        <para>The path that was followed in order to reach a given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> can be reconstructed by traversing all <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.PreviousEntrance">previous entrances</see>. The <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.EnterInterval">enter interval</see> and <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.EnterDirection">enter direction</see> determine how the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> was entered.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.CellEntrance.#ctor(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> instance for a given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <param name="cell">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> that is entered</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.CellEntrance.#ctor(yWorks.Layout.Router.Polyline.CellEntrance)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> instance that is a copy of a given other <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />.</para>
      </summary>
      <param name="other">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> to be copied</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.CellEntrance.ToString">
      <summary>
        <para>Returns a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />.</para>
      </summary>
      <returns>
        <para>a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellEntrance.Cell">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> of this <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> instance.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> of this <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellEntrance.PreviousEntrance">
      <summary>
        <para>Gets or sets the previous <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> along the path that was traversed in order to reach the <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.Cell">cell</see>.</para>
      </summary>
      <value>
        <para>the previous <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> or <c>null</c> if this <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.Cell">cell</see> is a start entrance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellEntrance.EnterInterval">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" /> that was used for entering this <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.Cell">cell</see>.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" /> used for entering this <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.Cell">cell</see> or <c>null</c> if it is a start entrance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellEntrance.EnterDirection">
      <summary>
        <para>Gets or sets the direction from which this <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.Cell">cell</see> was entered.</para>
      </summary>
      <value>
        <para>the direction from which this <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.Cell">cell</see> was entered or <c>null</c> if this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">cell</see> is a start entrance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellEntrance.Costs">
      <summary>
        <para>Gets or sets the costs for the implicit path given by the <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.PreviousEntrance">previous entrances</see>.</para>
      </summary>
      <remarks>
        <para>The costs must be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the costs are negative</para>
      </exception>
      <value>
        <para>the costs for the implicit path given by the <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.PreviousEntrance">previous entrances</see></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellEntrance.HeuristicCosts">
      <summary>
        <para>Gets or sets the heuristic costs for the implicit path given by the <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.PreviousEntrance">previous entrances</see>.</para>
      </summary>
      <remarks>
        <para>Heuristic costs must be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the heuristic costs are negative</para>
      </exception>
      <value>
        <para>the heuristic costs for the implicit path given by the <see cref="P:yWorks.Layout.Router.Polyline.CellEntrance.PreviousEntrance">previous entrances</see></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellEntrance.PreviousEdgeCellInfo">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" /> describing how the previous <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> was traversed.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" /> describing how the previous <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">cell</see> was traversed or <c>null</c> if this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">cell</see> is a start entrance</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.CellSegmentInfo">
      <summary>
        <para>This class stores information about the part of an edge segment that lies inside a specified <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.CellSegmentInfo.#ctor(yWorks.Algorithms.Edge,System.Int32,yWorks.Layout.Direction,yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" /> instance.</para>
      </summary>
      <param name="edge">
        <para>the edge to which the segment of this info belongs</para>
      </param>
      <param name="segmentIndex">
        <para>the index of the segment to which this info belongs</para>
      </param>
      <param name="direction">
        <para>the direction to which the segment of this info points</para>
      </param>
      <param name="locationRange">
        <para>the range within which the common location of this segment has to lie</para>
      </param>
      <param name="minExtension">
        <para>the minimum interval in extension direction this segment part is known to intersect</para>
      </param>
      <param name="maxExtension">
        <para>the maximum interval in extension direction this segment part will span</para>
      </param>
      <param name="cell">
        <para>the partition cell within which this part of the edge segment lies</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellSegmentInfo.Direction">
      <summary>
        <para>Gets the direction to which the segment of this info points.</para>
      </summary>
      <value>
        <para>the direction to which the segment of this info points</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.CellSegmentInfo.Cell">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> within which this part of the edge segment lies.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> within which this part of the edge segment lies</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.Channel">
      <summary>
        <para>This class describes a channel, i.e., a set of vertical or horizontal edge segments whose locations depend on each other.</para>
      </summary>
      <remarks>
        <para>Channels are used by the <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> to route edges using <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s describing their path.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.#ctor(yWorks.Layout.Router.Polyline.SegmentInfo)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.Channel" /> that contains the given <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see>.</para>
      </summary>
      <param name="segment">
        <para>the given segment info for which the <see cref="T:yWorks.Layout.Router.Polyline.Channel" /> is created</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given segment has a different orientation than the other segments already contained in the channel</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.AddSegment(yWorks.Layout.Router.Polyline.SegmentInfo)">
      <summary>
        <para>Adds a new <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see> to the <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see>.</para>
      </summary>
      <param name="segment">
        <para>the segment info to be added to this channel</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given segment has a different orientation than the other segments already contained in the channel</para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Channel.WidthInterval">
      <summary>
        <para>Gets an <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> spanning the union of the location ranges of the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment infos</see>.</para>
      </summary>
      <value>
        <para>an interval spanning the union of the location ranges of the contained segments</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Channel.LengthInterval">
      <summary>
        <para>Gets an <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> spanning the union of the maximum extension of the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment infos</see>.</para>
      </summary>
      <value>
        <para>an interval spanning the union of the maximum extension of the contained segments</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.MaxExtension" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.SegmentCount">
      <summary>
        <para>Returns the number of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment infos</see> in this channel.</para>
      </summary>
      <returns>
        <para>the number of segment infos in this channel</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Channel.Vertical">
      <summary>
        <para>Gets whether or not the segments in this <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see> are vertical.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the segments in this channel are vertical, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.GetSegment(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see> with the given index in the list of segments of this <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see>.</para>
      </summary>
      <param name="index">
        <para>the index of the segment in the list of segments</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see> with the given index in the list of segments</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.SegmentGroupCount">
      <summary>
        <para>Returns the number of <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup">segment groups</see> in this <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see>.</para>
      </summary>
      <returns>
        <para>the number of segment groups in this channel</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.AddSegmentGroup(yWorks.Layout.Router.Polyline.SegmentGroup)">
      <summary>
        <para>Adds a <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup">segment group</see> to this <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see>.</para>
      </summary>
      <param name="group">
        <para>the segment group to be added</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.GetSegmentGroup(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup">segment group</see> with the given index in this <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see>.</para>
      </summary>
      <param name="index">
        <para>the index of the segment group</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup">segment group</see> with the given index in this channel</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.GetCurrentLocation(yWorks.Layout.Router.Polyline.SegmentInfo)">
      <summary>
        <para>Returns the current location that the given <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see> has been assigned within its <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">location range</see>.</para>
      </summary>
      <param name="segmentInfo">
        <para>the segment info for which the current location will be returned</para>
      </param>
      <returns>
        <para>the current location of the segment info or <see cref="F:System.Double.NaN" /> if no location has been assigned before</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.Channel.SetCurrentLocation(yWorks.Layout.Router.Polyline.SegmentInfo,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.SetCurrentLocation(yWorks.Layout.Router.Polyline.SegmentInfo,System.Double)">
      <summary>
        <para>Specifies the current location that the given <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see> has been assigned within its <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">location range</see>.</para>
      </summary>
      <remarks>
        <para>During the distribution of the segments in the channel, different locations can be assigned but only the last one is finally assigned to the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see>.</para>
      </remarks>
      <param name="segmentInfo">
        <para>the segment info for which the current location will be set</para>
      </param>
      <param name="location">
        <para>the location of the segment info within its location range</para>
      </param>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Location" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Channel.Bounds">
      <summary>
        <para>Gets the bounds of this <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see>.</para>
      </summary>
      <remarks>
        <para>These bounds are determined by the channel's <see cref="P:yWorks.Layout.Router.Polyline.Channel.WidthInterval">width</see> and <see cref="P:yWorks.Layout.Router.Polyline.Channel.LengthInterval">length</see>.</para>
      </remarks>
      <value>
        <para>the bounds of this channel</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.Channel.WidthInterval" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.Channel.LengthInterval" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Channel.ToString">
      <summary>
        <para>Returns a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.Channel" /> object.</para>
      </summary>
      <returns>
        <para>a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.Channel" /> object</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting">
      <summary>
        <para>This class routes edges using their pre-calculated <see cref="T:yWorks.Layout.Router.Polyline.Path" /> information.</para>
      </summary>
      <remarks>
        <para>The concept of this algorithm is to bundle edge <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment</see>s into so-called <see cref="T:yWorks.Layout.Router.Polyline.Channel" />s and route each <see cref="T:yWorks.Layout.Router.Polyline.Channel" /> individually.</para>
        <para>This class is initialized using <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)" /> which must have been called before the edges are <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Route(yWorks.Algorithms.EdgeList,yWorks.Layout.Router.Polyline.PathSearchResult)">routed</see>.</para>
        <para>After a <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> instance is no longer in use, the <see cref="T:yWorks.Layout.Router.Polyline.Channel" /> information and the reference to the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see> must be reset using method <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Cleanup" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeInfo.GetSegmentInfo(System.Int32)" />
      <seealso cref="M:yWorks.Layout.LayoutGraph.SetPath(yWorks.Algorithms.Edge,yWorks.Algorithms.YList)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Initializes this <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> instance for routing paths that have been found with the given <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see>.</para>
      </summary>
      <remarks>
        <para>This method must be called before the edges are <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Route(yWorks.Algorithms.EdgeList,yWorks.Layout.Router.Polyline.PathSearchResult)">routed</see>.</para>
      </remarks>
      <param name="configuration">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see> used for the following path routing</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Route(yWorks.Algorithms.EdgeList,yWorks.Layout.Router.Polyline.PathSearchResult)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Cleanup">
      <summary>
        <para>Resets all <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see> information and the reference to the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see>.</para>
      </summary>
      <remarks>
        <para>Afterwards, <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> is ready to calculate paths for a new layout.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Configuration">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">path search configuration</see> with which the <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> has been <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">initialized</see>.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see> of this <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Route(yWorks.Algorithms.EdgeList,yWorks.Layout.Router.Polyline.PathSearchResult)">
      <summary>
        <para>Routes the given edges.</para>
      </summary>
      <remarks>
        <para>Before calling this method, method <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)" /> must have been called.</para>
        <para>As a first step, the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s of all edge paths are distributed to <see cref="T:yWorks.Layout.Router.Polyline.Channel" />s. After that, the segments in each of these <see cref="T:yWorks.Layout.Router.Polyline.Channel" />s are sorted and locations are assigned respecting the segments' location ranges by calling the subsequent methods:</para>
        <list type="number">
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.OptimizeSegmentOrder(yWorks.Layout.Router.Polyline.Channel)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.CalculateSegmentLocations(yWorks.Layout.Router.Polyline.Channel)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.AdjustSegmentLocations(yWorks.Layout.Router.Polyline.Channel)" />
          </item>
        </list>
        <para>Finally, the control points for the paths are calculated.</para>
      </remarks>
      <param name="edges">
        <para>the <see cref="T:yWorks.Algorithms.EdgeList">list of edges</see> to be routed</para>
      </param>
      <param name="pathSearchResult">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchResult">path search result</see> containing the <see cref="T:yWorks.Layout.Router.Polyline.Path" /> objects for the edges</para>
      </param>
      <exception cref="T:System.InvalidOperationException">
        <para>if the locations are not within the segment's location range</para>
      </exception>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchResult.GetPath(yWorks.Algorithms.Edge)" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Location" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.CreateSegmentInfoComparer(yWorks.Algorithms.YList,yWorks.Layout.Router.Polyline.PathSearchResult,yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Creates a <see cref="T:System.Collections.Generic.IComparer`1">comparator</see> for sorting the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s in a <see cref="T:yWorks.Layout.Router.Polyline.Channel" /> from left to right (for vertical segments) or top to bottom (for horizontal segments), respectively.</para>
      </summary>
      <remarks>
        <para>This method is called in <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Route(yWorks.Algorithms.EdgeList,yWorks.Layout.Router.Polyline.PathSearchResult)" /> before edge segments are distributed within the channels.</para>
      </remarks>
      <param name="channels">
        <para>the channels whose segments will be sorted by the <see cref="T:System.Collections.Generic.IComparer`1">comparator</see></para>
      </param>
      <param name="pathSearchResult">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchResult">path search result</see> containing the <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" />s with the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s for which the comparator will be used</para>
      </param>
      <param name="configuration">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see> used during this path search</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1">comparator</see> used for sorting the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s in a <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.SortSegmentInfos(System.Collections.Generic.IList{System.Object},System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Sorts the given list of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s using the given <see cref="T:System.Collections.Generic.IComparer`1">comparator</see>.</para>
      </summary>
      <remarks>
        <para>This method is called in <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.Route(yWorks.Algorithms.EdgeList,yWorks.Layout.Router.Polyline.PathSearchResult)" /> when the edge segments are distributed within the channels.</para>
      </remarks>
      <param name="segmentInfos">
        <para>the list of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s to be sorted</para>
      </param>
      <param name="segmentInfoComparator">
        <para>the comparator used for sorting the list of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.OptimizeSegmentOrder(yWorks.Layout.Router.Polyline.Channel)">
      <summary>
        <para>Optimizes the order of the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segments</see> in the given <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see>.</para>
      </summary>
      <remarks>
        <para>After the segments in the channel have been sorted using the comparator created by method <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.CreateSegmentInfoComparer(yWorks.Algorithms.YList,yWorks.Layout.Router.Polyline.PathSearchResult,yWorks.Layout.Router.Polyline.PathSearchConfiguration)" />, segments having a common <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup" /> are replaced by their common <see cref="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonSegmentInfo">representative segment info</see>.</para>
        <para>This method further improves the order of the resulting segment info list to make sure that the subsequent <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.CalculateSegmentLocations(yWorks.Layout.Router.Polyline.Channel)">location calculation</see> is able to respect the <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">location ranges</see> of the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s and, if possible, the minimum edge to edge distances and possible grid constraints for the segments.</para>
      </remarks>
      <param name="channel">
        <para>the channel for which the order of the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s is optimized</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.CalculateSegmentLocations(yWorks.Layout.Router.Polyline.Channel)">
      <summary>
        <para>Calculates the locations of the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment infos</see> in the given <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see>.</para>
      </summary>
      <remarks>
        <para>This method is called after the order of the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment infos</see> within a channel has been <see cref="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.OptimizeSegmentOrder(yWorks.Layout.Router.Polyline.Channel)">optimized</see>.</para>
      </remarks>
      <param name="channel">
        <para>the channel that contains the segment infos for which the locations will be calculated</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.Channel.SetCurrentLocation(yWorks.Layout.Router.Polyline.SegmentInfo,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting.AdjustSegmentLocations(yWorks.Layout.Router.Polyline.Channel)">
      <summary>
        <para>Adjusts the location assigned to a <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see> in the <see cref="T:yWorks.Layout.Router.Polyline.Channel">channel</see> considering the preferred alignment of the segment.</para>
      </summary>
      <remarks>
        <para>This method is called after the segments have been distributed in the channel but before the final locations of the segments are assigned to the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo">segment info</see>s.</para>
      </remarks>
      <param name="channel">
        <para>the channel that contains the segment infos for which the alignment should be considered</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.Channel.GetCurrentLocation(yWorks.Layout.Router.Polyline.SegmentInfo)" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment" />
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition">
      <summary>
        <para>This class describes an <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> that decomposes its area dynamically.</para>
      </summary>
      <remarks>
        <para>The partitioning strategy is based on binary space partitioning. It divides the partition space recursively in two <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">cells</see> until each cell is completely covered by one or more <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s or completely empty.</para>
      </remarks>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.CutObstacleCost">
      <summary>
        <para>Gets or sets the costs incurred for every <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> that must be cut in a subdivision.</para>
      </summary>
      <remarks>
        <para>Values need to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the cost is negative</para>
      </exception>
      <value>
        <para>a non-negative cut cost</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.UnbalancedObstaclesCost">
      <summary>
        <para>Gets or sets the costs incurred if the distribution after a subdivision of obstacles is unbalanced in sub-cells.</para>
      </summary>
      <remarks>
        <para>Values need to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the cost is negative</para>
      </exception>
      <value>
        <para>a non-negative cost value</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.UnbalancedRatioCost">
      <summary>
        <para>Gets or sets the costs incurred if the subdivision produces unbalanced rectangles.</para>
      </summary>
      <remarks>
        <para>Values need to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the cost is negative</para>
      </exception>
      <value>
        <para>a non-negative cost value</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.AddDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">
      <summary>
        <para>Adds the given <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener">dynamic decomposition listener</see> to receive <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> subdivision and creation events from this decomposition.</para>
      </summary>
      <remarks>
        <para>These events occur when the decomposition changes the partition by subdividing cells into sub-cells or when new cells are created.</para>
      </remarks>
      <param name="listener">
        <para>the dynamic decomposition listener to add</para>
      </param>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.RemoveDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">
      <summary>
        <para>Removes the given <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener">dynamic decomposition listener</see> such that it no longer receives <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> subdivision and creation events from this decomposition.</para>
      </summary>
      <param name="listener">
        <para>the dynamic decomposition listener to remove</para>
      </param>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.FireSubdividedEvent(yWorks.Layout.Router.Polyline.PartitionCell,System.Collections.Generic.IList{System.Object})">
      <summary>
        <para>Notifies all registered <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener">dynamic decomposition listeners</see> of a subdivision of a given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see>.</para>
      </summary>
      <param name="cell">
        <para>the cell that has been subdivided</para>
      </param>
      <param name="subCells">
        <para>the new sub-cells resulting from the subdivision of the given cell</para>
      </param>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.FireFinalizeCellEvent(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Notifies all registered <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener">dynamic decomposition listeners</see> that the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> has been finalized.</para>
      </summary>
      <param name="finalizedCell">
        <para>the cell that has been finalized</para>
      </param>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.FireCreateCellEvent(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Notifies all registered <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener">dynamic decomposition listeners</see> that the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> has been created.</para>
      </summary>
      <remarks>
        <para>This method is also called in <see cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.Init(System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.YRectangle)" />.</para>
      </remarks>
      <param name="createdCell">
        <para>the newly created cell</para>
      </param>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.#ctor">
      <summary>
        <para>Constructs a new instance of <see cref="T:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.Init(System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Initializes this <see cref="T:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition" /> instance with the given obstacles and partition bounds.</para>
      </summary>
      <remarks>
        <para>This method must be called before any other method is invoked.</para>
      </remarks>
      <param name="obstacles">
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> objects</para>
      </param>
      <param name="partitionBounds">
        <para>the bounds of the partition</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.Clear">
      <summary>
        <para>Clears the partition data such that the <see cref="T:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition" /> can be reused and <see cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.Init(System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.YRectangle)">initialized</see> with new <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.Init(System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.YRectangle)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetObstacleCutCosts(System.Int32,System.Int32,System.Int32)">
      <summary>
        <para>Calculates the cost of a cut with respect to the subdivided obstacles.</para>
      </summary>
      <remarks>
        <para>The cost can take values between <c>0</c> and <c>1</c>.</para>
        <para>This method is called while a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> is divided into upper and lower or left and right child cells depending on the cut costs (during <see cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetCells(yWorks.Layout.Router.Polyline.Obstacle)" />, <see cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetCells(yWorks.Algorithms.Geometry.YRectangle)" /> and <see cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetNeighbors(yWorks.Layout.Router.Polyline.PartitionCell)" /> methods).</para>
      </remarks>
      <param name="numObstaclesInFirstHalf">
        <para>the number of obstacles that lie completely in the first half</para>
      </param>
      <param name="numObstaclesInSecondHalf">
        <para>the number of obstacles that lie completely in the second half</para>
      </param>
      <param name="numObstaclesOnCut">
        <para>the number of obstacles that lie on the cut</para>
      </param>
      <returns>
        <para>the cost of a cut with respect to the subdivided obstacles</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetGeometricCutCosts(System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Calculates the cost of a cut with respect to the geometry of the sub-cells.</para>
      </summary>
      <remarks>
        <para>The cost can take values between <c>0</c> and <c>1</c>.</para>
        <para>This method is called while a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> is divided into upper and lower or left and right child cells depending on the cut costs (during <see cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetCells(yWorks.Layout.Router.Polyline.Obstacle)" />, <see cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetCells(yWorks.Algorithms.Geometry.YRectangle)" /> and <see cref="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetNeighbors(yWorks.Layout.Router.Polyline.PartitionCell)" /> methods).</para>
      </remarks>
      <param name="cut">
        <para>the coordinate of the cut</para>
      </param>
      <param name="min">
        <para>the left side of the subdivided cell</para>
      </param>
      <param name="max">
        <para>the right side of the subdivided cell</para>
      </param>
      <param name="orthogonalMin">
        <para>the upper side of the subdivided cell</para>
      </param>
      <param name="orthogonalMax">
        <para>the lower side of the subdivided cell</para>
      </param>
      <returns>
        <para>the cost of a cut with respect to the geometry of the sub-cells</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetNeighbors(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Returns the neighbor <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cells</see> of the given cell.</para>
      </summary>
      <param name="cell">
        <para>the cell whose neighbors will be returned</para>
      </param>
      <returns>
        <para>the neighbor cells of the given cell</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetObstacles(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s that cover the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see>.</para>
      </summary>
      <param name="cell">
        <para>the partition cell for which the obstacles will be returned</para>
      </param>
      <returns>
        <para>an unmodifiable list of <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> instances that cover the given cell</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetCells(yWorks.Layout.Router.Polyline.Obstacle)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cells</see> that are completely covered by the given <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />.</para>
      </summary>
      <param name="obstacle">
        <para>the obstacle for which the covered cells will be returned</para>
      </param>
      <returns>
        <para>an unmodifiable list of <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> instances that are completely covered by the given obstacle</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.GetCells(yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Returns a list of all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that intersect or cover the given rectangle.</para>
      </summary>
      <param name="rect">
        <para>the rectangular area whose (partially) covered cells will be returned</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that (partially) cover the given rectangular area</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition.Bounds">
      <summary>
        <para>Gets the bounds of the original rectangular area that is being partitioned.</para>
      </summary>
      <value>
        <para>the bounds of the original rectangular area</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.EdgeCellInfo">
      <summary>
        <para>This class encapsulates the information that determines the route of a specific edge within a specific <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeCellInfo.#ctor(yWorks.Algorithms.Edge,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.OrthogonalInterval,yWorks.Layout.Router.Polyline.OrthogonalInterval,yWorks.Layout.Direction,yWorks.Layout.Direction,System.Int32)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" /> instance.</para>
      </summary>
      <param name="edge">
        <para>the edge whose routing in the cell is described</para>
      </param>
      <param name="cell">
        <para>the cell in which the edge is routed</para>
      </param>
      <param name="enterInterval">
        <para>the interval that the edge uses to enter the cell</para>
      </param>
      <param name="exitInterval">
        <para>the interval that the edge uses to exit the cell</para>
      </param>
      <param name="enterDirection">
        <para>the direction in which the edge enters the cell</para>
      </param>
      <param name="exitDirection">
        <para>the direction in which the edge exits the cell</para>
      </param>
      <param name="enterSegmentNo">
        <para>the index of the edge segment that enters the cell</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.BendCount">
      <summary>
        <para>Gets the number of bends of the edge within this cell.</para>
      </summary>
      <value>
        <para>the number of bends of the edge within this cell</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeCellInfo.ToString">
      <summary>
        <para>Returns a string representation of the shape of the edge while crossing the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see>.</para>
      </summary>
      <returns>
        <para>a string representation of the shape of the edge while crossing the partition cell</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Type">
      <summary>
        <para>Gets the routing type of the edge within this cell.</para>
      </summary>
      <value>
        <para>the routing type of the edge within this cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.EnterSegmentIndex">
      <summary>
        <para>Gets or sets the index of the edge segment that enters this cell.</para>
      </summary>
      <remarks>
        <para>Values should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given index is negative</para>
      </exception>
      <value>
        <para>the index of the edge segment that enters this cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.ExitSegmentIndex">
      <summary>
        <para>Gets or sets the index of the edge segment that exits this cell.</para>
      </summary>
      <remarks>
        <para>Values should be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given index is negative</para>
      </exception>
      <value>
        <para>the index of the edge segment that exits this cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.EnterSegmentGroup">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup">segment group</see> containing the entering segment.</para>
      </summary>
      <remarks>
        <para>When specifying the segment group, the <see cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.EnterInterval">enter interval</see> is updated to use the segment group's common enter interval.</para>
      </remarks>
      <value>
        <para>the segment group containing the entering segment or <c>null</c> if the entering segment does not belong to a segment group</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonLocationRange" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.ExitSegmentGroup">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup">segment group</see> containing the exiting segment.</para>
      </summary>
      <remarks>
        <para>When specifying the segment group, the <see cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.ExitInterval">exit interval</see> is updated to use the segment group's common exit interval.</para>
      </remarks>
      <value>
        <para>the segment group containing the exiting segment or <c>null</c> if the exiting segment does not belong to a segment group</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonLocationRange" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Edge">
      <summary>
        <para>Gets the edge that is routed within the <see cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Cell">partition cell</see>.</para>
      </summary>
      <value>
        <para>the edge that is routed within the partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Cell">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> within which the edge is routed.</para>
      </summary>
      <value>
        <para>the partition cell within which the edge is routed</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.EnterInterval">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">interval</see> that the edge uses to enter this cell.</para>
      </summary>
      <value>
        <para>the interval that the edge uses to enter this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.ExitInterval">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">interval</see> that the edge uses to exit this cell.</para>
      </summary>
      <value>
        <para>the interval that the edge uses to exit this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.EnterDirection">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Direction">direction</see> in which the edge enters this cell.</para>
      </summary>
      <value>
        <para>the direction that the edge uses to enter this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.ExitDirection">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Direction">direction</see> in which the edge exits this cell.</para>
      </summary>
      <value>
        <para>the direction that the edge uses to exit this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.CellSegmentInfos">
      <summary>
        <para>Calculates the list of <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" />s for the segment parts of this edge that lie within the associated <see cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Cell">partition cell</see>.</para>
      </summary>
      <value>
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" /> objects created for the edge and this cell</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.EdgeInfo">
      <summary>
        <para>This class encapsulates the information required to route an edge with a path routing algorithm.</para>
      </summary>
      <seealso cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.#ctor(yWorks.Layout.Router.Polyline.Path,yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> instance.</para>
      </summary>
      <param name="path">
        <para>the path that will be used for routing the edge</para>
      </param>
      <param name="configuration">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see> of the path search algorithm</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeInfo.Fixed">
      <summary>
        <para>Gets whether the path of this <see cref="P:yWorks.Layout.Router.Polyline.EdgeInfo.Edge">edge</see> is fixed or should be routed by the path search algorithm.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the path of this <see cref="P:yWorks.Layout.Router.Polyline.EdgeInfo.Edge">edge</see> is fixed, <c>false</c> if it should be routed by the path search algorithm</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeInfo.Edge">
      <summary>
        <para>Gets the edge whose route is described by this <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> instance.</para>
      </summary>
      <value>
        <para>the edge whose route is described by this <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeInfo.EdgeCellInfos">
      <summary>
        <para>Gets a list of <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" />s describing how the edge traverses each <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> on its path.</para>
      </summary>
      <value>
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" />s describing how the edge traverses each partition cell on its path</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.GetEdgeCellInfo(yWorks.Layout.Router.Polyline.CellEntrance)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" /> of the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> in the path.</para>
      </summary>
      <param name="entrance">
        <para>the entrance for which the <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" /> will be returned</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" /> of the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> in the path</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.GetSegmentInfo(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> of the edge segment with the given index.</para>
      </summary>
      <param name="segmentIndex">
        <para>the index of the edge segment for which the segment info will be returned</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> of the edge segment with the given index</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.GetPreviousSegment(yWorks.Layout.Router.Polyline.SegmentInfo)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> of the segment preceding the segment of the given <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />.</para>
      </summary>
      <param name="segment">
        <para>the segment info for which the previous segment info will be returned</para>
      </param>
      <returns>
        <para>the segment info of the segment preceding the segment of the given segment info</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.GetNextSegment(yWorks.Layout.Router.Polyline.SegmentInfo)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> of the segment following the segment of the given <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />.</para>
      </summary>
      <param name="segment">
        <para>the segment info for which the next segment info will be returned</para>
      </param>
      <returns>
        <para>the segment info of the segment following the segment of the given segment info</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.SegmentCount">
      <summary>
        <para>Returns the number of segments of the edge.</para>
      </summary>
      <returns>
        <para>the number of segments of the edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.ToString">
      <summary>
        <para>Returns a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> object.</para>
      </summary>
      <returns>
        <para>a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> object</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeInfo.StrongSourcePort">
      <summary>
        <para>Gets or sets the location of the strong source port that the edge uses.</para>
      </summary>
      <remarks>
        <para>Defining a new strong source port also updates the first <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> to use this fixed port location.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the first segment is already fixed and the given port location contradicts the segment's fixed location</para>
      </exception>
      <value>
        <para>the strong source port location or <c>null</c> if no strong source port has been set</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Location" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfo.AtStrongPortConstraint" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeInfo.StrongTargetPort">
      <summary>
        <para>Gets or sets the location of the strong target port that the edge uses.</para>
      </summary>
      <remarks>
        <para>Defining a new strong target port also updates the last <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> to use this fixed port location.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the last segment is already fixed and the given port location contradicts the segment's fixed location</para>
      </exception>
      <value>
        <para>the strong target port location or <c>null</c> if no strong target port has been set</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Location" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfo.AtStrongPortConstraint" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.CalculateLineSegments">
      <summary>
        <para>Calculates an array of <see cref="T:yWorks.Algorithms.Geometry.LineSegment" />s created by the <see cref="M:yWorks.Layout.Router.Polyline.EdgeInfo.CalculatePathPoints">calculated path points</see>.</para>
      </summary>
      <returns>
        <para>an array of <see cref="T:yWorks.Algorithms.Geometry.LineSegment" />s created by the calculated path points</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeInfo.CalculatePathPoints">
      <summary>
        <para>Calculates a list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" />s containing the source port, bend and target port locations.</para>
      </summary>
      <returns>
        <para>a list of <see cref="T:yWorks.Algorithms.Geometry.YPoint" />s containing the source port, bend and target port locations</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor">
      <summary>
        <para>This class is used by <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" /> to provide routing details for the edges of the graph.</para>
      </summary>
      <remarks>
        <para>An <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> instance can be specified individually for single edges using a <see cref="T:yWorks.Algorithms.IDataProvider" /> that returns an <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> instance for each edge of the graph, or <c>null</c> if no <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> is bound to an edge. The <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with the graph using key <see cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.EdgeLayoutDescriptorDpKey" />.</para>
        <para>This class is designed such that it allows future additions of new getter methods.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.EdgeLayoutDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.#ctor">
      <summary>
        <para>Creates a new instance of an <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> with the default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumFirstSegmentLength">
      <summary>
        <para>Gets or sets the minimum length of the first segment of the edge path (at the source node).</para>
      </summary>
      <remarks>
        <para>The minimum length should be greater than or equal to <c>0</c>. If a negative value is given as input, the default value, i.e., <c>5.0</c>, will be used instead.</para>
      </remarks>
      <value>
        <para>the minimum length of the first segment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumLastSegmentLength">
      <summary>
        <para>Gets or sets the minimum length of the last segment of the edge path (at the target node).</para>
      </summary>
      <remarks>
        <para>The minimum length should be greater than or equal to <c>0</c>. If a negative value is given as input, the default value, i.e., <c>10.0</c>, will be used instead.</para>
      </remarks>
      <value>
        <para>the minimum length of the last segment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumEdgeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between a pair of edges.</para>
      </summary>
      <remarks>
        <para>The minimum distance should be greater than or equal to <c>0</c>. If a negative value is given as input, the default value, i.e., <c>3.0</c>, will be used instead.</para>
      </remarks>
      <value>
        <para>the minimum distance between a pair of edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumNodeCornerDistance">
      <summary>
        <para>Gets or sets the minimum distance that the edge should maintain from node corners when entering or leaving the node.</para>
      </summary>
      <remarks>
        <para>The minimum distance should be greater than or equal to <c>0</c>. If a negative value is given as input, the default value, i.e., <c>3.0</c>, will be used instead.</para>
      </remarks>
      <value>
        <para>the minimum distance the edge should maintain from node corners</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MonotonicPathRestriction">
      <summary>
        <para>Gets or sets the monotonic path restrictions that should be applied.</para>
      </summary>
      <remarks>
        <para>Monotonic path restrictions imply that (ideally) the vertical and/or horizontal segments of an edge path are directed from the source node towards the target node without ever changing their direction back towards the source node.</para>
        <para>If an unknown restriction is specified, <see cref="F:yWorks.Layout.Router.MonotonicPathRestriction.None" /> will be used instead.</para>
      </remarks>
      <value>
        <para>one of the predefined monotonic path restrictions</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.PenaltySettings">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Router.Polyline.PenaltySettings" /> used for this edge.</para>
      </summary>
      <remarks>
        <para>Besides specifying a completely customized setting, the user can choose between four predefined optimization strategies: <see cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationBalanced" />, <see cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeBends" />, <see cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeCrossings" /> and <see cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeLengths" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given penalty settings are <c>null</c></para>
      </exception>
      <value>
        <para>the penalty settings used for this edge</para>
      </value>
      <seealso cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationBalanced" />
      <seealso cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeBends" />
      <seealso cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeCrossings" />
      <seealso cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeLengths" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.CreateCopy">
      <summary>
        <para>Creates a copy of this <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> instance.</para>
      </summary>
      <returns>
        <para>a copy of this <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.EdgeRouter">
      <summary>
        <para>This edge routing algorithm applies polyline routes to the edges of the graph.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> Edges are normally routed in an orthogonal fashion, i.e., they only consist of horizontal and vertical segments. There is also a <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.PolylineRouting">routing style</see> in which, between horizontal and vertical segments, additional segments with other slopes are inserted.</para>
        <para>During the routing process, the positions of the nodes are considered to be fixed and the routing algorithm will not modify their locations or their sizes in any way.</para>
        <para>The edge routing algorithm can be applied wherever it is needed to route the edges as polyline or orthogonal segments without crossing any nodes, while keeping the positions of the nodes in the diagram fixed. Some potential applications include electric circuit design, floor planning and navigation maps.</para>
        <para> Sample output of the edge routing algorithm with default settings  Sample output of the edge routing algorithm with polyline routing and grouped edges  Sample output of the edge routing algorithm with polyline routing and group nodes <h2>Concept</h2> The edge routing algorithm basically performs three (four) steps to achieve an orthogonal (polyline) edge routing.</para>
        <list type="number">
          <item>Creating a <see cref="T:yWorks.Layout.Router.Polyline.IPartition" /> which divides the area of the graph area into several <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s.</item>
          <item>Finding the shortest/cheapest paths for all edges through the <see cref="T:yWorks.Layout.Router.Polyline.IPartition" /> using <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />.</item>
          <item>Assigning coordinates to the segments of the edges based on the paths that were calculated before with <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" />.</item>
          <item>Inserting non-orthogonal segments where horizontal and vertical segments meet (only if <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.PolylineRouting">polyline routing</see> is enabled).</item>
        </list>
        <para>The first two steps are customizable. <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s are able to influence how the <see cref="T:yWorks.Layout.Router.Polyline.IPartition" /> is created. They add <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s and/or mark them for adding costs later in the process. The currently used <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPartitionExtensions">partition extensions</see> can be dropped or extended by custom implementations.</para>
        <para>For example, the extension 'Node Partition' adds a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> to the <see cref="T:yWorks.Layout.Router.Polyline.IPartition" /> for each node and marks it as belonging to a node. During <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />, the extension 'Node Crossing' recognizes these <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s and adds costs that penalizes crossing a node. The edge will be routed around the nodes.</para>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s influence the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> by adding costs for traversing <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s or narrowing their intervals to allow a less expensive traversal of a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />. The currently used <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPathSearchExtensions">partition extensions</see> can be dropped or extended by custom implementations.</para>
        <para>Using <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" />s, it is possible to add individual layout settings like routing styles to edges. They are registered with the graph with key <see cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.EdgeLayoutDescriptorDpKey" />. If no descriptor is provided for an edge, a <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.DefaultEdgeLayoutDescriptor">default edge layout descriptor</see> is used as fallback value.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>The routing algorithm supports two approaches to connect edges on a specific side or even on an exact location to a node. <see cref="T:yWorks.Layout.PortConstraint" />s define a single constraint for the ports of an edge. To realize more complex port restrictions, several <see cref="T:yWorks.Layout.PortCandidate" />s or <see cref="T:yWorks.Layout.PortCandidateSet" />s can be assigned to edges or nodes. If an edge with registered <see cref="T:yWorks.Layout.PortCandidate" />s connects to nodes with <see cref="T:yWorks.Layout.PortCandidateSet" />s, the edge router will try to match both collections in order to find an appropriate port. In case there is no matching port candidate, a <see cref="T:yWorks.Layout.PortCandidate" /> specified for the edge is preferred. Since their simultaneous existence at the same node may be ambiguous, it is not recommended to use a combination of <see cref="T:yWorks.Layout.PortConstraint" />s and <see cref="T:yWorks.Layout.PortCandidate" />s in the same diagram.</para>
        <para>Edges can be grouped so that they share common segments at the beginning or end of their routes. Although a graph may contain source and target grouped edges, an edge can only either be part of a source or a target group. Edge groups are specified using <see cref="T:yWorks.Algorithms.IDataProvider" />s that provide the same ID object for all edges in the same group. Those <see cref="T:yWorks.Algorithms.IDataProvider" />s are registered with the graph with key <see cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" /> for source groups or key <see cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" /> for target groups.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.EdgeRouter.EdgeLayoutDescriptorDpKey">
      <summary>
        <para>A data provider key for specifying individual edge layout information.</para>
      </summary>
      <remarks>
        <para>If this <see cref="T:yWorks.Algorithms.IDataProvider" /> does not contain an <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> for an edge, then the layout algorithm will use the <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.DefaultEdgeLayoutDescriptor">default descriptor</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.DefaultEdgeLayoutDescriptor" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.EdgeRouter.LabelCrossingPenaltyFactorDpKey">
      <summary>
        <para>A data provider key for weighting the costs for crossing each label individually.</para>
      </summary>
      <remarks>
        <para>If the factor for a label is <c>0</c> then it is allowed to cross it. Very important labels should get a high factor.</para>
        <para>This factor is multiplied by the basic penalty arising when an edge must cross a <see cref="P:yWorks.Layout.Router.Polyline.PenaltySettings.NodeLabelCrossingPenalty">node label</see> or an <see cref="P:yWorks.Layout.Router.Polyline.PenaltySettings.EdgeLabelCrossingPenalty">edge label</see> in order to determine the final costs arising when this label is crossed.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.DefaultEdgeLayoutDescriptor" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.PenaltySettings" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.MaximumDuration">
      <summary>
        <para>Gets or sets the time limit (in milliseconds) set for the edge routing algorithm.</para>
      </summary>
      <remarks>
        <para>The maximum duration has to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the maximum duration is negative</para>
      </exception>
      <value>
        <para>a non-negative integer value</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.DefaultEdgeLayoutDescriptor">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> instance used for all those edges that do not have a specific edge layout descriptor assigned.</para>
      </summary>
      <value>
        <para>the default <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /></para>
      </value>
      <seealso cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.EdgeLayoutDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.GetEdgeLayoutDescriptor(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> instance for a given edge that is provided by a <see cref="T:yWorks.Algorithms.IDataProvider" /> which is registered with the graph with key <see cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.EdgeLayoutDescriptorDpKey" />.</para>
      </summary>
      <remarks>
        <para>For all those edges that do not have a specific layout descriptor assigned, the default layout descriptor returned by <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.DefaultEdgeLayoutDescriptor" /> will be assigned.</para>
        <para>This method may be overridden in order to create an <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> with custom configuration.</para>
      </remarks>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <returns>
        <para>the current <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> instance for a given edge</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.DefaultEdgeLayoutDescriptor" />
      <seealso cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.EdgeLayoutDescriptorDpKey" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.PolylineRouting">
      <summary>
        <para>Gets or sets whether or not the routing algorithm will route the edges of the graph with (non-orthogonal) polyline segments.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the routing algorithm creates (non-orthogonal) polyline segments, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.PreferredPolylineSegmentLength" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.MaximumPolylineSegmentRatio" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.PreferredPolylineSegmentLength">
      <summary>
        <para>Gets or sets the preferred length of (non-orthogonal) polyline segments.</para>
      </summary>
      <remarks>
        <para>If there is not enough space to use this preferred length, polyline segments may also be shorter.</para>
        <para>The preferred length of (non-orthogonal) polyline segments has to be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the preferred polyline segment length is negative</para>
      </exception>
      <value>
        <para>the preferred length of (non-orthogonal) polyline segments</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.MaximumPolylineSegmentRatio" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.MaximumPolylineSegmentRatio">
      <summary>
        <para>Gets or sets the maximum ratio between the horizontal/vertical part of a segment and the (non-orthogonal) polyline part.</para>
      </summary>
      <remarks>
        <para>When polyline segments are added to an edge path, corners between horizontal and vertical segments are cut and replaced by the new segment. This ratio describes the cutting points on a segment. If it is zero, the route stays orthogonal. The value cannot be larger than <c>0.5</c> because there may be another polyline segment at the other side of the segment. For long orthogonal segments the length of the polyline segment is determined by the value returned by <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.PreferredPolylineSegmentLength" />.</para>
        <para>The maximum polyline segment ratio must be between <c>0</c> and <c>0.5</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the maximum segment length is negative or greater than <c>0.5</c></para>
      </exception>
      <value>
        <para>the maximum polyline segment ratio</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.Rerouting">
      <summary>
        <para>Gets or sets whether or not the routing algorithm uses an additional step to reroute the edges that are considered to have the worst paths.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the rerouting step will be performed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope">
      <summary>
        <para>Gets or sets a (sub-)set of edges that shall be routed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given scope is unknown</para>
      </exception>
      <value>
        <para>one of the default scope values</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.AffectedEdgesDpKey" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.AffectedNodesDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key to look up the selection state of the nodes.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope">scope</see> is set to <see cref="F:yWorks.Layout.Router.Scope.RouteEdgesAtAffectedNodes" />, only the edges that are incident to selected nodes will be routed, while all other edges will be considered to have fixed routes.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Algorithms.IDataProvider" /> key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for the node selection</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key to look up the selection state of the edges.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope">scope</see> is set to <see cref="F:yWorks.Layout.Router.Scope.RouteAffectedEdges" />, only the selected edges will be routed, while all other edges will be considered to have fixed routes.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Algorithms.IDataProvider" /> key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for the edge selection</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.EdgeComparer">
      <summary>
        <para>Gets or sets a custom <see cref="T:System.Collections.Generic.IComparer`1" /> to define the processing order of the edges.</para>
      </summary>
      <value>
        <para>the current <see cref="T:System.Collections.Generic.IComparer`1" /> instance</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreateDefaultEdgeOrderComparer(yWorks.Layout.LayoutGraph,yWorks.Layout.Router.Polyline.PathSearchConfiguration)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.IsAffected(yWorks.Algorithms.Edge,yWorks.Algorithms.Graph)">
      <summary>
        <para>Returns whether or not a given edge is selected.</para>
      </summary>
      <remarks>
        <para>If all the edges of the graph will be routed by <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter" />, i.e., the <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope">scope</see> is set to <see cref="F:yWorks.Layout.Router.Scope.RouteAllEdges" />, this utility method returns <c>true</c> for all edges.</para>
        <para>This method may be overridden in order to determine differently whether or not a given edge is considered to be selected.</para>
      </remarks>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given edge is selected, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the routing algorithm considers the labels of the nodes as obstacles when calculating the edge routes to avoid overlaps.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the node labels are considered, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PenaltySettings.NodeLabelCrossingPenalty" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.IgnoreInnerNodeLabels">
      <summary>
        <para>Gets or sets whether or not this routing algorithm ignores node labels that are inside the bounds of their owner as obstacles for edge routes.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the routing algorithm ignores inner node labels, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.ConsiderNodeLabels" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.PenaltySettings.NodeLabelCrossingPenalty" />
      <seealso cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.LabelCrossingPenaltyFactorDpKey" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.ConsiderEdgeLabels">
      <summary>
        <para>Gets or sets whether or not the routing algorithm considers as obstacles the edge labels that do not belong to the (sub-)set of edges to be routed when calculating the edge routes.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels are considered, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.Scope" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.AffectedEdgesDpKey" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.PenaltySettings.NodeLabelCrossingPenalty" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.Grid">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Router.Polyline.Grid" /> instance on which the routing algorithm places the orthogonal segments.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.Grid" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.MinimumNodeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between edges and node bounds.</para>
      </summary>
      <remarks>
        <para>The minimum distance should have a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum node-to-edge distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum distance</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PenaltySettings.MinimumNodeToEdgeDistancePenalty" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreateGraphPartition(yWorks.Layout.Router.Polyline.IObstaclePartition)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance that divides the area of the graph into several rectangles.</para>
      </summary>
      <remarks>
        <para>This implementation creates a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> using the current <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> instance.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the edge routes are calculated. It may be overridden in order to create a new <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> object with a custom configuration.</para>
      </remarks>
      <param name="decomposition">
        <para>the current <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /></para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ConfigureGraphPartition(yWorks.Layout.Router.Polyline.GraphPartition)" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPartitionExtensions" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.ConfigureGraphPartition(yWorks.Layout.Router.Polyline.GraphPartition)">
      <summary>
        <para>Adds all registered <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s instances to a given <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the edge routes are calculated. It may be overridden in order to adjust the configuration of the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance.</para>
      </remarks>
      <param name="partition">
        <para>the given <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance</para>
      </param>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPartitionExtensions" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.CleanUpGraphPartition(yWorks.Layout.Router.Polyline.GraphPartition)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CleanUpGraphPartition(yWorks.Layout.Router.Polyline.GraphPartition)">
      <summary>
        <para>Removes all registered <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s from a given <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> after the edge routes are calculated. It may be overridden in order to provide a custom implementation for cleaning up a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance.</para>
      </remarks>
      <param name="partition">
        <para>the given <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ConfigureGraphPartition(yWorks.Layout.Router.Polyline.GraphPartition)" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPartitionExtensions" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPartitionExtensions">
      <summary>
        <para>Gets a list of all registered <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s can be added to a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> in order to create new <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s or can be removed from a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance.</para>
        <para>By default, the following <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s are registered with a given <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance:</para>
        <list type="bullet">
          <item>Minimum Node To Edge Distance Partition</item>
          <item>Node Partition</item>
          <item>Partition Grid Partition</item>
          <item>Node Label Partition</item>
          <item>Edge Label Partition</item>
          <item>Fixed Edges Partition</item>
          <item>External Strong Port Restriction Partition</item>
        </list>
      </remarks>
      <value>
        <para>a list containing all registered <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreateGraphPartition(yWorks.Layout.Router.Polyline.IObstaclePartition)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ConfigureGraphPartition(yWorks.Layout.Router.Polyline.GraphPartition)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreatePathSearch">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance that finds the paths of the edges through the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" />.</para>
      </summary>
      <remarks>
        <para>This method may be overridden in order to create a new <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> object with custom configuration.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ConfigurePathSearch(yWorks.Layout.Router.Polyline.PathSearch)" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPathSearchExtensions" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.ConfigurePathSearch(yWorks.Layout.Router.Polyline.PathSearch)">
      <summary>
        <para>Adds all registered <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s to a given <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the edge routes are calculated. It may be overridden in order to adjust the configuration of a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance.</para>
      </remarks>
      <param name="pathSearch">
        <para>a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreatePathSearch" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPathSearchExtensions" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.RegisteredPathSearchExtensions">
      <summary>
        <para>Gets a list of all registered <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s can be added to a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance in order to influence the path searching process or can be removed from a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance.</para>
        <para>By default, the following <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s are registered with a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance:</para>
        <list type="bullet">
          <item>Fixed Grouped Edges</item>
          <item>Node Crossing</item>
          <item>Minimum Node To Edge Distance</item>
          <item>Group Node Crossing</item>
          <item>Minimum Group Node To Edge Distance</item>
          <item>Node Label Crossing</item>
          <item>Edge Label Crossing</item>
          <item>Bends In Node To Edge Distance</item>
          <item>Bend</item>
          <item>Monotonic Route</item>
          <item>Edge Length</item>
          <item>Partition Grid</item>
          <item>Port Restriction</item>
          <item>Edge Grouping</item>
          <item>Minimum Node Corner Distance</item>
          <item>Interval Based Crossing</item>
          <item>Minimum Edge To Edge Distance And Grid</item>
          <item>Minimum First Last Segment Length</item>
          <item>Intersecting Source And Target</item>
        </list>
      </remarks>
      <value>
        <para>a list containing all registered <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreatePathSearch" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ConfigurePathSearch(yWorks.Layout.Router.Polyline.PathSearch)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreatePathRouting">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> instance that routes the edges using pre-calculated <see cref="T:yWorks.Layout.Router.Polyline.Path" /> objects.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the edge routes are calculated. It may be overridden in order to create a new <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> object with custom configuration.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreateObstacleDecomposition">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition" /> that is used by the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> to divide the graph area in rectangles.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the edge routes are calculated. It may be overridden in order to create a new <see cref="T:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition" /> object with custom configuration.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Router.Polyline.DynamicObstacleDecomposition" /> instance</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreateGraphPartition(yWorks.Layout.Router.Polyline.IObstaclePartition)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreatePathSearchContext(yWorks.Layout.Router.Polyline.PathSearch,yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Router.Polyline.PathSearchContext" /> that provides context information for the path searching algorithm.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the edge routes are calculated. It may be overridden in order to create a new <see cref="T:yWorks.Layout.Router.Polyline.PathSearchContext" /> object with custom configuration.</para>
      </remarks>
      <param name="pathSearch">
        <para>a given <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> instance</para>
      </param>
      <param name="configuration">
        <para>a given configuration for the path searching process</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Router.Polyline.PathSearchContext" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreateConfiguration(yWorks.Layout.LayoutGraph,yWorks.Layout.Grouping.GroupingSupport)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration" /> that is used during the path searching process.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the edge routes are calculated. It may be overridden in order to create a new <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration" /> object with custom configuration.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="grouping">
        <para>the grouping structure of the graph</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Performs the routing of the edges of the input graph.</para>
      </summary>
      <remarks>
        <para>This method also prepares the graph for the edge routing process.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CreateDefaultEdgeOrderComparer(yWorks.Layout.LayoutGraph,yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Creates a default <see cref="T:System.Collections.Generic.IComparer`1" /> instance to determine the order of the edges according to which they will be routed.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.EdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> before the edge routes are calculated. It may be overridden in order to create a new <see cref="T:System.Collections.Generic.IComparer`1" /> object with a custom configuration.</para>
        <para>By default, this method returns an instance of the default implementation.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="configuration">
        <para>the given configuration for the path searching process</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.EdgeRouter.CheckNodeSize(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Checks the sizes of the nodes to be non-zero.</para>
      </summary>
      <param name="g">
        <para>The graph to check.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.EdgeRouter.Partition">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance used during the routing process.</para>
      </summary>
      <value>
        <para>the current <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.Alignment">
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.Alignment.Min">
      <summary>
        <para>A constant specifying that the segment prefers to be placed close to the lower bound of its location range.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.Alignment.Max">
      <summary>
        <para>A constant specifying that the segment prefers to be placed close to the upper bound of its location range.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.Alignment.Any">
      <summary>
        <para>A constant specifying that the segment can be placed anywhere within its location range.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment" />
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.RoutingType">
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.RoutingType.Straight">
      <summary>
        <para>A routing type representing a straight crossing of the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see>, i.e., a single orthogonal edge segment enters and exits the cell.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.RoutingType.StraightBending">
      <summary>
        <para>A routing type representing a crossing of the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> with three segments, i.e., the edge enters and exits the cell using the same direction but has an orthogonal middle segment between the entering and exiting segment.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.RoutingType.Bending">
      <summary>
        <para>A routing type representing a crossing of the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> with a single bend, i.e., the edge enters the cell in one direction, makes a bend and exits the cell in an orthogonal direction.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.RoutingType.UTurn">
      <summary>
        <para>A routing type representing a crossing of the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> by making a U-turn, i.e., the edge enters and exits the cell on the same side using two turns and an orthogonal middle segment.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Type" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.RoutingType.End">
      <summary>
        <para>A routing type representing the source or target end of an edge being in the cell, i.e., the enter and/or exit interval is <c>null</c>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeCellInfo.Type" />
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.GraphPartition">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> partitions the bounding box of a graph into rectangles using the graph elements as <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s.</para>
      </summary>
      <remarks>
        <para>All <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s used during the partitioning are <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.CreateObstacle(yWorks.Algorithms.Geometry.YRectangle,System.Object)">created</see> by <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s. <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s have been <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.AddDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">registered</see> before using method <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" /> which is called during the <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.Init(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">initialization</see> of a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" />.</para>
        <para>The core partitioning is delegated to an <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> that is <see cref="M:yWorks.Layout.Router.Polyline.IObstaclePartition.Init(System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.YRectangle)">initialized</see> with these <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s.</para>
        <para>If the <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> is of type <see cref="T:yWorks.Layout.Router.Polyline.IDynamicDecomposition" />, <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> re-dispatches the decomposition notifications to its extensions.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.#ctor(yWorks.Layout.Router.Polyline.IObstaclePartition)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> instance using the given <see cref="P:yWorks.Layout.Router.Polyline.GraphPartition.Partition">delegate inner obstacle partition</see>.</para>
      </summary>
      <param name="partition">
        <para>the delegate inner obstacle partition</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.GraphPartition.Partition">
      <summary>
        <para>Gets the delegate inner obstacle partition.</para>
      </summary>
      <value>
        <para>the delegate inner obstacle partition</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.AddDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">
      <summary>
        <para>Adds the given listener to the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" />.</para>
      </summary>
      <remarks>
        <para>The listener will be notified upon dynamic decomposition events. If it is a <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />, method <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" /> is called during <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.Init(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">initialization</see>.</para>
      </remarks>
      <param name="listener">
        <para>the listener to be added</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.RemoveDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">
      <summary>
        <para>Removes the given listener from the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" />.</para>
      </summary>
      <remarks>
        <para>The listener will not be notified of dynamic decomposition events anymore.</para>
      </remarks>
      <param name="listener">
        <para>the listener to be removed</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.Init(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Initializes the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> with the given graph instance based on the given <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see> used by path search algorithms.</para>
      </summary>
      <remarks>
        <para>Before calling this method, any old partitioning information must be <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.Clear">cleared</see>.</para>
        <para>This initialization method calls <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" /> of all registered extensions. Then, the <see cref="P:yWorks.Layout.Router.Polyline.GraphPartition.Partition">inner delegate partition</see> is initialized passing all <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.CreateObstacle(yWorks.Algorithms.Geometry.YRectangle,System.Object)">added</see> obstacles as well as the given graph's bounds extended by a small padding.</para>
        <para>In the case where the <see cref="P:yWorks.Layout.Router.Polyline.GraphPartition.Partition">delegate partition</see> is of type <see cref="T:yWorks.Layout.Router.Polyline.IDynamicDecomposition" />, this <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> will also be added as <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" /> to it.</para>
      </remarks>
      <param name="configuration">
        <para>the configuration used by path search algorithms</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.GraphPartition.Clear" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.GraphPartition.AddDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.GetNeighbors(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Returns a list of all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that are neighbors of the given cell, i.e., those cells that have a common border segment with the given cell.</para>
      </summary>
      <param name="cell">
        <para>the cell whose neighbors will be returned</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that are neighbors of the given cell</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.GetNodes(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Returns a list of all <see cref="T:yWorks.Algorithms.Node" />s whose bounds intersect or cover the bounds of the given cell.</para>
      </summary>
      <param name="cell">
        <para>the cell</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Algorithms.Node" />s that are intersected by the given cell</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.GetObstacles(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s covering the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> by delegating to the corresponding method of the <see cref="P:yWorks.Layout.Router.Polyline.GraphPartition.Partition">inner partition</see>.</para>
      </summary>
      <param name="cell">
        <para>the cell whose obstacles will be returned</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s that cover the given cell</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.IObstaclePartition.GetObstacles(yWorks.Layout.Router.Polyline.PartitionCell)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.GetCells(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that are completely covered by the bounds of the given node.</para>
      </summary>
      <param name="node">
        <para>the node for which the covered cells will be returned</para>
      </param>
      <returns>
        <para>an unmodifiable list of <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> instances that are completely covered by the bounds of the given node</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the node is unknown</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.GetCells(yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Returns a list of all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that intersect or cover the given rectangle by delegating to the corresponding method of the <see cref="P:yWorks.Layout.Router.Polyline.GraphPartition.Partition">inner partition</see>.</para>
      </summary>
      <param name="rect">
        <para>the rectangular area whose (partially) covered cells will be returned</para>
      </param>
      <returns>
        <para>a list containing (partially) covered <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.IPartition.GetCells(yWorks.Algorithms.Geometry.YRectangle)" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.GraphPartition.Bounds">
      <summary>
        <para>Gets the bounds of the original rectangular area that is being partitioned.</para>
      </summary>
      <remarks>
        <para>This method delegates to the corresponding method of the <see cref="P:yWorks.Layout.Router.Polyline.GraphPartition.Partition">inner partition</see>.</para>
      </remarks>
      <value>
        <para>the bounds of the original rectangular area</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.IPartition.Bounds" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.Clear">
      <summary>
        <para>Clears the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition">partition</see> data such that the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> can be reused and <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.Init(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">initialized</see> with a new configuration.</para>
      </summary>
      <remarks>
        <para>All <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />s are <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.Cleanup">cleaned up</see>; partition listeners and obstacles are <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.RemoveDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">removed</see>.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Router.Polyline.GraphPartition.Init(yWorks.Layout.Router.Polyline.PathSearchConfiguration)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.OnCellSubdivided(yWorks.Layout.Router.Polyline.PartitionCell,System.Collections.Generic.IList{System.Object})">
      <summary>
        <para>Re-dispatches the event of the subdivision of a given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> into several sub-cells to all registered <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />s.</para>
      </summary>
      <remarks>
        <para>This method is a callback after a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> has been subdivided into several sub-cells.</para>
      </remarks>
      <param name="cell">
        <para>the cell that has been subdivided</para>
      </param>
      <param name="subCells">
        <para>the sub-cells resulting from the subdivision of the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.OnCellFinalized(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Re-dispatches the event of having completed the process of subdivisions of a given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> to all registered <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />s.</para>
      </summary>
      <remarks>
        <para>This method is a callback after a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> has been finalized and won't be further subdivided.</para>
      </remarks>
      <param name="finalizedCell">
        <para>the cell that has been finalized</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.OnCellCreated(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Re-dispatches the event of the creation of a new <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> to all registered <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />s.</para>
      </summary>
      <remarks>
        <para>This method is a callback after a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> has been created.</para>
      </remarks>
      <param name="createdCell">
        <para>the newly created <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.CreateObstacle(yWorks.Algorithms.Geometry.YRectangle,System.Object)">
      <summary>
        <para>Creates and returns a new <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> using the given bounds and data.</para>
      </summary>
      <remarks>
        <para>All obstacles created via this method are delegated to the <see cref="P:yWorks.Layout.Router.Polyline.GraphPartition.Partition">inner partition</see> upon <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.Init(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">initialization</see>.</para>
      </remarks>
      <param name="bounds">
        <para>the bounds of the obstacle</para>
      </param>
      <param name="data">
        <para>the additional data that should be associated with the obstacle</para>
      </param>
      <returns>
        <para>a new <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> using the given bounds and data</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartition.GetObstacle(System.Object)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> that has been created earlier for the given data object.</para>
      </summary>
      <param name="data">
        <para>the given data for which the obstacle will be returned</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> that has been created earlier for the given data object</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter" /> provides an empty implementation of <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" />.</para>
      </summary>
      <remarks>
        <para>The only real functionality is contained in method <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" /> which stores the given <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration" /> and <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> in properties.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.Configuration" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.GraphPartition" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.GraphPartition">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> passed to <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" />.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> passed to <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" /> or <c>null</c> if said method has not been called yet or this instance has been <see cref="M:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.Cleanup">cleaned up</see></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.Configuration">
      <summary>
        <para>Gets the configuration of the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> passed to <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" />.</para>
      </summary>
      <value>
        <para>the configuration of the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> passed to <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" /> or <c>null</c> if said method has not been called yet or this instance has been <see cref="M:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.Cleanup">cleaned up</see></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.OnCellCreated(yWorks.Layout.Router.Polyline.PartitionCell)">
      <param name="createdCell" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.OnCellSubdivided(yWorks.Layout.Router.Polyline.PartitionCell,System.Collections.Generic.IList{System.Object})">
      <param name="cell" />
      <param name="subCells" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.OnCellFinalized(yWorks.Layout.Router.Polyline.PartitionCell)">
      <param name="finalizedCell" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)">
      <summary>
        <para>Stores the given <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration" /> and <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> such that they are accessible through <see cref="P:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.Configuration" /> and <see cref="P:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.GraphPartition" />, respectively.</para>
      </summary>
      <param name="configuration">
        <para>the configuration used for the path search</para>
      </param>
      <param name="graphPartition">
        <para>the graph partition that uses this extension</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.GraphPartitionExtensionAdapter.Cleanup" />
    <member name="T:yWorks.Layout.Router.Polyline.Grid">
      <summary>
        <para>This class provides support for routing edges on equidistant grid lines.</para>
      </summary>
      <remarks>
        <para>The grid is defined by its origin and the spacing between the equidistant grid lines.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Grid.#ctor(System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.Grid" /> instance.</para>
      </summary>
      <remarks>
        <para>The spacing between the grid lines must be at least <c>1</c>. If the given spacing is smaller, value <c>1</c> is assumed.</para>
      </remarks>
      <param name="originX">
        <para>the x-coordinate of the origin of the grid</para>
      </param>
      <param name="originY">
        <para>the y-coordinate of the origin of the grid</para>
      </param>
      <param name="spacing">
        <para>the spacing between the grid lines</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Grid.OriginX">
      <summary>
        <para>Gets the x-coordinate of the origin.</para>
      </summary>
      <value>
        <para>the x-coordinate of the origin</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Grid.OriginY">
      <summary>
        <para>Gets the y-coordinate of the origin.</para>
      </summary>
      <value>
        <para>the y-coordinate of the origin</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Grid.Spacing">
      <summary>
        <para>Gets the spacing between the horizontal and vertical grid lines.</para>
      </summary>
      <value>
        <para>the spacing between the horizontal and vertical grid lines</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Grid.ToString">
      <summary>
        <para>Returns a string representation of the <see cref="T:yWorks.Layout.Router.Polyline.Grid" /> object.</para>
      </summary>
      <returns>
        <para>a string representation of the <see cref="T:yWorks.Layout.Router.Polyline.Grid" /> object.</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.IDynamicDecomposition">
      <summary>
        <para>This interface should be implemented by classes that dispatch notifications about changes in <see cref="T:yWorks.Layout.Router.Polyline.IPartition" />s.</para>
      </summary>
      <remarks>
        <para>Such classes can be notified when <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s are created, divided, and/or finalized.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IDynamicDecomposition.AddDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">
      <summary>
        <para>Adds the given <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" /> that will be notified of dynamic decomposition events to the <see cref="T:yWorks.Layout.Router.Polyline.IPartition" />.</para>
      </summary>
      <param name="listener">
        <para>the listener to be added</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IDynamicDecomposition.RemoveDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">
      <summary>
        <para>Removes the given <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" /> from the <see cref="T:yWorks.Layout.Router.Polyline.IPartition" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" /> will be no more notified of dynamic decomposition events.</para>
      </remarks>
      <param name="listener">
        <para>the listener to be removed</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.IDecompositionListener">
      <summary>
        <para>This interface is implemented by classes that require to be notified of changes in <see cref="T:yWorks.Layout.Router.Polyline.IPartition" />s.</para>
      </summary>
      <remarks>
        <para>Implementations are notified when <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s are created, divided, and/or finalized.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IDecompositionListener.OnCellCreated(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Callback after the new given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> has been created.</para>
      </summary>
      <param name="createdCell">
        <para>the newly created <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IDecompositionListener.OnCellSubdivided(yWorks.Layout.Router.Polyline.PartitionCell,System.Collections.Generic.IList{System.Object})">
      <summary>
        <para>Callback after the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> has been subdivided into several sub-cells.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.IDecompositionListener" /> may not modify the list of sub-cells.</para>
      </remarks>
      <param name="cell">
        <para>the cell that has been subdivided</para>
      </param>
      <param name="subCells">
        <para>the sub-cells resulting from the subdivision of the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IDecompositionListener.OnCellFinalized(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Callback after the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> has been finalized and won't be further subdivided.</para>
      </summary>
      <param name="finalizedCell">
        <para>the cell that has been finalized</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.IEnterIntervalCalculator">
      <summary>
        <para>This interface provides additional intervals in order to move from one <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> into an adjacent one.</para>
      </summary>
      <remarks>
        <para>To find a <see cref="T:yWorks.Layout.Router.Polyline.Path" /> for an edge, the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> algorithm moves from the current partition cell to an adjacent partition cell. By default, the orthogonal interval shared by these two cells is used. Implementations of this interface may be added to the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> to calculate additional enter intervals that might accumulate lower costs for entering the adjacent cell.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearch.AddAdditionalEnterIntervalCalculator(yWorks.Layout.Router.Polyline.IEnterIntervalCalculator)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IEnterIntervalCalculator.AppendEnterIntervals(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.OrthogonalInterval,System.Collections.Generic.IList{System.Object},yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Appends additional enter intervals to the given list of enter intervals for moving from the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> of the current <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> to the neighboring cell.</para>
      </summary>
      <param name="currentEntrance">
        <para>the current <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> that is exited</para>
      </param>
      <param name="enteredCell">
        <para>the neighboring cell that will be entered</para>
      </param>
      <param name="commonInterval">
        <para>the common interval of the left and entered partition cells</para>
      </param>
      <param name="allEnterIntervals">
        <para>the list to which additional enter intervals have to be appended</para>
      </param>
      <param name="context">
        <para>the context of the path search</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension">
      <summary>
        <para>This interface provides methods for extending the functionality of a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" />.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" /> can be used for <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.CreateObstacle(yWorks.Algorithms.Geometry.YRectangle,System.Object)">creating</see> new <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s that will be given to the initializer of the <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> where they can react to the <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" />'s decomposition events if it implements the <see cref="T:yWorks.Layout.Router.Polyline.IDynamicDecomposition" /> interface.</para>
        <para>A <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" /> has to be <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.AddDynamicDecompositionListener(yWorks.Layout.Router.Polyline.IDecompositionListener)">added</see> to the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> which will call method <see cref="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)" /> before the <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> is initialized.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.PreparePartition(yWorks.Layout.Router.Polyline.PathSearchConfiguration,yWorks.Layout.Router.Polyline.GraphPartition)">
      <summary>
        <para>Adds a <see cref="T:yWorks.Layout.Router.Polyline.IGraphPartitionExtension" /> to the <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" />.</para>
      </summary>
      <remarks>
        <para>It is called by the given <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> upon initialization before its <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> is initialized. Implementations may use the graph upon which the given <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" /> is based to initialize themselves and/or to <see cref="M:yWorks.Layout.Router.Polyline.GraphPartition.CreateObstacle(yWorks.Algorithms.Geometry.YRectangle,System.Object)">add obstacles</see> to the list with which <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> is initialized.</para>
      </remarks>
      <param name="configuration">
        <para>the configuration used for the path search</para>
      </param>
      <param name="graphPartition">
        <para>the graph partition that uses this extension</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IGraphPartitionExtension.Cleanup">
      <summary>
        <para>Cleans up the extension from the last partitioning with the current <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">configuration</see> and <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" />.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.IObstaclePartition">
      <summary>
        <para>This class implements a <see cref="T:yWorks.Layout.Router.Polyline.IPartition" /> that takes a list of <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s as input to subdivide an area into <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s.</para>
      </summary>
      <remarks>
        <para>Implementations have to satisfy the following condition for each pair of <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> and <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s either completely cover <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s or do not intersect <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s at all.</item>
        </list>
        <para> Example of an <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> of a graph consisting of two nodes connected by one edge. The two nodes are considered to be obstacles. The colored partition cells subdivide the area such that each obstacle either completely covers a partition cell or does not intersect with a partition cell.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IObstaclePartition.Init(System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Initializes a new <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> of the area with the given bounds using the given list of <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s.</para>
      </summary>
      <remarks>
        <para>Unused partitions must be cleared using method <see cref="M:yWorks.Layout.Router.Polyline.IObstaclePartition.Clear" />.</para>
      </remarks>
      <param name="obstacles">
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s that have to be considered by the partition</para>
      </param>
      <param name="bounds">
        <para>the bounds of the partition</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.IObstaclePartition.Clear" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IObstaclePartition.GetObstacles(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s that cover the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <param name="cell">
        <para>the partition cell for which the obstacles will be returned</para>
      </param>
      <returns>
        <para>an unmodifiable list of <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> instances that cover the given cell</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IObstaclePartition.GetCells(yWorks.Layout.Router.Polyline.Obstacle)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that are completely covered by the given <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />.</para>
      </summary>
      <param name="obstacle">
        <para>the obstacle for which the covered cells will be returned</para>
      </param>
      <returns>
        <para>an unmodifiable list of <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> instances that are completely covered by the given obstacle</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IObstaclePartition.Clear">
      <summary>
        <para>Clears the partition data such that the <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> can be reused and <see cref="M:yWorks.Layout.Router.Polyline.IObstaclePartition.Init(System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.YRectangle)">initialized</see> with new <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" />s.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Router.Polyline.IObstaclePartition.Init(System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.YRectangle)" />
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.IPartition">
      <summary>
        <para>This class divides a rectangular area into one or more <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s have to be disjoint. The union of all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s covers the original area.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IPartition.GetNeighbors(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Returns a list of all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that are neighbors of the given cell, i.e., those cells that have a common border segment with the given cell.</para>
      </summary>
      <param name="cell">
        <para>the cell whose neighbors will be returned</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that are neighbors of the given cell</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.IPartition.GetCells(yWorks.Algorithms.Geometry.YRectangle)">
      <summary>
        <para>Returns a list of all <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that intersect or cover the given rectangle.</para>
      </summary>
      <param name="rect">
        <para>the rectangular area whose (partially) covered cells will be returned</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s that (partially) cover the given rectangular area</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.IPartition.Bounds">
      <summary>
        <para>Gets the bounds of the original rectangular area that is partitioned.</para>
      </summary>
      <value>
        <para>the bounds of the original rectangular area</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.Interval">
      <summary>
        <para>This class represents a one-dimensional closed interval.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.#ctor(System.Double,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.Interval" /> between the given bounds.</para>
      </summary>
      <remarks>
        <para>The upper and lower bound of the two given values are determined automatically, i.e., the smaller one will be treated as the lower bound and the larger one as the upper bound.</para>
      </remarks>
      <param name="bound1">
        <para>the first interval bound</para>
      </param>
      <param name="bound2">
        <para>the second interval bound</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Interval.Min">
      <summary>
        <para>Gets the lower bound of the interval.</para>
      </summary>
      <value>
        <para>the lower bound of the interval</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Interval.Max">
      <summary>
        <para>Gets the upper bound of the interval.</para>
      </summary>
      <value>
        <para>the upper bound of the interval</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Interval.Center">
      <summary>
        <para>Gets the midpoint of the interval.</para>
      </summary>
      <value>
        <para>the midpoint of the interval</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.Contains(System.Double)">
      <summary>
        <para>Checks whether or not the given value lies within the interval.</para>
      </summary>
      <param name="value">
        <para>the value to check</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the value lies within the interval, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Interval.Size">
      <summary>
        <para>Gets the size of the interval, i.e., the difference between the <see cref="P:yWorks.Layout.Router.Polyline.Interval.Max">upper bound</see> and the <see cref="P:yWorks.Layout.Router.Polyline.Interval.Min">lower bound</see>.</para>
      </summary>
      <value>
        <para>the size of the interval</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.Intersects(yWorks.Layout.Router.Polyline.Interval,System.Double)">
      <summary>
        <para>Checks whether or not this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> intersects with the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see>, considering the given minimum intersection length.</para>
      </summary>
      <param name="other">
        <para>the other interval to check</para>
      </param>
      <param name="minIntersection">
        <para>the minimum length of the intersection of the intervals</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the intervals intersect at least by the given minimum length, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.DistanceTo(System.Double)">
      <summary>
        <para>Returns the distance between the value and this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see>.</para>
      </summary>
      <remarks>
        <para>If this interval contains the specified value, the distance is <c>0</c>. Otherwise, it is the minimum of <c>dist(value, lower bound)</c> and <c>dist(value, upper bound)</c>.</para>
      </remarks>
      <param name="value">
        <para>the value to which the distance is calculated</para>
      </param>
      <returns>
        <para>the distance between the value and the interval</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.DistanceTo(yWorks.Layout.Router.Polyline.Interval)">
      <summary>
        <para>Returns the distance between this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> and the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see>.</para>
      </summary>
      <remarks>
        <para>If the intervals <see cref="M:yWorks.Layout.Router.Polyline.Interval.Intersects(yWorks.Layout.Router.Polyline.Interval,System.Double)">intersect</see>, the distance is <c>0</c>. Otherwise, it is equal to <c>dist(minimum of upper bounds, maximum of lower bounds)</c>.</para>
      </remarks>
      <param name="other">
        <para>the other interval to which the distance is calculated</para>
      </param>
      <returns>
        <para>the distance between this interval and the given interval</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.CoveredBy(yWorks.Layout.Router.Polyline.Interval,System.Double)">
      <summary>
        <para>Checks whether or not the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> fully covers this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> given a small epsilon value.</para>
      </summary>
      <remarks>
        <para>The given interval covers this interval, if <c>other lower bound - epsilon &lt;= this lower bound</c> and <c>this upper bound &lt;= other upper bound + epsilon</c>.</para>
      </remarks>
      <param name="other">
        <para>the other interval</para>
      </param>
      <param name="eps">
        <para>the epsilon value that determines the extended range of the other interval</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this interval is fully covered by the other interval, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.GetClosest(System.Double)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> bound that is closest to the given value.</para>
      </summary>
      <param name="value">
        <para>the value for which the closest interval bound will be returned</para>
      </param>
      <returns>
        <list type="bullet">
          <item>the <c>value</c>, if the given value lies within the interval, or</item>
          <item>the lower bound, if the given value is smaller than or equal to the lower bound, or</item>
          <item>the upper bound, if the given value is greater than or equal to the upper bound</item>
        </list>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.IsLessThan(yWorks.Layout.Router.Polyline.Interval)">
      <summary>
        <para>Checks whether or not the upper bound of this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> is smaller than the lower bound of the given interval.</para>
      </summary>
      <param name="other">
        <para>the interval to compare</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the current interval is on the left of the given one, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.IsGreaterThan(yWorks.Layout.Router.Polyline.Interval)">
      <summary>
        <para>Checks whether or not the lower bound of this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> is greater than the upper bound of the given interval.</para>
      </summary>
      <param name="other">
        <para>the interval to compare</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the current interval is on the right of the given one, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.ToString">
      <summary>
        <para>Returns a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.Interval" /> object.</para>
      </summary>
      <returns>
        <para>a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.Interval" /> object</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.HasSameRange(yWorks.Layout.Router.Polyline.Interval,System.Double)">
      <summary>
        <para>Checks whether or not this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> and the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> cover the same range.</para>
      </summary>
      <remarks>
        <para>The intervals are considered to cover the same range, if their minimum values as well as their maximum values differ only in the given epsilon value.</para>
      </remarks>
      <param name="other">
        <para>the other interval</para>
      </param>
      <param name="eps">
        <para>the maximum distance between the two minimum and the two maximum values</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the intervals cover the same range, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.CalculateIntersection(yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval)">
      <summary>
        <para>Returns the intersection of the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">intervals</see>.</para>
      </summary>
      <remarks>
        <para>The intersection is <c>null</c> if the given intervals do not intersect each other. Otherwise, the intersection is <c>[maximum of lower bounds, minimum of upper bounds]</c>.</para>
      </remarks>
      <param name="i1">
        <para>the first interval</para>
      </param>
      <param name="i2">
        <para>the second interval</para>
      </param>
      <returns>
        <para>the intersection of the given intervals or <c>null</c> if the intervals do not intersect</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.CalculateUnion(yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval)">
      <summary>
        <para>Returns the union of the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">intervals</see>.</para>
      </summary>
      <remarks>
        <para>The union is <c>[minimum of lower bounds, maximum of upper bounds]</c>.</para>
      </remarks>
      <param name="i1">
        <para>the first interval</para>
      </param>
      <param name="i2">
        <para>the second interval</para>
      </param>
      <returns>
        <para>the union of the given intervals</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.CalculateUnion(yWorks.Layout.Router.Polyline.Interval,System.Double)">
      <summary>
        <para>Returns the union of the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">intervals</see> and the given value.</para>
      </summary>
      <remarks>
        <para>The union is between the minimum of the lower bound of the given interval and the given value and the maximum of the upper bound of the given interval and the given value.</para>
      </remarks>
      <param name="interval">
        <para>the interval to be extended</para>
      </param>
      <param name="value">
        <para>the value to be in the union</para>
      </param>
      <returns>
        <para>the union of the given interval and the given value</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.CalculateBridge(yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval)">
      <summary>
        <para>Returns the bridging <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> between the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">intervals</see>.</para>
      </summary>
      <remarks>
        <para>The bridging interval is <c>null</c> if the given intervals intersect each other. Otherwise, the bridging interval is <c>[minimum of upper bounds, maximum of lower bounds]</c>.</para>
      </remarks>
      <param name="i1">
        <para>the first interval</para>
      </param>
      <param name="i2">
        <para>the second interval</para>
      </param>
      <returns>
        <para>the bridging interval between the given intervals or <c>null</c> if the intervals intersect</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.CalculateSpanningRectangle(yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval)">
      <summary>
        <para>Returns the spanning rectangle between the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">intervals</see>.</para>
      </summary>
      <remarks>
        <para>The first interval spans the rectangle in horizontal dimension, the second interval in vertical dimension.</para>
      </remarks>
      <param name="horizontal">
        <para>the interval that defines the location and length of the rectangle in horizontal dimension</para>
      </param>
      <param name="vertical">
        <para>the interval that defines the location and length of the rectangle in vertical dimension</para>
      </param>
      <returns>
        <para>the spanning rectangle between the given intervals</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.Equals(System.Object)">
      <summary>
        <para>Checks whether or not this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see> equals to the given <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see>.</para>
      </summary>
      <remarks>
        <para>Two intervals are equal if they have the same lower and upper bounds.</para>
      </remarks>
      <param name="other">
        <para>the other interval</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the two given intervals are equal, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Interval.GetHashCode">
      <summary>
        <para>Returns the hash code for this <see cref="T:yWorks.Layout.Router.Polyline.Interval">interval</see>.</para>
      </summary>
      <returns>
        <para>the hash code for this interval</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.Obstacle">
      <summary>
        <para>This class describes the obstacles that are used by implementations of <see cref="T:yWorks.Layout.Router.Polyline.IObstaclePartition" /> to subdivide an area into <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Obstacle.#ctor(yWorks.Algorithms.Geometry.YRectangle,System.Object)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.Obstacle" /> instance with the given bounds and additional data.</para>
      </summary>
      <param name="bounds">
        <para>the bounds of the obstacle</para>
      </param>
      <param name="data">
        <para>the additional data associated to the obstacle</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Obstacle.Bounds">
      <summary>
        <para>Gets the bounds of the obstacle.</para>
      </summary>
      <value>
        <para>a <see cref="T:yWorks.Algorithms.Geometry.YRectangle" /> representing the bounds of the obstacle</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Obstacle.Data">
      <summary>
        <para>Gets the additional data related to the obstacle.</para>
      </summary>
      <value>
        <para>the additional data related to the obstacle</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">
      <summary>
        <para>A horizontal or vertical <see cref="T:yWorks.Layout.Router.Polyline.Interval" /> that additionally stores a y- (in the horizontal case) or x-coordinate (in the vertical case).</para>
      </summary>
      <remarks>
        <para>During a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />, orthogonal intervals are used for specifying the location where an edge enters or exits a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see>.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PathSearch" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.#ctor(System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" /> instance using the <c>from</c> and <c>to</c> value as interval bounds.</para>
      </summary>
      <param name="from">
        <para>the start of the interval bounds</para>
      </param>
      <param name="to">
        <para>the end of the interval bounds</para>
      </param>
      <param name="location">
        <para>the location in the two-dimensional coordinate system</para>
      </param>
      <param name="isVertical">
        <para>
          <c>true</c> if the orthogonal interval is vertical, <c>false</c> if it is horizontal</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given range is <c>null</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.#ctor(yWorks.Layout.Router.Polyline.Interval,System.Double,System.Boolean)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" /> instance with the given interval bounds.</para>
      </summary>
      <param name="range">
        <para>the given range</para>
      </param>
      <param name="location">
        <para>the location in the two-dimensional coordinate system</para>
      </param>
      <param name="isVertical">
        <para>
          <c>true</c> if the orthogonal interval is vertical, <c>false</c> if it is horizontal</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given range is <c>null</c></para>
      </exception>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.OrthogonalInterval.Vertical">
      <summary>
        <para>Gets whether or not the <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> is oriented vertically.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the orthogonal interval is oriented vertically, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.OrthogonalInterval.Min">
      <summary>
        <para>Gets the lower bound of the <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see>.</para>
      </summary>
      <value>
        <para>the lower bound of the orthogonal interval</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.OrthogonalInterval.Max">
      <summary>
        <para>Gets the upper bound of the <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see>.</para>
      </summary>
      <value>
        <para>the upper bound of the orthogonal interval</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.OrthogonalInterval.Size">
      <summary>
        <para>Gets the length of the <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see>.</para>
      </summary>
      <value>
        <para>the length of the orthogonal interval</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.Interval.Size" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.OrthogonalInterval.Range">
      <summary>
        <para>Gets the range of this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see>.</para>
      </summary>
      <value>
        <para>the range of this orthogonal interval</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.OrthogonalInterval.Location">
      <summary>
        <para>Gets the vertical coordinate for horizontal intervals or the horizontal coordinate for vertical intervals, respectively.</para>
      </summary>
      <value>
        <para>the vertical coordinate for horizontal intervals or the horizontal coordinate for vertical intervals, respectively</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.OrthogonalInterval.Center">
      <summary>
        <para>Gets the center of this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> in the 2D-coordinate system.</para>
      </summary>
      <value>
        <para>the center of this orthogonal interval in the 2D-coordinate system</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.Crosses(yWorks.Layout.Router.Polyline.OrthogonalInterval)">
      <summary>
        <para>Determines whether or not this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> crosses the given one.</para>
      </summary>
      <remarks>
        <para>The orthogonal intervals must have different orientations.</para>
      </remarks>
      <param name="other">
        <para>the other orthogonal interval</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this orthogonal interval crosses the given one, <c>false</c> otherwise</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given orthogonal intervals have the same orientation</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.DistanceTo(yWorks.Layout.Router.Polyline.OrthogonalInterval)">
      <summary>
        <para>Returns the distance of the <see cref="P:yWorks.Layout.Router.Polyline.OrthogonalInterval.Range">ranges</see> of this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> and the given <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see>.</para>
      </summary>
      <remarks>
        <para>The orthogonal intervals must have the same orientation.</para>
      </remarks>
      <param name="other">
        <para>the other orthogonal interval</para>
      </param>
      <returns>
        <para>
          <c>0</c> if the orthogonal intervals <see cref="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.Intersects(yWorks.Layout.Router.Polyline.OrthogonalInterval,System.Double)">intersect</see> each other, otherwise the minimal distance between the orthogonal intervals is returned</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the orthogonal intervals have different orientations</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.ManhattanDistanceTo(yWorks.Layout.Router.Polyline.OrthogonalInterval)">
      <summary>
        <para>Returns the Manhattan distance of this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> and the given <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see>.</para>
      </summary>
      <remarks>
        <para>If both intervals have the same orientation, the Manhattan distance is the sum of the distance between the intervals' ranges and the distance between the intervals' locations.</para>
        <para>If the intervals have different orientations, the Manhattan distance is the sum of the distances between one interval's range and the other interval's location.</para>
      </remarks>
      <param name="other">
        <para>the other orthogonal interval</para>
      </param>
      <returns>
        <para>the Manhattan distance between this interval and the given one</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.Intersects(yWorks.Layout.Router.Polyline.OrthogonalInterval,System.Double)">
      <summary>
        <para>Checks whether or not this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> intersects the given <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> and the intersection has a given minimum intersection size.</para>
      </summary>
      <remarks>
        <para>Orthogonal intervals intersect each other, if their ranges intersect each other by at least the given minimum intersection size. The location of both orthogonal intervals is ignored. The orthogonal intervals must have the same orientation.</para>
      </remarks>
      <param name="other">
        <para>the other orthogonal interval</para>
      </param>
      <param name="minIntersection">
        <para>the minimum size of the intersection</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this interval intersects the given other orthogonal interval, <c>false</c> otherwise</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the orthogonal intervals have different orientations</para>
      </exception>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.CoveredBy(yWorks.Layout.Router.Polyline.OrthogonalInterval)">
      <summary>
        <para>Checks whether or not this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> is fully covered by the given <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see>.</para>
      </summary>
      <remarks>
        <para>The given orthogonal interval covers this orthogonal interval, if this interval's range is covered by the given interval's range. The location of both orthogonal intervals is ignored. The orthogonal intervals must have the same orientation.</para>
      </remarks>
      <param name="other">
        <para>the other orthogonal interval</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this orthogonal interval is fully covered by the other orthogonal interval, <c>false</c> otherwise</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the orthogonal intervals have different orientations</para>
      </exception>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.HasSameRange(yWorks.Layout.Router.Polyline.OrthogonalInterval)">
      <summary>
        <para>Checks whether or not this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> and the given <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal interval</see> cover the same range.</para>
      </summary>
      <remarks>
        <para>If both orthogonal intervals cover the same range, they are considered the same. The location of both orthogonal intervals is ignored. The orthogonal intervals must have the same orientation.</para>
      </remarks>
      <param name="other">
        <para>the other orthogonal interval</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the orthogonal intervals cover the same range, <c>false</c> otherwise</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the orthogonal intervals have different orientations</para>
      </exception>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.CalculateIntersection(yWorks.Layout.Router.Polyline.OrthogonalInterval,yWorks.Layout.Router.Polyline.OrthogonalInterval)">
      <summary>
        <para>Calculates the intersection of the given <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal intervals</see>.</para>
      </summary>
      <remarks>
        <para>If the returned orthogonal interval is vertical, it will have the same horizontal location as <c>i2</c> and the shared vertical range of both intervals. If it is horizontal, it will have the same vertical location as <c>i2</c> and the shared horizontal range of both intervals. The orthogonal intervals must have same orientation.</para>
      </remarks>
      <param name="i1">
        <para>the first orthogonal interval</para>
      </param>
      <param name="i2">
        <para>the second orthogonal interval</para>
      </param>
      <returns>
        <para>the shared orthogonal interval of both given orthogonal intervals</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the orthogonal intervals have different orientations</para>
      </exception>
      <seealso cref="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.Intersects(yWorks.Layout.Router.Polyline.OrthogonalInterval,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.CalculateUnion(yWorks.Layout.Router.Polyline.OrthogonalInterval,yWorks.Layout.Router.Polyline.OrthogonalInterval)">
      <summary>
        <para>Calculates the union of the given <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval">orthogonal intervals</see>.</para>
      </summary>
      <remarks>
        <para>If the returned orthogonal interval is vertical, it will have the same horizontal location as <c>i2</c> and the shared vertical range of both orthogonal intervals. If it is horizontal, it will have the same vertical location as <c>i2</c> and the shared vertical range of both orthogonal intervals. The orthogonal intervals must have same orientation.</para>
      </remarks>
      <param name="i1">
        <para>the first orthogonal interval</para>
      </param>
      <param name="i2">
        <para>the second orthogonal interval</para>
      </param>
      <returns>
        <para>the union of both given orthogonal intervals</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the orthogonal intervals have different orientations</para>
      </exception>
      <seealso cref="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.Intersects(yWorks.Layout.Router.Polyline.OrthogonalInterval,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.OrthogonalInterval.ToString">
      <summary>
        <para>Returns a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" /> object.</para>
      </summary>
      <returns>
        <para>a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" /> object</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PartitionCell">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> represents a rectangular part of a <see cref="T:yWorks.Layout.Router.Polyline.IPartition" /> as result of the decomposition process.</para>
      </summary>
      <remarks>
        <para>Each instance of <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> can hold arbitrary additional information (e.g. what element of the graph is covered by a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />) which can be provided using method <see cref="M:yWorks.Layout.Router.Polyline.PartitionCell.PutData(System.Object,System.Object)" />. Accessing and removing this information can be done using <see cref="M:yWorks.Layout.Router.Polyline.PartitionCell.GetData(System.Object)" /> and <see cref="M:yWorks.Layout.Router.Polyline.PartitionCell.RemoveData(System.Object)" />, respectively.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCellKeys" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.#ctor(yWorks.Algorithms.Geometry.YRectangle,yWorks.Layout.Router.Polyline.IPartition)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> of the given <see cref="T:yWorks.Layout.Router.Polyline.IPartition" /> with the location and the size of the given rectangle.</para>
      </summary>
      <param name="bounds">
        <para>the bounds describing the size and location of the partition cell</para>
      </param>
      <param name="partition">
        <para>the partition to which the partition cell belongs</para>
      </param>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IPartition" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.#ctor(System.Double,System.Double,System.Double,System.Double,yWorks.Layout.Router.Polyline.IPartition)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> instance of the given <see cref="T:yWorks.Layout.Router.Polyline.IPartition" /> with the given bounds.</para>
      </summary>
      <param name="x">
        <para>the x-coordinate of the upper-left corner of the partition cell</para>
      </param>
      <param name="y">
        <para>the y-coordinate of the upper-left corner of the partition cell</para>
      </param>
      <param name="width">
        <para>the width of the partition cell</para>
      </param>
      <param name="height">
        <para>the height of the partition cell</para>
      </param>
      <param name="partition">
        <para>the partition to which the partition cell belongs</para>
      </param>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IPartition" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.PutData(System.Object,System.Object)">
      <summary>
        <para>Stores the additional data associated with the given key for this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <param name="key">
        <para>the key with which the additional data will be associated</para>
      </param>
      <param name="data">
        <para>the additional data</para>
      </param>
      <returns>
        <para>the previous data associated with the given key or <c>null</c> if there was no data associated with the given key</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.GetData(System.Object)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.RemoveData(System.Object)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.ClearData" />
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCellKeys" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.GetData(System.Object)">
      <summary>
        <para>Returns the additional data associated with the given key for this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <param name="key">
        <para>the key whose associated data will be returned</para>
      </param>
      <returns>
        <para>the additional data associated with the given key or <c>null</c> if there is no data associated with the given key</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.PutData(System.Object,System.Object)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.RemoveData(System.Object)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.ClearData" />
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCellKeys" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.RemoveData(System.Object)">
      <summary>
        <para>Removes the additional data associated with the given key for this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <param name="key">
        <para>the key for which the associated data will be removed</para>
      </param>
      <returns>
        <para>the additional data associated with the given key or <c>null</c> if there is no data associated with the given key</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.GetData(System.Object)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.PutData(System.Object,System.Object)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.ClearData" />
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCellKeys" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.ClearData">
      <summary>
        <para>Clears all additional data for this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.GetData(System.Object)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.PutData(System.Object,System.Object)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.RemoveData(System.Object)" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.Partition">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.IPartition">partition</see> to which this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> belongs.</para>
      </summary>
      <value>
        <para>the partition to which this partition cell belongs</para>
      </value>
      <seealso cref="T:yWorks.Layout.Router.Polyline.IPartition" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.Id">
      <summary>
        <para>Gets a unique identifier of this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <value>
        <para>a unique identifier of this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.Bounds">
      <summary>
        <para>Gets the bounds of this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <value>
        <para>the bounds of this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.MinX">
      <summary>
        <para>Gets the x-coordinate of the left border of this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <value>
        <para>the x-coordinate of the left border of this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.MinY">
      <summary>
        <para>Gets the y-coordinate of the upper border of this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <value>
        <para>the y-coordinate of the upper border of this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.MaxX">
      <summary>
        <para>Gets the x-coordinate of the right border of this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <value>
        <para>the x-coordinate of the right border of this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.MaxY">
      <summary>
        <para>Gets the y-coordinate of the bottom border of this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <value>
        <para>the y-coordinate of the bottom border of this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.Width">
      <summary>
        <para>Gets the width of this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <value>
        <para>the width of this partition cell</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.Height">
      <summary>
        <para>Gets the height of this <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <value>
        <para>the height of this partition cell</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.CreateBorderInterval(yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" /> that defines the location, the size and the orientation of the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder" />.</para>
      </summary>
      <remarks>
        <para>The values defining the border are:</para>
        <list type="bullet">
          <item>
            <see cref="F:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.West" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.East" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.North" />
          </item>
          <item>
            <see cref="F:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.South" />
          </item>
        </list>
      </remarks>
      <param name="border">
        <para>a border of this partition cell</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" /> that defines the location, the size and the orientation of the given border</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder" />
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder">
      <summary>
        <para>This class is a type-safe enumeration used for defining the border of a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.CreateBorderInterval(yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder)" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.North">
      <summary>
        <para>A type constant that defines the upper border of a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.CreateBorderInterval(yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder)" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.South">
      <summary>
        <para>A type constant that defines the bottom border of a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.CreateBorderInterval(yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder)" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.East">
      <summary>
        <para>A type constant that defines the right border of a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.CreateBorderInterval(yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder)" />
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.West">
      <summary>
        <para>A type constant that defines the left border of a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PartitionCell.CreateBorderInterval(yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.ValueOfExitDirection(yWorks.Layout.Direction)">
      <summary>
        <para>Returns the type of the border that is passed through when exiting a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> in the given direction.</para>
      </summary>
      <param name="direction">
        <para>the direction in which a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> has been exited</para>
      </param>
      <returns>
        <para>the type of the border that is passed through when exiting a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /></para>
      </returns>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.ValueOfEnterDirection(yWorks.Layout.Direction)">
      <summary>
        <para>Returns the type of the border that is passed through when entering a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> in the given direction.</para>
      </summary>
      <param name="direction">
        <para>the direction in which a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> has been entered</para>
      </param>
      <returns>
        <para>the type of the border that is passed through when entering a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /></para>
      </returns>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.ValueOfPortConstraint(yWorks.Layout.PortConstraint)">
      <summary>
        <para>Returns the type of the border that is defined by the given <see cref="T:yWorks.Layout.PortConstraint" />.</para>
      </summary>
      <remarks>
        <para>The border type corresponds to the <see cref="P:yWorks.Layout.PortConstraint.Side">side</see> of the given <see cref="T:yWorks.Layout.PortConstraint" />.</para>
      </remarks>
      <param name="pc">
        <para>the port constraint for which the border type is returned</para>
      </param>
      <returns>
        <para>the type of the border that is defined by the given port constraint</para>
      </returns>
      <seealso cref="T:yWorks.Layout.PortConstraint" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.ValueOfPortCandidate(yWorks.Layout.PortCandidate)">
      <summary>
        <para>Returns the type of the border that is defined by the given <see cref="T:yWorks.Layout.PortCandidate" />.</para>
      </summary>
      <remarks>
        <para>The border type corresponds to the <see cref="P:yWorks.Layout.PortCandidate.Direction">direction</see> of the given <see cref="T:yWorks.Layout.PortCandidate" />.</para>
      </remarks>
      <param name="pc">
        <para>the port candidate for which the border type is returned</para>
      </param>
      <returns>
        <para>the type of the border that is defined by the given port candidate</para>
      </returns>
      <seealso cref="T:yWorks.Layout.PortCandidate" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PartitionCell.PartitionCellBorder.MirrorBorder">
      <summary>
        <para>Gets the type of the border that is on the opposite side of the border defined by this type.</para>
      </summary>
      <value>
        <para>the type of the border that is on the opposite side of the border defined by this type</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PartitionCellKeys">
      <summary>
        <para>This class defines keys to obtain additional information about a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
      <remarks>
        <para>In order to get the data of the <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> that is associated with the given key, method <see cref="M:yWorks.Layout.Router.Polyline.PartitionCell.GetData(System.Object)" /> should be used.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.NodesKey">
      <summary>
        <para>The key references a <see cref="T:System.Collections.Generic.IList`1" /> of nodes whose bounds are covering a certain <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.NodesInNodeToEdgeDistanceKey">
      <summary>
        <para>The key references a <see cref="T:System.Collections.Generic.IList`1" /> of nodes being in node to edge distance to a certain <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.NodeLabelLayoutsKey">
      <summary>
        <para>The key references a <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:yWorks.Layout.INodeLabelLayout" />s covering a certain <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.NodeLabelCrossingCostFactorsKey">
      <summary>
        <para>The key references a <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:System.Double" /> values representing factors that are multiplied by an edge's <see cref="P:yWorks.Layout.Router.Polyline.PenaltySettings.NodeLabelCrossingPenalty">node label crossing costs</see> in case the edge crosses the corresponding <see cref="T:yWorks.Layout.INodeLabelLayout">node label</see> registered with key <see cref="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.NodeLabelLayoutsKey" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.EdgeLabelLayoutsKey">
      <summary>
        <para>The key references a <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:yWorks.Layout.IEdgeLabelLayout" />s covering a certain <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.EdgeLabelCrossingCostFactorsKey">
      <summary>
        <para>The key references a <see cref="T:System.Collections.Generic.IList`1" /> of <see cref="T:System.Double" /> values representing factors that are multiplied by an edge's <see cref="P:yWorks.Layout.Router.Polyline.PenaltySettings.EdgeLabelCrossingPenalty">edge label crossing costs</see> in case the edge crosses the corresponding <see cref="T:yWorks.Layout.IEdgeLabelLayout">edge label</see> registered with key <see cref="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.EdgeLabelLayoutsKey" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.PartitionGridCellIdKey">
      <summary>
        <para>The key references the <see cref="T:yWorks.Layout.Grid.PartitionCellId" /> of the <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> cell covering a certain <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.PartitionGridRowIndexKey">
      <summary>
        <para>The key references the row index of the <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> cell covering a certain <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PartitionCellKeys.PartitionGridColumnIndexKey">
      <summary>
        <para>The key references the column index of the <see cref="T:yWorks.Layout.Grid.PartitionGrid" /> cell covering a certain <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.Path">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Router.Polyline.Path" /> represents the result of a path search as a list of consecutive <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s.</para>
      </summary>
      <remarks>
        <para>A path starts with a <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> for a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> of the source node and ends with one for a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> of the target node.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.Router.Polyline.PathSearch" />
      <seealso cref="T:yWorks.Layout.Router.Polyline.PathSearchResult" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Path.#ctor(yWorks.Algorithms.Edge,System.Collections.Generic.IList{System.Object},System.Double)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.Path" /> for the given edge, <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance">cell entrances</see> and cost.</para>
      </summary>
      <param name="edge">
        <para>the edge for which the path was calculated</para>
      </param>
      <param name="entrances">
        <para>the list of <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> objects describing the edge path from source node to target node</para>
      </param>
      <param name="cost">
        <para>the overall cost of this path</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Path.Edge">
      <summary>
        <para>Gets the edge for which this path was calculated.</para>
      </summary>
      <value>
        <para>the edge</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.Path.Cost">
      <summary>
        <para>Gets the overall cost of this path.</para>
      </summary>
      <value>
        <para>the overall cost of this path</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Path.GetEntrance(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> at the given position of this path.</para>
      </summary>
      <param name="position">
        <para>the position of the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> to return</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> at the given position of this path</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.Path.SetEntrance(System.Int32,yWorks.Layout.Router.Polyline.CellEntrance)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Path.SetEntrance(System.Int32,yWorks.Layout.Router.Polyline.CellEntrance)">
      <summary>
        <para>Replaces the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> at the given position of this path with the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />.</para>
      </summary>
      <param name="position">
        <para>the position of the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> to replace</para>
      </param>
      <param name="entrance">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> to be stored at the given position</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.Path.GetEntrance(System.Int32)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Path.PositionOf(yWorks.Layout.Router.Polyline.CellEntrance)">
      <summary>
        <para>Returns the position of the first occurrence of the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> in this path, or <c>-1</c> if this path does not contain this <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />.</para>
      </summary>
      <param name="entrance">
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> for which the position is retrieved</para>
      </param>
      <returns>
        <para>the position of the first occurrence of the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> in this path, or <c>-1</c> if this path does not contain this <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.Path.Length">
      <summary>
        <para>Returns the number of <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> objects in this path.</para>
      </summary>
      <returns>
        <para>the number of <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> objects in this path</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PathSearch">
      <summary>
        <para>This is a pathfinding algorithm that calculates the shortest (i.e., the cheapest) paths for a set of edges through a <see cref="T:yWorks.Layout.Router.Polyline.GraphPartition" />.</para>
      </summary>
      <remarks>
        <para>It is based on an <a href="http://en.wikipedia.org/wiki/A*_search_algorithm">A*-algorithm</a> and uses <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" />s as steps between source node and target node.</para>
        <para>In each step, the algorithm takes a <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />, that consists mainly of a <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> and from where it was entered, from a queue with all seen <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s, determines all possible neighbor cells and their enter intervals and enqueues the resulting <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />. To influence the order in which the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s will be processed, the path search assigns real costs (like Dijkstra) as well as heuristic costs (A*-algorithm's heuristic) to the enqueued <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s. The real costs arise from entering a neighbor cell, e.g., a bend has to be created, while the heuristic costs are an estimation of how expensive it will be to reach the target node continuing the path with this neighboring cell. Therefore, the path search prefers searching in the direction in which the target node lies. The <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> with the lowest combined costs is processed next until the target cell is reached.</para>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s modify the path search as they are able to add start entrances and weight them with costs. They also add real and heuristic costs to <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s that are created for the currently entered <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> and calculate shorter enter intervals that are less expensive to pass.</para>
        <para>The algorithm gets a <see cref="T:yWorks.Layout.Router.Polyline.PathSearchContext" /> which provides information about the graph and the currently routed edge. It stores the results of the path search that can then be retrieved calling <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.PathSearchResult" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearch.AddPathSearchExtension(yWorks.Layout.Router.Polyline.PathSearchExtension)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearch.AddAdditionalEnterIntervalCalculator(yWorks.Layout.Router.Polyline.IEnterIntervalCalculator)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.AddPathSearchExtension(yWorks.Layout.Router.Polyline.PathSearchExtension)">
      <summary>
        <para>Adds the given extension to the list of <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s.</para>
      </summary>
      <remarks>
        <para>An extension can influence the pathfinding process by adding costs for entering certain <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s.</para>
      </remarks>
      <param name="extension">
        <para>the extension to add to this path search</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the extension has been added, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.RemovePathSearchExtension(yWorks.Layout.Router.Polyline.PathSearchExtension)">
      <summary>
        <para>Removes the given extension from the list of <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s.</para>
      </summary>
      <param name="extension">
        <para>the extension to remove from the path search</para>
      </param>
      <returns>
        <para>
          <c>true</c> if an extension was removed as a result of this call, <c>false</c> if the given extension was not contained in the list</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.AddAdditionalEnterIntervalCalculator(yWorks.Layout.Router.Polyline.IEnterIntervalCalculator)">
      <summary>
        <para>Adds a new interval calculator to the list of registered <see cref="T:yWorks.Layout.Router.Polyline.IEnterIntervalCalculator" />s.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.IEnterIntervalCalculator" />s may add <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s with narrowed intervals to the queue. The interval is more specific and will be judged with lower costs.</para>
      </remarks>
      <param name="enterIntervalCalculator">
        <para>the calculator to add</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the calculator was successfully added, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.RemoveAdditionalEnterIntervalCalculator(yWorks.Layout.Router.Polyline.IEnterIntervalCalculator)">
      <summary>
        <para>Removes the given interval calculator from the list of registered <see cref="T:yWorks.Layout.Router.Polyline.IEnterIntervalCalculator" />s.</para>
      </summary>
      <param name="enterIntervalCalculator">
        <para>the calculator to remove</para>
      </param>
      <returns>
        <para>
          <c>true</c> if an interval calculator was removed as a result of this call, <c>false</c> if the given calculator was not part of the list</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.Init(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Initializes the fields of this <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />.</para>
      </summary>
      <remarks>
        <para>This method also calls <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)" /> for all registered path search extensions.</para>
      </remarks>
      <param name="configuration">
        <para>the configuration that the path search shall use</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.Clear">
      <summary>
        <para>Resets all registered <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s and <see cref="T:yWorks.Algorithms.Util.DataProviders" /> added to this <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />.</para>
      </summary>
      <remarks>
        <para>So, <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> is ready to calculate paths for a new layout.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CleanUp" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.GetFinalizedPath(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the path for the given edge if it has already been finalized.</para>
      </summary>
      <remarks>
        <para>The path is finalized if the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> chose it as the best result for the edge.</para>
      </remarks>
      <param name="edge">
        <para>the edge for which the path is returned</para>
      </param>
      <returns>
        <para>the finalized path for the given edge or <c>null</c> if no path has been found and finalized</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.FindPathsForCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Finds the path for the current edge in the given context.</para>
      </summary>
      <remarks>
        <para>This method:</para>
        <list type="bullet">
          <item>Calls <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" /> for all extensions.</item>
          <item>Collects and enqueues all start entrances.</item>
          <item>Iteratively processes the next cheapest cell entrance and</item>
          <item>Calls <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" /> for all extensions.</item>
        </list>
        <para>It is called by <see cref="M:yWorks.Layout.Router.Polyline.PathSearch.FindPaths(yWorks.Layout.Router.Polyline.PathSearchContext)" /> and may be overridden to skip certain edges or implement a custom path search.</para>
      </remarks>
      <param name="context">
        <para>the context information needed for finding a path</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.DecreasePenaltySettings(yWorks.Layout.Router.Polyline.PenaltySettings,System.Double,yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Decreases the given penalty settings for the current edge.</para>
      </summary>
      <remarks>
        <para>If finding a path for the current edge takes too long according to the <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.MaximumDuration">maximum duration</see> of the <see cref="T:yWorks.Layout.Router.Polyline.EdgeRouter">edge routing algorithm</see>, the path search for the current edge is canceled and restarted using decreased penalties. The <c>decreaseFactor</c> indicates, how much the penalties shall be reduced.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.PathSearch.FindPathsForCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" />. If overriding this method, note that the penalty for creating bends should not be reduced as this results in more possible turns of the edge path and, therefore, a longer runtime of the path search. Furthermore, not all penalties should be decreased equally as these decreases would neutralize each other.</para>
        <para>The <c>decreaseFactor</c> takes values from <c>[0,1]</c>, where <c>0</c> means no reduction while <c>1</c> means the strongest reduction.</para>
      </remarks>
      <param name="penaltySettings">
        <para>the penalty settings whose penalties shall be reduced</para>
      </param>
      <param name="decreaseFactor">
        <para>the factor with values between <c>0</c> and <c>1</c> that indicates how strong to reduce the penalties</para>
      </param>
      <param name="context">
        <para>the context information of the current path search</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.FindPaths(yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Finds paths for the edges in the given context and stores them in its <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.PathSearchResult">PathSearchResult</see>.</para>
      </summary>
      <remarks>
        <para>This is the main method of <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />.</para>
        <para>It initializes its extensions using <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" /> and delegates the path search for each edge to <see cref="M:yWorks.Layout.Router.Polyline.PathSearch.FindPathsForCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" />.</para>
        <para>The path calculations for all edges are finalized by calling the extensions' <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" /> method and, after that, the path search result is filled with the path for each edge.</para>
        <para>At last, the extensions are asked to finalize the path search result using their <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizePathSearchResult(yWorks.Layout.Router.Polyline.PathSearchResult)" /> callback.</para>
      </remarks>
      <param name="context">
        <para>the context to use during the path search</para>
      </param>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.Edges" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.PathSearchResult" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.FinalizePath(yWorks.Layout.Router.Polyline.Path)">
      <summary>
        <para>Informs all registered path search extensions about completing a path by calling their <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizePath(yWorks.Layout.Router.Polyline.Path)">finalizePath(Path)</see> method.</para>
      </summary>
      <remarks>
        <para>That way, extensions can collect data about this path to use it later during path search.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Router.Polyline.PathSearch.FindPathsForCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" /> and may be overridden to use a custom finalization step.</para>
      </remarks>
      <param name="path">
        <para>the path to finalize</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.HandleNeighbor(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Adds <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s for every interval through which the neighboring cell can be entered from the current entrance to the queue.</para>
      </summary>
      <remarks>
        <para>The algorithm calls this method in every step for each neighbor of the current cell to collect all next possible entrances for the current path. This path consists of several entrances where each knows the entrance through which it has been entered.</para>
        <para>After calculating all possible enter intervals to the given neighboring cell, each interval gets rated with costs. If there is already an entrance for the neighboring cell whose interval is the same with one of these intervals, this entrance will be used and re-enqueued, so that the path search can still reach it. The current entrance is set as its predecessor within the current path and its enter interval and costs will be updated.</para>
        <para>If there is an entrance for the neighboring cell whose interval is intersected by a current interval, new entrances will be created with the new enter intervals and enqueued. The same happens if there is no entrance that has been matched with one of the current intervals, yet. Costs will be added. If there are some entries afterwards that are intersected by the current interval and have higher costs, they will be removed from the queue.</para>
        <para>This method is called during cost calculation. It may be overridden to change the interval handling for the <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s.</para>
      </remarks>
      <param name="currentEntrance">
        <para>the current cell entrance</para>
      </param>
      <param name="neighborCell">
        <para>the neighboring cell that is handled.</para>
      </param>
      <param name="context">
        <para>the context information</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearch.CalculateCosts(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.OrthogonalInterval[],yWorks.Layout.Router.Polyline.EdgeCellInfo[],yWorks.Layout.Router.Polyline.PathSearchContext,System.Double[],System.Double[])" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearch.CalculateHeuristicCosts(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PathSearchContext)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.CalculateCosts(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.OrthogonalInterval[],yWorks.Layout.Router.Polyline.EdgeCellInfo[],yWorks.Layout.Router.Polyline.PathSearchContext,System.Double[],System.Double[])">
      <summary>
        <para>Calculates the costs for moving from the current <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> to the neighboring <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> using different enter intervals.</para>
      </summary>
      <remarks>
        <para>It is called by <see cref="M:yWorks.Layout.Router.Polyline.PathSearch.HandleNeighbor(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.PathSearchContext)" /> to determine the costs for all <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s that it will create and enqueue afterwards.</para>
        <para>The costs for the given enter intervals are retrieved from all registered <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s. The calculation stops when it reaches the given maximum cost value.</para>
      </remarks>
      <param name="currentEntrance">
        <para>the current cell entrance</para>
      </param>
      <param name="enteredCell">
        <para>the partition cell to enter</para>
      </param>
      <param name="enterIntervals">
        <para>the different entering intervals of the entered cell</para>
      </param>
      <param name="lastEdgeCellInfos">
        <para>the information about how the last cell was crossed</para>
      </param>
      <param name="context">
        <para>the context information</para>
      </param>
      <param name="costs">
        <para>the array in which the calculated costs for entering the neighbor cell via the according enter intervals shall be written</para>
      </param>
      <param name="maxAllowedCosts">
        <para>the maximum costs an enter interval may induce. If this cost is exceeded, no further additional costs for this interval are calculated. Note that the entries in this array get modified during cost calculation</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CalculateCosts(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.OrthogonalInterval,yWorks.Layout.Router.Polyline.EdgeCellInfo,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearch.CalculateHeuristicCosts(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Returns the estimated costs for the rest of the path when using the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> for the next step in the path search.</para>
      </summary>
      <remarks>
        <para>It is called by <see cref="M:yWorks.Layout.Router.Polyline.PathSearch.HandleNeighbor(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.PathSearchContext)" /> to determine the heuristic part of the costs with which the entrance will be enqueued.</para>
        <para>The heuristic costs for the given entrance are retrieved from all registered <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s.</para>
      </remarks>
      <param name="entrance">
        <para>the current entrance</para>
      </param>
      <param name="context">
        <para>the context information</para>
      </param>
      <returns>
        <para>the heuristic costs for the rest of the path if the given entrance is used</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CalculateHeuristicCosts(yWorks.Layout.Router.Polyline.CellEntrance)" />
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration">
      <summary>
        <para>This class contains the basic configuration used by path search algorithms.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchConfiguration.#ctor(yWorks.Layout.LayoutGraph,yWorks.Layout.Grouping.GroupingSupport,yWorks.Layout.Router.Polyline.EdgeRouter)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.PathSearchConfiguration" /> used for a path search.</para>
      </summary>
      <param name="graph">
        <para>the graph containing the edges whose path will be searched</para>
      </param>
      <param name="grouping">
        <para>the grouping information of the graph</para>
      </param>
      <param name="edgeRouter">
        <para>the edge routing algorithm using this configuration</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchConfiguration.Graph">
      <summary>
        <para>Gets the graph containing the edges whose path is searched.</para>
      </summary>
      <value>
        <para>the current graph</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchConfiguration.Grouping">
      <summary>
        <para>Gets the grouping information of the graph.</para>
      </summary>
      <value>
        <para>the grouping information of the graph</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchConfiguration.EdgeRouter">
      <summary>
        <para>Gets the edge routing algorithm using this configuration.</para>
      </summary>
      <value>
        <para>the edge routing algorithm using this configuration</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchConfiguration.RemainingTime">
      <summary>
        <para>Gets the remaining time (in milliseconds) within which the algorithm should complete its calculation.</para>
      </summary>
      <value>
        <para>the remaining time for the calculation</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PathSearchContext">
      <summary>
        <para>This class provides context information that is useful for the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> algorithm.</para>
      </summary>
      <remarks>
        <para>Most notably, the context provides access to the edge that is currently being routed (see <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge" />).</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.#ctor(yWorks.Layout.Router.Polyline.PathSearch,yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.PathSearchContext" />.</para>
      </summary>
      <param name="pathSearch">
        <para>the path search that uses this context</para>
      </param>
      <param name="configuration">
        <para>the configuration used for the path search</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchContext.PathSearch">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> that uses this context.</para>
      </summary>
      <value>
        <para>the path search that uses this context</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchContext.Configuration">
      <summary>
        <para>Gets the configuration used for the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />.</para>
      </summary>
      <value>
        <para>the configuration used for the path search</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchContext.Edges">
      <summary>
        <para>Gets the <see cref="T:yWorks.Algorithms.IEdgeCursor" /> to iterate over the edges that are routed.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IEdgeCursor" /> to iterate over the edges for which a path is calculated</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.SetEdges(yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Specifies the edges that shall be routed.</para>
      </summary>
      <param name="edges">
        <para>the list of edges that shall be routed</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">
      <summary>
        <para>Gets or sets the edge that is currently routed.</para>
      </summary>
      <remarks>
        <para>This edge is one of those returned by <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.Edges" />.</para>
      </remarks>
      <value>
        <para>the edge that is currently routed</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdgeLayoutDescriptor">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor" /> for the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see> containing edge specific settings for the path search.</para>
      </summary>
      <value>
        <para>the descriptor for the current edge</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.SourceCellCount">
      <summary>
        <para>Returns the number of all cells that are covered by the source node of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see>.</para>
      </summary>
      <returns>
        <para>the number of all cells that are covered by the source node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.AddSourceCell(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Adds an additional source cell of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see> if it is not already contained in the list of source cells.</para>
      </summary>
      <param name="cell">
        <para>the new source cell to add</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.SourceCellCount" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.GetSourceCell(System.Int32)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.GetSourceCell(System.Int32)">
      <summary>
        <para>Returns the source cell with the given index in the list of all cells that are covered by the source node of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see>.</para>
      </summary>
      <param name="index">
        <para>the index of the source cell</para>
      </param>
      <returns>
        <para>the source cell with the given index in the list of all source cells</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.IsSourceCell(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Determines whether or not the given cell is a source cell of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see>.</para>
      </summary>
      <param name="cell">
        <para>the cell</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given cell is in the list of source cells, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.SourceCellCount" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.GetSourceCell(System.Int32)" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchContext.CombinedSourceCell">
      <summary>
        <para>Gets an artificial <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> with the size of the bounding box of all source cells of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see>.</para>
      </summary>
      <value>
        <para>an artificial partition cell with the size of the bounding box of all source cells</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.GetSourceCell(System.Int32)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.TargetCellCount">
      <summary>
        <para>Returns the number of all cells that are covered by the target node of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see>.</para>
      </summary>
      <returns>
        <para>the number of all cells that are covered by the target node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.AddTargetCell(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Adds an additional target cell of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see> if it is not already contained in the list of target cells.</para>
      </summary>
      <param name="cell">
        <para>the new target cell to add</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.TargetCellCount" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.GetTargetCell(System.Int32)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.GetTargetCell(System.Int32)">
      <summary>
        <para>Returns the target cell with the given index in the list of all cells that are covered by the target node of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see>.</para>
      </summary>
      <param name="index">
        <para>the index of the target cell</para>
      </param>
      <returns>
        <para>the target cell with the given index in the list of all cells that are covered by the target node of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchContext.IsTargetCell(yWorks.Layout.Router.Polyline.PartitionCell)">
      <summary>
        <para>Determines whether or not the given cell is a target cell of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see>.</para>
      </summary>
      <param name="cell">
        <para>the cell</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given cell is in the list of target cells, <c>false</c> otherwise</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.TargetCellCount" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.GetTargetCell(System.Int32)" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchContext.CombinedTargetCell">
      <summary>
        <para>Gets an artificial <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell">partition cell</see> with the size of the bounding box of all target cells of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge">current edge</see>.</para>
      </summary>
      <value>
        <para>an artificial partition cell with the size of the bounding box of all target cells</para>
      </value>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchContext.GetTargetCell(System.Int32)" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchContext.PathSearchResult">
      <summary>
        <para>Gets the results of the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />.</para>
      </summary>
      <value>
        <para>the results of the path search</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PathSearchExtension">
      <summary>
        <para>Extensions are added to a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> to influence the search process.</para>
      </summary>
      <remarks>
        <para>An extension contains several callback methods that are used by the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> to, e.g., calculate the costs for the next possible steps (i.e., entering the next partition cell) and to decide when the target is reached.</para>
        <para>The <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> uses the callbacks in the following order:</para>
        <list type="number">
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.AppendStartEntrances(System.Collections.Generic.IList{System.Object})" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CalculateStartEntranceCost(yWorks.Layout.Router.Polyline.CellEntrance)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CalculateCosts(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.OrthogonalInterval,yWorks.Layout.Router.Polyline.EdgeCellInfo,System.Double)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CalculateHeuristicCosts(yWorks.Layout.Router.Polyline.CellEntrance)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.IsValidTargetEntrance(yWorks.Layout.Router.Polyline.CellEntrance)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizePath(yWorks.Layout.Router.Polyline.Path)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" /> or <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CancelCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" /></item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizePathSearchResult(yWorks.Layout.Router.Polyline.PathSearchResult)" />
          </item>
          <item>
            <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CleanUp" />
          </item>
        </list>
      </remarks>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearch.AddPathSearchExtension(yWorks.Layout.Router.Polyline.PathSearchExtension)" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchExtension.Configuration">
      <summary>
        <para>Gets the configuration used for the path search.</para>
      </summary>
      <remarks>
        <para>This property is initialized in <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)" />.</para>
      </remarks>
      <value>
        <para>the configuration used for the path search</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PathSearchExtension.Context">
      <summary>
        <para>Gets the current context of the path search.</para>
      </summary>
      <remarks>
        <para>This property is initialized in <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" />.</para>
      </remarks>
      <value>
        <para>the current context of the path search</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.Initialize(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Initializes this extension for path searches using the given configuration.</para>
      </summary>
      <remarks>
        <para>This method is the first one to be called by the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />. It may be overridden to initialize this extension with necessary settings like <see cref="T:yWorks.Layout.Grouping.GroupingSupport" />.</para>
      </remarks>
      <param name="configuration">
        <para>the configuration to use for the following path searches</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Initializes this extension with the context that contains the list of edges for which paths are calculated.</para>
      </summary>
      <remarks>
        <para>This method may be called several times during a path search. Each call will be balanced by calls to <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" /> and <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizePathSearchResult(yWorks.Layout.Router.Polyline.PathSearchResult)" />.</para>
        <para>It may be overridden to initialize/reset the settings for the routed edges (e.g. minimum distances).</para>
      </remarks>
      <param name="context">
        <para>the context containing the list of edges for which paths shall be found</para>
      </param>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.Edges" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Initializes this extension with the current edge set in the given context.</para>
      </summary>
      <remarks>
        <para>This method is called for each edge of the <see cref="P:yWorks.Layout.Router.Polyline.PathSearchExtension.Context">context</see>. Each call will be balanced by a call to either <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" /> or <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CancelCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" />.</para>
        <para>It may be overridden to initialize/reset the settings for the current edge (e.g. minimum distances).</para>
      </remarks>
      <param name="context">
        <para>the context containing the current edge</para>
      </param>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.AppendStartEntrances(System.Collections.Generic.IList{System.Object})">
      <summary>
        <para>Appends additional start <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance">entrances</see> for the path search of the current edge to the given list of all previously generated entrances.</para>
      </summary>
      <remarks>
        <para>This method is called before starting the actual path search to determine possible starting points. The current implementation doesn't add any <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s. It may be overridden to add <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s with specific enter intervals, e.g., to consider <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
      </remarks>
      <param name="allStartEntrances">
        <para>a list of all previously generated entrances</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CalculateStartEntranceCost(yWorks.Layout.Router.Polyline.CellEntrance)">
      <summary>
        <para>Returns the cost for starting the path in the given entrance.</para>
      </summary>
      <remarks>
        <para>This method is called for each start entrance of the current edge.</para>
        <para>The current implementation doesn't add any costs for the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />. It may be overridden to make start entrances with less specific intervals more expensive. For example, intervals that allow more than just the <see cref="T:yWorks.Layout.PortConstraint" /> location to connect to the source node become more expensive.</para>
      </remarks>
      <param name="startEntrance">
        <para>the start entrance for which the cost is calculated</para>
      </param>
      <returns>
        <para>the cost for starting the path in the given entrance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CalculateCosts(yWorks.Layout.Router.Polyline.CellEntrance,yWorks.Layout.Router.Polyline.PartitionCell,yWorks.Layout.Router.Polyline.OrthogonalInterval,yWorks.Layout.Router.Polyline.EdgeCellInfo,System.Double)">
      <summary>
        <para>Calculates the costs for entering the given <see cref="T:yWorks.Layout.Router.Polyline.PartitionCell" /> via the given enter <see cref="T:yWorks.Layout.Router.Polyline.OrthogonalInterval" />.</para>
      </summary>
      <remarks>
        <para>The given <see cref="T:yWorks.Layout.Router.Polyline.EdgeCellInfo" /> describes how the partition cell that has been entered by the current entrance would be traversed if this enter interval to the neighboring cell would be chosen.</para>
        <para>The <c>maxAllowedCosts</c> describe the maximum costs that entering the neighboring cell via the given enter interval may induce. If the maximum cost is exceeded, calculations that may further increase its cost may be skipped because this interval won't be chosen anyway.</para>
        <para>This implementation doesn't add any costs. It may be overridden to add costs, e.g., if entering through the given interval would create a bend.</para>
      </remarks>
      <param name="currentEntrance">
        <para>the entrance that was used for entering the current cell</para>
      </param>
      <param name="enteredCell">
        <para>the neighboring cell that shall be entered</para>
      </param>
      <param name="enterInterval">
        <para>the interval that shall be used for entering the neighboring cell</para>
      </param>
      <param name="edgeCellInfo">
        <para>the information about how the current cell would be traversed if the neighboring cell would be entered by this enter interval</para>
      </param>
      <param name="maxAllowedCosts">
        <para>the maximum allowed costs for this enter interval</para>
      </param>
      <returns>
        <para>the costs for entering the neighboring cell via the enter interval</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CalculateHeuristicCosts(yWorks.Layout.Router.Polyline.CellEntrance)">
      <summary>
        <para>Calculates the heuristic costs for the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> that describe the minimal costs that will arise to finish the path if the given cell entrance is used as next step.</para>
      </summary>
      <remarks>
        <para>After evaluating the costs for each enter interval to a neighboring cell, this method is called for each of the resulting <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s.</para>
        <para>This implementation doesn't add any costs. It may be overridden to add some heuristic costs, e.g., if the edge would have to bend to reach the target node from the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />.</para>
      </remarks>
      <param name="entrance">
        <para>the entrance to calculate the heuristic costs for the rest of the path</para>
      </param>
      <returns>
        <para>the minimal costs that will arise to finish the path if the given cell entrance is used as next step</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.IsValidTargetEntrance(yWorks.Layout.Router.Polyline.CellEntrance)">
      <summary>
        <para>Determines whether or not this extension considers the given <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> as a valid target entrance, i.e., the path may end with the given entrance.</para>
      </summary>
      <remarks>
        <para>Each time a <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" /> is chosen as next step, all registered extensions are asked if this entrance is a valid target entrance. Only if none of the extensions returns <c>false</c>, a <see cref="T:yWorks.Layout.Router.Polyline.Path" /> is created.</para>
        <para>This implementation accepts all <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />s as valid targets. It may be overridden to only activate the target if the route fulfills a certain condition.</para>
      </remarks>
      <param name="entrance">
        <para>the entrance to decide if it is a valid target entrance</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the path may end with this entrance, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizePath(yWorks.Layout.Router.Polyline.Path)">
      <summary>
        <para>After finding a valid target entrance and creating a <see cref="T:yWorks.Layout.Router.Polyline.Path" />, the extension is notified of the found path.</para>
      </summary>
      <remarks>
        <para>If the path search is configured to calculate several possible paths for an edge, the path search proceeds with choosing another unhandled <see cref="T:yWorks.Layout.Router.Polyline.CellEntrance" />.</para>
        <para>This implementation does nothing. It may be overridden to collect some information about the given path that may influence the path search of later edges.</para>
      </remarks>
      <param name="path">
        <para>the path found for the current edge in the context</para>
      </param>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.CurrentEdge" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CancelCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Handles the cancellation of the path search for the current edge.</para>
      </summary>
      <remarks>
        <para>This callback notifies the extension when the path search for the current edge is canceled. Then, the path search will proceed with altering the penalties of the current edge and reinitializing it again.</para>
        <para>This implementation does nothing. It may be overridden to reset some edge specific information, e.g., removing previously added listeners.</para>
      </remarks>
      <param name="context">
        <para>the context containing the current edge for which the path search has been canceled</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Handles the completion of the path search for the current edge.</para>
      </summary>
      <remarks>
        <para>This callback notifies the extension when enough paths are found for the current edge. After that, the path search either proceeds with initializing the next current edge in the context's edge list or calls <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" /> if all edges in this list have been handled.</para>
        <para>This implementation does nothing. It may be overridden to add/reset some edge specific information, e.g., removing previously added listeners or adding new start entrances.</para>
      </remarks>
      <param name="context">
        <para>the context containing the current edge for which the path search has been finished</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeCurrentEdge(yWorks.Layout.Router.Polyline.PathSearchContext)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)">
      <summary>
        <para>Handles the completion of all marked edges.</para>
      </summary>
      <remarks>
        <para>This callback notifies the extension if enough paths have been found for all edges in the context's edge list.</para>
      </remarks>
      <param name="context">
        <para>the context containing the list of edges for which paths have been found</para>
      </param>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PathSearchContext.Edges" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizePathSearchResult(yWorks.Layout.Router.Polyline.PathSearchResult)">
      <summary>
        <para>Completes the path search result.</para>
      </summary>
      <remarks>
        <para>This callback notifies the extensions of the paths chosen for the edges in the current context. After calling <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.FinalizeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)">finalizeEdges</see>, the <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> decides, which of the found paths to use for each edge and adds them to the <see cref="T:yWorks.Layout.Router.Polyline.PathSearchResult" />.</para>
        <para>With this callback, the registered extensions are notified of this result before the path search either initializes the next list of edges to route or ends the path search by calling <see cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CleanUp" />. This implementation does nothing.</para>
      </remarks>
      <param name="pathSearchResult">
        <para>the path search result for the edge in the current context's edge list</para>
      </param>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.InitializeEdges(yWorks.Layout.Router.Polyline.PathSearchContext)" />
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CleanUp" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchExtension.CleanUp">
      <summary>
        <para>Cleans up the extension from the path searches with the current <see cref="P:yWorks.Layout.Router.Polyline.PathSearchExtension.Configuration">configuration</see> and <see cref="P:yWorks.Layout.Router.Polyline.PathSearchExtension.Context">context</see>.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PathSearchResult">
      <summary>
        <para>This class manages the best <see cref="T:yWorks.Layout.Router.Polyline.Path" />s found for each edge and provides according <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" />s.</para>
      </summary>
      <remarks>
        <para>These are used by the <see cref="T:yWorks.Layout.Router.Polyline.ChannelBasedPathRouting" /> algorithm to calculate the final segment locations for the segments of an edge path.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchResult.#ctor(yWorks.Layout.Router.Polyline.PathSearchConfiguration)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.PathSearchResult" />.</para>
      </summary>
      <param name="configuration">
        <para>the configuration used for the path search</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchResult.GetEdgeInfo(yWorks.Layout.Router.Polyline.Path)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> for the given path.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> has been created for this path by this context before, a new one is instantiated, otherwise the stored one is returned.</para>
      </remarks>
      <param name="path">
        <para>the path for which the <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> will be returned</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> describing the given path</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchResult.GetEdgeInfo(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns an <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> for the given edge.</para>
      </summary>
      <remarks>
        <para>If the given edge shall be routed but no path has been set for it, yet, <c>null</c> is returned. If no <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> has been created for the path by this context before, a new one is instantiated, otherwise the stored one is returned.</para>
      </remarks>
      <param name="edge">
        <para>the edge for which the <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> will be returned</para>
      </param>
      <returns>
        <para>an <see cref="T:yWorks.Layout.Router.Polyline.EdgeInfo" /> describing the path of the edge</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Router.Polyline.PathSearchResult.SetPath(yWorks.Algorithms.Edge,yWorks.Layout.Router.Polyline.Path)" />
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchResult.SetPath(yWorks.Algorithms.Edge,yWorks.Layout.Router.Polyline.Path)">
      <summary>
        <para>Specifies a found path for an edge.</para>
      </summary>
      <param name="edge">
        <para>the edge for which the path is set</para>
      </param>
      <param name="path">
        <para>the found path</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PathSearchResult.GetPath(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the previously registered path found for the edge.</para>
      </summary>
      <param name="edge">
        <para>the edge for which the path is provided</para>
      </param>
      <returns>
        <para>the previously registered path found for the edge or <c>null</c> if no path has been registered, yet</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PenaltySettings">
      <summary>
        <para>This class provides the cost penalties that are applied for violating restrictions during a <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> calculates the <em>shortest</em> path from the source to the target, where <em>shortest</em> path means the path with the lowest costs. Costs result from violations of restrictions that are defined by the different <see cref="T:yWorks.Layout.Router.Polyline.PathSearchExtension" />s. This class defines penalties for the various violations. The <see cref="T:yWorks.Layout.Router.Polyline.PathSearch" /> can be adapted to specific needs by varying these penalties. In order to avoid a certain violation, the appropriate penalty must be increased.</para>
        <para>There are some predefined penalty settings which set a different focus for the path search: <see cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationBalanced" />, <see cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeBends" />, <see cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeLengths" /> and <see cref="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeCrossings" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationBalanced">
      <summary>
        <para>Optimization strategy that balances bends and edge crossings in the edge routes.</para>
      </summary>
      <remarks>
        <para>By default, this strategy is used for the path search.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeBends">
      <summary>
        <para>Optimization strategy that minimizes bends in the edge routes.</para>
      </summary>
      <remarks>
        <para>Edges may cross other edges to prevent bends occurring around them.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeCrossings">
      <summary>
        <para>Optimization strategy that minimizes edge crossings in the edge routes.</para>
      </summary>
      <remarks>
        <para>This may cause more bends.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Router.Polyline.PenaltySettings.OptimizationEdgeLengths">
      <summary>
        <para>Optimization strategy that minimizes the length of the edge routes.</para>
      </summary>
      <remarks>
        <para>In consequence, there may be more edge crossings.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PenaltySettings.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.PenaltySettings" />.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.EdgeLengthPenalty">
      <summary>
        <para>Gets or sets the penalty for the edge length.</para>
      </summary>
      <remarks>
        <para>This penalty will make long routes more expensive than short routes so edges will preferably be kept short.</para>
        <para>Increasing the edge length penalty will raise the importance of short edges in relation to all other penalties while decreasing this penalty will raise the importance of all other restrictions. A high edge length penalty will result in routes that have less bends and more edge crossings to maintain the edge as short as possible.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.BendPenalty">
      <summary>
        <para>Gets or sets the penalty for an edge bend.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes with many bends more expensive than routes with few or no bends. Hence, edges will have preferably few bends.</para>
        <para>Increasing bend penalty will raise the importance of avoiding bends in relation to other penalties while decreasing this penalty will raise the importance of all other restrictions. A high bend penalty will result in routes that will preferably cross other edges instead of bending to avoid other edges. When increasing the edge bend penalty, the resulting routes will have more edge crossings.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.EdgeCrossingPenalty">
      <summary>
        <para>Gets or sets the penalty for a crossing of two edges.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that cross many other edges more expensive than routes that cross few other edges or no edges at all. Hence, edges preferably won't cross other edges.</para>
        <para>Increasing the edge crossing penalty will raise the importance of avoiding edge crossings in relation to other penalties, while decreasing this penalty will raise the importance of all other restrictions. When increasing the edge crossing penalty, the resulting route will be longer and have more bends because crossing other edges needs to be avoided.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.NodeCrossingPenalty">
      <summary>
        <para>Gets or sets the penalty for an edge crossing a regular node.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that cross normal nodes more expensive than routes that avoid crossing nodes. Hence, edges won't preferably cross any nodes.</para>
        <para>Increasing the node crossing penalty will raise the importance of avoiding node crossings in relation to other penalties, while decreasing this penalty will raise the importance of all other restrictions.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.GroupNodeCrossingPenalty">
      <summary>
        <para>Gets or sets the penalty for an edge crossing a group node.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that cross group nodes more expensive than routes that avoid crossing group nodes. Hence, edges won't preferably cross any group nodes.</para>
        <para>Increasing the group node crossing penalty will raise the importance of avoiding group node crossings in relation to other penalties, while decreasing this penalty will raise the importance of all other restrictions.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.NodeLabelCrossingPenalty">
      <summary>
        <para>Gets or sets the penalty for an edge crossing a node label.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that cross node labels more expensive than routes that avoid crossing node labels. Hence, edges won't preferably cross any node labels.</para>
        <para>Increasing the node label crossing penalty will raise the importance of avoiding node labels crossings in relation to other penalties, while decreasing this penalty will raise the importance of all other restrictions. A high label crossing penalty will cause edges to bend more often to avoid passing straight through labels.</para>
        <para>The crossing penalty can be weighted for each label individually using the <see cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.LabelCrossingPenaltyFactorDpKey" />.</para>
        <para>Use <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.ConsiderNodeLabels" /> to set whether node labels should be considered when routing the edges.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.ConsiderNodeLabels" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.EdgeLabelCrossingPenalty">
      <summary>
        <para>Gets or sets the penalty for an edge crossing an edge label.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that cross edge labels of fixed edges more expensive than routes that avoid crossing edge labels, so edges won't preferably cross any edge labels that belong to fixed edges.</para>
        <para>Increasing the edge label crossing penalty will raise the importance of avoiding edge labels crossings in relation to other penalties, while decreasing this penalty will raise the importance of all other restrictions. A high label crossing penalty will cause edges to bend more often to avoid passing straight through labels.</para>
        <para>The crossing penalty can be weighted for each label individually using the <see cref="F:yWorks.Layout.Router.Polyline.EdgeRouter.LabelCrossingPenaltyFactorDpKey" />.</para>
        <para>Use <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.ConsiderEdgeLabels" /> to set whether edge labels should be considered when routing the edges.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.ConsiderEdgeLabels" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.MinimumNodeToEdgeDistancePenalty">
      <summary>
        <para>Gets or sets the penalty for violations of the minimum distance between any edge and any normal node side.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that pass too close to normal nodes more expensive than routes that maintain the specified minimum node to edge distance.</para>
        <para>Increasing the minimum node to edge distance penalty will raise the importance of maintaining the minimum distance to nodes, while decreasing this penalty will raise the importance of all other restrictions. A high penalty for violating the minimum distance between edges and nodes will produce edges that rather use a long route around nodes to maintain the specified distance than pass through a small channel between two nodes.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.MinimumNodeToEdgeDistance" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.MinimumGroupNodeToEdgeDistancePenalty">
      <summary>
        <para>Gets or sets the penalty for violations of the minimum distance between any edge and any group node side.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that pass group nodes too close more expensive than routes that maintain the specified minimum node to edge distance.</para>
        <para>Increasing the minimum group node to edge distance penalty will raise the importance of maintaining the minimum distance to group nodes, while decreasing this penalty will raise the importance of all other restrictions. A high penalty for violating the minimum distance between edges and group nodes will produce edges that rather use a long route around group nodes to maintain the specified distance than pass through a small channel between two group nodes.</para>
        <para>Use <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.MinimumNodeToEdgeDistance" /> to set the minimum distance.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.MinimumNodeToEdgeDistance" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.MinimumEdgeToEdgeDistancePenalty">
      <summary>
        <para>Gets or sets the penalty for violations of the minimum distance between any two edges.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that pass other edges too close more expensive than routes that maintain the specified minimum edge to edge distance.</para>
        <para>Increasing the minimum edge to edge distance penalty will raise the importance of maintaining the minimum distance to other edges, while decreasing this penalty will raise the importance of all other restrictions. When this penalty has a high value, edges will maintain the specified distance. This may also reduce the number of edges that pass through a small channel between nodes. So, if such a channel is part of the shortest routes for many edges, some of them will take a longer way.</para>
        <para>Use <see cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumEdgeToEdgeDistance" /> to set the minimum distance for a certain edge to any other edge.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumEdgeToEdgeDistance" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.MinimumNodeCornerDistancePenalty">
      <summary>
        <para>Gets or sets the penalty for violations of the minimum distance the edge shall maintain from node corners when entering or leaving the node.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that end too close to the corner of their source or target node more expensive than routes that maintain the specified minimum node corner distance.</para>
        <para>Increasing the node corner distance penalty will raise the importance of maintaining the minimum distance to the corner of the adjacent nodes, while decreasing this penalty will raise the importance of all other restrictions.</para>
        <para>Use <see cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumNodeCornerDistance" /> to set the minimum node corner distance for a certain edge.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumNodeCornerDistance" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.MinimumFirstLastSegmentLengthPenalty">
      <summary>
        <para>Gets or sets the penalty for violations of the minimum length of the first and last segment of an edge.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes whose first/last bend is too close to their source or target node more expensive than routes that maintain the specified minimum first/last segment length.</para>
        <para>Increasing the minimum first last segment length penalty will raise the importance of maintaining the first and last segment as long as they fit the minimum first/last segment length, while decreasing this penalty will raise the importance of all other restrictions.</para>
        <para>Use <see cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumFirstSegmentLength" /> to set the minimum length of the first segment and <see cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumLastSegmentLength" /> to set the minimum length of the last segment of a certain edge.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumFirstSegmentLength" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MinimumLastSegmentLength" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.BendsInNodeToEdgeDistancePenalty">
      <summary>
        <para>Gets or sets the penalty for an edge bend being closer to the border of the source node, the target node or one of their ancestor group nodes than the minimum node to edge distance.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that bend too close to their source or target node more expensive than routes that maintain the specified minimum node to edge distance.</para>
        <para>Increasing the bends in node to edge distance penalty will raise the importance of avoiding bends that violate the minimum node to edge distance, while decreasing this penalty will raise the importance of all other restrictions. This penalty supports <see cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.MinimumNodeToEdgeDistance" />. In case the path search finally reaches the target node, the minimum node to edge distance for this node must be violated. Penalizing bends that are too close to the node forces the edge to directly cross this distance and connect to the node.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeRouter.MinimumNodeToEdgeDistance" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.MonotonyViolationPenalty">
      <summary>
        <para>Gets or sets the penalty for violating the monotonic path restrictions of an edge.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes with detours m ore expensive than routes that stay monotone.</para>
        <para>Increasing the monotony violation penalty will raise the importance of avoiding detours in the specified direction, while decreasing this penalty will raise the importance of all other restrictions.</para>
        <para>Use <see cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MonotonicPathRestriction" /> to set the monotonic path restrictions of a certain edge.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.EdgeLayoutDescriptor.MonotonicPathRestriction" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.PartitionGridCellReentrancePenalty">
      <summary>
        <para>Gets or sets the penalty for an edge leaving and reentering in the same <see cref="T:yWorks.Layout.Grid.PartitionGrid">partition grid</see> cell.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that re-enter the same partition grid cell more expensive than routes taking a more direct way.</para>
        <para>Increasing the partition grid reentrance penalty will raise the importance of taking the most direct way through the partition grid, while decreasing this penalty will raise the importance of all other restrictions.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="T:yWorks.Layout.Grid.PartitionGrid" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.PortViolationPenalty">
      <summary>
        <para>Gets or sets the penalty if an edge does not comply with its <see cref="T:yWorks.Layout.PortCandidate" />s or <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes that start or end at a point that doesn't comply with its port constraints more expensive than routes that obey them.</para>
        <para>Increasing the port violation penalty will raise the importance of maintaining port constraints, while decreasing this penalty will raise the importance of all other restrictions. It is recommended to have high penalties for port violation since the constraints lose purpose if they are disregarded.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="T:yWorks.Layout.PortCandidate" />
      <seealso cref="T:yWorks.Layout.PortConstraint" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.InvalidEdgeGroupingPenalty">
      <summary>
        <para>Gets or sets the penalty for an edge with a group ID that is not grouped at source or target side.</para>
      </summary>
      <remarks>
        <para>This penalty will make routes for grouped edges that don't use partly the same path as the other edges in this group more expensive than routes that stick to the group.</para>
        <para>Increasing the invalid edge grouping penalty will raise the importance of grouping edges with the same group ID, while decreasing this penalty will raise the importance of all other restrictions. As edge groups require that the route of an edge belonging to an edge group stays partly identical to the other edges of the group, the route may not be optimal with respect to the other restrictions. To maintain the edges together as long as possible, this penalty should be higher than most others.</para>
        <para>Grouped edges have the same source or target group ID assigned in the data provider registered with the graph with the <see cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" /> or <see cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" /> key.</para>
        <para>The value must be greater than or equal to <c>0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PenaltySettings.SingleSideSelfLoopPenalty">
      <summary>
        <para>Gets or sets the penalty for bends of a self-loop edge.</para>
      </summary>
      <remarks>
        <para>This penalty will make self-loops leave and enter the node at different sides unless they are forced to one side by <see cref="T:yWorks.Layout.PortConstraint" />s or <see cref="T:yWorks.Layout.PortCandidate" />s.</para>
        <para>Increasing this penalty will stronger enforce routing the self-loops between two sides of the node but it will also require more time for determining the edge path. Decreasing the penalty may result in self-loops that only connect to one side of the node.</para>
        <para>By default this value is set to <c>9</c>. The value must be <c>&gt;= 0</c>, otherwise the default value will be assigned.</para>
      </remarks>
      <value>
        <para>the penalty</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PenaltySettings.CreateCopy">
      <summary>
        <para>Creates a copy of this <see cref="T:yWorks.Layout.Router.Polyline.PenaltySettings" /> instance.</para>
      </summary>
      <remarks>
        <para>This implementation uses method <see cref="M:yWorks.Layout.Router.Polyline.PenaltySettings.NewInstance" /> to obtain a new instance which adopts all settings.</para>
      </remarks>
      <returns>
        <para>a copy of this instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PenaltySettings.NewInstance">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.PenaltySettings" />.</para>
      </summary>
      <remarks>
        <para>This factory method is used by <see cref="M:yWorks.Layout.Router.Polyline.PenaltySettings.CreateCopy" />. Subclasses can override this method in order to return a more specialized version.</para>
      </remarks>
      <returns>
        <para>a specialized <see cref="T:yWorks.Layout.Router.Polyline.PenaltySettings" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.PolylineLayoutStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Router.Polyline.PolylineLayoutStage" /> extends the orthogonal edge paths with polyline segments.</para>
      </summary>
      <remarks>
        <para>The current implementation only adds octilinear segments to all orthogonal edges. Non-orthogonal edges are completely ignored.</para>
        <para>An octilinear segment is added between two consecutive vertical and horizontal segments. The length of an octilinear segment can be influenced by the <see cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.MaximumNonOrthogonalSegmentRatio">maximum non-orthogonal segment ratio</see> and the <see cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.PreferredPolylineSegmentLength">preferred polyline segment length</see>. The new octilinear segments maintain a <see cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.MinimumNodeToEdgeDistance">minimum distance</see> between the edges and all nodes in the graph if possible.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PolylineLayoutStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.PolylineLayoutStage" /> using the given <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>the core layout routine</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.AffectedNodesDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key used for looking up the selected state of the nodes of the graph to be laid out.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.Scope">scope</see> is set to <see cref="F:yWorks.Layout.Router.Scope.RouteEdgesAtAffectedNodes" />, only edges of selected nodes are routed, while all other edges are considered to have fixed routes.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for the node selection</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.Scope" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Algorithms.IDataProvider" /> key used for looking up the selected state of the edges of the graph to be laid out.</para>
      </summary>
      <remarks>
        <para>If the <see cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.Scope">scope</see> is set to <see cref="F:yWorks.Layout.Router.Scope.RouteAffectedEdges" />, only the selected edges are routed, while all other edges are considered to have fixed routes.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key for the edge selection</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.Scope" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.Scope">
      <summary>
        <para>Gets or sets the (sub-)set of edges to be routed in a polyline fashion.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given argument is none of the predefined scope values</para>
      </exception>
      <value>
        <para>one of the default scope values</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.AffectedEdgesDpKey" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.AffectedNodesDpKey" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.MinimumNodeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between edges and node bounds.</para>
      </summary>
      <remarks>
        <para>Values should be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance between edges and node bounds</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.MaximumNonOrthogonalSegmentRatio">
      <summary>
        <para>Gets or sets the maximum segment length ratio at each end of an orthogonal segment that may get converted into a (non-orthogonal) polyline segment.</para>
      </summary>
      <remarks>
        <para>The ratio must be between <c>0</c> and <c>0.5</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the ratio does not lie within <c>[0,0.5]</c> interval</para>
      </exception>
      <value>
        <para>a value from the interval <c>[0,0.5]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.PolylineLayoutStage.PreferredPolylineSegmentLength">
      <summary>
        <para>Gets or sets the preferred segment length for (non-orthogonal) polyline segments.</para>
      </summary>
      <remarks>
        <para>Values should be greater than or equal to <c>0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the length is negative</para>
      </exception>
      <value>
        <para>the preferred segment length for (non-orthogonal) polyline segments</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.PolylineLayoutStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Adds polyline segments to the edge routes produced by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.SegmentGroup">
      <summary>
        <para>Represents a group of segments of different edges that shall be combined at their common source or target.</para>
      </summary>
      <remarks>
        <para>Grouped edges have the same source or target group ID assigned in the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with <see cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" /> or <see cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" /> keys.</para>
        <para>The <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup" /> contains the <see cref="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonLocationRange">common location range</see> for the edge group and provides a <see cref="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonSegmentInfo">common segment info</see> representing the grouped segments.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentGroup.#ctor(yWorks.Layout.Router.Polyline.Interval,System.Collections.Generic.IList{System.Object})">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup" /> that contains the given segments and a range to place them.</para>
      </summary>
      <param name="commonLocationRange">
        <para>the location range of the given <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s</para>
      </param>
      <param name="segmentInfos">
        <para>the list containing the grouped <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonLocationRange">
      <summary>
        <para>Gets the common location range for the <see cref="P:yWorks.Layout.Router.Polyline.SegmentGroup.SegmentInfos">segments</see> in this group.</para>
      </summary>
      <remarks>
        <para>For vertical grouped segments, this interval describes the horizontal range where this segment can be placed. Horizontal grouped segments are placed in a vertical range.</para>
      </remarks>
      <value>
        <para>the common location range for the segments in this group</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentGroup.SegmentInfos">
      <summary>
        <para>Gets the list of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s contained in this group.</para>
      </summary>
      <value>
        <para>the list of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" />s contained in this group</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonSegmentInfo">
      <summary>
        <para>Gets the common <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> representing the grouped segments.</para>
      </summary>
      <remarks>
        <para>The returned segment info is used for placing the common segment. The coordinates are applied to all edges in the bundle later.</para>
      </remarks>
      <value>
        <para>the common segment info representing the grouped segments</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentGroup.GetHashCode">
      <summary>
        <para>Returns the hash code for this <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup" />.</para>
      </summary>
      <returns>
        <para>the hash code for this <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.SegmentInfo">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> holds information about the possible location of an orthogonal edge segment.</para>
      </summary>
      <remarks>
        <para>Most notably, it stores the <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Direction">direction</see> of the segment and the <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">interval</see> that restricts the location of the segment.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentInfo.#ctor(yWorks.Algorithms.Edge,System.Int32,yWorks.Layout.Direction,yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval,System.Collections.Generic.IList{System.Object})">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> with the given information.</para>
      </summary>
      <param name="edge">
        <para>the edge to which the segment of this info belongs</para>
      </param>
      <param name="segmentIndex">
        <para>the index of the segment to which this info belongs</para>
      </param>
      <param name="direction">
        <para>the direction to which the segment of this info points</para>
      </param>
      <param name="locationRange">
        <para>the range within which the common location of this segment has to lie</para>
      </param>
      <param name="minExtension">
        <para>the minimum interval in extension direction this segment is known to intersect</para>
      </param>
      <param name="maxExtension">
        <para>the maximum interval in extension direction this segment will span</para>
      </param>
      <param name="cellSegmentInfos">
        <para>the list of <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" /> objects upon which this segment info is built</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentInfo.#ctor(yWorks.Algorithms.Edge,System.Int32,yWorks.Algorithms.Geometry.LineSegment)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfo" /> using a <see cref="T:yWorks.Algorithms.Geometry.LineSegment" /> to describe the edge segment.</para>
      </summary>
      <param name="edge">
        <para>the edge to which the segment of this info belongs</para>
      </param>
      <param name="segmentIndex">
        <para>the index of the segment to which this info belongs</para>
      </param>
      <param name="segment">
        <para>a line segment describing the edge segment</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentInfo.CellSegmentInfoCount">
      <summary>
        <para>Returns the number of <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" /> of this segment info.</para>
      </summary>
      <returns>
        <para>the number of <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" /> of this segment info</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentInfo.GetCellSegmentInfo(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" /> at the given index of this segment info.</para>
      </summary>
      <param name="index">
        <para>the index of the <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" /> to return</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" /> at the given index of this segment info</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfo.SegmentGroup">
      <summary>
        <para>Sets the <see cref="T:yWorks.Layout.Router.Polyline.SegmentGroup">segment group</see> for this segment info and its associated <see cref="T:yWorks.Layout.Router.Polyline.CellSegmentInfo" />s.</para>
      </summary>
      <remarks>
        <para>The <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">location ranges</see> are adjusted to use the <see cref="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonLocationRange" />.</para>
      </remarks>
      <value>
        <para>the segment group to which this segment info shall belong</para>
      </value>
      <seealso cref="T:yWorks.Layout.Router.Polyline.SegmentGroup" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfo.AtStrongPortConstraint">
      <summary>
        <para>Gets or sets whether or not this edge segment has the restriction of a strong <see cref="T:yWorks.Layout.PortConstraint" />.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this edge segment has the restriction of a strong <see cref="T:yWorks.Layout.PortConstraint" />, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Router.Polyline.SegmentInfoBase">
      <summary>
        <para>This class stores location information for orthogonal edge segments.</para>
      </summary>
      <remarks>
        <para>Most notably, <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfoBase" /> stores the <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Direction">direction</see> to which the segment points and the <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">interval</see> describing possible locations and extensions of a segment.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentInfoBase.#ctor(yWorks.Algorithms.Edge,System.Int32,yWorks.Layout.Direction,yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval,yWorks.Layout.Router.Polyline.Interval)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfoBase" />.</para>
      </summary>
      <param name="edge">
        <para>the edge to which the segment of this info belongs</para>
      </param>
      <param name="segmentIndex">
        <para>the index of the segment to which this info belongs</para>
      </param>
      <param name="direction">
        <para>the direction to which the segment of this info points</para>
      </param>
      <param name="locationRange">
        <para>the range within which the common location of this segment has to lie</para>
      </param>
      <param name="minExtension">
        <para>the minimum interval in extension direction this segment is known to intersect</para>
      </param>
      <param name="maxExtension">
        <para>the maximum interval in extension direction this segment will span</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentInfoBase.#ctor(yWorks.Algorithms.Edge,System.Int32,yWorks.Algorithms.Geometry.LineSegment)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfoBase" /> using a line segment to describe the edge segment.</para>
      </summary>
      <remarks>
        <para>This constructor is meant to be used for fixed orthogonal edge segments.</para>
      </remarks>
      <param name="edge">
        <para>the edge to which this segment info belongs</para>
      </param>
      <param name="segmentIndex">
        <para>the index of the segment to which this info belongs</para>
      </param>
      <param name="segment">
        <para>a line segment describing the edge segment</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Router.Polyline.SegmentInfoBase.ToString">
      <summary>
        <para>Returns a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfoBase" /> object.</para>
      </summary>
      <returns>
        <para>a string representation of this <see cref="T:yWorks.Layout.Router.Polyline.SegmentInfoBase" /> object</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.MinExtension">
      <summary>
        <para>Gets the minimum known extension of the segment, i.e., the minimum interval that this segment will cover in any case.</para>
      </summary>
      <remarks>
        <para>For horizontal intervals, this is the minimum horizontal extension; for vertical intervals, this is the minimum vertical extension.</para>
      </remarks>
      <value>
        <para>the minimum extension of the segment or <c>null</c> if no minimum extension can be determined</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.MaxExtension">
      <summary>
        <para>Gets the maximum extension that this segment can span.</para>
      </summary>
      <remarks>
        <para>For horizontal intervals, this is the maximum horizontal extension; for vertical intervals, this is the maximum vertical extension.</para>
      </remarks>
      <value>
        <para>the maximum extension that this segment can span</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">
      <summary>
        <para>Gets the range, i.e., the interval within which the segment should be placed.</para>
      </summary>
      <remarks>
        <para>For horizontal segments, this is the range containing the vertical location; for vertical segments, this is the range containing the horizontal location.</para>
      </remarks>
      <value>
        <para>the interval within which the segment should be placed</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.PreferredAlignment">
      <summary>
        <para>Gets or sets the preferred placement of this segment within its location range.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown alignment is given</para>
      </exception>
      <value>
        <para>one of the predefined alignments</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Location">
      <summary>
        <para>Gets or sets the <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Fixed">fixed</see> location within the <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">location range</see> for this segment info.</para>
      </summary>
      <remarks>
        <para>For horizontal segments, this is the vertical location; for vertical segments, this is the horizontal location.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>if the segment info already has a fixed location</para>
      </exception>
      <exception cref="T:System.ArgumentException">
        <para>if the given location does not lie within the location range</para>
      </exception>
      <value>
        <para>the fixed location that has been set before or <c>0</c> if no fixed location has been set</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Fixed" />
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange" />
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Fixed">
      <summary>
        <para>Gets whether or not this segment info is fixed, i.e., a <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Location">fixed location</see> has been determined within its <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">location range</see>.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if this segment info has a fixed location assigned to it, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Vertical">
      <summary>
        <para>Gets whether or not the associated segment is vertical.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the segment of this segment info is vertical, <c>false</c> if it is horizontal</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Direction">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Direction" /> to which the segment of this info points.</para>
      </summary>
      <value>
        <para>the direction to which the segment of this info points</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.Edge">
      <summary>
        <para>Gets the edge to which the segment of this info belongs.</para>
      </summary>
      <value>
        <para>the edge to which the segment of this info belongs</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.SegmentIndex">
      <summary>
        <para>Gets the index of the segment of this info.</para>
      </summary>
      <value>
        <para>the index of the segment of this info</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.SegmentGroup">
      <summary>
        <para>Gets or sets the segment group to which this segment info belongs.</para>
      </summary>
      <remarks>
        <para>When defining the segment group, the <see cref="P:yWorks.Layout.Router.Polyline.SegmentInfoBase.LocationRange">location range</see> will be adjusted to use the common interval of the segment group.</para>
      </remarks>
      <value>
        <para>the segment group to which this segment info belongs or <c>null</c> if no segment group is assigned</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.Polyline.SegmentGroup.CommonLocationRange" />
    </member>
    <member name="T:yWorks.Layout.Router.SnapOuterPortsToNodeBorderStage">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Router.SnapOuterPortsToNodeBorderStage" /> moves edge ports that are outside the corresponding area of the nodes to their border.</para>
      </summary>
      <remarks>
        <para>Thus, it guarantees that ports are always in the interior of the nodes or on their borders.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.SnapOuterPortsToNodeBorderStage.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.SnapOuterPortsToNodeBorderStage" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Router.SnapOuterPortsToNodeBorderStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Snaps all edge ports that lie outside the bounds of the nodes to their border.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Router.StraightLineEdgeRouter">
      <summary>
        <para>This edge routing algorithm routes edges as straight-lines considering the specified <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The edges connect to their ports with straight-lines. This may lead to edges crossing nodes.  <h2>Concept</h2> <see cref="T:yWorks.Layout.Router.StraightLineEdgeRouter" /> will first invoke the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout" /> if one exists. Then, it will remove all bends from the edges and will place the ports either on the center of the nodes or at a location specified by a <see cref="T:yWorks.Layout.PortConstraint" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Router.StraightLineEdgeRouter.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Router.StraightLineEdgeRouter" /> with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="core">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Router.StraightLineEdgeRouter.Scope">
      <summary>
        <para>Gets or sets the (sub-)set of edges to be routed.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Router.StraightLineEdgeRouter" /> will only route those edges and leave the remaining edges unchanged.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given argument is an unknown specifier</para>
      </exception>
      <value>
        <para>one of the valid scope specifiers</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.StraightLineEdgeRouter.AffectedEdgesDpKey" />
      <seealso cref="P:yWorks.Layout.Router.StraightLineEdgeRouter.AffectedNodesDpKey" />
    </member>
    <member name="P:yWorks.Layout.Router.StraightLineEdgeRouter.AffectedNodesDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> that provides the selected state of the nodes of the graph.</para>
      </summary>
      <remarks>
        <para>If the scope only includes <see cref="F:yWorks.Layout.Router.Scope.RouteEdgesAtAffectedNodes">edges at selected nodes</see>, only edges of the nodes marked in this <see cref="T:yWorks.Algorithms.IDataProvider" /> are routed while all other edges are considered to have fixed routes.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> for the node selection</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.StraightLineEdgeRouter.Scope" />
    </member>
    <member name="P:yWorks.Layout.Router.StraightLineEdgeRouter.AffectedEdgesDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> that provides the selected state of the edges of the graph.</para>
      </summary>
      <remarks>
        <para>If the scope only includes <see cref="F:yWorks.Layout.Router.Scope.RouteAffectedEdges">selected edges</see>, only edges of the nodes marked in this <see cref="T:yWorks.Algorithms.IDataProvider" /> are routed while all other edges are considered to have fixed routes.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> for the edge selection</para>
      </value>
      <seealso cref="P:yWorks.Layout.Router.StraightLineEdgeRouter.Scope" />
    </member>
    <member name="M:yWorks.Layout.Router.StraightLineEdgeRouter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Routes the edges as straight-lines from their source to their target after invoking the <see cref="M:yWorks.Layout.LayoutStageBase.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">core layout algorithm</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.SelfLoopRouter">
      <summary>
        <para>A <see cref="T:yWorks.Layout.SelfLoopRouter" /> routes the self-loops (reflexive edges) of a graph.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The nodes and normal edges are arranged by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. This layout algorithm only handles the paths of self-loops.</para>
        <para>Self-loops are routed either <see cref="F:yWorks.Layout.SelfLoopStyle.Orthogonal">orthogonal</see> or with <see cref="F:yWorks.Layout.SelfLoopStyle.Rounded">rounded</see> corners. The layout algorithm places the self-loops in the least crowded quadrant around a node.</para>
        <para />
        <para>Small graph with self-loops</para>
        <para>
          <h2>Concept</h2> Self-loops are handled in four steps:</para>
        <list type="number">
          <item>Remove all self-loops of the input graph</item>
          <item>Invoke the core layout algorithm on the now self-loops free graph</item>
          <item>Reinsert all formerly removed self-loops</item>
          <item>Route the self-loops of the input graph</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>
          <see cref="T:yWorks.Layout.SelfLoopRouter" /> can either be used as a <see cref="T:yWorks.Layout.ILayoutStage" /> wrapping a <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> which cannot handle self-loops. Then it will hide the self-loops from this <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and take over the routing of them. <br /> If no <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> is specified, <see cref="T:yWorks.Layout.SelfLoopRouter" /> can work alone. It will route only the self-loops and keep the remaining graph unchanged.</para>
        <para>When all self-loops already have a suitable layout, this layout algorithm can <see cref="P:yWorks.Layout.SelfLoopRouter.KeepAllSelfLoopRoutes">keep the self-loop paths</see>. It will just hide the self-loops before invoking the core layout algorithm, such that they are not altered by it. <br /> To only exclude some self-loops from routing, a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.SelfLoopRouter.KeepSelfLoopLayoutDpKey" /> can be used for marking those self-loops.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.MultiStageLayout" />
    </member>
    <member name="F:yWorks.Layout.SelfLoopRouter.KeepSelfLoopLayoutDpKey">
      <summary>
        <para>A data provider key for determining which self-loops should keep their current path.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with this key, all self-loops will be routed.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.SelfLoopRouter.KeepAllSelfLoopRoutes" />
    </member>
    <member name="M:yWorks.Layout.SelfLoopRouter.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.SelfLoopRouter" /> with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.SelfLoopRouter.CornerApproximationPointsCount">
      <summary>
        <para>Gets or sets the number of points that are used for rounding the corners of the self-loops.</para>
      </summary>
      <remarks>
        <para>For rounded corners, the number of points should be at least <c>2</c>. All smaller values will produce one bend and, therefore, an orthogonal path.</para>
        <para>The number of points for a corner must be at least <c>1</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified point count is less than <c>1</c></para>
      </exception>
      <value>
        <para>the number of bends that are inserted to round the corners of self-loops</para>
      </value>
      <seealso cref="P:yWorks.Layout.SelfLoopRouter.LayoutStyle" />
      <seealso cref="F:yWorks.Layout.SelfLoopStyle.Rounded" />
    </member>
    <member name="P:yWorks.Layout.SelfLoopRouter.LineDistance">
      <summary>
        <para>Gets or sets the distance between two self-loops incident to the same node.</para>
      </summary>
      <remarks>
        <para>The distance needs to be a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the distance between the self-loops</para>
      </value>
      <seealso cref="F:yWorks.Layout.SelfLoopStyle.Rounded" />
    </member>
    <member name="P:yWorks.Layout.SelfLoopRouter.SmartSelfLoopPlacement">
      <summary>
        <para>Gets or sets whether or not the algorithm chooses the side of the self-loop depending on the incident edges.</para>
      </summary>
      <remarks>
        <para>If this option is enabled, self-loops are placed on one of the four corners of the corresponding node. For the choice of the corner, the algorithm considers all incident edges. Otherwise, self-loops are always placed at the upper left corner of the corresponding node.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if self-loops are placed smartly, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SelfLoopRouter.LayoutStyle">
      <summary>
        <para>Gets or sets the layout style of the self-loops.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified style is unknown</para>
      </exception>
      <value>
        <para>the layout style for self-loops</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.SelfLoopRouter.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Delegates the arrangement of nodes and edges to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> and routes the self-loops.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.SelfLoopRouter.LayoutSelfLoops(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates the routes of the self-loops in the given graph.</para>
      </summary>
      <remarks>
        <para>This method will only change the routes of self-loops that are not marked to be <see cref="F:yWorks.Layout.SelfLoopRouter.KeepSelfLoopLayoutDpKey">kept</see>.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.SelfLoopRouter.ApplyLayout(yWorks.Layout.LayoutGraph)" /> after the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> has arranged the graph and all self-loops have been reinserted into the graph. It may be overridden to introduce custom self-loop styles.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.SelfLoopRouter.KeepAllSelfLoopRoutes">
      <summary>
        <para>Gets or sets whether or not this algorithm should keep all self-loop routes.</para>
      </summary>
      <remarks>
        <para>When enabled, no self-loop will be routed, instead the existing self-loop layout will be moved with its node.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if all self-loops should keep their routes, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.SequentialLayout">
      <summary>
        <para>A <see cref="T:yWorks.Layout.SequentialLayout" /> allows for chaining multiple <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see>.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> are invoked one after the other in the order in which they were <see cref="M:yWorks.Layout.SequentialLayout.AppendLayout(yWorks.Layout.ILayoutAlgorithm)">added to the chain</see>. They all run independently of each other, i.e., they only influence each other by the changed input graph. Hence, the sequence determines the result.</para>
        <para>One possible application would be to bundle several <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> and pass a single <see cref="T:yWorks.Layout.ILayoutAlgorithm" /> instance to a <see cref="T:yWorks.Layout.BufferedLayout" />.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.SequentialLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.SequentialLayout" /> instance with an empty chain of <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see>.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.SequentialLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Executes all <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> in the chain, one after the other.</para>
      </summary>
      <remarks>
        <para>The order of the layout algorithms is defined by the order in which they were appended.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.SequentialLayout.AppendLayout(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Appends the given <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> to the end of the chain.</para>
      </summary>
      <param name="layouter">
        <para>the <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithm</see> to append</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.SequentialLayout.AppendLayouts(System.Collections.Generic.ICollection{yWorks.Layout.ILayoutAlgorithm})">
      <summary>
        <para>Appends the specified list of <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> to the end of the chain.</para>
      </summary>
      <param name="layouters">
        <para>the list of <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> to append</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.SequentialLayout.Layouts">
      <summary>
        <para>Gets or sets the chain of <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see>.</para>
      </summary>
      <value>
        <para>the list of layout algorithms that are invoked one after the other</para>
      </value>
      <seealso cref="M:yWorks.Layout.SequentialLayout.AppendLayout(yWorks.Layout.ILayoutAlgorithm)" />
      <seealso cref="M:yWorks.Layout.SequentialLayout.AppendLayouts(System.Collections.Generic.ICollection{yWorks.Layout.ILayoutAlgorithm})" />
    </member>
    <member name="M:yWorks.Layout.SequentialLayout.RemoveAll">
      <summary>
        <para>Clears the current chain of <see cref="T:yWorks.Layout.ILayoutAlgorithm">layout algorithms</see> and therefore removes all layout algorithms.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.SeriesParallel.DefaultOutEdgeComparer">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.SeriesParallel.DefaultOutEdgeComparer" /> is the default implementation for the out-edge comparator used in <see cref="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout" />.</para>
      </summary>
      <remarks>
        <para>It keeps the order of the edges in the graph for edges without <see cref="T:yWorks.Layout.PortConstraint" />s and considers the <see cref="T:yWorks.Layout.PortConstraint" />s such that the order of the target nodes of the outgoing edges is similar to the port location at the source node. Note that this won't work for all cases because the target nodes may not be completely independent.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultOutEdgeComparer" />
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.DefaultOutEdgeComparer.#ctor">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.SeriesParallel.DefaultOutEdgeComparer" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.DefaultOutEdgeComparer.Compare(System.Object,System.Object)">
      <summary>
        <para>Compares the two given edges considering their <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
      </summary>
      <remarks>
        <para>The order of edges is kept unless there are <see cref="T:yWorks.Layout.PortConstraint" />s assigned. Then the edges will be sorted to avoid edge crossings.</para>
      </remarks>
      <param name="o1">
        <para>the first edge</para>
      </param>
      <param name="o2">
        <para>the second edge</para>
      </param>
      <returns>
        <para>the order of the given two edges</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.SeriesParallel.DefaultPortAssignment">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.SeriesParallel.DefaultPortAssignment" /> implements the default port assignment strategy.</para>
      </summary>
      <remarks>
        <para>Ports are either placed at the <see cref="F:yWorks.Layout.SeriesParallel.PortAssignmentMode.Center">center</see> or get <see cref="F:yWorks.Layout.SeriesParallel.PortAssignmentMode.Distributed">distributed</see> at the sides of the node.</para>
        <para>If <see cref="T:yWorks.Layout.PortConstraint" />s are specified, the strong <see cref="T:yWorks.Layout.PortConstraint" />s are handled separately and keep their initial location relative to the node while weak <see cref="T:yWorks.Layout.PortConstraint" />s just influence on which side of the node the port is placed.</para>
        <para>If there are edge groups specified, the edges which belong to the same group get the same port locations.</para>
      </remarks>
      <seealso cref="T:yWorks.Layout.PortConstraint" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.SeriesParallel.DefaultPortAssignment" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.#ctor(yWorks.Layout.SeriesParallel.PortAssignmentMode,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.SeriesParallel.DefaultPortAssignment" /> instance using the given <see cref="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.Mode">mode</see> and a given value for the <see cref="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.BorderGapToPortGapRatio">ratio</see> of the gap between the border and the ports to the gap between the ports themselves.</para>
      </summary>
      <param name="mode">
        <para>one of the predefined port assignment modes</para>
      </param>
      <param name="ratio">
        <para>the ratio of the distance between outer ports and the border to the distance between any two ports</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the given mode is unknown or the given ratio is negative</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Places the ports of edges connecting to the given node according to the <see cref="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.Mode">port assignment mode</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node">
        <para>the node whose adjacent edges' ports should be placed</para>
      </param>
      <seealso cref="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.Mode" />
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.GetPortBorderGap(System.Double,System.Int32)">
      <summary>
        <para>Determines the distance between the outer ports and the border of the node.</para>
      </summary>
      <remarks>
        <para>This implementation calculates the gap according to the number of edges at one side of the node. It also includes the <see cref="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.BorderGapToPortGapRatio">ratio between border gap and port gap</see>.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)" /> to calculate the location of the first port. It may be overridden to implement a different distribution of ports on the node's side.</para>
      </remarks>
      <param name="sideLength">
        <para>the width/height of the side</para>
      </param>
      <param name="edgeCount">
        <para>the number of edges that connect to this side</para>
      </param>
      <returns>
        <para>the absolute gap to be used on both sides of the ports</para>
      </returns>
      <seealso cref="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.BorderGapToPortGapRatio" />
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.GetPortDistanceDelta(System.Double,System.Int32,System.Double)">
      <summary>
        <para>Determines the distance between two adjacent ports.</para>
      </summary>
      <remarks>
        <para>This implementation calculates the gap according to the number of edges at one side of the node. The edges are distributed keeping the given gap to the border of the node.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)" /> to calculate the distance between two ports. It may be overridden to implement a different distribution of ports on the node's side.</para>
      </remarks>
      <param name="sideLength">
        <para>the width/height of the side</para>
      </param>
      <param name="edgeCount">
        <para>the number of edges/ports that connect to this side</para>
      </param>
      <param name="portBorderGap">
        <para>the port border gap (i.e. calculated by <see cref="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.GetPortBorderGap(System.Double,System.Int32)" />)</para>
      </param>
      <returns>
        <para>the absolute distance to be used between two adjacent ports</para>
      </returns>
      <seealso cref="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.GetPortBorderGap(System.Double,System.Int32)" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.Mode">
      <summary>
        <para>Gets or sets the mode that describes how ports are placed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown mode is specified</para>
      </exception>
      <value>
        <para>one of the predefined port assignment modes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.BorderGapToPortGapRatio">
      <summary>
        <para>Gets or sets the ratio of the <em>border gap</em> (distance between the outer ports and the node border) to the <em>port gap</em> (distance between adjacent ports).</para>
      </summary>
      <remarks>
        <para>The ratio must have a positive value. If the ratio is <c>0</c>, the ports will be distributed along the whole side of the node without a gap between the last port and the corner.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified ratio is negative</para>
      </exception>
      <value>
        <para>the ratio of the border gap (gap between ports and border) to the port gap (gap between two ports)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.ForkStyle">
      <summary>
        <para>Gets or sets the fork style which influences the port assignment.</para>
      </summary>
      <remarks>
        <para>If the fork style is set to <see cref="F:yWorks.Layout.SeriesParallel.ForkStyle.OutsideNode" />, edges without port constraints will be assigned in flow direction.</para>
        <para>If the fork style is set to <see cref="F:yWorks.Layout.SeriesParallel.ForkStyle.AtNode" />, the ports of edges in flow direction also get distributed to the sides unless they are without bends. Due to large minimum first/last segment lengths edges may overlap.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified fork style is unknown</para>
      </exception>
      <value>
        <para>one of the predefined fork styles</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor">
      <summary>
        <para>An <see cref="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor" /> provides routing details for an edge that are considered by <see cref="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout" />.</para>
      </summary>
      <remarks>
        <para>Such an <see cref="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor" /> can either be specified for a single edge or shared by several edges. It is assigned by registering a <see cref="T:yWorks.Algorithms.IDataProvider" /> with key <see cref="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.EdgeLayoutDescriptorDpKey" />. If no <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with this key, <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultEdgeLayoutDescriptor">a default descriptor</see> is used.</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.EdgeLayoutDescriptorDpKey" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultEdgeLayoutDescriptor" />
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor.MinimumLength">
      <summary>
        <para>Gets or sets the minimum length for the associated edge.</para>
      </summary>
      <remarks>
        <para>The minimum length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>for negative edge lengths</para>
      </exception>
      <value>
        <para>the minimum edge length</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor.MinimumFirstSegmentLength">
      <summary>
        <para>Gets or sets the minimum length for the first segment of the associated edge.</para>
      </summary>
      <remarks>
        <para>The minimum first segment length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>for negative minimum segment lengths</para>
      </exception>
      <value>
        <para>the minimum first segment length</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor.MinimumLastSegmentLength">
      <summary>
        <para>Gets or sets the minimum length for the last segment of the associated edge.</para>
      </summary>
      <remarks>
        <para>The minimum last segment length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>for negative minimum segment lengths</para>
      </exception>
      <value>
        <para>the minimum last segment length</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor.CreateCopy">
      <summary>
        <para>Creates a copy of this <see cref="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor" /> instance.</para>
      </summary>
      <returns>
        <para>a copy of this <see cref="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.SeriesParallel.PortAssignmentMode">
      <seealso cref="M:yWorks.Layout.SeriesParallel.DefaultPortAssignment.#ctor(yWorks.Layout.SeriesParallel.PortAssignmentMode,System.Double)" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.Mode" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.PortAssignmentMode.Center">
      <summary>
        <para>A port assignment specifier which defines that all ports are reset to the center of their nodes.</para>
      </summary>
      <seealso cref="T:yWorks.Layout.PortConstraint" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.PortAssignmentMode.Distributed">
      <summary>
        <para>A port assignment specifier which defines that the ports of incoming and outgoing edges are distributed evenly at the side of their nodes.</para>
        <para>The source ports of edges without <see cref="T:yWorks.Layout.PortConstraint" />s will be distributed at the sides of their source and target nodes. Edges with weak <see cref="T:yWorks.Layout.PortConstraint" />s are distributed at the side of the nodes which is specified in the <see cref="T:yWorks.Layout.PortConstraint" />.</para>
        <para>Grouped edges will get the same port location.</para>
      </summary>
      <seealso cref="T:yWorks.Layout.PortConstraint" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="T:yWorks.Layout.SeriesParallel.ForkStyle">
      <summary>
        <para>Fork style specifier that defines that the edges will fork on a node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SeriesParallel.DefaultPortAssignment.ForkStyle" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.ForkStyle.OutsideNode">
      <summary>
        <para>Fork style specifier that defines that the edges will fork outside a node. Edges leave/enter the nodes south/north and bend between their source and target.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.ForkStyle.AtNode">
      <summary>
        <para>Fork style specifier that defines that the edges will fork on a node. Edges leave/enter the nodes south/north if they are straight (no bends) or east and west of the node.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.SeriesParallel.RoutingStyle">
      <summary>
        <para>Style constant describing a polyline edge style.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.RoutingStyle.Orthogonal">
      <summary>
        <para>Style constant describing an orthogonal edge style. If this style is used, edges will contain only horizontal and vertical segments.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.RoutingStyle.Octilinear">
      <summary>
        <para>Style constant describing an octilinear edge style. If this style is used, edges will contain horizontal, vertical and <c>45</c>-degree sloped segments.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.RoutingStyle.Polyline">
      <summary>
        <para>Style constant describing a polyline edge style. If this style is used, edges will contain vertical and other sloped segments.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle" />
    </member>
    <member name="T:yWorks.Layout.SeriesParallel.IPortAssignment">
      <summary>
        <para>A <see cref="T:yWorks.Layout.SeriesParallel.IPortAssignment" /> is used by <see cref="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout" /> for determining the locations of the edges' ports at their incident nodes.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.IPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Assigns both the incoming edges' target ports as well as all source ports for the outgoing edges.</para>
      </summary>
      <remarks>
        <para>Outgoing edges are sorted according to the specified out-edge comparator from left to right and incoming edges are in the order of the subgraphs they are coming from.</para>
        <para>This method is called by <see cref="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout" /> before the actual layout of the graph takes place.</para>
      </remarks>
      <param name="graph">
        <para>the graph instance the node is part of</para>
      </param>
      <param name="node">
        <para>the node whose incident edges' ports are assigned</para>
      </param>
      <seealso cref="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.OutEdgeComparerDpKey" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultOutEdgeComparer" />
    </member>
    <member name="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout">
      <summary>
        <para>This layout algorithm arranges series-parallel graphs.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> Series-parallel graphs are directed graphs with a single source (node without incoming edges) and a single sink (node without outgoing edges). The layout algorithm highlights the main layout direction (from source to sink). It also emphasizes the paths through the graph because edges are routed with few bends.</para>
        <para>
          <see cref="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout" /> is suitable for the visualization of circuits, call trees or flowcharts.</para>
        <para> <h2>Concept</h2> Series-parallel graphs are directed graphs with a single source (node without incoming edges) and a single sink (node without outgoing edges) that are built using only the following two rules:</para>
        <list type="number">
          <item>
            <b>Series composition:</b> The source of a subgraph is merged with the sink of a second subgraph.</item>
          <item>
            <b>Parallel composition:</b> The sources and sinks of two subgraphs are merged.</item>
        </list>
        <para>From the recursive structure of series-parallel graphs, the layout algorithm retrieves a decomposition tree where each node represents one of the decomposition types. Then, this tree is traversed recursively from bottom to top, aligning subgraphs above (series) or next to (parallel) each other until the whole graph is arranged. The edges are routed when both end nodes are placed. Different <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle">routing styles</see> can be used.</para>
        <para>To avoid moving all nodes several times and to be aware of the area that the subtrees occupy, the layout algorithm keeps track of the shape of the subtrees. These shapes are moved and merged during the layout calculation. The layout algorithm also stores the connections between nodes and nodes that haven't already been placed in these shapes.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>
          <see cref="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout" /> can take strong <see cref="T:yWorks.Layout.PortConstraint" />s into account. It will connect the edges to the specified locations, the directions, however, will be ignored.</para>
        <para>Grouping of nodes can also be handled by this layout algorithm. It is important that a group node contains a whole series-parallel subgraph. Otherwise, the group nodes may overlap with each other or with other nodes. Edges which are connected to non-empty group nodes are not allowed. Furthermore, the user may specify minimum size constraints for each group node using <see cref="T:yWorks.Algorithms.IDataProvider" /> key <see cref="F:yWorks.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey" />.</para>
        <para>The layout algorithm can be configured to reserve space for node labels and to place the edge labels along the edge such that the labels won't overlap with other graph elements. Edge labels are placed according to the information stored in a <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> instance. However, labels that should be centered between source and target are placed close to the target node, unless this edge connects to the local source and sink of a subgraph.</para>
        <para>Parallel subgraphs can be aligned in different ways. Depending on the node sizes, a different alignment can increase the compactness of the layout.</para>
        <para>The way in which edges are distributed around their incident nodes is computed by an instance of <see cref="T:yWorks.Layout.SeriesParallel.IPortAssignment" />. The <see cref="T:yWorks.Layout.SeriesParallel.DefaultPortAssignment">default assignment</see> is able to consider <see cref="T:yWorks.Layout.PortConstraint" />s and edge groups.</para>
        <para>The <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.FromSketchMode">From Sketch mode</see> allows to take the initial locations of the nodes into account. However, the layout algorithm won't insert crossings because it maintains the order of children of each node.</para>
        <para>
          <see cref="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout" /> supports custom sorting of the outgoing edges of a node. A <see cref="T:System.Collections.Generic.IComparer`1" /> can be assigned individually for the nodes using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.OutEdgeComparerDpKey" />. For all nodes for which the <see cref="T:yWorks.Algorithms.IDataProvider" /> returns <c>null</c>, the layout algorithm falls back to the <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultOutEdgeComparer">default comparator</see>.</para>
        <para>By default, this layout algorithm can only handle graphs with a series-parallel structure. To apply it to a general graph, <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.GeneralGraphHandling">general graph handling</see> needs to be activated. Then, the layout algorithm will temporarily add and/or remove some edges from the input graph until a series-parallel graph is obtained. The edges that were removed will be routed separately afterwards.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.EdgeLayoutDescriptorDpKey">
      <summary>
        <para>A data provider key for storing individual settings for edges.</para>
      </summary>
      <remarks>
        <para>If no edge layout descriptor is mapped for an edge, a default edge layout descriptor will be obtained by method <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultEdgeLayoutDescriptor" />.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultEdgeLayoutDescriptor" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.OutEdgeComparerDpKey">
      <summary>
        <para>A data provider key for assigning different orderings for outgoing edges of the nodes.</para>
      </summary>
      <remarks>
        <para>If the <see cref="T:System.Collections.Generic.IComparer`1" /> associated with a node is <c>null</c>, the outgoing edges maintain their initial order.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultOutEdgeComparer" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.PortAssignmentDpKey">
      <summary>
        <para>A data provider key for providing an individual port distribution at nodes.</para>
      </summary>
      <remarks>
        <para>If there is no <see cref="T:yWorks.Layout.SeriesParallel.IPortAssignment" /> specified for a node, the layout algorithm uses the <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultPortAssignment">default assignment</see>.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultPortAssignment" />
    </member>
    <member name="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelsDpKey">
      <summary>
        <para>A data provider key for marking edge labels of non-series-parallel edges.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelSelectionKey" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelingAlgorithm" />
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.SeriesParallelLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.SeriesParallel.SeriesParallelLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.SeriesParallelLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Calculates a series-parallel layout for the given graph.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <exception cref="T:yWorks.Algorithms.InvalidGraphStructureException">
        <para>if the graph is not series-parallel</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.SeriesParallel.SeriesParallelLayout.IsSeriesParallelGraph(yWorks.Algorithms.Graph)">
      <summary>
        <para>Determines whether or not the given graph has a series-parallel structure.</para>
      </summary>
      <remarks>
        <para>The current implementation detects the series-parallel graph structure in linear time.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>
          <c>true</c> if the given graph is series-parallel, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the layout algorithm reserves space for node labels to avoid overlaps.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node labels are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.IntegratedEdgeLabeling">
      <summary>
        <para>Gets or sets whether or not the layout algorithm will place edge labels and reserve space for them.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels should be placed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.VerticalAlignment">
      <summary>
        <para>Gets or sets the vertical alignment of parallel subgraphs.</para>
      </summary>
      <remarks>
        <para>The alignment is defined by a ratio:</para>
        <list type="bullet">
          <item>Ratio <c>0</c> means that nodes are top-aligned</item>
          <item>Ratio <c>0.5</c> means that nodes are center-aligned</item>
          <item>Ratio <c>1</c> means that nodes are bottom-aligned</item>
        </list>
      </remarks>
      <value>
        <para>the vertical alignment ratio from interval <c>[0,1]</c></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.GeneralGraphHandling">
      <summary>
        <para>Gets or sets whether or not the layout algorithm can handle general graphs.</para>
      </summary>
      <remarks>
        <para>General graphs are required to be transformed before being laid out (by adding or removing some edges) such that they satisfy the criteria of a series-parallel graph. After the layout, the graph will be restored and the initial edges which weren't included in the series-parallel graph are routed by a separate <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeRouter">edge routing algorithm</see>. Furthermore, the labels of these edges are placed by a customizable <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelingAlgorithm">edge labeling algorithm</see>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if general graphs should be handled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeRouter">
      <summary>
        <para>Gets or sets the edge routing algorithm used for the edges of a general graph that are not part of the series-parallel subgraph whose layout is calculated.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if <c>null</c> is specified</para>
      </exception>
      <value>
        <para>the edge routing algorithm applied to the non-series-parallel edges</para>
      </value>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.GeneralGraphHandling" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgesDpKey" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgesDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> that is used for marking non-series-parallel edges.</para>
      </summary>
      <remarks>
        <para>This key is used for determining the edges that are not part of the series-parallel structure in a general graph, such that the specified non-series-parallel edge router only routes marked edges.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given key is set to <c>null</c></para>
      </exception>
      <value>
        <para>the selection key</para>
      </value>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.GeneralGraphHandling" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelingAlgorithm">
      <summary>
        <para>Gets or sets the labeling algorithm that is applied to all edge labels that belong to non-series-parallel edges.</para>
      </summary>
      <value>
        <para>the labeling algorithm used for edge labels of non-series-parallel edges</para>
      </value>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.GeneralGraphHandling" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelSelectionKey" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelSelectionKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> that is used by the <see cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelingAlgorithm">non-series-parallel edge labeling algorithm</see> to determine which edge labels it should place.</para>
      </summary>
      <remarks>
        <para>During the layout, a <see cref="T:yWorks.Algorithms.IDataProvider" /> with this key will be registered with the graph. It will mark all <see cref="T:yWorks.Layout.IEdgeLabelLayout" />s that belong to non-series-parallel edges. A specified custom non-series-parallel edge labeling algorithm needs to obey this selection. If using <see cref="T:yWorks.Layout.Labeling.GenericLabeling" /> as labeling algorithm, set this key as value of property <see cref="P:yWorks.Layout.Labeling.LabelingBase.AffectedLabelsDpKey" />.</para>
        <para>The labeling algorithm set as default is already configured such that it uses the correct selection key.</para>
      </remarks>
      <value>
        <para>the non-series-parallel edge label selection <see cref="T:yWorks.Algorithms.IDataProvider" /> key</para>
      </value>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.NonSeriesParallelEdgeLabelingAlgorithm" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultPortAssignment">
      <summary>
        <para>Gets or sets the default <see cref="T:yWorks.Layout.SeriesParallel.IPortAssignment" /> used for those nodes that do not have their own specific instance.</para>
      </summary>
      <remarks>
        <para>A <see cref="T:yWorks.Layout.SeriesParallel.IPortAssignment" /> instance is defined using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.PortAssignmentDpKey" />.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if <c>null</c> is specified</para>
      </exception>
      <value>
        <para>the port assignment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultOutEdgeComparer">
      <summary>
        <para>Gets or sets the default <see cref="T:System.Collections.Generic.IComparer`1" /> used for sorting the outgoing edges incident to nodes that do not have a specific <see cref="T:System.Collections.Generic.IComparer`1" />.</para>
      </summary>
      <remarks>
        <para>Such a comparator is defined using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.OutEdgeComparerDpKey" />.</para>
      </remarks>
      <value>
        <para>the default <see cref="T:System.Collections.Generic.IComparer`1" /> for outgoing edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle">
      <summary>
        <para>Gets or sets the currently used routing style for edges.</para>
      </summary>
      <value>
        <para>the routing style for the edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.MinimumPolylineSegmentLength">
      <summary>
        <para>Gets or sets the minimum vertical distance of the edge segments that are not orthogonal.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified length is smaller than <c>0</c></para>
      </exception>
      <value>
        <para>the minimum vertical distance</para>
      </value>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.MinimumSlope" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle" />
      <seealso cref="F:yWorks.Layout.SeriesParallel.RoutingStyle.Polyline" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.MinimumSlope">
      <summary>
        <para>Gets or sets the minimum slope which a non-orthogonal edge segment should have.</para>
      </summary>
      <remarks>
        <para>A higher minimum slope prevents those segments in very wide graphs from becoming nearly horizontal. The slope needs to have a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified slope is smaller than <c>0</c></para>
      </exception>
      <value>
        <para>the minimum slope for a non-orthogonal segment</para>
      </value>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.MinimumPolylineSegmentLength" />
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle" />
      <seealso cref="F:yWorks.Layout.SeriesParallel.RoutingStyle.Polyline" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.PreferredOctilinearSegmentLength">
      <summary>
        <para>Gets or sets the preferred length for non-orthogonal segments in octilinear edge routes.</para>
      </summary>
      <remarks>
        <para>If there is not enough space, those segments may be shorter than the specified length. The length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified length is smaller than <c>0</c></para>
      </exception>
      <value>
        <para>the preferred length for non-orthogonal segments in octilinear edge routes</para>
      </value>
      <seealso cref="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.RoutingStyle" />
      <seealso cref="F:yWorks.Layout.SeriesParallel.RoutingStyle.Octilinear" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.DefaultEdgeLayoutDescriptor">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor" /> instance used for all those edges that do not have a specific layout descriptor assigned.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified <see cref="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor" /> is <c>null</c></para>
      </exception>
      <value>
        <para>the current <see cref="T:yWorks.Layout.SeriesParallel.EdgeLayoutDescriptor" /> instance</para>
      </value>
      <seealso cref="F:yWorks.Layout.SeriesParallel.SeriesParallelLayout.EdgeLayoutDescriptorDpKey" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.MinimumNodeToNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance between nodes.</para>
      </summary>
      <remarks>
        <para>This distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is smaller than <c>0</c></para>
      </exception>
      <value>
        <para>the minimum distance between nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.MinimumNodeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between nodes and edges.</para>
      </summary>
      <remarks>
        <para>This distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is smaller than <c>0</c></para>
      </exception>
      <value>
        <para>the minimum distance between nodes and edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.MinimumEdgeToEdgeDistance">
      <summary>
        <para>Gets or sets the minimum distance between edges.</para>
      </summary>
      <remarks>
        <para>This distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is smaller than <c>0</c></para>
      </exception>
      <value>
        <para>the minimum distance between edges</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.FromSketchMode">
      <summary>
        <para>Gets or sets whether or not to take the coordinates of the input diagram into account when arranging the nodes.</para>
      </summary>
      <remarks>
        <para>The order of edges incident to the same source node will remain the same as in the original layout.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if input coordinates are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.ComponentLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for arranging the components of the graph is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that arranges the graph components is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.SeriesParallel.SeriesParallelLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="T:yWorks.Layout.SimpleProfitModel">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.SimpleProfitModel" /> implements the ranking for edge and node labels.</para>
      </summary>
      <remarks>
        <para>In this implementation node label positions have no ranking, the profit for all candidates is <c>1</c>.</para>
        <para>The ranking of edge label positions depends on the locations described in the <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> associated with an edge.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.SimpleProfitModel.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.SimpleProfitModel" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.SimpleProfitModel.GetProfit(yWorks.Layout.LabelCandidate)">
      <param name="candidate" />
    </member>
    <member name="T:yWorks.Layout.SliderEdgeLabelLayoutModel">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.SliderEdgeLabelLayoutModel" /> allows placement of labels at a set of continuous rotated positions along both sides of an edge or directly on the edge path.</para>
      </summary>
      <remarks>
        <para>It is possible to specify distance values that control the distance between label and edge and between label and nodes.</para>
        <para />
        <para>
          <see cref="F:yWorks.Layout.SliderMode.Center" /> mode on the left, <see cref="F:yWorks.Layout.SliderMode.Side" /> mode in the middle and <see cref="F:yWorks.Layout.SliderMode.SingleSide" /> on the right</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.SliderEdgeLabelLayoutModel.#ctor(yWorks.Layout.SliderMode)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.SliderEdgeLabelLayoutModel" /> with the given mode.</para>
      </summary>
      <param name="mode">
        <para>the slider mode</para>
      </param>
      <seealso cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Mode" />
    </member>
    <member name="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Mode">
      <summary>
        <para>Gets the model's slider mode which determines whether the label slides <see cref="F:yWorks.Layout.SliderMode.Center">on the edge</see>, <see cref="F:yWorks.Layout.SliderMode.Side">along both sides of the edge</see> or <see cref="F:yWorks.Layout.SliderMode.SingleSide">along one side of the edge</see>.</para>
      </summary>
      <value>
        <para>the model's slider mode</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SliderEdgeLabelLayoutModel.DistanceRelativeToEdge">
      <summary>
        <para>Gets or sets whether or not the distance to the edge is interpreted relative to the edge's path.</para>
      </summary>
      <remarks>
        <para>If enabled, the label is placed to the left of the edge segment (relative to the segment direction) if the given distance is less than <c>0</c> and to the right of the edge segment if the given distance is greater than <c>0</c>.</para>
        <para>If disabled, the label is placed below the edge segment (in geometric sense) if the distance is less than <c>0</c> and above the edge segment if the distance is greater than <c>0</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the distance is described relative to the edge, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Distance" />
    </member>
    <member name="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Distance">
      <summary>
        <para>Gets or sets the distance between the label's box and the edge's path.</para>
      </summary>
      <value>
        <para>the distance between the label's box and the edge's path</para>
      </value>
      <seealso cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.DistanceRelativeToEdge" />
    </member>
    <member name="P:yWorks.Layout.SliderEdgeLabelLayoutModel.AutoRotationEnabled">
      <summary>
        <para>Gets or sets whether or not edge labels are automatically rotated according to the angle of the corresponding reference edge segment.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels are automatically rotated according to the angle of the corresponding reference edge segment, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SliderEdgeLabelLayoutModel.AutoFlipping">
      <summary>
        <para>Gets or sets whether or not edge labels get flipped if they would be upside down in their current position.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if edge labels get flipped if they would be upside down in their current position, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Angle">
      <summary>
        <para>Gets or sets the angle (measured in radians) of the label model.</para>
      </summary>
      <remarks>
        <para>The angle is applied in clockwise direction.</para>
      </remarks>
      <value>
        <para>the angle of the label model</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.SliderEdgeLabelLayoutModel.DefaultParameter">
      <summary>
        <para>Gets a model parameter that encodes the default position of this model's allowed edge label positions.</para>
      </summary>
      <remarks>
        <para>This parameter can be passed to <see cref="M:yWorks.Layout.SliderEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)" /> to retrieve the corresponding label box.</para>
        <para>The default positions for the <see cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Mode">slider modes</see> are relative to the first edge segment, either at the beginning of the segment (<see cref="F:yWorks.Layout.SliderMode.Side" /> or <see cref="F:yWorks.Layout.SliderMode.SingleSide" />) or at its middle (<see cref="F:yWorks.Layout.SliderMode.Center" />).</para>
      </remarks>
      <value>
        <para>the model parameter describing the default placement of the edge label</para>
      </value>
      <seealso cref="P:yWorks.Layout.SliderEdgeLabelLayoutModel.Mode" />
    </member>
    <member name="M:yWorks.Layout.SliderEdgeLabelLayoutModel.GetLabelPlacement(yWorks.Algorithms.Geometry.YDimension,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout,System.Object)">
      <param name="labelSize" />
      <param name="edgeLayout" />
      <param name="sourceNode" />
      <param name="targetNode" />
      <param name="para" />
    </member>
    <member name="M:yWorks.Layout.SliderEdgeLabelLayoutModel.GetLabelCandidates(yWorks.Layout.IEdgeLabelLayout,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">
      <summary>
        <para>Returns all <see cref="T:yWorks.Layout.EdgeLabelCandidate" />s that describe valid label positions within this model.</para>
      </summary>
      <remarks>
        <para>The number of candidates and their respective locations are computed depending on the geometries of both label and edge.</para>
      </remarks>
      <param name="labelLayout">
        <para>the label for which candidates should be generated</para>
      </param>
      <param name="edgeLayout">
        <para>the layout of the edge to which the label belongs</para>
      </param>
      <param name="sourceLayout">
        <para>the layout of the source node of the label-owning edge</para>
      </param>
      <param name="targetLayout">
        <para>the layout of the target node of the label-owning edge</para>
      </param>
      <returns>
        <para>a list of <see cref="T:yWorks.Layout.EdgeLabelCandidate" /> instances</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.SliderEdgeLabelLayoutModel.CreateModelParameter(yWorks.Algorithms.Geometry.YOrientedRectangle,yWorks.Layout.IEdgeLayout,yWorks.Layout.INodeLayout,yWorks.Layout.INodeLayout)">
      <param name="labelBounds" />
      <param name="edgeLayout" />
      <param name="sourceNode" />
      <param name="targetNode" />
    </member>
    <member name="T:yWorks.Layout.SubgraphLayout">
      <summary>
        <para>A <see cref="T:yWorks.Layout.SubgraphLayout" /> is a <see cref="T:yWorks.Layout.ILayoutStage" /> that filters out all graph elements that are not part of a specific subgraph.</para>
      </summary>
      <remarks>
        <para>The nodes that induce this subgraph are marked using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with a <see cref="P:yWorks.Layout.SubgraphLayout.AffectedNodesDpKey">specific key</see>. They will be arranged by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.SubgraphLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.SubgraphLayout" /> instance with an optional <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="coreLayouter">
        <para>The core layout algorithm.</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.SubgraphLayout.AffectedNodesDpKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> which marks the nodes that induce the subgraph to be arranged.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified key is <c>null</c></para>
      </exception>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.SubgraphLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Delegates the arrangement of the <see cref="P:yWorks.Layout.SubgraphLayout.AffectedNodesDpKey">specified subgraph</see> of the given graph to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Swimlanes">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Swimlanes" /> provides helper classes and methods to handle swimlanes.</para>
      </summary>
      <remarks>
        <para>It is used by <see cref="T:yWorks.Layout.Hierarchic.HierarchicLayout" /> to arrange the nodes in lanes.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Layout.Swimlanes.SwimlaneRepresentative">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Swimlanes.SwimlaneRepresentative">SwimlaneRepresentative</see> represents the position and arrangement mode for a swimlane.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Swimlanes.SwimlaneRepresentative.#ctor(System.Int32,System.Boolean)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Swimlanes.SwimlaneRepresentative" /> instance.</para>
      </summary>
      <param name="swimlanePos">
        <para>denotes the current position of the represented swimlane</para>
      </param>
      <param name="allowRearrangement">
        <para>
          <c>true</c> if the represented swimlane may be <see cref="P:yWorks.Layout.Swimlanes.SwimlaneRepresentative.AllowRearrangement">rearranged</see>, <c>false</c> otherwise</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Swimlanes.SwimlaneRepresentative.SwimlanePos">
      <summary>
        <para>Gets or sets the current position of the represented swimlane.</para>
      </summary>
      <remarks>
        <para>The swimlane positions are described by a zero-based index and must not be negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the position is smaller than <c>0</c></para>
      </exception>
      <value>
        <para>the current position of the swimlane</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Swimlanes.SwimlaneRepresentative.AllowRearrangement">
      <summary>
        <para>Gets or sets whether or not the represented swimlane can be rearranged.</para>
      </summary>
      <remarks>
        <para>For all swimlanes with disabled rearrangement, the relative ordering given by <see cref="P:yWorks.Layout.Swimlanes.SwimlaneRepresentative.SwimlanePos" /> is preserved. The other swimlanes may be rearranged.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the represented swimlane can be rearranged, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Swimlanes.ArrangeSwimlanes(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Calculates an ordering of the swimlanes.</para>
      </summary>
      <remarks>
        <para>The ordering will try to reduce:</para>
        <list type="number">
          <item>the number of swimlanes traversed by edges</item>
          <item>the number of swimlanes spanned by <see cref="M:yWorks.Layout.Grouping.GroupingSupport.IsGroupNode(yWorks.Algorithms.Node)">group nodes</see></item>
        </list>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node2Swimlane">
        <para>the assignment of nodes to swimlanes</para>
      </param>
      <seealso cref="T:yWorks.Layout.Swimlanes.SwimlaneRepresentative" />
      <seealso cref="T:yWorks.Layout.Grouping.GroupingSupport" />
    </member>
    <member name="M:yWorks.Layout.Swimlanes.ArrangeSwimlanes(yWorks.Algorithms.Graph,yWorks.Algorithms.IDataProvider,System.Int32,yWorks.Layout.SwimlanesMode)">
      <summary>
        <para>Calculates an ordering of the swimlanes considering the specified ordering mode.</para>
      </summary>
      <remarks>
        <para>Depending on the swimlane mode, the ordering will try to reduce:</para>
        <list type="number">
          <item>the number of swimlanes traversed by edges</item>
          <item>the number of swimlanes spanned by <see cref="M:yWorks.Layout.Grouping.GroupingSupport.IsGroupNode(yWorks.Algorithms.Node)">group nodes</see></item>
        </list>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node2Swimlane">
        <para>the assignment of nodes to swimlanes</para>
      </param>
      <param name="iterations">
        <para>the number of iterations performed by the heuristic.</para>
      </param>
      <param name="mode">
        <para>one of the valid swimlane ordering mode specifier</para>
      </param>
      <seealso cref="T:yWorks.Layout.Swimlanes.SwimlaneRepresentative" />
      <seealso cref="T:yWorks.Layout.Grouping.GroupingSupport" />
    </member>
    <member name="T:yWorks.Layout.Transformer.OperationType">
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
    </member>
    <member name="F:yWorks.Layout.Transformer.OperationType.MirrorXAxis">
      <summary>
        <para>Operation specifier defining that the graph will be mirrored at the x-axis.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
    </member>
    <member name="F:yWorks.Layout.Transformer.OperationType.MirrorYAxis">
      <summary>
        <para>Operation specifier defining that the graph will be mirrored at the y-axis.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
    </member>
    <member name="F:yWorks.Layout.Transformer.OperationType.Rotate">
      <summary>
        <para>Operation specifier defining that the graph will be rotated.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.RotationAngle" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled" />
    </member>
    <member name="F:yWorks.Layout.Transformer.OperationType.Scale">
      <summary>
        <para>Operation specifier defining that the graph will be scaled.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactor" />
      <seealso cref="M:yWorks.Layout.Transformer.GraphTransformer.SetScaleFactors(System.Double,System.Double)" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.ScaleNodeSize" />
    </member>
    <member name="F:yWorks.Layout.Transformer.OperationType.Translate">
      <summary>
        <para>Operation specifier defining that the graph will be translated.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.TranslateX" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.TranslateY" />
    </member>
    <member name="T:yWorks.Layout.Transformer.GraphTransformer">
      <summary>
        <para>This layout algorithm applies geometric transformations to (sub-)graphs.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> There are several ways to transform the graph that include mirroring, rotating, scaling and translating. </para>
        <para>The highlighted subgraph is rotated by <c>45</c> degrees</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>The layout can be <see cref="F:yWorks.Layout.Transformer.OperationType.Scale">scaled</see> with independent factors for the horizontal and vertical scaling. Optionally, the sizes of nodes can be scaled, too.</para>
        <para>The layout can be mirrored either on the <see cref="F:yWorks.Layout.Transformer.OperationType.MirrorXAxis">x-axis</see> or the <see cref="F:yWorks.Layout.Transformer.OperationType.MirrorYAxis">y-axis</see>.</para>
        <para>A <see cref="F:yWorks.Layout.Transformer.OperationType.Rotate">rotation</see> can be specified. Instead of <see cref="P:yWorks.Layout.Transformer.GraphTransformer.RotationAngle">defining</see> a rotation angle the angle can be <see cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled">determined automatically</see> to fit specific bounds.</para>
        <para>The coordinates in the layout can be <see cref="F:yWorks.Layout.Transformer.OperationType.Translate">translated</see> by a specific vector.</para>
        <para>To only apply previously mentioned transformations to a subgraph, the <see cref="T:yWorks.Layout.SubgraphLayout" /> needs to be <see cref="P:yWorks.Layout.MultiStageLayout.SubgraphLayoutEnabled">enabled</see>. Then the nodes in the subgraph must be marked in a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the according <see cref="P:yWorks.Layout.SubgraphLayout.AffectedNodesDpKey">key</see>.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Transformer.GraphTransformer.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Transformer.GraphTransformer" /> with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.Operation">
      <summary>
        <para>Gets or sets the transformation operation.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified operation is unknown</para>
      </exception>
      <value>
        <para>one of the valid operation specifiers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.RotationAngle">
      <summary>
        <para>Gets or sets the angle of rotation.</para>
      </summary>
      <remarks>
        <para>The angle must be given in degrees.</para>
      </remarks>
      <value>
        <para>the rotation angle in degrees</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Rotate" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled">
      <summary>
        <para>Gets or sets whether or not to automatically choose the best fitting rotation angle.</para>
      </summary>
      <remarks>
        <para>The angle will be chosen such that the bounding box after the rotation fits best to the <see cref="M:yWorks.Layout.Transformer.GraphTransformer.PreferredLayoutSize(System.Double,System.Double)">preferred aspect ratio</see>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the best fitting rotation angle should be automatically determined, <c>false</c> if the specified angle should be used</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Rotate" />
    </member>
    <member name="M:yWorks.Layout.Transformer.GraphTransformer.PreferredLayoutSize(System.Double,System.Double)">
      <summary>
        <para>Specifies the preferred size of the layout.</para>
      </summary>
      <remarks>
        <para>If performing a <see cref="F:yWorks.Layout.Transformer.OperationType.Rotate">rotation</see> and this rotation should be <see cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled">automatically fitted</see>, then the given preferred size defines the aspect ratio that will be used for fitting the layout rotation.</para>
        <para>The preferred width and height need to be non-negative.</para>
      </remarks>
      <param name="width">
        <para>the preferred width of the layout</para>
      </param>
      <param name="height">
        <para>the preferred height of the layout</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the specified width or height is negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.PreferredWidth" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.PreferredHeight" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Rotate" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.PreferredHeight">
      <summary>
        <para>Gets or sets the preferred height of the layout.</para>
      </summary>
      <remarks>
        <para>This value will be used for <see cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled">fitting the rotation</see> to preferred bounds.</para>
        <para>The preferred height needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified height is negative</para>
      </exception>
      <value>
        <para>the preferred height of the layout</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.PreferredWidth" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Rotate" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.PreferredWidth">
      <summary>
        <para>Gets or sets the preferred width of the layout.</para>
      </summary>
      <remarks>
        <para>This value will be used for <see cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled">fitting the rotation</see> to preferred bounds.</para>
        <para>The preferred width needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified width is negative</para>
      </exception>
      <value>
        <para>the preferred width of the layout</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.PreferredHeight" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Rotate" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.ScaleNodeSize">
      <summary>
        <para>Gets or sets whether or not to also scale node sizes when performing the <see cref="F:yWorks.Layout.Transformer.OperationType.Scale">scale operation</see>.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the sizes of the nodes are also scaled, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Scale" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactor">
      <summary>
        <para>Sets the uniform scaling factor used for the <see cref="F:yWorks.Layout.Transformer.OperationType.Scale">scale operation</see>.</para>
      </summary>
      <remarks>
        <para>This factor applies vertical and horizontal.</para>
        <para>Only positive scaling factors are allowed.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified scaling factor is negative or <c>0</c></para>
      </exception>
      <value>
        <para>the scaling factor</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactorX" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactorY" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Scale" />
    </member>
    <member name="M:yWorks.Layout.Transformer.GraphTransformer.SetScaleFactors(System.Double,System.Double)">
      <summary>
        <para>Specifies the horizontal and vertical scaling factor used for the <see cref="F:yWorks.Layout.Transformer.OperationType.Scale">scale operation</see>.</para>
      </summary>
      <remarks>
        <para>Only positive scaling factors are allowed.</para>
      </remarks>
      <param name="xFactor">
        <para>the horizontal scaling factor</para>
      </param>
      <param name="yFactor">
        <para>the vertical scaling factor</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if one the specified scaling factors is negative or <c>0</c></para>
      </exception>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactorX" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactorY" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Scale" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactorY">
      <summary>
        <para>Gets or sets the vertical scaling factor used for the <see cref="F:yWorks.Layout.Transformer.OperationType.Scale">scale operation</see>.</para>
      </summary>
      <remarks>
        <para>Only positive scaling factors are allowed.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified scaling factor is negative or <c>0</c></para>
      </exception>
      <value>
        <para>the vertical scaling factor</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactorX" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Scale" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactorX">
      <summary>
        <para>Gets or sets the horizontal scaling factor used for the <see cref="F:yWorks.Layout.Transformer.OperationType.Scale">scale operation</see>.</para>
      </summary>
      <remarks>
        <para>Only positive scaling factors are allowed.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified scaling factor is negative or <c>0</c></para>
      </exception>
      <value>
        <para>the horizontal scaling factor</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.ScaleFactorY" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Scale" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.TranslateX">
      <summary>
        <para>Gets or sets the horizontal translation distance.</para>
      </summary>
      <remarks>
        <para>A positive value means the graph is moved to the right while, a negative value means the graph is moved to the left.</para>
      </remarks>
      <value>
        <para>the translation distance along the x-axis</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.TranslateY" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Translate" />
    </member>
    <member name="P:yWorks.Layout.Transformer.GraphTransformer.TranslateY">
      <summary>
        <para>Gets or sets the vertical translation distance.</para>
      </summary>
      <remarks>
        <para>A positive value means the graph is moved downwards, while a negative value means the graph is moved upwards.</para>
      </remarks>
      <value>
        <para>the translation distance along the y-axis</para>
      </value>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.TranslateX" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Translate" />
    </member>
    <member name="M:yWorks.Layout.Transformer.GraphTransformer.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Applies the selected transformation to the given graph after invoking the optional <see cref="P:yWorks.Layout.Transformer.GraphTransformer.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Transformer.GraphTransformer.ApplyBestFitRotationAngle(yWorks.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>
        <para>Rotates the given graph so its resulting bounding box fits best to the given bounds.</para>
      </summary>
      <param name="graph">
        <para>the graph that is rotated</para>
      </param>
      <param name="width">
        <para>the width of the preferred layout bounds</para>
      </param>
      <param name="height">
        <para>the height of the preferred layout bounds</para>
      </param>
      <returns>
        <para>the rotation angle</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.BestFitRotationEnabled" />
    </member>
    <member name="M:yWorks.Layout.Transformer.GraphTransformer.FindBestFitRotationAngle(yWorks.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>
        <para>Returns the rotation angle for the graph that will result in a layout that fits best to the given bounds.</para>
      </summary>
      <param name="graph">
        <para>the graph that is rotated</para>
      </param>
      <param name="width">
        <para>the width of the preferred layout bounds</para>
      </param>
      <param name="height">
        <para>the height of the preferred layout bounds</para>
      </param>
      <returns>
        <para>the rotation angle</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Transformer.GraphTransformer.ApplyBestFitRotationAngle(yWorks.Layout.LayoutGraph,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Transformer.GraphTransformer.SetMaximalBounds(yWorks.Layout.LayoutGraph,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Fits the given graph into the specified rectangular bounds.</para>
      </summary>
      <remarks>
        <para>If the bounding box fits in the given bounds, nothing is done. Otherwise, the graph is scaled and optionally moved to fit.</para>
      </remarks>
      <param name="graph">
        <para>the graph to modify</para>
      </param>
      <param name="x">
        <para>the upper left x-coordinate of the bounds</para>
      </param>
      <param name="y">
        <para>the upper left y-coordinate of the bounds</para>
      </param>
      <param name="w">
        <para>the width of the bounds</para>
      </param>
      <param name="h">
        <para>the height of the bounds</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Transformer.GraphTransformer.Translate(yWorks.Layout.LayoutGraph,System.Double,System.Double)">
      <summary>
        <para>Translates the layout coordinates by the given vector.</para>
      </summary>
      <param name="graph">
        <para>the graph that is translated</para>
      </param>
      <param name="dx">
        <para>the horizontal distance the given graph is moved</para>
      </param>
      <param name="dy">
        <para>the vertical distance the given graph is moved</para>
      </param>
      <seealso cref="F:yWorks.Layout.Transformer.OperationType.Translate" />
      <seealso cref="P:yWorks.Layout.Transformer.GraphTransformer.Operation" />
    </member>
    <member name="T:yWorks.Layout.Tree.AspectRatioNodePlacer">
      <summary>
        <para>This <see cref="T:yWorks.Layout.Tree.INodePlacer" /> places the subtrees such that the overall aspect ratio of the arranged subtree will be close to a preferred aspect ratio.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The aspect ratio describes the relation between width and height of the subtree. To achieve the desired aspect ratio, this <see cref="T:yWorks.Layout.Tree.INodePlacer" /> divides the child <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s into as much rows as needed. The edges are either routed along the rows or along the columns. </para>
        <para>Aspect ratio <c>1</c></para>
        <para />
        <para>Aspect ratio <c>0.5</c></para>
        <para />
        <para>Aspect ratio <c>2</c></para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioNodePlacer.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Tree.AspectRatioNodePlacer" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node depending on whether or not the child nodes are arranged <see cref="P:yWorks.Layout.Tree.AspectRatioNodePlacer.Horizontal">horizontally</see>.</para>
      </summary>
      <remarks>
        <para>If the child nodes are distributed horizontally, the edge should connect <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North">north</see>, otherwise it should connect <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.West">west</see>.</para>
      </remarks>
      <param name="child">
        <para>the child node</para>
      </param>
      <returns>
        <para>
          <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" /> if nodes are placed in rows, <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.West" /> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Arranges the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see> of children of the local root node in rows or columns that fit the specified <see cref="P:yWorks.Layout.Tree.AspectRatioNodePlacer.AspectRatio">aspect ratio</see>.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction of the connector</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> containing the local root and all its subtrees</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioNodePlacer.Horizontal">
      <summary>
        <para>Gets or sets whether child nodes are distributed in horizontal rows or vertical columns.</para>
      </summary>
      <value>
        <para>
          <c>true</c> for horizontal rows, <c>false</c> for vertical columns</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioNodePlacer.VerticalDistance">
      <summary>
        <para>Gets or sets the vertical distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </summary>
      <remarks>
        <para>The nodes will be placed below each other, keeping this distance.</para>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the vertical distance between elements</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioNodePlacer.HorizontalDistance">
      <summary>
        <para>Gets or sets the horizontal distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </summary>
      <remarks>
        <para>The nodes will be placed next to each other, keeping this distance.</para>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the horizontal distance between elements</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioNodePlacer.AspectRatio">
      <summary>
        <para>Gets or sets the preferred aspect ratio (width/height) for the subtrees.</para>
      </summary>
      <remarks>
        <para>This ratio determines among how many rows/columns the nodes will be distributed.</para>
        <para>The aspect ratio needs to be positive.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified aspect ratio is <c>0</c> or negative</para>
      </exception>
      <value>
        <para>the preferred ratio between width and height</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioNodePlacer.FillStyle">
      <summary>
        <para>Gets or sets how rows/columns are aligned with each other.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown fill style is specified</para>
      </exception>
      <value>
        <para>one of the predefined fill styles</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioNodePlacer.CreateFromSketchComparer">
      <summary>
        <para>Creates an <see cref="T:System.Collections.Generic.IComparer`1">edge comparator</see> which takes the initial coordinates of the nodes into account.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:System.Collections.Generic.IComparer`1" /> defines the order of the outgoing edges of a node before the actual placement of the node's subtree is calculated. It also considers whether or not the rows are placed <see cref="P:yWorks.Layout.Tree.AspectRatioNodePlacer.Horizontal">horiontally</see>.</para>
      </remarks>
      <returns>
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> for the edges</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.AspectRatioTreeLayout">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.AspectRatioTreeLayout" /> arranges tree graphs in a compact fashion.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> This layout algorithm tries to generate compact tree layouts with a certain preferred aspect ratio. </para>
        <para>Example layout with an aspect ratio of <c>0.5</c></para>
        <para>
          <h2>Concept</h2>
        </para>
        <para>The layout algorithm starts from the root and recursively assigns coordinates to all tree nodes. In this manner, leaf nodes will be placed first, while each parent node is placed centered above its child nodes.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>The aspect ratio of each subtree can be specified individually. A <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeAspectRatioDpKey" /> returns the aspect ratio for each local root node.</para>
        <para>A custom node can be defined as root of the tree using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SelectedRootDpKey" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeAspectRatioDpKey">
      <summary>
        <para>A data provider key for specifying a target aspect ratio for each subtree.</para>
      </summary>
      <remarks>
        <para>The aspect ratio needs to be greater than <c>0</c>.</para>
        <list type="bullet">
          <item>aspect ratio <c>1</c>: width and height of the layout should be the same</item>
          <item>aspect ratio between <c>0</c> and <c>1</c>: the height of the layout should be greater than its width</item>
          <item>aspect ratio greater than <c>1</c>: the width of the layout should be greater than its height</item>
        </list>
        <para>If no specific ratio is defined for a subtree, the layout algorithm falls back to the default <see cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.AspectRatio">aspect ratio</see>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacementDpKey">
      <summary>
        <para>A data provider key for specifying the placement of each subtree root.</para>
      </summary>
      <remarks>
        <para>If no root placement is specified for one of the subtree roots, the default <see cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacement">root placement</see> will be used.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeRoutingPolicyDpKey">
      <summary>
        <para>A data provider key for specifying the routing direction for each subtree root.</para>
      </summary>
      <remarks>
        <para>The children in a subtree are arranged either horizontally or vertically. The edges are routed to the top of the child nodes or at the side, respectively. Directions depend on the <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see> and refer to <see cref="F:yWorks.Layout.LayoutOrientation.TopToBottom" /> for this description.</para>
        <para>If no specific routing policy is specified for a subtree root, the layout algorithm uses the default <see cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeArrangement">routing direction</see>.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SelectedRootDpKey">
      <summary>
        <para>A data provider key for marking the node that will be used as root node of the tree.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.AspectRatioTreeLayout.graph">
      <summary>
        <para>The input graph this algorithm is handling.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioTreeLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.AspectRatioTreeLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.HorizontalDistance">
      <summary>
        <para>Gets or sets the horizontal distance between adjacent nodes.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the horizontal distance between nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.VerticalDistance">
      <summary>
        <para>Gets or sets the vertical distance between adjacent nodes.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the vertical distance between nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.ComponentLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for arranging the components of the graph is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that arranges the graph components is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.HideGroupsStageEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for hiding group nodes is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage used for hiding group nodes is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStage" />
      <seealso cref="T:yWorks.Layout.Grouping.HideGroupsStage" />
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.ParallelEdgeRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing parallel edges is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing parallel edges is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouter" />
      <seealso cref="T:yWorks.Layout.ParallelEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioTreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Arranges the given graph considering the specified <see cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.AspectRatio">aspect ratio</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <exception cref="T:yWorks.Algorithms.InvalidGraphStructureException">
        <para>if the input graph is not a tree</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioTreeLayout.GetAspectRatio(yWorks.Algorithms.Node)">
      <summary>
        <para>Retrieves the aspect ratio for the subtree that is rooted at the given node.</para>
      </summary>
      <remarks>
        <para>If there is an individual aspect ratio for the subtree provided by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeAspectRatioDpKey" />, that ratio will be returned. Otherwise, the <see cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.AspectRatio">default aspect ratio</see> will be returned.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> before a subtree is arranged. It may be overridden to use another approach to define the aspect ratio for subtrees.</para>
      </remarks>
      <param name="localRoot">
        <para>the root node of the subtree</para>
      </param>
      <returns>
        <para>the aspect ratio of the subtree rooted at the local root node</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeAspectRatioDpKey" />
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.AspectRatio" />
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioTreeLayout.GetSuccessors(yWorks.Algorithms.Node)">
      <summary>
        <para>Retrieves all children of the given local root.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> to arrange the subtrees below the local root.</para>
      </remarks>
      <param name="localRoot">
        <para>the root of a subtree</para>
      </param>
      <returns>
        <para>all successors of the given node</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.Comparer">
      <summary>
        <para>Gets or sets the <see cref="T:System.Collections.Generic.IComparer`1" /> that will be used for sorting the <see cref="M:yWorks.Algorithms.Node.SortOutEdges(System.Collections.Generic.IComparer{System.Object})">outgoing edges</see> of each local root in the tree before they are being arranged.</para>
      </summary>
      <value>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> or <c>null</c> if the default order should be used</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioTreeLayout.CreateBends(yWorks.Layout.IEdgeLayout,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Layout.Tree.RootPlacement,yWorks.Layout.Tree.SubtreeArrangement)">
      <summary>
        <para>Adds bends to the given <see cref="T:yWorks.Layout.IEdgeLayout" />.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> for each edge, after the nodes are placed, to route the path of the edges. It may be overridden to apply a custom routing style.</para>
      </remarks>
      <param name="edgeLayout">
        <para>the layout of the edge that is routed</para>
      </param>
      <param name="localRoot">
        <para>the local root of the subtree</para>
      </param>
      <param name="child">
        <para>the child connected to the local root with the given edge</para>
      </param>
      <param name="rootPlacement">
        <para>the placement specifier of the local root</para>
      </param>
      <param name="routingPolicy">
        <para>the direction specifier for the routing</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioTreeLayout.GetSubtreeArrangement(System.Object)">
      <summary>
        <para>Retrieves the routing for the subtree that is rooted at the given node.</para>
      </summary>
      <remarks>
        <para>Either an individual routing for the subtree (defined via a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeRoutingPolicyDpKey" />), or if there is none, the <see cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeArrangement">default routing</see> is returned.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> to determine the direction of the subtrees. It may be overridden to use another approach to define the routing for a subtree.</para>
      </remarks>
      <param name="localRoot">
        <para>the root of the subtree</para>
      </param>
      <returns>
        <para>the routing policy for the subtree</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeRoutingPolicyDpKey" />
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeArrangement" />
    </member>
    <member name="M:yWorks.Layout.Tree.AspectRatioTreeLayout.GetRootPlacement(System.Object)">
      <summary>
        <para>Retrieves the root placement for the subtree that is rooted at the given node.</para>
      </summary>
      <remarks>
        <para>Either an individual root placement for the subtree (defined via a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacementDpKey" />), or if there is none, the <see cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacement">default root placement</see> is returned.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" /> after a subtree is arranged to align the local root node. It may be overridden to use another approach to define the root placement for a subtree.</para>
      </remarks>
      <param name="localRoot">
        <para>the root of the subtree</para>
      </param>
      <returns>
        <para>the root placement of the subtree</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacementDpKey" />
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacement" />
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.AspectRatio">
      <summary>
        <para>Gets or sets the default aspect ratio for this <see cref="T:yWorks.Layout.Tree.AspectRatioTreeLayout" />.</para>
      </summary>
      <remarks>
        <para>This aspect ratio is used for all subtrees for which there is no specific aspect ratio defined in a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeAspectRatioDpKey" />.</para>
        <para>The aspect ratio needs to have a positive value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified aspect ratio is <c>0</c> or negative</para>
      </exception>
      <value>
        <para>the aspect ratio</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacement">
      <summary>
        <para>Gets or sets the desired placement of the tree's root node.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown placement specifiers is set</para>
      </exception>
      <value>
        <para>one of <see cref="F:yWorks.Layout.Tree.RootPlacement.Top" />, <see cref="F:yWorks.Layout.Tree.RootPlacement.Corner" />, <see cref="F:yWorks.Layout.Tree.RootPlacement.CornerSide" /> or <see cref="F:yWorks.Layout.Tree.RootPlacement.CornerTop" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeArrangement">
      <summary>
        <para>Gets or sets how the children of a local root are arranged and how the edges between them are routed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified routing policy is unknown</para>
      </exception>
      <value>
        <para>one of <see cref="F:yWorks.Layout.Tree.SubtreeArrangement.Horizontal" /> or <see cref="F:yWorks.Layout.Tree.SubtreeArrangement.Vertical" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.AspectRatioTreeLayout.BendDistance">
      <summary>
        <para>Gets or sets the preferred distance between any two bends of an edge.</para>
      </summary>
      <remarks>
        <para>Additionally, the preferred bend distance governs the distance between the first and last edges and the corresponding ports.</para>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the preferred bend distance</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Tree.AssistantNodePlacer">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.AssistantNodePlacer" /> places nodes that are marked as assistants left and right of their parents and all other nodes below the assistant nodes.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> </para>
        <para>Assistants are marked</para>
        <para>
          <h2>Concept</h2> This <see cref="T:yWorks.Layout.Tree.INodePlacer" /> delegates the placement of all assistant nodes to an instance of <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" />. The non-assistant nodes are handled by another <see cref="P:yWorks.Layout.Tree.AssistantNodePlacer.ChildNodePlacer">node placer</see>. To be able to do this, <see cref="T:yWorks.Layout.Tree.AssistantNodePlacer" /> uses a <see cref="T:yWorks.Layout.Tree.IProcessor" /> which prepares the graph for node placing.</para>
        <para>A <see cref="T:yWorks.Algorithms.IDataProvider" /> that is registered using <see cref="F:yWorks.Layout.Tree.AssistantNodePlacer.AssistantNodeDpKey" /> returns <c>true</c> for assistant nodes and <c>false</c> for all other nodes.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.AssistantNodePlacer.AssistantNodeDpKey">
      <summary>
        <para>A data provider key for marking which nodes are placed as assistants.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.AssistantNodePlacer" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.AssistantNodePlacer" /> instance that uses the transformation defined by the given matrix.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this method is called</para>
      </exception>
      <param name="child" />
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Delegates the calculation of the child connectors to the <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" /> which arranges the assistant nodes.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="connectorMap">
        <para>the map that must be used for storing the direction specifiers of the child nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Tree.IProcessor" /> that prepares the graph for placing assistant node.</para>
      </summary>
      <remarks>
        <para>The pre-processing step adds a dummy node as a child to the current root and changes all edges of non-assistant children such that they start at this dummy node. That way, <see cref="T:yWorks.Layout.Tree.AssistantNodePlacer" /> is able to delegate the assistant nodes to a <see cref="T:yWorks.Layout.Tree.INodePlacer" /> different from the one used for placing non-assistant nodes. The <see cref="P:yWorks.Layout.Tree.AssistantNodePlacer.ChildNodePlacer">child node placer</see> is assigned to the dummy node. So the non-assistant children are placed by this delegate placer.</para>
        <para>All changes will be cleaned up during the post-processing step.</para>
      </remarks>
      <param name="layouter">
        <para>the current <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the root node handled by this <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.IProcessor" /> instance that prepares the graph for <see cref="T:yWorks.Layout.Tree.AssistantNodePlacer" /></para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Tree.AssistantNodePlacer.Spacing">
      <summary>
        <para>Gets or sets the spacing between subtrees for the delegate <see cref="T:yWorks.Layout.Tree.INodePlacer" />.</para>
      </summary>
      <remarks>
        <para>The spacing needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given spacing is negative</para>
      </exception>
      <value>
        <para>the distance between subtrees</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Delegates the arrangement of <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s to an instance of <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" />.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" /> places all assistant nodes left and right of the local root node. The <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> associated with the dummy node which contains <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s of the non-assistant nodes is placed below the assistant nodes, center-aligned with respect to the local root node.</para>
      </remarks>
      <param name="nodeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for obtaining an initial shape of the root node</para>
      </param>
      <param name="subtreeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for accessing the pre-calculated shapes of the subtrees</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="localRoot">
        <para>the root of the subtree that should be arranged by this method</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> containing the local root and all assistant nodes and non-assistant nodes</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Arranges the local root relative to the subtree shape of its children.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this method is called</para>
      </exception>
      <param name="localRoot" />
      <param name="parentConnectorDirection" />
    </member>
    <member name="P:yWorks.Layout.Tree.AssistantNodePlacer.ChildNodePlacer">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance that places the non-assistant children.</para>
      </summary>
      <remarks>
        <para>These non-assistant child nodes will be placed below the assistant child nodes and are arranged by the given <see cref="T:yWorks.Layout.Tree.INodePlacer" />. Non-assistant child nodes are the ones that are not marked in the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Tree.AssistantNodePlacer.AssistantNodeDpKey" />.</para>
      </remarks>
      <value>
        <para>the child node placer for the non-assistant children</para>
      </value>
      <seealso cref="F:yWorks.Layout.Tree.AssistantNodePlacer.AssistantNodeDpKey" />
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.CreateComparer">
      <summary>
        <para>Delegates the creation of <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.CreateFromSketchComparer">from-sketch comparators</see> to the two <see cref="T:yWorks.Layout.Tree.INodePlacer" />s handling assistant and non-assistant nodes.</para>
      </summary>
      <remarks>
        <para>The from-sketch <see cref="T:System.Collections.Generic.IComparer`1" />s are <see cref="M:yWorks.Layout.Tree.AssistantNodePlacer.CreateCompoundComparer(System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object})">combined</see> into a compound comparator. The one for the edges connecting to assistant nodes is retrieved from a <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" /> while the other one is provided by the <see cref="P:yWorks.Layout.Tree.AssistantNodePlacer.ChildNodePlacer">child placer</see>.</para>
      </remarks>
      <returns>
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> to compare edges, considering the initial locations of their target nodes</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Tree.AssistantNodePlacer.ChildNodePlacer" />
      <seealso cref="M:yWorks.Layout.Tree.AssistantNodePlacer.CreateCompoundComparer(System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object})" />
      <seealso cref="M:yWorks.Layout.Tree.IFromSketchNodePlacer.CreateFromSketchComparer" />
    </member>
    <member name="M:yWorks.Layout.Tree.AssistantNodePlacer.CreateCompoundComparer(System.Collections.Generic.IComparer{System.Object},System.Collections.Generic.IComparer{System.Object})">
      <summary>
        <para>Creates a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares outgoing edges connecting to assistant nodes and edges connecting to non-assistant nodes separately.</para>
      </summary>
      <param name="assistantComparator">
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> for edges connecting to <em>assistant</em> nodes</para>
      </param>
      <param name="childComparator">
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> for edges connecting to <em>non-assistant</em> nodes</para>
      </param>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that compares edges to assistant nodes separately from edges to non-assistant nodes</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.BalloonLayout">
      <summary>
        <para>A tree layout algorithm that arranges the subtrees of the tree in a balloon-like fashion.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> <see cref="T:yWorks.Layout.Tree.BalloonLayout" /> is designed to arrange directed and undirected tree graphs. Subtrees rooted at a node are placed in a radial fashion around their root node. All direct children of one node can be placed on a common circle around their parent node (depending on the <see cref="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy">alignment policy</see>). Therefore, subtrees look like balloons or stars, especially if subtrees have similar sizes. The edges of the tree are drawn as straight lines.  Sample balloon-drawing of a large tree obtained with default settings  Sample balloon-drawing featuring interleaved child placement and ray-like node labels <h2>Concept</h2> The algorithm executes the following steps:</para>
        <list type="number">
          <item>Select a root node according to the specified <see cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy">root policy</see>.</item>
          <item>Determine the placement of subtrees around the root using a bottom-up recursive approach (starting with leaf nodes).</item>
          <item>Assign the actual coordinates of nodes, again using a recursive approach (starting with the root node).</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>The algorithm features integrated <see cref="P:yWorks.Layout.Tree.BalloonLayout.IntegratedEdgeLabeling">edge labeling</see> as well as <see cref="P:yWorks.Layout.Tree.BalloonLayout.IntegratedNodeLabeling">node labeling</see>. Edge labels and node labels are placed automatically without generating overlaps with other labels or graph elements. There are different <see cref="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelingPolicy">ways</see> to place node labels. Edge labeling will take the settings of <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> into account.</para>
        <para>Defining a <see cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge">preferred wedge angle</see> has a great influence on the layout style. Subtrees rooted at a node get a certain amount of radial space to be placed around the parent node, such that a preferred angle close to <c>360</c> degrees will generate drawings where subtrees look like balloons, while an angle close to <c>180</c> degrees could be chosen to get drawings where subtrees look like semicircles.</para>
        <para>Since it is computationally not very complex, <see cref="T:yWorks.Layout.Tree.BalloonLayout" /> is very well suited for large tree graphs. It performs well even for huge graphs.</para>
        <para>This layout algorithm can only handle graphs with a tree structure. To apply it to a general graph, a <see cref="T:yWorks.Layout.Tree.TreeReductionStage" /> can be appended. This stage will temporarily remove some edges of the input graph until a tree is obtained. These edges will later be reinserted and routed separately.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.BalloonLayout.InterleavedNodesDpKey">
      <summary>
        <para>A data provider key for marking nodes whose child nodes should be placed in an interleaved fashion.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Algorithms.IDataProvider" /> allows to individually configure the interleaving feature for each node in the graph.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.InterleavedMode" />
    </member>
    <member name="F:yWorks.Layout.Tree.BalloonLayout.SelectedRootDpKey">
      <summary>
        <para>A data provider key for marking the node that will be used as root node of the tree.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.BalloonLayout.graph">
      <summary>
        <para>The layout graph being acted upon.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.BalloonLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.BalloonLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.Comparer">
      <summary>
        <para>Gets or sets the <see cref="T:System.Collections.Generic.IComparer`1" /> instance that determines the order of the outgoing edges for each node of the tree.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:System.Collections.Generic.IComparer`1" /> is specified (i.e. the <see cref="T:System.Collections.Generic.IComparer`1" /> is <c>null</c>), the outgoing edges will be sorted according to the current <see cref="P:yWorks.Layout.Tree.BalloonLayout.ChildOrderingPolicy">child ordering policy</see>.</para>
      </remarks>
      <value>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> instance to sort outgoing edges or <c>null</c> if edges are sorted according to the <see cref="P:yWorks.Layout.Tree.BalloonLayout.ChildOrderingPolicy">child ordering policy</see></para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildOrderingPolicy" />
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.FromSketchMode" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.ChildOrderingPolicy">
      <summary>
        <para>Gets or sets the child ordering policy for sorting the child nodes around their parents.</para>
      </summary>
      <remarks>
        <para>The sorting policy can affect the compactness of drawings. Advantageous orderings allow adjacent subtrees to be close together and can thus make the whole layout more compact.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown ordering policy is given</para>
      </exception>
      <value>
        <para>one of the predefined child ordering policies</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.FromSketchMode" />
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.Comparer" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance to be kept between the nodes in the tree.</para>
      </summary>
      <remarks>
        <para>The distance needs to be a non-negative integer value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given minimum distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum node distance</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.AllowOverlaps" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.FromSketchMode">
      <summary>
        <para>Gets or sets whether or not to consider the given coordinates of the input diagram when arranging the tree.</para>
      </summary>
      <remarks>
        <para>Enabling this feature, the original circular order of child nodes around their parent nodes will be maintained according to the initial coordinates when determining the order of the child nodes.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the initial coordinates of the nodes are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy">
      <summary>
        <para>Gets or sets the root node selection policy of this layout algorithm.</para>
      </summary>
      <remarks>
        <para>The policy determines which node is chosen as (virtual) tree root during the layout process.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown root node policy is given</para>
      </exception>
      <value>
        <para>one of the predefined root node policies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge">
      <summary>
        <para>Gets or sets the preferred radial amount (wedge) in degrees that child nodes may in total occupy around their parent node.</para>
      </summary>
      <remarks>
        <para>The wedge angle controls the degree to which the child nodes may radiate from the center of layout. A value close to <c>360</c> means that the child nodes may radiate in (almost) any direction from their parent node, edge lengths can in consequence stay rather small. On the other hand, a small value means that children are restricted to a small angle; thus, edge lengths (and drawings) may become large.</para>
        <para>The minimum allowed wedge angle is <c>1</c> and the maximum allowed value is <c>359</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given angle is smaller than <c>1</c> or larger than <c>359</c></para>
      </exception>
      <value>
        <para>the preferred wedge angle in degrees from the interval <c>[1,359]</c></para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredRootWedge" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.PreferredRootWedge">
      <summary>
        <para>Gets or sets the preferred radial amount (wedge) in degrees that child nodes may in total occupy around the global root.</para>
      </summary>
      <remarks>
        <para>This property allows to separately control the wedge angle for the designated root node of the tree, while <see cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge" /> controls the angles of all child nodes. The root node will be determined depending on the <see cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy">root node policy</see>.</para>
        <para>The minimum allowed root wedge angle is <c>1</c> and the maximum allowed value is <c>360</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given angle is smaller than <c>1</c> or larger than <c>360</c></para>
      </exception>
      <value>
        <para>the preferred wedge angle in degrees from the interval <c>[1,360]</c></para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.AllowOverlaps">
      <summary>
        <para>Gets or sets whether or not (partially) overlapping nodes are allowed.</para>
      </summary>
      <remarks>
        <para>If overlaps are allowed, the resulting layouts can become significantly more compact. Overlaps will mostly occur at the borders of nodes. Nodes will not be totally covered by other nodes.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if node overlaps are allowed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.CompactnessFactor">
      <summary>
        <para>Gets or sets the factor defining how compact layout results will potentially be, where a smaller factor produces potentially more compact layouts.</para>
      </summary>
      <remarks>
        <para>The algorithm tries to optimize the child node arrangement around each tree node such that each subtree is as close to its root as possible, while still fitting into the <see cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge">preferred wedge angle</see> and not overlapping with adjacent subtrees.</para>
        <para>High compactness factor values induce the optimization procedure to be less strict and accept less optimal results, while low factor values mean that the optimization will only stop when being nearly optimal. Thus, lower values lead to a potentially higher runtime.</para>
        <para>The minimum factor value is <c>0.05</c> and the maximum is <c>1.0</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the factor is smaller than <c>0.05</c> or greater than <c>1.0</c></para>
      </exception>
      <value>
        <para>the compactness factor from the interval [0.05, 1.0]</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.MinimumEdgeLength">
      <summary>
        <para>Gets or sets the minimum length that this layout algorithm assigns to edges of the graph.</para>
      </summary>
      <remarks>
        <para>A lower minimum edge length allows generally more compact layouts. It has the highest effect if most nodes of the graph have a low degree, as the minimum can potentially be met for such graphs.</para>
        <para>The minimum length must be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given length is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum edge length</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the layout algorithm reserves space for node labels.</para>
      </summary>
      <remarks>
        <para>The size of nodes will temporarily be adjusted such that the label is included. Therefore, result drawings may get significantly larger if this feature is enabled.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if node labels are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.InterleavedMode">
      <summary>
        <para>Gets or sets the mode for child node arrangement.</para>
      </summary>
      <remarks>
        <para>Child nodes are either placed interleaved or on a single layer around their parent node. Interleaved placement means that child nodes are placed around their common parent in two different layers in an alternating fashion. For example, the first child is on the inner layer, the second child on the outer layer, the third one again on the inner layer, etc.</para>
        <para>Independent of this mode, the alignment of child nodes on the same layer is still defined by the <see cref="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy">alignment policy</see>. However, <see cref="F:yWorks.Layout.Tree.ChildAlignmentPolicy.Smart" /> is only supported for non-interleaved arrangement.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown mode for interleaved arrangement is given</para>
      </exception>
      <value>
        <para>the mode for interleaved child node arrangement</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy">
      <summary>
        <para>Gets or sets the child alignment policy for this layout algorithm.</para>
      </summary>
      <remarks>
        <para>This policy influences the distance of child nodes to their parent nodes and the alignment of children with the same parent.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown policy is given</para>
      </exception>
      <value>
        <para>one of the predefined child alignment policies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.IntegratedNodeLabeling">
      <summary>
        <para>Gets or sets whether or not the layout algorithm automatically places node labels.</para>
      </summary>
      <remarks>
        <para>If enabled, this layout algorithm will calculate the positions for the node labels assuring that no overlaps occur.</para>
        <para>Different labeling strategies may be selected using <see cref="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelingPolicy" />.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if integrated node labeling is enabled, <c>false</c> otherwise.</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelingPolicy" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.IntegratedEdgeLabeling">
      <summary>
        <para>Gets or sets whether or not the layout algorithm automatically places edge labels.</para>
      </summary>
      <remarks>
        <para>If enabled, this layout algorithm will calculate the positions for the edge labels assuring that no overlaps occur.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if integrated edge labeling is enabled, <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelingPolicy">
      <summary>
        <para>Gets or sets the policy defining how node labels are placed by the integrated node labeling mechanism (for example, the desired label orientation).</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown labeling policy is given</para>
      </exception>
      <value>
        <para>one of the predefined node labeling policies</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.IntegratedNodeLabeling" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelSpacing">
      <summary>
        <para>Gets or sets the distance between node labels belonging to the same node.</para>
      </summary>
      <remarks>
        <para>It also defines the distance between labels and the node they belong to in case of label placement outside of the node (e.g. for <see cref="F:yWorks.Layout.Tree.NodeLabelingPolicy.RayLike">ray-like label placement</see>).</para>
        <para>The spacing must have a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given spacing value is negative</para>
      </exception>
      <value>
        <para>the non-negative node label spacing</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.IntegratedNodeLabeling" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.EdgeLabelSpacing">
      <summary>
        <para>Gets or sets the distance between edge labels belonging to the same edge as well as the distance of the edge labels to the target node of the edge.</para>
      </summary>
      <remarks>
        <para>The spacing must have a non-negative value.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given label spacing value is negative</para>
      </exception>
      <value>
        <para>the non-negative edge label spacing</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.IntegratedEdgeLabeling" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.ChainStraighteningMode">
      <summary>
        <para>Gets or sets whether or not chains are drawn straight or not.</para>
      </summary>
      <remarks>
        <para>A chain is defined as a tree node with exactly one child node. If this feature is enabled, then the incoming edge and outgoing edge of the chain will have the same orientation, i.e., the whole chain looks straight.</para>
        <para>Straightening all chains can lead to smoother, more symmetric results.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if chains are drawn straight, <c>false</c> otherwise.</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.ComponentLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for arranging the components of the graph is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that arranges the graph components is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.HideGroupsStageEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for hiding group nodes is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage used for hiding group nodes is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStage" />
      <seealso cref="T:yWorks.Layout.Grouping.HideGroupsStage" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.OrientationLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> that modifies the orientation of the layout is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that modifies the orientation is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.OrientationLayout" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation" />
      <seealso cref="T:yWorks.Layout.OrientationLayout" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.ParallelEdgeRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing parallel edges is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing parallel edges is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouter" />
      <seealso cref="T:yWorks.Layout.ParallelEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="T:yWorks.Layout.Tree.BalloonLayout.NodeInfo">
      <summary>
        <para>Encapsulates information bound to a node while the algorithm calculates a layout.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.upperAngle">
      <summary>
        <para>The upper angle of the subtree wedge rooted at the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.lowerAngle">
      <summary>
        <para>The lower angle of the subtree wedge rooted at the node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.gapAngle">
      <summary>
        <para>The angle of the gap to the wedge of the previous child node.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.dist">
      <summary>
        <para>The distance of the node to its root node.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Tree.BalloonLayout.NodeInfo.AngleSum">
      <summary>
        <para>Gets the sum of all wedge angles of the subtree rooted at this node.</para>
      </summary>
      <value>
        <para>the sum of <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.upperAngle" />, <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.lowerAngle" /> and <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.gapAngle" /></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.BalloonLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Arranges the given graph as a tree graph in a balloon-like fashion.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <exception cref="T:yWorks.Algorithms.InvalidGraphStructureException">
        <para>if the given graph is not a tree</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Tree.BalloonLayout.GetInfo(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Tree.BalloonLayout.NodeInfo" /> object associated with the given node while the layout algorithm is active.</para>
      </summary>
      <remarks>
        <para>The returned object contains detailed information describing the placement of a node in the layout being computed, e.g., a node's distance to its parent or the wedge angle of the subtree rooted at a node.</para>
        <para>Subclasses may want to override this method to realize another node information setup. This method is called throughout the algorithm, each time some information associated with a node needs to be retrieved or stored.</para>
      </remarks>
      <param name="node">
        <para>the node whose information object should be retrieved</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.BalloonLayout.NodeInfo" /> instance associated to the given node</para>
      </returns>
      <seealso cref="T:yWorks.Layout.Tree.BalloonLayout.NodeInfo" />
    </member>
    <member name="M:yWorks.Layout.Tree.BalloonLayout.DetermineRoot">
      <summary>
        <para>Determines the root node of <see cref="F:yWorks.Layout.Tree.BalloonLayout.graph" /> according to the chosen <see cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy">root node policy</see>.</para>
      </summary>
      <remarks>
        <para>This method may be overridden to implement some other strategy for choosing the root node of the input graph. It is called before the rest of the layout process within <see cref="M:yWorks.Layout.Tree.BalloonLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)" />.</para>
      </remarks>
      <returns>
        <para>the root node of <see cref="F:yWorks.Layout.Tree.BalloonLayout.graph" /></para>
      </returns>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy" />
    </member>
    <member name="M:yWorks.Layout.Tree.BalloonLayout.CalculateChildArrangement(yWorks.Algorithms.Node)">
      <summary>
        <para>Calculates a child node arrangement for a given root node of the tree.</para>
      </summary>
      <remarks>
        <para>During the arrangement, child nodes of <c>root</c> will be <see cref="M:yWorks.Layout.Tree.BalloonLayout.SortChildNodes(yWorks.Algorithms.Node)">sorted</see>. Furthermore, distances of the child nodes will be chosen such that the wedge of the subtree of <c>root</c> fits into the preferred wedge angle, which is either defined via <see cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredRootWedge" /> or <see cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge" />. Calculated distances are stored in <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.dist" />.</para>
        <para>The angle values - upper and lower wedge angle - may also be updated during this process and stored in <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.upperAngle" /> and <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.lowerAngle" />, respectively. To compute the angles of wedges, method <see cref="M:yWorks.Layout.Tree.BalloonLayout.CalculateAngles(yWorks.Algorithms.Node,System.Double)" /> is used.</para>
        <para>This method may be overridden to perform a custom child node arrangement. If support for available features like <see cref="P:yWorks.Layout.Tree.BalloonLayout.InterleavedMode">interleaving</see> should be maintained, then these features need to be carefully considered during the arrangement.</para>
      </remarks>
      <param name="root">
        <para>the node for whose children to compute an arrangement</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.BalloonLayout.SortChildNodes(yWorks.Algorithms.Node)">
      <summary>
        <para>Sorts the child nodes (successors) of the given node.</para>
      </summary>
      <remarks>
        <para>This implementation uses the original node coordinates if <see cref="P:yWorks.Layout.Tree.BalloonLayout.FromSketchMode">From Sketch mode</see> is enabled. Otherwise it uses <see cref="P:yWorks.Layout.Tree.BalloonLayout.Comparer">the specified comparator</see> to sort the outgoing edges and thus the children of <c>root</c>. If there is no such comparator, then the sorting depends on whether or not the child nodes are placed in an <see cref="P:yWorks.Layout.Tree.BalloonLayout.InterleavedMode">interleaved</see> fashion:</para>
        <list type="bullet">
          <item>Normal: Children are sorted according to the chosen <see cref="P:yWorks.Layout.Tree.BalloonLayout.ChildOrderingPolicy">child ordering policy</see>.</item>
          <item>Interleaved: Children are sorted such that the resulting interleaved node placement is compact, while children inducing larger subgraphs are placed next to smaller ones.</item>
        </list>
        <para>This method may be overridden to realize a custom child node ordering. It gets called in method <see cref="M:yWorks.Layout.Tree.BalloonLayout.CalculateChildArrangement(yWorks.Algorithms.Node)" /> before coordinates are assigned and just after the wedge sizes for all subtrees rooted at <c>root</c> are determined.</para>
      </remarks>
      <param name="root">
        <para>the node whose child nodes will be sorted</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.BalloonLayout.GetPreferredChildWedge(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the preferred radial amount (wedge) in degrees that child nodes may in total occupy around the given node.</para>
      </summary>
      <remarks>
        <para>The wedge angle controls the degree to which the child nodes may radiate from the center of layout. A value close to <c>360</c> means that the child nodes may radiate in (almost) any direction from their parent node, edge lengths can in consequence stay rather small. On the other hand, a small value means that children are restricted to a small angle; thus, edges lengths (and drawings) may become large.</para>
        <para>This method returns the <see cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredRootWedge">preferred root wedge</see> if node <c>root</c> was selected as global root node (<see cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy" />). Otherwise, it either returns <see cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge" /> or if the given node has an outdegree equal to <c>2</c>, it returns the minimum of <see cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge" /> and <c>180</c>.</para>
        <para>This method may be overridden to provide a custom child wedge function.</para>
      </remarks>
      <param name="root">
        <para>the node to get the preferred wedge angle for</para>
      </param>
      <returns>
        <para>the preferred wedge angle for <c>root</c> in degrees</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredChildWedge" />
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.PreferredRootWedge" />
    </member>
    <member name="M:yWorks.Layout.Tree.BalloonLayout.CalculateAngles(yWorks.Algorithms.Node,System.Double)">
      <summary>
        <para>Calculates the wedge angle that has to be reserved for the subtree rooted at the given node scaling the <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.dist">distance</see> with the given scale factor.</para>
      </summary>
      <remarks>
        <para>Given some <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.dist">distance</see> the <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.upperAngle">upper angle</see> and <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.lowerAngle">lower angle</see> of the wedge belonging to the subtree rooted at <c>root</c> will be calculated and stored in the <see cref="T:yWorks.Layout.Tree.BalloonLayout.NodeInfo" /> instance associated with <c>root</c> (<see cref="M:yWorks.Layout.Tree.BalloonLayout.GetInfo(yWorks.Algorithms.Node)" />).</para>
        <para>This method may be overridden to perform a custom wedge angle assignment scheme. The method is called when <see cref="M:yWorks.Layout.Tree.BalloonLayout.CalculateChildArrangement(yWorks.Algorithms.Node)">arranging child nodes</see>. Large edge labels on the incoming edge to <c>root</c> need to be considered, if <see cref="P:yWorks.Layout.Tree.BalloonLayout.IntegratedEdgeLabeling">integrated edge labeling</see> should still work properly.</para>
      </remarks>
      <param name="root">
        <para>the node for which the wedge angles are calculated</para>
      </param>
      <param name="scaleFactor">
        <para>a factor to be applied to the <see cref="F:yWorks.Layout.Tree.BalloonLayout.NodeInfo.dist">distance</see> of <c>root</c></para>
      </param>
      <returns>
        <para>the sum of the upper and lower wedge angle of the subtree rooted at the given root node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.BalloonLayout.CalculateChildArrangement(yWorks.Algorithms.Node)" />
    </member>
    <member name="T:yWorks.Layout.Tree.BusNodePlacer">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.BusNodePlacer" /> creates a bus to which all child nodes and the local root node are connected.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> </para>
        <para>The root node is marked</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.BusNodePlacer.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Tree.BusNodePlacer" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.BusNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.BusNodePlacer" /> instance that uses the transformation defined by the given matrix.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.BusNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this method is called</para>
      </exception>
      <param name="child" />
    </member>
    <member name="M:yWorks.Layout.Tree.BusNodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Determines connector directions depending on whether or not the child nodes are placed above or below the bus.</para>
      </summary>
      <remarks>
        <para>When a child node is placed above the bus, the edge should connect <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North">north</see>, otherwise it should connect <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.South">south</see>.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root</para>
      </param>
      <param name="connectorMap">
        <para>the map that must be used for storing the direction specifiers of the child nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.BusNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Places all children of the local root below and above a bus segment that is shared by the edges.</para>
      </summary>
      <remarks>
        <para>The bus is located below the local root and the children are placed below this bus or next to the local root.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged subtree shape that contains the local root node and all its children</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.BusNodePlacer.CreateComparer">
      <summary>
        <para>Creates a <see cref="T:System.Collections.Generic.IComparer`1" /> for outgoing edges that takes the rotation into account.</para>
      </summary>
      <remarks>
        <para>This implementation keeps the current order of edges.</para>
      </remarks>
      <returns>
        <para>
          <c>null</c>
        </para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.ClassicTreeLayout">
      <summary>
        <para>This layout algorithm arranges graphs with a tree structure.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> <see cref="T:yWorks.Layout.Tree.ClassicTreeLayout" /> is designed to arrange directed and undirected trees that have a unique root node. All children are placed below their parent in relation to the main layout direction. The edges of the graph are routed as straight-line segments or in an orthogonal bus-like fashion.</para>
        <para>Tree layout algorithms are commonly used for visualizing relational data and for producing diagrams of high quality that are able to reveal possible hierarchic properties of the graph. More precisely, they find applications in dataflow analysis, software engineering, bioinformatics and business administration.</para>
        <para> A Dendrogram  A graph containing group nodes  Left-to-right layout with global layering <h2>Concept</h2></para>
        <para>The layout algorithm starts from the root and recursively assigns coordinates to all tree nodes. In this manner, leaf nodes will be placed first, while each parent node is placed centered above its children.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>The layout algorithm supports custom sorting of sibling nodes by using a specific <see cref="T:yWorks.Layout.Tree.NodeOrderComparer" />. Each tree node may have an individual <see cref="T:yWorks.Layout.Tree.NodeOrderComparer" /> that is stored in a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with <see cref="F:yWorks.Layout.Tree.NodeOrderComparer.NodeOrderComparableDpKey" />. If this <see cref="T:yWorks.Layout.Tree.NodeOrderComparer" /> uses the initial coordinates of the nodes, it allows the incremental insertion of child nodes while keeping the relative locations of the other nodes.</para>
        <para>A custom node can be defined as root of the tree using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Tree.ClassicTreeLayout.SelectedRootDpKey" />.</para>
        <para>
          <see cref="T:yWorks.Layout.Tree.ClassicTreeLayout" /> can be configured to <see cref="P:yWorks.Layout.Tree.ClassicTreeLayout.ConsiderNodeLabels">reserve space for node labels</see>. It can also <see cref="P:yWorks.Layout.Tree.ClassicTreeLayout.IntegratedEdgeLabeling">place edge labels along edges</see> such that the labels won't overlap with other graph elements. Edge labels are placed according to the information stored in a <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> instance. However, the placement along the edge will only affect the order of multiple labels at the same edge. The algorithm will always place the labels close to the target node.</para>
        <para>Grouping of nodes can also be handled by this layout algorithm. It is important that a group node contains a whole subtree. Otherwise, the group nodes may overlap with each other or with other nodes. Furthermore, the user may specify minimum size constraints for each group node using <see cref="T:yWorks.Algorithms.IDataProvider" /> key <see cref="F:yWorks.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey" />.</para>
        <para>This layout algorithm can only handle graphs with a tree structure. To apply it to a general graph, a <see cref="T:yWorks.Layout.Tree.TreeReductionStage" /> can be appended. This stage will temporarily remove some edges of the input graph until a tree is obtained. After the layout calculation, the stage will reinsert the edges that were removed and route them separately.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.ClassicTreeLayout.SelectedRootDpKey">
      <summary>
        <para>A data provider key for marking the node that will be used as root node of the tree.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.ClassicTreeLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.ClassicTreeLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.EnforceGlobalLayering">
      <summary>
        <para>Gets or sets whether or not a global layering is enforced, that is, each node spans exactly one layer.</para>
      </summary>
      <remarks>
        <para>If it is enabled, the algorithm ensures that nodes never span more than one layer. Otherwise, nodes with larger size might span two or more layers such that a more compact layout is produced.</para>
        <para>This setting can be advantageous, if the hierarchical structure of the tree should be emphasized.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if global layering is enforced, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.VerticalAlignment" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.VerticalAlignment" />
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement">
      <summary>
        <para>Gets or sets the layout policy for leaf nodes.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified policy is unknown</para>
      </exception>
      <value>
        <para>one of the predefined layout policies for leaf nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.GroupingSupported">
      <summary>
        <para>Gets or sets whether or not group nodes are handled by the layout algorithm.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if grouping is supported, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.HideGroupsStageEnabled" />
    </member>
    <member name="M:yWorks.Layout.Tree.ClassicTreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Arranges the given graph as a tree.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.Comparer">
      <summary>
        <para>Gets or sets the <see cref="T:System.Collections.Generic.IComparer`1" /> instance that is used for sorting the outgoing edges of each node of the tree.</para>
      </summary>
      <remarks>
        <para>This comparator defines the relative order of the child nodes in the layout.</para>
      </remarks>
      <value>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> instance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.PortStyle">
      <summary>
        <para>Gets or sets the port assignment policy that will be applied.</para>
      </summary>
      <value>
        <para>one of the predefined port assignment policies</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.EdgeRoutingStyle">
      <summary>
        <para>Gets or sets the edge routing style used by this layout algorithm.</para>
      </summary>
      <remarks>
        <para>If <see cref="F:yWorks.Layout.Tree.EdgeRoutingStyle.Plain" /> is set, the edges will be routed as straight-line segments. If <see cref="F:yWorks.Layout.Tree.EdgeRoutingStyle.Orthogonal" /> is set, all edges will be routed orthogonally in a bus-like fashion.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an invalid layout style is provided</para>
      </exception>
      <value>
        <para>one of <see cref="F:yWorks.Layout.Tree.EdgeRoutingStyle.Plain" /> or <see cref="F:yWorks.Layout.Tree.EdgeRoutingStyle.Orthogonal" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the minimum horizontal distance between adjacent nodes within the same layer.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.MinimumLayerDistance">
      <summary>
        <para>Gets or sets the minimum distance between two adjacent layers.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given distance is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the layout algorithm reserves space for node labels.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if node labels are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.IntegratedEdgeLabeling">
      <summary>
        <para>Gets or sets whether or not the layout algorithm reserves space for edge labels and places them.</para>
      </summary>
      <remarks>
        <para>To define the desired placement for each label add a <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> on <see cref="T:yWorks.Layout.IEdgeLabelLayout" />.</para>
        <para>This method is a convenience method that assures that the <see cref="P:yWorks.Layout.MultiStageLayout.Labeling">label layouter</see> is of type <see cref="T:yWorks.Layout.LabelLayoutTranslator" /> and <see cref="P:yWorks.Layout.LabelLayoutTranslator.TranslateEdgeLabels" /> is set to <c>true</c>.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if integrated edge labeling is enabled, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.BusAlignment">
      <summary>
        <para>Gets or sets the vertical bus alignment for orthogonally routed edge buses.</para>
      </summary>
      <remarks>
        <para>The bus alignment determines the relative position of an edge bus between two subsequent layers. The value of this property must lie within the interval <c>[0,1]</c> where:</para>
        <list type="bullet">
          <item>A value of <c>0</c> places the bus at the top, directly below the parent node.</item>
          <item>A value of <c>0.5</c> places the bus in the middle between parent and child nodes.</item>
          <item>A value of <c>1</c> places the bus at the bottom, directly above the child nodes.</item>
        </list>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if <c>busAlignment</c> is not in <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a value from the interval <c>[0,1]</c></para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.EdgeRoutingStyle" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.EnforceGlobalLayering" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.VerticalAlignment">
      <summary>
        <para>Gets or sets the vertical alignment of the nodes within their corresponding layers.</para>
      </summary>
      <remarks>
        <para>The value for the vertical alignment is considered as relative to the height of the corresponding layer, which is determined by the maximum height of the nodes that belong to the particular layer.</para>
        <para>The value of this property must lie within the interval <c>[0,1]</c>, where:</para>
        <list type="bullet">
          <item>A value of <c>0</c> corresponds to top-alignment.</item>
          <item>A value of <c>0.5</c> corresponds to center-alignment.</item>
          <item>A value of <c>1</c> corresponds to bottom-alignment.</item>
        </list>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if vertical alignment value does not lie within <c>[0,1]</c></para>
      </exception>
      <value>
        <para>a value from the interval <c>[0,1]</c></para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.EnforceGlobalLayering" />
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.ModificationMatrix">
      <summary>
        <para>Gets or sets the modification matrix used for rotating / mirroring the layout.</para>
      </summary>
      <value>
        <para>the current modification matrix</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.ComponentLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for arranging the components of the graph is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that arranges the graph components is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.ParallelEdgeRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing parallel edges is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing parallel edges is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouter" />
      <seealso cref="T:yWorks.Layout.ParallelEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Tree.ClassicTreeLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="T:yWorks.Layout.Tree.DefaultNodePlacer">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" /> is the default implementation of interface <see cref="T:yWorks.Layout.Tree.INodePlacer" />.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The layout style can be customized in several ways. Subtrees sharing the same local root node are either placed above or below each other. </para>
        <para>Each layer in the tree uses different configurations of <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" /></para>
        <para>
          <h2>Features</h2>
        </para>
        <para>
          <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s can be arranged in each main direction specified in <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />. That way, the subtrees of the same graph can have different directions.</para>
        <para>This node placer aligns the local root node according to a chosen <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment">alignment</see>.</para>
        <para>There are various <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle">routing styles</see> that result in different edge routes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,System.Double,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" /> instance with customized <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalDistance">vertical</see> and <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.HorizontalDistance">horizontal distance</see>.</para>
      </summary>
      <param name="childPlacement">
        <para>the child placement specifier describing the style of the arrangement</para>
      </param>
      <param name="verticalDistance">
        <para>the vertical distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <param name="horizontalDistance">
        <para>the horizontal distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the placement specifier is unknown or if the horizontal/vertical distance is negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalDistance" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.HorizontalDistance" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,System.Double,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" /> instance with customized <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment">root alignment</see>, <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalDistance">vertical</see> and <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.HorizontalDistance">horizontal distance</see>.</para>
      </summary>
      <param name="childPlacement">
        <para>the child placement specifier describing the style of the arrangement</para>
      </param>
      <param name="rootAlignment">
        <para>the alignment specifier describing how the root node is aligned with its child nodes</para>
      </param>
      <param name="verticalDistance">
        <para>the vertical distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <param name="horizontalDistance">
        <para>the horizontal distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the placement specifier or the root alignment specifier is unknown or if the horizontal/vertical distance is negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalDistance" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.HorizontalDistance" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,yWorks.Layout.Tree.RoutingStyle,System.Double,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" /> instance with customized <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment">root alignment</see>, <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle">routing style</see>, <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalDistance">vertical</see> and <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.HorizontalDistance">horizontal distance</see>.</para>
      </summary>
      <param name="childPlacement">
        <para>the child placement specifier describing the style of the arrangement</para>
      </param>
      <param name="rootAlignment">
        <para>the alignment specifier describing how the root node is aligned with its child nodes</para>
      </param>
      <param name="routingStyle">
        <para>the routing style specifier</para>
      </param>
      <param name="verticalDistance">
        <para>the vertical distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <param name="horizontalDistance">
        <para>the horizontal distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the placement specifier or the root alignment or the routing style is unknown or if the horizontal/vertical distance is negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalDistance" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.HorizontalDistance" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,yWorks.Layout.Tree.RoutingStyle,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" /> instance with custom settings.</para>
      </summary>
      <param name="childPlacement">
        <para>the child placement specifier describing the style of the arrangement</para>
      </param>
      <param name="rootAlignment">
        <para>the alignment specifier describing how the root node is aligned with its child nodes</para>
      </param>
      <param name="routingStyle">
        <para>the routing style specifier</para>
      </param>
      <param name="verticalDistance">
        <para>the vertical distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <param name="horizontalDistance">
        <para>the horizontal distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <param name="minFirstSegmentLength">
        <para>the minimum length of the first edge segment (connected to the root node)</para>
      </param>
      <param name="minLastSegmentLength">
        <para>the minimum length of the last edge segment (connected to the child node)</para>
      </param>
      <param name="minSlope">
        <para>the minimum slope between the root node and the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </param>
      <param name="minSlopeHeight">
        <para>the minimum vertical height of sloped edge segments</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the placement specifier or the root alignment or the routing style is unknown or if the horizontal/vertical distance or the minimum first/last segment length or the minimum slope or the minimum vertical height is negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalDistance" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.HorizontalDistance" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumFirstSegmentLength" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumLastSegmentLength" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumSlope" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumSlopeHeight" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Arranges the root node and its children.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction of the connector</para>
      </param>
      <returns>
        <para>the merged <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> containing the local root and all its subtrees</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.CalculateParentConnector(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.INodeLayout,yWorks.Layout.Tree.TreeLayout.SubtreeShape,yWorks.Algorithms.Edge,yWorks.Layout.IEdgeLayout,System.SByte)">
      <summary>
        <para>Calculates the bends for the connector to the parent node.</para>
      </summary>
      <remarks>
        <para>This implementation adds bends to the connector for edges that route the edges around the child node in case there are <see cref="T:yWorks.Layout.PortConstraint" />s that conflict with the direction of the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>.</para>
        <para>This method is called in <see cref="M:yWorks.Layout.Tree.DefaultNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" /> to route the edges after the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s are arranged. It may be overridden to customize the routing style.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="localRoot">
        <para>the local root node whose connector is calculated and stored in the given subtree shape</para>
      </param>
      <param name="rootLayout">
        <para>the <see cref="T:yWorks.Layout.INodeLayout" /> of the root node</para>
      </param>
      <param name="subtreeShape">
        <para>the shape of the whole subtree of the local root</para>
      </param>
      <param name="parentEdge">
        <para>the incoming edge of the local root node that will be the connector for the given subtree shape</para>
      </param>
      <param name="parentEdgeLayout">
        <para>the current <see cref="T:yWorks.Layout.IEdgeLayout" /> of the connector edge</para>
      </param>
      <param name="direction">
        <para>the direction specifier as defined in the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> interface which should be used for the connector</para>
      </param>
      <seealso cref="M:yWorks.Layout.Tree.NodePlacerBase.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.CalculateTargetEdgeLayout(yWorks.Layout.INodeLayout,yWorks.Layout.Tree.TreeLayout.SubtreeShape,yWorks.Algorithms.Edge)">
      <summary>
        <para>Calculates the routing of the target side of the edge to the given child node.</para>
      </summary>
      <remarks>
        <para>This implementation just resets the current <see cref="T:yWorks.Layout.IEdgeLayout" />.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.DefaultNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" /> after the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">shapes</see> of the local root's children are placed. It may be overridden to add some <see cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddTargetPoint(System.Double,System.Double)">target points</see> to the edge.</para>
      </remarks>
      <param name="rootLayout">
        <para>the <see cref="T:yWorks.Layout.INodeLayout" /> of the local root node</para>
      </param>
      <param name="childShape">
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of the child's subtree that is connected through the given edge</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.CalculateSlopedSourceEdgeLayout(yWorks.Layout.INodeLayout,yWorks.Layout.Tree.TreeLayout.SubtreeShape,yWorks.Algorithms.Edge,System.Double,System.Double)">
      <summary>
        <para>Calculates the routing of the source side of the edge to the given child node.</para>
      </summary>
      <remarks>
        <para>This method delegates to <see cref="M:yWorks.Layout.Tree.DefaultNodePlacer.CalculateSourceEdgeLayout(yWorks.Layout.INodeLayout,yWorks.Layout.Tree.TreeLayout.SubtreeShape,yWorks.Algorithms.Edge)" /> if the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle">routing style</see> is not <see cref="F:yWorks.Layout.Tree.RoutingStyle.Fork" />. It may be overridden to implement a custom routing style.</para>
      </remarks>
      <param name="rootLayout">
        <para>the <see cref="T:yWorks.Layout.INodeLayout" /> of the local root node</para>
      </param>
      <param name="childShape">
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance of the corresponding child's subtree</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="rootForkCoordinate">
        <para>the y-coordinate of the first bend of the edge if the placement is horizontal, the x-coordinate otherwise</para>
      </param>
      <param name="childForkCoordinate">
        <para>the y-coordinate of the second (= last) bend of the edge if the placement is horizontal, the x-coordinate otherwise</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.CalculateSourceEdgeLayout(yWorks.Layout.INodeLayout,yWorks.Layout.Tree.TreeLayout.SubtreeShape,yWorks.Algorithms.Edge)">
      <summary>
        <para>Calculates the routing of the source side of the edge to the given child node.</para>
      </summary>
      <remarks>
        <para>This implementation adds bends to the <see cref="T:yWorks.Layout.IEdgeLayout" /> of the given edge according to the specified <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle">routing style</see> and <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>. It also updates the target points in the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.DefaultNodePlacer.CalculateSlopedSourceEdgeLayout(yWorks.Layout.INodeLayout,yWorks.Layout.Tree.TreeLayout.SubtreeShape,yWorks.Algorithms.Edge,System.Double,System.Double)" /> to route the edges. It may be overridden to implement a custom edge routing style.</para>
      </remarks>
      <param name="rootLayout">
        <para>the <see cref="T:yWorks.Layout.INodeLayout" /> of the local root node</para>
      </param>
      <param name="childShape">
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of the child's subtree that is connected through the given edge</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">
      <summary>
        <para>Gets or sets the direction in which the child nodes are placed with respect to their parent node.</para>
      </summary>
      <remarks>
        <para>Subtrees can be placed below, above, left or right of their roots.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown placement specifier is set</para>
      </exception>
      <value>
        <para>one of the valid placement specifiers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment">
      <summary>
        <para>Gets or sets how the root node is aligned with its children and their <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown root alignment specifier is set</para>
      </exception>
      <value>
        <para>one of the valid root alignment specifiers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalAlignment">
      <summary>
        <para>Gets or sets the relative vertical alignment of nodes with the same parent.</para>
      </summary>
      <remarks>
        <para>All values between <c>0</c> and <c>1</c> result in a valid alignment.</para>
        <list type="bullet">
          <item>
            <c>0</c> - nodes are top-aligned</item>
          <item>
            <c>0.5</c> - nodes are center-aligned</item>
          <item>
            <c>1</c> - nodes are bottom-aligned</item>
        </list>
        <para>Values outside the interval <c>[0,1]</c> will result in a more compact node placement with unaligned nodes.</para>
      </remarks>
      <value>
        <para>the relative vertical alignment of nodes that have the same parent node</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node depending on the selected <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>.</para>
      </summary>
      <remarks>
        <para>If the child nodes are placed <see cref="F:yWorks.Layout.Tree.ChildPlacement.HorizontalDownward">below</see> the root node, the edge should connect <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North">north</see>. If they are placed <see cref="F:yWorks.Layout.Tree.ChildPlacement.HorizontalUpward">above</see> the root node it should connect <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.South">south</see>. The vertical placements are handled analogous.</para>
      </remarks>
      <param name="child">
        <para>the child node</para>
      </param>
      <returns>
        <para>the connector direction depending on the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see></para>
      </returns>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle">
      <summary>
        <para>Gets or sets the style in which edge paths are routed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified routing style is unknown</para>
      </exception>
      <value>
        <para>the routing style specifier</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.VerticalDistance">
      <summary>
        <para>Gets or sets the vertical distance between nodes or <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the non-negative vertical distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumFirstSegmentLength">
      <summary>
        <para>Gets or sets the minimum length for the first segment of an edge.</para>
      </summary>
      <remarks>
        <para>During layout calculation, the edges of the tree are directed. Hence, the first segment is always the segment that is attached to the source, which is the local root node.</para>
        <para>The length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum segment length is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum segment length</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumLastSegmentLength">
      <summary>
        <para>Gets or sets the minimum length for the last segment of an edge.</para>
      </summary>
      <remarks>
        <para>During layout calculation, the edges of the tree are directed. Hence, the last segment is always the segment that is attached to the target, which is a child node.</para>
        <para>The length needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the minimum segment length is negative</para>
      </exception>
      <value>
        <para>the non-negative minimum segment length</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumSlope">
      <summary>
        <para>Gets or sets the minimum slope of the edge segments.</para>
      </summary>
      <remarks>
        <para>These sloped segments are between the vertical first and last segment of the edge.</para>
        <para>The segments may become steeper but they will have at least the specified slope. Negative minimum slopes can lead to edge routes looking like spider legs.</para>
      </remarks>
      <value>
        <para>the minimum slope</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumSlopeHeight" />
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumSlopeHeight">
      <summary>
        <para>Gets or sets the minimum height for sloped edge segments.</para>
      </summary>
      <remarks>
        <para>These sloped segments are between the vertical first and last segment of the edge.</para>
        <para>The segments may become steeper to reach the specified height.</para>
      </remarks>
      <value>
        <para>the minimum height for sloped segments</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.MinimumSlope" />
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultNodePlacer.HorizontalDistance">
      <summary>
        <para>Gets or sets the horizontal distance between nodes or <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the non-negative horizontal distance</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.CreateComparer">
      <summary>
        <para>Creates a <see cref="T:System.Collections.Generic.IComparer`1" /> for outgoing edges which takes the initial coordinates of the edges' targets into account.</para>
      </summary>
      <remarks>
        <para>Child nodes are sorted in a way that the layout will resemble the current arrangement of the nodes. This is especially useful for interactive or incremental layout calculation.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that considers the initial coordinates of the nodes</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultNodePlacer.CreateFromSketchComparer">
      <summary>
        <para>Delegates to <see cref="M:yWorks.Layout.Tree.DefaultNodePlacer.CreateComparer" />.</para>
      </summary>
      <returns>
        <para>the From Sketch <see cref="T:System.Collections.Generic.IComparer`1" /></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.CreateComparer" />
    </member>
    <member name="T:yWorks.Layout.Tree.DefaultPortAssignment">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.DefaultPortAssignment" /> provides some simple <see cref="P:yWorks.Layout.Tree.DefaultPortAssignment.Mode">port assignment styles</see>.</para>
      </summary>
      <remarks>
        <para>Ports are either <see cref="F:yWorks.Layout.Tree.PortAssignmentMode.None">centered</see> on the node, distributed at one side of the node or placed considering <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DefaultPortAssignment" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.#ctor(yWorks.Layout.Tree.PortAssignmentMode,System.Double)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DefaultPortAssignment" /> instance using the given port assignment mode and ratio between the border and the ports and the gap between the ports themselves.</para>
      </summary>
      <param name="mode">
        <para>one of the predefined port assignment specifiers</para>
      </param>
      <param name="ratio">
        <para>the ratio of the distance between outer ports and the border to the distance between any two ports</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown mode is specified or if the specified ratio is negative</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Places the ports of edges connecting to the given node according to the <see cref="P:yWorks.Layout.Tree.DefaultPortAssignment.Mode">port assignment mode</see>.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node">
        <para>the node whose adjacent edges' ports should be placed</para>
      </param>
      <seealso cref="P:yWorks.Layout.Tree.DefaultPortAssignment.Mode" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignParentEdgeTargetPort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge)">
      <summary>
        <para>Assigns relative coordinates to the target port of the incoming edge from the parent of the given node.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)" /> if the given node has a parent node. It may be overridden to assign a custom location to the target port of the incoming edge.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="edge">
        <para>the edge from the parent node</para>
      </param>
      <seealso cref="P:yWorks.Layout.IEdgeLayout.TargetPoint" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Int32)">
      <summary>
        <para>Assigns relative coordinates to the source port of the outgoing edge to a child of the given node.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)" /> for each outgoing edge of the given node. It may be overridden to assign a custom location to the source port of outgoing edges.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="node">
        <para>the node</para>
      </param>
      <param name="edge">
        <para>the edge to the child node</para>
      </param>
      <param name="index">
        <para>the zero-based index of the child edge</para>
      </param>
      <seealso cref="P:yWorks.Layout.IEdgeLayout.SourcePoint" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.GetPortBorderGap(System.Double,System.Int32)">
      <summary>
        <para>Determines the distance between the outer ports and the border of the node.</para>
      </summary>
      <remarks>
        <para>This implementation calculates the gap according to the number of edges at one side of the node. It also includes the <see cref="P:yWorks.Layout.Tree.DefaultPortAssignment.BorderGapToPortGapRatio">ratio between border gap and port gap</see>.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Int32)" /> to calculate the location of the first port. It may be overridden to implement a different distribution of ports on the node's side.</para>
      </remarks>
      <param name="sideLength">
        <para>the width/height of the side</para>
      </param>
      <param name="edgeCount">
        <para>the number of edges that connect to this side</para>
      </param>
      <returns>
        <para>the absolute gap to be used on both sides of the ports</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Int32)" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultPortAssignment.BorderGapToPortGapRatio" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.GetPortDistanceDelta(System.Double,System.Int32,System.Double)">
      <summary>
        <para>Determines the distance between two adjacent ports.</para>
      </summary>
      <remarks>
        <para>This implementation calculates the gap according to the number of edges at one side of the node. The edges are distributed keeping the given gap to the border of the node.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Int32)" /> to calculate the distance between two ports. It may be overridden to implement a different distribution of ports on the node's side.</para>
      </remarks>
      <param name="sideLength">
        <para>the width/height of the side</para>
      </param>
      <param name="edgeCount">
        <para>the number of edges/ports that connect to this side</para>
      </param>
      <param name="portBorderGap">
        <para>the port border gap (i.e. calculated by <see cref="M:yWorks.Layout.Tree.DefaultPortAssignment.GetPortBorderGap(System.Double,System.Int32)" />)</para>
      </param>
      <returns>
        <para>the absolute distance to be used between two adjacent ports</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Int32)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultPortAssignment.GetPortBorderGap(System.Double,System.Int32)" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.GetSourcePortConstraint(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge,System.Int32)">
      <summary>
        <para>Retrieves the source <see cref="T:yWorks.Layout.PortConstraint" /> for the given edge.</para>
      </summary>
      <remarks>
        <para>This implementation accesses the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Int32)" /> in <see cref="F:yWorks.Layout.Tree.PortAssignmentMode.PortConstraint" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <param name="index">
        <para>the index of the child that is the target of the given edge</para>
      </param>
      <returns>
        <para>the source <see cref="T:yWorks.Layout.PortConstraint" /> or <c>null</c> if no source <see cref="T:yWorks.Layout.PortConstraint" /> is specified</para>
      </returns>
      <seealso cref="T:yWorks.Layout.PortConstraint" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignChildEdgeSourcePort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge,System.Int32)" />
    </member>
    <member name="M:yWorks.Layout.Tree.DefaultPortAssignment.GetTargetPortConstraint(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Retrieves the target <see cref="T:yWorks.Layout.PortConstraint" /> for the given edge.</para>
      </summary>
      <remarks>
        <para>This implementation accesses the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignParentEdgeTargetPort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge)" /> in <see cref="F:yWorks.Layout.Tree.PortAssignmentMode.PortConstraint" />.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the edge</para>
      </param>
      <returns>
        <para>the target <see cref="T:yWorks.Layout.PortConstraint" /> or <c>null</c> if no target <see cref="T:yWorks.Layout.PortConstraint" /> is specified</para>
      </returns>
      <seealso cref="T:yWorks.Layout.PortConstraint" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultPortAssignment.AssignParentEdgeTargetPort(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Algorithms.Edge)" />
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultPortAssignment.Mode">
      <summary>
        <para>Gets or sets the mode that describes how ports are placed.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if an unknown mode is specified</para>
      </exception>
      <value>
        <para>one of the predefined port assignment specifiers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultPortAssignment.BorderGapToPortGapRatio">
      <summary>
        <para>Gets or sets the ratio of the <em>border gap</em> (distance between the outer ports to the node border) to the <em>port gap</em> (distance between adjacent ports).</para>
      </summary>
      <remarks>
        <para>The ratio must have a positive value. When the ratio is <c>0</c> the ports will be distributed along the whole side of the node without a gap between the last port and the corner.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified ratio is negative</para>
      </exception>
      <value>
        <para>the ratio of the border gap (gap between ports and border) to the port gap (gap between two ports)</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DefaultPortAssignment.ReversedPortOrder">
      <summary>
        <para>Gets or sets whether or not the port assignment should reverse the order of the ports.</para>
      </summary>
      <remarks>
        <para>The normal order is from left to right and from top to bottom. It will be reversed if this option is enabled.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the order of the ports are reversed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Tree.DelegatingNodePlacer">
      <summary>
        <para>
          <see cref="T:yWorks.Layout.Tree.DelegatingNodePlacer" /> delegates the arrangement of the children to two different <see cref="T:yWorks.Layout.Tree.INodePlacer" />s.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> This <see cref="T:yWorks.Layout.Tree.INodePlacer" /> can, for example, be used for creating mind maps or a playing schedule of a sports competition. </para>
        <para>There are two subtrees that are placed above and below the root; Both subtrees consist of two subtrees that are placed left and right of their local root</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryNodesDpKey">
      <summary>
        <para>A data provider key for dividing the children into two sets.</para>
      </summary>
      <remarks>
        <para>If there is no <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with this key, half of the nodes are placed left of the root and the remaining nodes are placed right of the root.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.DelegatingNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix,yWorks.Layout.Tree.INodePlacer,yWorks.Layout.Tree.INodePlacer)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" /> instance with default settings using the given modification matrix and the given node placers as delegates.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix</para>
      </param>
      <param name="placerUpperLeft">
        <para>the first delegate <see cref="T:yWorks.Layout.Tree.INodePlacer" /> which places the left subtrees</para>
      </param>
      <param name="placerLowerRight">
        <para>the second delegate <see cref="T:yWorks.Layout.Tree.INodePlacer" /> which places the right subtrees</para>
      </param>
      <seealso cref="F:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryNodesDpKey" />
    </member>
    <member name="M:yWorks.Layout.Tree.DelegatingNodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Tree.IProcessor" /> that partitions child nodes of the current root node into two subsets.</para>
      </summary>
      <remarks>
        <para>In a pre-processing step the child nodes are divided into an upper-left and a lower-right subset. The first set is arranged using <see cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryPlacer">the first delegate</see>, the second set is arranged using <see cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.SecondaryPlacer">the second delegate</see>. To be able to delegate to different <see cref="T:yWorks.Layout.Tree.INodePlacer" />s this <see cref="T:yWorks.Layout.Tree.IProcessor" /> adds dummy nodes to which it assigns the according <see cref="T:yWorks.Layout.Tree.INodePlacer" />s.</para>
        <para>The changes to the graph are restored in the post-processing step.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.SecondaryPlacer" />
      <seealso cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryPlacer" />
      <param name="layouter" />
      <param name="graph" />
      <param name="currentRoot" />
    </member>
    <member name="M:yWorks.Layout.Tree.DelegatingNodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Does nothing.</para>
      </summary>
      <remarks>
        <para>Since the <see cref="T:yWorks.Layout.Tree.DelegatingNodePlacer" /> always places one part of the tree on one side and the remaining tree on the opposite side, it doesn't need to calculate the directions of the connectors.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="connectorMap">
        <para>the map that must be used for storing the direction specifiers of the child nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.DelegatingNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Places the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s of the child nodes using the two delegate node placers retrieved with <see cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryPlacer" /> and <see cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.SecondaryPlacer" />.</para>
      </summary>
      <returns>
        <para>the merged <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the subtree rooted at the local root node</para>
      </returns>
      <param name="nodeShapeProvider" />
      <param name="subtreeShapeProvider" />
      <param name="graph" />
      <param name="localRoot" />
      <param name="parentConnectorDirection" />
    </member>
    <member name="M:yWorks.Layout.Tree.DelegatingNodePlacer.SecondaryChildren(yWorks.Algorithms.Node,yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Returns all lower-right children of the local root node.</para>
      </summary>
      <remarks>
        <para>Which children belong to this list is determined using the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryNodesDpKey" />. If no such <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered, the second half of the children is returned.</para>
        <para>These children are placed using the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> returned by <see cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.SecondaryPlacer" />.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>the list of lower-right child <see cref="T:yWorks.Algorithms.Node" />s</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryNodesDpKey" />
    </member>
    <member name="M:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryChildren(yWorks.Algorithms.Node,yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Returns all upper-left children of the local root node.</para>
      </summary>
      <remarks>
        <para>Which children belong to this list is determined using the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryNodesDpKey" />. If no such <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered, the first half of the children is returned.</para>
        <para>These children are placed using the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> returned by <see cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryPlacer" />.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <returns>
        <para>the list of upper-left child <see cref="T:yWorks.Algorithms.Node" />s</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryNodesDpKey" />
    </member>
    <member name="M:yWorks.Layout.Tree.DelegatingNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this method is called</para>
      </exception>
      <param name="child" />
    </member>
    <member name="M:yWorks.Layout.Tree.DelegatingNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Arranges the local root relative to the subtree shape of its children.</para>
      </summary>
      <exception cref="T:System.InvalidOperationException">
        <para>if this method is called</para>
      </exception>
      <param name="localRoot" />
      <param name="parentConnectorDirection" />
    </member>
    <member name="P:yWorks.Layout.Tree.DelegatingNodePlacer.SecondaryPlacer">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance that will arrange the lower-right part of the graph.</para>
      </summary>
      <value>
        <para>the lower-right <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryPlacer" />
      <seealso cref="M:yWorks.Layout.Tree.DelegatingNodePlacer.SecondaryChildren(yWorks.Algorithms.Node,yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="P:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryPlacer">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance that will arrange the upper-left part of the graph.</para>
      </summary>
      <value>
        <para>the upper-left <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.DelegatingNodePlacer.SecondaryPlacer" />
      <seealso cref="M:yWorks.Layout.Tree.DelegatingNodePlacer.PrimaryChildren(yWorks.Algorithms.Node,yWorks.Layout.LayoutGraph)" />
    </member>
    <member name="T:yWorks.Layout.Tree.DendrogramNodePlacer">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.DendrogramNodePlacer" /> arranges subtrees as dendrograms.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> This <see cref="T:yWorks.Layout.Tree.INodePlacer" /> arranges nodes from top to bottom. It arranges subtrees in such a way that all subtrees of a single local root are aligned with their bottom border. </para>
        <para>Note: This implementation does not support <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.DendrogramNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DendrogramNodePlacer" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Tree.DendrogramNodePlacer.MinimumRootDistance">
      <summary>
        <para>Gets or sets the minimum distance between the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of a root node and the bus connecting to all of its children.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance between the root and the bus</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DendrogramNodePlacer.MinimumSubtreeDistance">
      <summary>
        <para>Gets or sets the minimum horizontal distance between adjacent <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see>.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance between two adjacent <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.DendrogramNodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Provides <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" /> for all children.</para>
      </summary>
      <remarks>
        <para>Edges will always connect to the top of the child nodes.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="connectorMap">
        <para>the map that is used for storing the direction specifiers of the child nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.DendrogramNodePlacer.CreateComparer">
      <summary>
        <para>Creates a <see cref="T:System.Collections.Generic.IComparer`1" /> that sorts outgoing edges according to the x-coordinate of their target nodes.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:System.Collections.Generic.IComparer`1" /> can be used for achieving a From Sketch layout.</para>
      </remarks>
      <returns>
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.DendrogramNodePlacer.CreateFromSketchComparer" />
    </member>
    <member name="M:yWorks.Layout.Tree.DendrogramNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Arranges the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see> of the local root and its children as a dendrogram.</para>
      </summary>
      <param name="nodeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for obtaining an initial shape of the root node</para>
      </param>
      <param name="subtreeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for accessing the pre-calculated shapes of the subtrees</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="localRoot">
        <para>the root of the subtree that should be arranged by this method</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the combined shape of the whole subtree rooted at the given local root node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.DendrogramNodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates an optional <see cref="T:yWorks.Layout.Tree.IProcessor" /> for pre- and post-processing.</para>
      </summary>
      <remarks>
        <para>This implementation returns <c>null</c>. Hence, no pre- or post-processing is done.</para>
      </remarks>
      <param name="layouter">
        <para>the current <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the root node handled by this <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
      <returns>
        <para>
          <c>null</c>
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.DendrogramNodePlacer.CreateFromSketchComparer">
      <summary>
        <para>Creates a <see cref="T:System.Collections.Generic.IComparer`1" /> for the edges which takes the initial x-coordinates of the nodes into account.</para>
      </summary>
      <remarks>
        <para>This implementation delegates to <see cref="M:yWorks.Layout.Tree.DendrogramNodePlacer.CreateComparer" />.</para>
      </remarks>
      <returns>
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> for the edges</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.DendrogramNodePlacer.CreateComparer" />
    </member>
    <member name="T:yWorks.Layout.Tree.DoubleLineNodePlacer">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.DoubleLineNodePlacer" /> arranges the children of a local root alternating in two lines.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> This <see cref="T:yWorks.Layout.Tree.INodePlacer" /> arranges nodes from top to bottom. It places the subtrees in two horizontal lines below the root. They are distributed in an alternating fashion, i.e., adjacent subtrees are in different lines.</para>
        <para>This node placer is especially useful for leaves with a large width.</para>
        <para />
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.DoubleLineNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DoubleLineNodePlacer" /> instance with the default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.DoubleLineNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.DoubleLineNodePlacer" /> instance whose direction is specified by the given modification matrix.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix for this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.DoubleLineNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" /> for every given child node.</para>
      </summary>
      <remarks>
        <para>Edges always connect to the top of the child nodes.</para>
      </remarks>
      <returns>
        <para>
          <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" />
        </para>
      </returns>
      <param name="child" />
    </member>
    <member name="M:yWorks.Layout.Tree.DoubleLineNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Places the children of the given local root alternating in two horizontal lines.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged subtree shape that contains the local root node and all its children</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Tree.DoubleLineNodePlacer.RootAlignment">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment">RootAlginment</see> that defines how the root node is aligned with its children and their shapes.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> instance specifying the location relative to the subtrees</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.DoubleLineNodePlacer.DoubleLineSpacingRatio">
      <summary>
        <para>Gets or sets the ratio of the <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.Spacing">spacing</see> between the root and the children in the upper line and the spacing between the two lines of subtrees.</para>
      </summary>
      <value>
        <para>the ratio to determine the spacing between the two lines of subtrees</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Tree.FreeNodePlacer">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.FreeNodePlacer" /> is a simple <em>pseudo</em>-placer.</para>
      </summary>
      <remarks>
        <para>The children of local root nodes are not moved. The <see cref="T:yWorks.Layout.Tree.INodePlacer" /> just merges their rotated shapes and routes the edges.</para>
        <para>This <see cref="T:yWorks.Layout.Tree.INodePlacer" /> may be useful if a local root node does not have any children or you want to place them manually.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.FreeNodePlacer.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Tree.FreeNodePlacer" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.FreeNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node.</para>
      </summary>
      <remarks>
        <para>This implementation returns <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.None" /> for every node.</para>
      </remarks>
      <param name="child">
        <para>the child node</para>
      </param>
      <returns>
        <para>
          <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.None" />
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.FreeNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Merges the rotated shapes of the given local root and its children and routes the edges between them.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged subtree shape that contains the local root node and all its children</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.FreeNodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Tree.IProcessor" /> that will change all descending <see cref="T:yWorks.Layout.Tree.INodePlacer" />s to <see cref="T:yWorks.Layout.Tree.FreeNodePlacer" />.</para>
      </summary>
      <param name="layouter">
        <para>the current <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the current root node handled by this <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.IProcessor" /> suitable for <see cref="T:yWorks.Layout.Tree.FreeNodePlacer" /></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.FillStyle">
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioNodePlacer.FillStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.FillStyle.Leading">
      <summary>
        <para>Style specifier which defines that rows/columns are aligned with their leading side.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioNodePlacer.FillStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.FillStyle.Centered">
      <summary>
        <para>Style specifier which defines that rows/columns are aligned with their center.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioNodePlacer.FillStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.FillStyle.Justify">
      <summary>
        <para>Style specifier which defines that rows/columns are justified to have the same width/height.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioNodePlacer.FillStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.FillStyle.Trailing">
      <summary>
        <para>Style specifier which defines that rows/columns are aligned with their trailing side.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioNodePlacer.FillStyle" />
    </member>
    <member name="T:yWorks.Layout.Tree.RootPlacement">
      <seealso cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.CreateBends(yWorks.Layout.IEdgeLayout,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Layout.Tree.RootPlacement,yWorks.Layout.Tree.SubtreeArrangement)" />
      <seealso cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.GetRootPlacement(System.Object)" />
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootPlacement.Top">
      <summary>
        <para>A root placement specifier for placing the root centered above its subtree, depending on the actual <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see>.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacementDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootPlacement.Corner">
      <summary>
        <para>A root placement specifier for placing the root in the upper left corner of the subtree bounds with respect to the actual <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see>.</para>
        <para>Whether the root is placed entirely beside the subtree with no horizontal overlaps or entirely above the subtree without vertical overlaps will be determined by the layout of the subtree. The layout algorithm tries to minimize the bounds of the subtree.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacementDpKey" />
      <seealso cref="F:yWorks.Layout.Tree.RootPlacement.CornerTop" />
      <seealso cref="F:yWorks.Layout.Tree.RootPlacement.CornerSide" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootPlacement.CornerSide">
      <summary>
        <para>A root placement specifier for placing the root in the upper left corner of the subtree bounds with respect to the actual <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see>.</para>
        <para>The root is placed entirely beside the subtree with no horizontal overlaps. This might by important if the root's height is very large while its width is small.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacementDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootPlacement.CornerTop">
      <summary>
        <para>A root placement specifier for placing the root of a subtree in the upper left corner of the subtree bounds with respect to the actual <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see>.</para>
        <para>The root is placed entirely above the subtree with no vertical overlaps. This might by important if the root's width is very large while its height is small.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.RootPlacementDpKey" />
    </member>
    <member name="T:yWorks.Layout.Tree.SubtreeArrangement">
      <summary>
        <para>A direction specifier for placing the child nodes next to each other in direction of the actual <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see>, with the edges connecting in the direction of flow.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.CreateBends(yWorks.Layout.IEdgeLayout,yWorks.Algorithms.Node,yWorks.Algorithms.Node,yWorks.Layout.Tree.RootPlacement,yWorks.Layout.Tree.SubtreeArrangement)" />
      <seealso cref="M:yWorks.Layout.Tree.AspectRatioTreeLayout.GetSubtreeArrangement(System.Object)" />
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeArrangement" />
    </member>
    <member name="F:yWorks.Layout.Tree.SubtreeArrangement.Horizontal">
      <summary>
        <para>A direction specifier for placing the child nodes next to each other in direction of the actual <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see>, with the edges connecting in the direction of flow.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeRoutingPolicyDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.SubtreeArrangement.Vertical">
      <summary>
        <para>A direction specifier for placing the child nodes above each other in direction of the actual <see cref="P:yWorks.Layout.MultiStageLayout.LayoutOrientation">layout orientation</see>, with the edges connecting orthogonally to the direction of flow.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.Tree.AspectRatioTreeLayout.SubtreeRoutingPolicyDpKey" />
    </member>
    <member name="T:yWorks.Layout.Tree.InterleavedMode">
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.InterleavedMode" />
    </member>
    <member name="F:yWorks.Layout.Tree.InterleavedMode.Off">
      <summary>
        <para>A child placement mode where all child nodes are placed around their parent with equal distances.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.InterleavedMode" />
    </member>
    <member name="F:yWorks.Layout.Tree.InterleavedMode.AllNodes">
      <summary>
        <para>A child placement mode where nodes are placed in an interleaved fashion, that is, with two different, alternating distances to the parent node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.InterleavedMode" />
    </member>
    <member name="F:yWorks.Layout.Tree.InterleavedMode.MarkedNodes">
      <summary>
        <para>A child placement mode where child nodes of selected nodes are placed in an interleaved fashion, that is, with two different, alternating distances to the parent node.</para>
        <para>All other nodes are placed without interleaving. The node selection can be specified by registering an appropriate <see cref="T:yWorks.Algorithms.IDataProvider" /> for key <see cref="F:yWorks.Layout.Tree.BalloonLayout.InterleavedNodesDpKey" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.InterleavedMode" />
    </member>
    <member name="T:yWorks.Layout.Tree.NodeLabelingPolicy">
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.NodeLabelingPolicy.RayLike">
      <summary>
        <para>Node labeling policy for ray-like label placement at nodes with zero or one child node.</para>
        <para>Labels belonging to leaf nodes and nodes with exactly one successor (thus forming a sort of chain) will not be oriented horizontal but ray-like; they get the same orientation as their nodes' incoming edge. The labels of the other nodes will be oriented horizontally and placed at the center of the corresponding node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.NodeLabelingPolicy.RayLikeLeaves">
      <summary>
        <para>Node labeling policy for ray-like label placement at leaf nodes.</para>
        <para>Labels corresponding to leaf nodes get the same orientation as their nodes' incoming edge and are placed outside the node (without overlaps). The labels of the other nodes will be oriented horizontally and placed at the center of the corresponding node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.NodeLabelingPolicy.Horizontal">
      <summary>
        <para>Node labeling policy for horizontal label placement at all nodes.</para>
        <para>The node labels are placed at the center of the corresponding node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.NodeLabelingPolicy" />
    </member>
    <member name="T:yWorks.Layout.Tree.ChildAlignmentPolicy">
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildAlignmentPolicy.Plain">
      <summary>
        <para>Alignment policy to align child nodes rooted at the same parent such that the border of their convex hull has the same distance to the parent node's center.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildAlignmentPolicy.SameCenter">
      <summary>
        <para>Alignment policy to align child nodes rooted at the same parent such that each child has the same center-to-center distance to the parent node.</para>
        <para>All nodes will be placed on a common radius around their parent, respective to their center coordinates.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildAlignmentPolicy.Compact">
      <summary>
        <para>Alignment policy for aligning child nodes such that the distances to their parent are kept short and drawings can potentially become more compact.</para>
        <para>This policy realizes the exact same child alignment as <see cref="F:yWorks.Layout.Tree.ChildAlignmentPolicy.Plain" /> if there are no edge labels associated with edges going to child nodes or if <see cref="P:yWorks.Layout.Tree.BalloonLayout.IntegratedEdgeLabeling">integrated edge labeling</see> is disabled.</para>
        <para>If edge labels need to be considered, edge labels will be added to the convex hull of the child node to which the edge connects. This means that child nodes connected with a labeled edge will be aligned at the border where the edge label begins. In consequence, edge labels will be aligned with neighboring edge labels as well as neighboring child nodes if a child node has no edge label at its incoming edge.</para>
        <para>This alignment strategy is especially effective if large edge labels need to be considered while drawings should still be compact and distances from parent to child nodes short.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildAlignmentPolicy.Smart">
      <summary>
        <para>Alignment policy to align child nodes rooted at the same parent using a mixture of the other policies and aiming to achieve symmetry and compactness at the same time.</para>
        <para>Similar to <see cref="F:yWorks.Layout.Tree.ChildAlignmentPolicy.SameCenter" />, this policy aims to achieve alignments featuring equal distances between parent and child node centers. However, a much larger distance for all child nodes caused by single large subtrees is avoided by this policy. In such cases, the smaller subtrees may be placed on a common radius and the large subtrees are placed with different distances.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildAlignmentPolicy" />
    </member>
    <member name="T:yWorks.Layout.Tree.ChildOrderingPolicy">
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildOrderingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildOrderingPolicy.Compact">
      <summary>
        <para>Child ordering policy which orders child nodes depending on their subtree size such that large subtrees are placed next to small ones in order to save space.</para>
        <para>The actual area of a subtree is used as the subtree size. The smallest subtree is placed next to the largest subtree, followed by the second smallest subtree and so on. This way, drawings can become more compact, because the adjacent placement of large subtrees is avoided (which would require edges to become longer for subtrees to fit next to each other).</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildOrderingPolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildOrderingPolicy.Symmetric">
      <summary>
        <para>Child ordering policy which sorts the child nodes according to their wedge angles.</para>
        <para>The node with the greatest angle gets median position in the sorting order. The smaller the wedges, the farther away a node will be placed from the median position. Using this policy, the produced results are often more symmetric.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.ChildOrderingPolicy" />
    </member>
    <member name="T:yWorks.Layout.Tree.RootNodePolicy">
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootNodePolicy.DirectedRoot">
      <summary>
        <para>Root node policy for choosing a node with indegree <c>0</c> as root node of the tree.</para>
        <para>The selection of the root node will happen according to <see cref="M:yWorks.Algorithms.Trees.GetRoot(yWorks.Algorithms.Graph)" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy" />
      <seealso cref="M:yWorks.Algorithms.Trees.GetRoot(yWorks.Algorithms.Graph)" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootNodePolicy.CenterRoot">
      <summary>
        <para>Root node policy for choosing the center node as root node of the tree.</para>
        <para>A <see cref="M:yWorks.Algorithms.Trees.GetCenterRoot(yWorks.Algorithms.Graph)">center node</see> induces a minimum depth tree when being used as the root of that tree.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy" />
      <seealso cref="M:yWorks.Algorithms.Trees.GetCenterRoot(yWorks.Algorithms.Graph)" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootNodePolicy.WeightedCenterRoot">
      <summary>
        <para>Root node policy for choosing a weighted center node as root node of the tree.</para>
        <para>A <see cref="M:yWorks.Algorithms.Trees.GetWeightedCenterNode(yWorks.Algorithms.Graph,yWorks.Algorithms.INodeMap)">weighted center node</see> is a node which is part of the greatest number of all undirected paths in a graph.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootNodePolicy.SelectedRoot">
      <summary>
        <para>Root node policy for choosing a custom node as the root node of the tree.</para>
        <para>The root node is specified using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Tree.BalloonLayout.SelectedRootDpKey" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.RootNodePolicy" />
    </member>
    <member name="T:yWorks.Layout.Tree.ChildPlacement">
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,yWorks.Layout.Tree.RoutingStyle,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,yWorks.Layout.Tree.RoutingStyle,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildPlacement.VerticalToLeft">
      <summary>
        <para>Placement specifier which defines that subtrees are placed one below the other and left of the root node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildPlacement.VerticalToRight">
      <summary>
        <para>Placement specifier which defines that subtrees are placed one below the other and right of the root node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildPlacement.HorizontalUpward">
      <summary>
        <para>Placement specifier which defines that subtrees are placed horizontally next to each other and above the root node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.ChildPlacement.HorizontalDownward">
      <summary>
        <para>Placement specifier which defines that subtrees are placed horizontally next to each other and below the root node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement" />
    </member>
    <member name="T:yWorks.Layout.Tree.RootAlignment">
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,yWorks.Layout.Tree.RoutingStyle,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,yWorks.Layout.Tree.RoutingStyle,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootAlignment.LeadingOffset">
      <summary>
        <para>Alignment specifier which defines that the root node is placed ahead of all its child subtrees.</para>
        <para>Depending on the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, the root node is placed ahead (e.g. <see cref="F:yWorks.Layout.Tree.ChildPlacement.HorizontalDownward" />: left) of the combined bounding box of all subtrees without labels.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootAlignment.Leading">
      <summary>
        <para>Alignment specifier which defines that the root node is placed aligned with its first subtree.</para>
        <para>Depending on the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, the root node is placed aligned with the bounding box of its first (e.g. <see cref="F:yWorks.Layout.Tree.ChildPlacement.HorizontalDownward" />: left) subtree.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootAlignment.Center">
      <summary>
        <para>Alignment specifier which defines that the root node is placed aligned with the center of its subtrees.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootAlignment.Median">
      <summary>
        <para>Alignment specifier which defines that the root node is placed at the median of the connection points to its subtrees.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootAlignment.Trailing">
      <summary>
        <para>Alignment specifier which defines that the root node is placed aligned with its last subtree.</para>
        <para>Depending on the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, the root node is placed aligned with the bounding box of its last (e.g. <see cref="F:yWorks.Layout.Tree.ChildPlacement.HorizontalDownward" />: right) subtree.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootAlignment.TrailingOffset">
      <summary>
        <para>Alignment specifier which defines that the root is placed after all its subtree.</para>
        <para>Depending on the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, the root node is placed after (e.g. <see cref="F:yWorks.Layout.Tree.ChildPlacement.HorizontalDownward" />: right) of the combined bounding box of all subtrees without labels.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootAlignment.TrailingOnBus">
      <summary>
        <para>Alignment specifier which defines that the root is placed after all its subtrees, centered on the bus.</para>
        <para>Depending on the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, the root node is placed after (e.g. <see cref="F:yWorks.Layout.Tree.ChildPlacement.HorizontalDownward" />: right) of the combined bounding box of all subtrees without labels. The bus leaves directly from the root node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.RootAlignment.LeadingOnBus">
      <summary>
        <para>Alignment specifier which defines that the root is placed ahead of all its subtrees, centered on the bus.</para>
        <para>Depending on the <see cref="P:yWorks.Layout.Tree.DefaultNodePlacer.ChildPlacement">child placement</see>, the root node is placed ahead (e.g. <see cref="F:yWorks.Layout.Tree.ChildPlacement.HorizontalDownward" />: left) of the combined bounding box of all subtrees without labels. The bus leaves directly from the root node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RootAlignment" />
    </member>
    <member name="T:yWorks.Layout.Tree.RoutingStyle">
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,yWorks.Layout.Tree.RoutingStyle,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.#ctor(yWorks.Layout.Tree.ChildPlacement,yWorks.Layout.Tree.RootAlignment,yWorks.Layout.Tree.RoutingStyle,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.RoutingStyle.Fork">
      <summary>
        <para>Routing style specifier which defines that edge paths are routed orthogonally with the bends located in the channel between the root node and the child nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.RoutingStyle.ForkAtRoot">
      <summary>
        <para>Routing style specifier which defines that edge paths are routed orthogonally with just one bend.</para>
        <para>Edges will leave the root node at its sides and bend exactly above the according child node. If the child node is placed directly below the root node, the edge will bend inside of the root node and leave it at the bottom.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.RoutingStyle.Straight">
      <summary>
        <para>Routing style specifier which defines that edge paths are routed with a straight segment to the center of the child nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.RoutingStyle.Polyline">
      <summary>
        <para>Routing style constant which defines that edge paths are routed with a straight segment to the connector of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of the child nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.DefaultNodePlacer.RoutingStyle" />
    </member>
    <member name="T:yWorks.Layout.Tree.PortAssignmentMode">
      <seealso cref="M:yWorks.Layout.Tree.DefaultPortAssignment.#ctor(yWorks.Layout.Tree.PortAssignmentMode,System.Double)" />
      <seealso cref="P:yWorks.Layout.Tree.DefaultPortAssignment.Mode" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortAssignmentMode.PortConstraint">
      <summary>
        <para>A port assignment specifier that defines that <see cref="T:yWorks.Layout.PortConstraint" />s are considered. Ports are placed using the following rules:</para>
        <list type="bullet">
          <item>edges without a <see cref="T:yWorks.Layout.PortConstraint" /> are anchored at the center of the node</item>
          <item>edges with a weak <see cref="T:yWorks.Layout.PortConstraint" /> are anchored at the center of their specified side</item>
          <item>edges with a strong <see cref="T:yWorks.Layout.PortConstraint" /> are anchored at their initial coordinates</item>
        </list>
        <para>If edges with <see cref="T:yWorks.Layout.PortConstraint" />s are grouped, all edges in the same group will use the port coordinates of the first edge in the group.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortAssignmentMode.DistributedNorth">
      <summary>
        <para>A port assignment specifier which defines that edges are distributed evenly at the northern side of their nodes.</para>
        <para>Grouped edges will use the same port coordinate and will be considered as a single edge when calculating the distribution.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortAssignmentMode.DistributedSouth">
      <summary>
        <para>A port assignment specifier which defines that edges are distributed evenly at the southern side of their nodes.</para>
        <para>Grouped edges will use the same port coordinate and will be considered as a single edge when calculating the distribution.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortAssignmentMode.DistributedEast">
      <summary>
        <para>A port assignment specifier which defines that edges are distributed evenly at the eastern side of their nodes.</para>
        <para>Grouped edges will use the same port coordinate and will be considered as a single edge when calculating the distribution.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortAssignmentMode.DistributedWest">
      <summary>
        <para>A port assignment specifier which defines that edges are distributed evenly at the western side of their nodes.</para>
        <para>Grouped edges will use the same port coordinate and will be considered as a single edge when calculating the distribution.</para>
      </summary>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortAssignmentMode.None">
      <summary>
        <para>A port assignment specifier which defines that all ports are reset to the center of their nodes.</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Tree.ConnectorDirection">
      <summary>
        <para>A direction constant that describes that the last connector segment points up.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorDirection" />
    </member>
    <member name="F:yWorks.Layout.Tree.ConnectorDirection.North">
      <summary>
        <para>A direction constant that describes that the last connector segment points up. The edge from the parent will connect to the north of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorDirection" />
    </member>
    <member name="F:yWorks.Layout.Tree.ConnectorDirection.East">
      <summary>
        <para>A direction constant that describes that the last connector segment points to the right. The edge from the parent will connect to the east of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorDirection" />
    </member>
    <member name="F:yWorks.Layout.Tree.ConnectorDirection.South">
      <summary>
        <para>A direction constant that describes that the last connector segment points down. The edge from the parent will connect to the south of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorDirection" />
    </member>
    <member name="F:yWorks.Layout.Tree.ConnectorDirection.West">
      <summary>
        <para>A direction constant that describes that the last connector segment points to the left. The edge from the parent will connect to the west of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorDirection" />
    </member>
    <member name="T:yWorks.Layout.Tree.BorderLineSide">
      <summary>
        <para>Side constant that defines the index of the eastern border line.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.BorderLineSide.North">
      <summary>
        <para>Side constant that defines the index of the northern border line.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)" />
    </member>
    <member name="F:yWorks.Layout.Tree.BorderLineSide.East">
      <summary>
        <para>Side constant that defines the index of the eastern border line.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)" />
    </member>
    <member name="F:yWorks.Layout.Tree.BorderLineSide.South">
      <summary>
        <para>Side constant that defines the index of the southern border line.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)" />
    </member>
    <member name="F:yWorks.Layout.Tree.BorderLineSide.West">
      <summary>
        <para>Side constant that defines the index of the western border line.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)" />
    </member>
    <member name="T:yWorks.Layout.Tree.LayeredRoutingStyle">
      <seealso cref="P:yWorks.Layout.Tree.LayeredNodePlacer.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.LayeredRoutingStyle.Straight">
      <summary>
        <para>Routing style specifier which defines that edges consist of one straight segment.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.LayeredNodePlacer.RoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.LayeredRoutingStyle.Orthogonal">
      <summary>
        <para>Routing style specifier which defines that edges are routed in an orthogonal, bus-like fashion.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.LayeredNodePlacer.RoutingStyle" />
    </member>
    <member name="T:yWorks.Layout.Tree.MultiParentRoutingStyle">
      <seealso cref="P:yWorks.Layout.Tree.MultiParentDescriptor.EdgeStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.MultiParentRoutingStyle.Polyline">
      <summary>
        <para>Routing style for routing non-shared edge segments in a polyline fashion.</para>
        <para>The edges connected to a multi-parent structure will share their paths until shortly above/below the multi-parent nodes. This style only applies to the part of the edges where they split to connect to different multi-parents.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.MultiParentDescriptor.EdgeStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.MultiParentRoutingStyle.Orthogonal">
      <summary>
        <para>Routing style for routing non-shared edge segments in an orthogonal fashion.</para>
        <para>The edges connected to a multi-parent structure will share their paths until shortly above/below the multi-parent nodes. This style only applies to the part of the edges where they split to connect to different multi-parents.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.MultiParentDescriptor.EdgeStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.MultiParentRoutingStyle.Straight">
      <summary>
        <para>Routing style for routing non-shared edge segments straight. This style will route the part of the edges that doesn't share the same path directly from the center of the multi-parent to the common point of the edges in the multi-parent structure.</para>
        <para>The edges connected to a multi-parent structure will share their paths until shortly above/below the multi-parent nodes. This style only applies to the part of the edges where they split to connect to different multi-parents.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.MultiParentDescriptor.EdgeStyle" />
    </member>
    <member name="T:yWorks.Layout.Tree.ParentConnectorDirection">
      <seealso cref="M:yWorks.Layout.Tree.AspectRatioNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.AspectRatioNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.AssistantNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.AssistantNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.AssistantNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.BusNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.BusNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.DefaultNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.DelegatingNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.DelegatingNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.DelegatingNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.DendrogramNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.DoubleLineNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.DoubleLineNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.FreeNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.FreeNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.GridNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.GridNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.GroupedNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.LayeredNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.LayeredNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.LeafNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.LeftRightNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.LeftRightNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.NodePlacerBase.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.TranslateDirectionToModel(yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.TranslateDirectionToReal(yWorks.Layout.Tree.ParentConnectorDirection)" />
      <seealso cref="M:yWorks.Layout.Tree.SimpleNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)" />
      <seealso cref="M:yWorks.Layout.Tree.SimpleNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="F:yWorks.Layout.Tree.ParentConnectorDirection.None">
      <summary>
        <para>Direction specifier which indicates that no connector should be calculated.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="F:yWorks.Layout.Tree.ParentConnectorDirection.Any">
      <summary>
        <para>Direction specifier which indicates that any direction can be used for the connector to the parent node.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="F:yWorks.Layout.Tree.ParentConnectorDirection.North">
      <summary>
        <para>Direction specifier which indicates that the connector to the parent node should end in a segment that can be extended by a segment that goes north.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="F:yWorks.Layout.Tree.ParentConnectorDirection.East">
      <summary>
        <para>Direction specifier which indicates that the connector to the parent node should end in a segment that can be extended by a segment that goes east.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="F:yWorks.Layout.Tree.ParentConnectorDirection.South">
      <summary>
        <para>Direction specifier which indicates that the connector to the parent node should end in a segment that can be extended by a segment that goes south.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="F:yWorks.Layout.Tree.ParentConnectorDirection.West">
      <summary>
        <para>Direction specifier which indicates that the connector to the parent node should end in a segment that can be extended by a segment that goes west.</para>
      </summary>
      <seealso cref="M:yWorks.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="T:yWorks.Layout.Tree.PortStyle">
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.PortStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortStyle.NodeCenter">
      <summary>
        <para>A constant defining that ports are placed at the center of the nodes.</para>
        <para>This constant uses <c>(0,0)</c> as port offset.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.PortStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortStyle.BorderCenter">
      <summary>
        <para>A constant defining that ports are placed at the center of the border of the nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.PortStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortStyle.BorderDistributed">
      <summary>
        <para>A constant defining that ports are evenly distributed along the border of the nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.PortStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.PortStyle.PortConstraintsAware">
      <summary>
        <para>A constant defining that ports are assigned based on given <see cref="T:yWorks.Layout.PortConstraint">port constraints</see>.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.PortStyle" />
    </member>
    <member name="T:yWorks.Layout.Tree.EdgeRoutingStyle">
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.EdgeRoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.EdgeRoutingStyle.Plain">
      <summary>
        <para>A constant for routing the edges as straight-line segments.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.EdgeRoutingStyle" />
    </member>
    <member name="F:yWorks.Layout.Tree.EdgeRoutingStyle.Orthogonal">
      <summary>
        <para>A constant for routing the edges orthogonally in a bus-like fashion.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.EdgeRoutingStyle" />
    </member>
    <member name="T:yWorks.Layout.Tree.LeafPlacement">
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.LeafPlacement.LeavesStacked">
      <summary>
        <para>A policy for placing the leaf nodes in a stack-like fashion with balanced stack heights.</para>
        <para>In this context, a stack-like fashion means that leaf nodes that connect to the same parent node are placed one upon the other, resulting in horizontally compact layouts.</para>
        <para>This policy tries to balance stack heights, i.e., for each subtree that consists only of leaf nodes, <see cref="F:yWorks.Layout.Tree.LeafPlacement.LeavesStackedRight" /> or <see cref="F:yWorks.Layout.Tree.LeafPlacement.LeavesStackedLeftAndRight" /> will be used depending on the number of leaves in the subtree.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.LeafPlacement.LeavesStackedLeft">
      <summary>
        <para>A policy for placing the leaf nodes in a stack-like fashion using a single stack left.</para>
        <para>In this context, a stack-like fashion means that leaf nodes that connect to the same root node are placed one upon the other, resulting in horizontally compact layouts.</para>
        <para>This policy uses a single stack that lies to the left relative to the center of the parent node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.LeafPlacement.LeavesStackedRight">
      <summary>
        <para>A policy for placing the leaf nodes in a stack-like fashion using a single stack right.</para>
        <para>In this context, a stack-like fashion means that leaf nodes that connect to the same root node are placed one upon the other, resulting in horizontally compact layouts.</para>
        <para>This policy uses a single stack that lies to the right relative to the center of the parent node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.LeafPlacement.LeavesStackedLeftAndRight">
      <summary>
        <para>A policy for placing the leaf nodes in a stack-like fashion using two stacks.</para>
        <para>In this context, a stack-like fashion means that leaf nodes that connect to the same root node are placed one upon the other, resulting in horizontally compact layouts.</para>
        <para>This policy distributes leaf nodes among two stacks, one to the left and one to the right relative to the center of the parent node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.LeafPlacement.AllLeavesOnSameLayer">
      <summary>
        <para>A policy for placing the leaf nodes in a Dendrogram-like fashion.</para>
        <para>According to this policy, all leaf nodes are placed in one layer (i.e. all leaves are placed on one horizontal line in a top-to-bottom or in a bottom-to-top layout).</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
    </member>
    <member name="F:yWorks.Layout.Tree.LeafPlacement.SiblingsOnSameLayer">
      <summary>
        <para>A policy for placing the leaf nodes with the same parent in the same layer.</para>
        <para>For example, siblings are being placed on a horizontal line in a top-to-bottom or in a bottom-to-top layout.</para>
        <para>This policy produces vertically compact layouts.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.LeafPlacement" />
    </member>
    <member name="T:yWorks.Layout.Tree.GridNodePlacer">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.GridNodePlacer" /> arranges the shapes of the children of a local root in a grid.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> The grid consists of a number of rows. The subtrees are assigned to the rows using a <see cref="T:yWorks.Algorithms.IDataProvider" /> that is registered with the graph with <see cref="F:yWorks.Layout.Tree.GridNodePlacer.RowIndexDpKey" />. </para>
        <para>Child nodes placed in a grid using three rows and four columns</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.GridNodePlacer.RowIndexDpKey">
      <summary>
        <para>A data provider key for assigning nodes to the rows in the grid.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered with this key, all nodes will be placed in the same row.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.GridNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.GridNodePlacer" /> with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.GridNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.GridNodePlacer" /> instance whose direction is specified by the given modification matrix.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix for this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.GridNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix,yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.GridNodePlacer" /> instance with the given <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">modification matrix</see> and <see cref="P:yWorks.Layout.Tree.GridNodePlacer.RootAlignment">root alignment</see>.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix for this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /></para>
      </param>
      <param name="rootAlignment">
        <para>the alignment of the local root with its subtrees</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.GridNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" /> for every given child node.</para>
      </summary>
      <remarks>
        <para>Edges always connect to the top of the child nodes.</para>
      </remarks>
      <returns>
        <para>
          <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" />
        </para>
      </returns>
      <param name="child" />
    </member>
    <member name="M:yWorks.Layout.Tree.GridNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Places the children of a local root node in a grid.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged subtree shape that contains the local root node and all its children</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.GridNodePlacer.CreateFromSketchComparer">
      <summary>
        <para>Creates a <see cref="T:System.Collections.Generic.IComparer`1" /> that sorts the outgoing edges according to the rows and x-coordinates of their target nodes.</para>
      </summary>
      <remarks>
        <para>Edges that connect to nodes in different rows are ordered by the row index. If two edges connect to the same row, they are sorted by the x-coordinates of their target nodes.</para>
      </remarks>
      <returns>
        <para>a <see cref="T:System.Collections.Generic.IComparer`1" /> that orders edges lexicographically by row and x-coordinates of their target nodes</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.GridNodePlacer.RowIndexDpKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.GridNodePlacer.RootAlignment">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment">RootAlginment</see> that defines how the root node is aligned with its children and their shapes.</para>
      </summary>
      <value>
        <para>
          <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> instance specifying the location relative to the subtrees</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Tree.GroupedNodePlacer">
      <summary>
        <para>This <see cref="T:yWorks.Layout.Tree.INodePlacer" /> places the children of a local root in groups.</para>
      </summary>
      <remarks>
        <para>The groups are determined by the grouping of the edges that connect the children to its root. The placement of the groups is specified by a <see cref="T:yWorks.Layout.Tree.INodePlacer" /> which will consider grouped children as one child. The children within a group are placed by another <see cref="T:yWorks.Layout.Tree.INodePlacer" />.</para>
        <para> There are three edge groups whose target nodes are placed above each other</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="M:yWorks.Layout.Tree.GroupedNodePlacer.#ctor(yWorks.Layout.Tree.INodePlacer,yWorks.Layout.Tree.INodePlacer)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.GroupedNodePlacer" /> instance.</para>
      </summary>
      <param name="groupPlacer">
        <para>the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> which places the child groups</para>
      </param>
      <param name="childPlacer">
        <para>the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> which places the children within their group</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.GroupedNodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Delegates to the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> responsible for arranging the nodes in one group.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="connectorMap">
        <para>the map used for storing the direction specifiers of the child nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.GroupedNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Places the groups of <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s according to their group IDs.</para>
      </summary>
      <param name="nodeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for obtaining an initial shape of the root node</para>
      </param>
      <param name="subtreeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for accessing the pre-calculated shapes of the subtrees</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="localRoot">
        <para>the root of the subtree that should be arranged by this method</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s of the local root and its children</para>
      </returns>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="M:yWorks.Layout.Tree.GroupedNodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Tree.IProcessor" /> that prepares the graph for edge grouping.</para>
      </summary>
      <remarks>
        <para>In a pre-processing step, the <see cref="T:yWorks.Layout.Tree.IProcessor" /> inserts a dummy node for each edge group and connects it to the local root and the edges of the according group. The child node placer is assigned to those dummy nodes and will arrange them during the layout calculation.</para>
        <para>The changes to the graph are restored in a post-processing step.</para>
      </remarks>
      <param name="layouter">
        <para>the current <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the root node handled by this <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.IProcessor" /> responsible for preparing the graph</para>
      </returns>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="T:yWorks.Layout.Tree.IFromSketchNodePlacer">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.IFromSketchNodePlacer" /> arranges the subtrees while taking the initial locations of the nodes into account.</para>
      </summary>
      <remarks>
        <para>It provides a <see cref="T:System.Collections.Generic.IComparer`1" /> which sorts the outgoing edges of a node according to the initial coordinates of their target nodes. Keeping the original order of nodes, this <see cref="T:System.Collections.Generic.IComparer`1" /> allows to incrementally add new nodes to the graph.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.IFromSketchNodePlacer.CreateFromSketchComparer">
      <summary>
        <para>Creates an <see cref="T:System.Collections.Generic.IComparer`1">edge comparator</see> which takes the initial coordinates of the nodes into account.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:System.Collections.Generic.IComparer`1" /> defines the order of the outgoing edges of a node before the actual placement of the node's subtree is calculated.</para>
      </remarks>
      <returns>
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> for the edges</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.INodePlacer">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.INodePlacer" /> is responsible for the arrangement of a local root node and all of its subtrees.</para>
      </summary>
      <remarks>
        <para>Subtrees are represented as <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see>s with a connecting edge to the root of the subtree.</para>
        <para>Implementations of this interface have to:</para>
        <list type="bullet">
          <item>arrange the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see> and the root node (only the relative position matters, shapes can be placed at any absolute location, <see cref="T:yWorks.Layout.Tree.TreeLayout" /> will perform the final alignment).</item>
          <item>perform the edge routing from the root node to all child nodes with respect to the connector provided by the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see></item>
          <item>calculate the union of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see> and the shape of the root node as well as any added edges</item>
          <item>initialize the connector of the root node with respect to the preferred connection direction</item>
          <item>return the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see> for the subtree including the local root</item>
        </list>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.INodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Provides the direction of the connector to the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see> for each child node.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="T:yWorks.Layout.Tree.TreeLayout" /> before the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see> for the children of the local root node are calculated. The direction specifiers are stored in the given map for all child nodes of the local root.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="connectorMap">
        <para>the map that must be used for storing the direction specifiers of the child nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.INodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Arranges the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see> of the local root and its children and routes the edges that connect them.</para>
      </summary>
      <remarks>
        <para>This method is the main method of the tree layout algorithm. It is called by <see cref="T:yWorks.Layout.Tree.TreeLayout" /> in each recursion step to place the local root in relation to its children. Their shapes will be merged into one <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see>, which is returned by this method.</para>
        <para>The <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see> for the local root can be obtained from the <c>nodeShapeProvider</c>. <c>subtreeShapeProvider</c> contains the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see> assigned to the child nodes.</para>
        <para>Due to the order in which the tree nodes are processed, it is guaranteed that at the time of the invocation of this method the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see> of every descendant node has already been calculated.</para>
      </remarks>
      <param name="nodeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for obtaining an initial shape of the root node</para>
      </param>
      <param name="subtreeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for accessing the pre-calculated shapes of the subtrees</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="localRoot">
        <para>the root of the subtree that should be arranged by this method</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the combined shape of the whole subtree</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.INodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates an optional <see cref="T:yWorks.Layout.Tree.IProcessor" /> for pre- and post-processing.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="T:yWorks.Layout.Tree.TreeLayout" /> before arranging the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShapes</see>. If no pre- or post-processing is needed, this method may return <c>null</c>.</para>
      </remarks>
      <param name="layouter">
        <para>the current <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the root node handled by this <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Tree.IProcessor" /> instance or <c>null</c></para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.IPortAssignment">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> places the ports of edges connecting to the same node.</para>
      </summary>
      <remarks>
        <para>Classes implementing this interface are responsible for the assignment of the edges' ports. <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instances need to obey the currently set ports.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.IPortAssignment.AssignPorts(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Places the ports of edges connecting to the given node.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="T:yWorks.Layout.Tree.TreeLayout" /> before the actual layout calculation takes place. It assigns both the single incoming edge's target port as well as all source ports of all outgoing child edges.</para>
      </remarks>
      <param name="graph">
        <para>the graph</para>
      </param>
      <param name="node">
        <para>the node whose adjacent edges' ports should be set</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Tree.IProcessor">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.IProcessor" /> provides the possibility for each <see cref="T:yWorks.Layout.Tree.INodePlacer" /> to prepare (and clean up) the graph for the children of the local root.</para>
      </summary>
      <remarks>
        <para>It is created by <see cref="M:yWorks.Layout.Tree.INodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)" /> and called by the <see cref="T:yWorks.Layout.Tree.TreeLayout" /> before and after the actual arrangement of the nodes.</para>
        <para>A <see cref="T:yWorks.Layout.Tree.IProcessor" /> may change values within the <see cref="T:yWorks.Algorithms.IDataMap" />s for its children. It can also temporarily change the graph by hiding nodes or adding dummy nodes.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.IProcessor.PreProcess(yWorks.Algorithms.IDataMap,yWorks.Algorithms.IDataMap,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Performs preparations for the actual tree layout in a pre-processing step.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="T:yWorks.Layout.Tree.TreeLayout" /> before the <see cref="T:yWorks.Layout.Tree.INodePlacer" />s are called recursively. A <see cref="T:yWorks.Layout.Tree.IProcessor" /> may change some settings within this method. This can be used for specifying values for the children of the local root, manipulate the graph structure or do anything else that needs to be done.</para>
      </remarks>
      <param name="nodePlacerDataProvider">
        <para>the map that stores a <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance for each node</para>
      </param>
      <param name="portAssignmentDataProvider">
        <para>The map that stores a <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> instance for each node</para>
      </param>
      <param name="childComparatorProvider">
        <para>the map that stores a <see cref="T:System.Collections.Generic.IComparer`1" /> instance for each node</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.IProcessor.PostProcess">
      <summary>
        <para>This method is called by the <see cref="T:yWorks.Layout.Tree.TreeLayout" /> after the layout has finished.</para>
      </summary>
      <remarks>
        <para>It can be used for cleanup tasks.</para>
        <para>Changes on the graph structure that have been made in <see cref="M:yWorks.Layout.Tree.IProcessor.PreProcess(yWorks.Algorithms.IDataMap,yWorks.Algorithms.IDataMap,yWorks.Algorithms.IDataMap)" /> can be undone here.</para>
      </remarks>
    </member>
    <member name="T:yWorks.Layout.Tree.LayeredNodePlacer">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.LayeredNodePlacer" /> arranges the nodes of a subtree respecting layers.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> Nodes that have the same depth in the tree will be placed in the same horizontal layer. They will be vertically <see cref="P:yWorks.Layout.Tree.LayeredNodePlacer.VerticalAlignment">aligned</see>. </para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.LayeredNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix,System.Object)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.LayeredNodePlacer" /> instance whose direction is specified by the given modification matrix.</para>
      </summary>
      <remarks>
        <para>The given ID identifies different <see cref="T:yWorks.Layout.Tree.LayeredNodePlacer" /> instances that share the same layer heights.</para>
      </remarks>
      <param name="modificationMatrix">
        <para>the transformation matrix for this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /></para>
      </param>
      <param name="id">
        <para>the <see cref="T:yWorks.Layout.Tree.LayeredNodePlacer" /> ID</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.LayeredNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.LayeredNodePlacer" /> instance with the default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Tree.LayeredNodePlacer.DendrogramStyle">
      <summary>
        <para>Gets or sets whether or not the layering is done dendrogram-like.</para>
      </summary>
      <remarks>
        <para>When enabled, leaves are placed in the same layer and remaining tree nodes are assigned to a layer as close to their children as possible.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the graph is layered as a dendrogram, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.LayeredNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" /> for every given child node.</para>
      </summary>
      <remarks>
        <para>Edges always connect to the top of the child nodes.</para>
      </remarks>
      <returns>
        <para>
          <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" />
        </para>
      </returns>
      <param name="child" />
    </member>
    <member name="M:yWorks.Layout.Tree.LayeredNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Places the children of local root in layers.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged subtree shape that contains the local root node and all its children</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.LayeredNodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Tree.IProcessor" /> that distributes the nodes over the layers.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.Tree.IProcessor" /> is chosen depending on the <see cref="P:yWorks.Layout.Tree.LayeredNodePlacer.DendrogramStyle">layout style</see>.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the current root node for this node placer</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.IProcessor" /> or <c>null</c> if the layer information is already assigned to the current root</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Tree.LayeredNodePlacer.DendrogramStyle" />
      <param name="layouter" />
    </member>
    <member name="P:yWorks.Layout.Tree.LayeredNodePlacer.RootAlignment">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment">RootAlginment</see> that defines how the root node is aligned with its children and their shapes.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> instance specifying the location relative to the subtrees</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.LayeredNodePlacer.VerticalAlignment">
      <summary>
        <para>Gets or sets the relative vertical alignment of nodes within their respective layers.</para>
      </summary>
      <remarks>
        <para>A value of <c>0</c> means that nodes are top-aligned; a value of <c>0.5</c> means that nodes are center-aligned; a value of <c>1</c> means that nodes are bottom-aligned;</para>
        <para>Values for a valid vertical alignment are in the range <c>[0..1]</c>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified alignment is outside <c>[0..1]</c></para>
      </exception>
      <value>
        <para>the vertical alignment of nodes within their layers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.LayeredNodePlacer.Id">
      <summary>
        <para>Gets the ID of this <see cref="T:yWorks.Layout.Tree.LayeredNodePlacer" />.</para>
      </summary>
      <remarks>
        <para>The ID is used for identifying <see cref="T:yWorks.Layout.Tree.LayeredNodePlacer" />s that share information about the layer height. Using different IDs allows aligned layouts within different subtrees.</para>
      </remarks>
      <value>
        <para>the ID of this node placer</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.LayeredNodePlacer.LayerSpacing">
      <summary>
        <para>Gets or sets the distance between two adjacent layers.</para>
      </summary>
      <remarks>
        <para>The spacing needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified spacing is negative</para>
      </exception>
      <value>
        <para>the spacing between two layers</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.LayeredNodePlacer.RoutingStyle">
      <summary>
        <para>Gets or sets the routing style for the edges in the subtree.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the specified routing style specifier is unknown</para>
      </exception>
      <value>
        <para>one of the predefined edge routing styles</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.LayeredNodePlacer.BusAlignment">
      <summary>
        <para>Gets or sets the vertical bus alignment for orthogonally routed edges.</para>
      </summary>
      <remarks>
        <para>The bus alignment determines the relative position of an edge bus in between two subsequent layers of nodes.</para>
        <para>Values for a valid vertical alignment are in the range <c>[0..1]</c>, such that:</para>
        <list type="bullet">
          <item>A value of <c>0.0</c> places the bus at the top, right below the parent node.</item>
          <item>A value of <c>0.5</c> places the bus in the middle between parent and child nodes.</item>
          <item>A value of <c>1.0</c> places the bus at the bottom, right above the child nodes.</item>
        </list>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified alignment is outside <c>[0..1]</c></para>
      </exception>
      <value>
        <para>the relative bus alignment</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.LayeredNodePlacer.PolylineLabeling">
      <summary>
        <para>Gets or sets whether or not straight edges are extended to avoid label overlaps.</para>
      </summary>
      <remarks>
        <para>If enabled, polyline connectors between the parent and its children are added to the according subtree shape. Node or edge labels will not be crossed.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if polyline connectors are added, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Tree.LeafNodePlacer">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.LeafNodePlacer" /> creates a <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see> for a leaf node and routes its incoming edge at the target side.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.LeafNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.LeafNodePlacer" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.LeafNodePlacer.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates an optional <see cref="T:yWorks.Layout.Tree.IProcessor" /> for pre- and post-processing.</para>
      </summary>
      <remarks>
        <para>This implementation returns <c>null</c>. Hence, no pre- or post-processing is done.</para>
      </remarks>
      <param name="layouter">
        <para>the current <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the root node handled by this <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
      <returns>
        <para>
          <c>null</c>
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.LeafNodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Does nothing because leaf nodes don't have children so there are no child connectors.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="connectorMap">
        <para>the map that must be used for storing the direction specifiers of the child nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.LeafNodePlacer.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the local root node (a leaf node in this case) and adds target points to the incoming edge.</para>
      </summary>
      <remarks>
        <para>The incoming edge is routed according to possibly assigned <see cref="T:yWorks.Layout.PortConstraint" />s.</para>
      </remarks>
      <param name="nodeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for obtaining an initial shape of the root node</para>
      </param>
      <param name="subtreeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for accessing the pre-calculated shapes of the subtrees</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="localRoot">
        <para>the root of the subtree that should be arranged by this method</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of the leaf node including the connector</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.LeftRightNodePlacer">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" /> arranges the children in a subtree on the left and the right of a vertical bus.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> </para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.LeftRightNodePlacer.LeftRightDpKey">
      <summary>
        <para>A data provider key for assigning nodes to the left or the right side of the bus.</para>
      </summary>
      <remarks>
        <para>If no <see cref="T:yWorks.Algorithms.IDataProvider" /> is specified using this key, the nodes will be placed alternating from left to right.</para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.LeftRightNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.LeftRightNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" /> instance using the given modification matrix.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix for this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /></para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.LeftRightNodePlacer.HorizontalDistance">
      <summary>
        <para>Gets or sets the horizontal distance between nodes or subtrees.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the non-negative horizontal distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.LeftRightNodePlacer.VerticalDistance">
      <summary>
        <para>Gets or sets the vertical distance between nodes or subtrees.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified distance is negative</para>
      </exception>
      <value>
        <para>the non-negative vertical distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.LeftRightNodePlacer.Spacing">
      <summary>
        <para>Sets a uniform horizontal and vertical spacing between subtrees.</para>
      </summary>
      <remarks>
        <para>This method sets the given distance value for the <see cref="P:yWorks.Layout.Tree.LeftRightNodePlacer.HorizontalDistance">horizontal spacing</see> and for the <see cref="P:yWorks.Layout.Tree.LeftRightNodePlacer.VerticalDistance">vertical spacing</see>.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the specified spacing value is negative</para>
      </exception>
      <seealso cref="P:yWorks.Layout.Tree.LeftRightNodePlacer.HorizontalDistance" />
      <seealso cref="P:yWorks.Layout.Tree.LeftRightNodePlacer.VerticalDistance" />
    </member>
    <member name="M:yWorks.Layout.Tree.LeftRightNodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Determines the direction of the child connectors according to which side of the bus the child is assigned.</para>
      </summary>
      <remarks>
        <para>Children on the left will get a connector to the <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.East" />. Children on the right will get one to the <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.West" />. A connector to the <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" /> is assigned for the bottom child.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="connectorMap">
        <para>the map that must be used for storing the direction specifiers of the child nodes</para>
      </param>
      <seealso cref="P:yWorks.Layout.Tree.LeftRightNodePlacer.PlaceLastOnBottom" />
    </member>
    <member name="M:yWorks.Layout.Tree.LeftRightNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node.</para>
      </summary>
      <remarks>
        <para>Since the connector directions are already determined by <see cref="M:yWorks.Layout.Tree.LeftRightNodePlacer.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)" />, this method doesn't need to be called.</para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
        <para>if this method is called</para>
      </exception>
      <param name="child" />
    </member>
    <member name="M:yWorks.Layout.Tree.LeftRightNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Places the subtree shapes of the children left and right of a common vertical bus.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged subtree shape that contains the local root node and all its children</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Tree.LeftRightNodePlacer.PlaceLastOnBottom">
      <summary>
        <para>Gets or sets whether or not the last child is placed centered, aligned with the bus and below the other child nodes.</para>
      </summary>
      <remarks>
        <para>When enabled, the last child will always be centered independent of the number of siblings.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the last child is separated, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.LeftRightNodePlacer.CreateComparer">
      <summary>
        <para>Returns a <see cref="T:System.Collections.Generic.IComparer`1" /> for outgoing edges that considers the locations of the target nodes.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:System.Collections.Generic.IComparer`1" /> applies the <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">modification matrix</see> of this <see cref="T:yWorks.Layout.Tree.LeftRightNodePlacer" /> and then compares the y-coordinates of the target nodes.</para>
      </remarks>
      <returns>
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> that compares outgoing edges according to the locations of their target nodes</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.LeftRightNodePlacer.CreateLeftRightDataProvider(yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Creates a special <see cref="T:yWorks.Algorithms.IDataProvider" /> that determines whether a given node is placed left or right of the parent node.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Algorithms.IDataProvider" /> can be registered with the graph with key <see cref="F:yWorks.Layout.Tree.LeftRightNodePlacer.LeftRightDpKey" />. It calculates the side with respect to the initial coordinates of the nodes in the graph, considering the orientation of the subtree.</para>
        <para>If a node is assigned to the left side, this <see cref="T:yWorks.Algorithms.IDataProvider" /> will return <c>true</c>. For the right side, it will return <c>false</c>.</para>
      </remarks>
      <param name="nodePlacerMap">
        <para>a <see cref="T:yWorks.Algorithms.IDataProvider" /> containing the corresponding <see cref="T:yWorks.Layout.Tree.INodePlacer" />s for the node</para>
      </param>
    </member>
    <member name="T:yWorks.Layout.Tree.MultiParentDescriptor">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.MultiParentDescriptor" /> provides style information for multi-parent structures.</para>
      </summary>
      <remarks>
        <para>This class is used by <see cref="T:yWorks.Layout.Tree.TreeLayout" /> to determine the desired layout of nodes that constitute a multi-parent structure. All nodes of such a structure are placed side by side and the incident edges are routed over common points for incoming edges and for outgoing edges.</para>
        <para />
        <para>A tree graph containing multi-parent structures</para>
      </remarks>
      <seealso cref="F:yWorks.Layout.Tree.TreeLayout.MultiParentDescriptorDpKey" />
    </member>
    <member name="M:yWorks.Layout.Tree.MultiParentDescriptor.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.MultiParentDescriptor" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Tree.MultiParentDescriptor.MinimumNodeDistance">
      <summary>
        <para>Gets or sets the minimum distance between two nodes belonging to the same multi-parent structure.</para>
      </summary>
      <remarks>
        <para>The distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given node distance is negative</para>
      </exception>
      <value>
        <para>the minimum distance between nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.MultiParentDescriptor.MinimumBusDistance">
      <summary>
        <para>Gets or sets the minimum distance between the nodes of a multi-parent structure and the bus connecting these nodes.</para>
      </summary>
      <remarks>
        <para>In case the edge style is not orthogonal, the bus only consists of a common point.</para>
        <para>The minimum distance needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given bus distance is negative</para>
      </exception>
      <value>
        <para>the minimum bus distance</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.MultiParentDescriptor.VerticalAlignment">
      <summary>
        <para>Gets or sets the relative vertical alignment of nodes belonging to the same multi-parent structure.</para>
      </summary>
      <remarks>
        <para>A value of <c>0</c> means that nodes are top-aligned; a value of <c>1</c> means that nodes are bottom-aligned; a value of <c>0.5</c> means that nodes are center-aligned.</para>
        <para>Values outside the interval <c>[0,1]</c> will result in a compact node placement with unaligned nodes, especially when labels are considered.</para>
      </remarks>
      <value>
        <para>the relative vertical alignment of multi-parent nodes</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.MultiParentDescriptor.EdgeStyle">
      <summary>
        <para>Gets or sets the routing style for edges that connect to nodes which constitute a multi-parent structure.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the given routing style is unknown</para>
      </exception>
      <value>
        <para>one of the predefined routing styles</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Tree.NodeOrderComparer">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.NodeOrderComparer" /> compares edges according to a specified order.</para>
      </summary>
      <remarks>
        <para>It obtains the order from a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Tree.NodeOrderComparer.NodeOrderComparableDpKey" />.</para>
        <para>Various tree layout algorithms can use this <see cref="T:System.Collections.Generic.IComparer`1" /> to influence the resulting layout. To achieve this, use this comparator and assign it to the comparator property of the layout algorithm classes.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Tree.ClassicTreeLayout.Comparer" />
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.DefaultOutEdgeComparer" />
      <seealso cref="F:yWorks.Layout.Tree.TreeLayout.OutEdgeComparerDpKey" />
      <seealso cref="P:yWorks.Layout.Tree.BalloonLayout.Comparer" />
      <seealso cref="P:yWorks.Layout.Tree.AspectRatioTreeLayout.Comparer" />
      <seealso cref="F:yWorks.Layout.Tree.NodeOrderComparer.NodeOrderComparableDpKey" />
    </member>
    <member name="F:yWorks.Layout.Tree.NodeOrderComparer.NodeOrderComparableDpKey">
      <summary>
        <para>A data provider key for registering an order for each node in the graph.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.NodeOrderComparer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.NodeOrderComparer" /> instance.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.NodeOrderComparer.Compare(System.Object,System.Object)">
      <summary>
        <para>Compares two edges according to their index in the order specified using a <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </summary>
      <remarks>
        <para>Target nodes for which the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with <see cref="F:yWorks.Layout.Tree.NodeOrderComparer.NodeOrderComparableDpKey" /> returns <c>null</c> or an <see cref="T:System.Object" /> that does not implement <see cref="T:System.IComparable" /> are treated as being smaller than other target nodes.</para>
      </remarks>
      <param name="edge1">
        <para>the first edge</para>
      </param>
      <param name="edge2">
        <para>the second edge</para>
      </param>
      <seealso cref="F:yWorks.Layout.Tree.NodeOrderComparer.NodeOrderComparableDpKey" />
    </member>
    <member name="T:yWorks.Layout.Tree.NodePlacerBase">
      <summary>
        <para>Abstract base class for implementations of the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> interface.</para>
      </summary>
      <remarks>
        <para>This class provides convenience methods for sub-tasks that are often used during the arrangement of a local root and its children. It also offers prepared implementations for the methods of the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> interface.</para>
        <para>Subclasses just need to override the following two abstract methods: <see cref="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" /> and <see cref="M:yWorks.Layout.Tree.NodePlacerBase.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.NodePlacerBase.graph">
      <summary>
        <para>The graph instance this class is working on.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.#ctor">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Tree.NodePlacerBase" />.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates an optional <see cref="T:yWorks.Layout.Tree.IProcessor" /> for pre- and post-processing.</para>
      </summary>
      <remarks>
        <para>This implementation returns <c>null</c>. Hence, no pre- or post-processing will be done.</para>
      </remarks>
      <param name="layouter">
        <para>the current <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the root node handled by this <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
      <returns>
        <para>
          <c>null</c>
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.GetSubtreeShape(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the subtree rooted at the given node.</para>
      </summary>
      <remarks>
        <para>This is a convenience method that retrieves a <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of a complete subtree from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
        <para>This method is used in <see cref="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" /> for retrieving the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s for the subtrees that are arranged. It may be overridden to return a custom implementation of <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />.</para>
      </remarks>
      <param name="node">
        <para>the local root node</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of the subtree rooted at the given local root node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.GetNodeShape(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the given node.</para>
      </summary>
      <remarks>
        <para>This is a convenience method that retrieves a <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for a single node from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
        <para>This method is used in <see cref="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" /> for retrieving the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s for the local root nodes. It may be overridden to return a custom implementation of <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the given node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Provides the direction of the connector to the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see> for each child node.</para>
      </summary>
      <remarks>
        <para>This implementation uses <see cref="M:yWorks.Layout.Tree.NodePlacerBase.DetermineChildConnector(yWorks.Algorithms.Node)" /> to retrieve the direction for the connectors.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="connectorMap">
        <para>the map that must be used for storing the direction specifiers of the child nodes</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node.</para>
      </summary>
      <remarks>
        <para>This method is used in <see cref="M:yWorks.Layout.Tree.NodePlacerBase.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)" /> and must be implemented by subclasses.</para>
      </remarks>
      <param name="child">
        <para>the child node</para>
      </param>
      <returns>
        <para>a direction specifier as defined in the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> interface</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Arranges the local root relative to the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of its children.</para>
      </summary>
      <remarks>
        <para>This is the main method that must be implemented by subclasses. It is called by <see cref="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction of the connector</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance that describes the shape of the whole subtree rooted at the given local root</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Initializes the local data structures and then delegates the work to the abstract variant of this method (<see cref="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />)</para>
      </summary>
      <param name="nodeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for obtaining an initial shape of the root node</para>
      </param>
      <param name="subtreeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for accessing the pre-calculated shapes of the subtrees</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="localRoot">
        <para>the root of the subtree that should be arranged by this method</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the subtree rooted at the local root node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.NodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="M:yWorks.Layout.Tree.NodePlacerBase.Clone">
      <summary>
        <para>Returns a clone of this <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance.</para>
      </summary>
      <returns>
        <para>an exact copy of this <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.RotatableNodePlacerBase">
      <summary>
        <para>Abstract base class for <see cref="T:yWorks.Layout.Tree.INodePlacer" />s that support rotations of the subtrees.</para>
      </summary>
      <remarks>
        <para>The direction specified in this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /> (defined by a <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">transformation matrix</see>) rotates the subtree that is placed. This is the final direction of this subtree. Rotations are not accumulated.</para>
        <para>
          <see cref="T:yWorks.Layout.Tree.INodePlacer" />s of this type will only implement the default direction (i.e. top-to-bottom). The other directions are calculated using the specified modification <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix" />. The direction used by the implementing <see cref="T:yWorks.Layout.Tree.INodePlacer" />s is called the model direction while the actual direction in the graph is the real direction.</para>
        <para>Note that using rotatable <see cref="T:yWorks.Layout.Tree.INodePlacer" />s has some pitfalls. Calculations must be aware of the rotations. Especially operations on <see cref="T:yWorks.Algorithms.Geometry.BorderLine" />s should not be called directly (e.g. <see cref="M:yWorks.Algorithms.Geometry.BorderLine.MergeWithMin(yWorks.Algorithms.Geometry.BorderLine)" />, <see cref="M:yWorks.Algorithms.Geometry.BorderLine.MergeWithMax(yWorks.Algorithms.Geometry.BorderLine)" />). The corresponding methods of <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /> already support the different directions.</para>
        <para>Subclasses just need to override the following two abstract methods: <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" /> and <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.graph">
      <summary>
        <para>The graph instance this <see cref="T:yWorks.Layout.Tree.INodePlacer" /> is working on.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.subtreeShapeProvider">
      <summary>
        <para>The provider of <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s for whole subtrees.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.nodeShapeProvider">
      <summary>
        <para>The provider of <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s for single nodes.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.createdChildren">
      <summary>
        <para>The list containing the created children.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Creates a new instance of <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /> whose direction is specified by the given modification matrix.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix for the <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.CreateProcessor(yWorks.Layout.Tree.TreeLayout,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node)">
      <summary>
        <para>Creates an optional <see cref="T:yWorks.Layout.Tree.IProcessor" /> for pre- and post-processing.</para>
      </summary>
      <remarks>
        <para>This implementation returns <c>null</c>. Hence, no pre- or post-processing is done.</para>
      </remarks>
      <param name="layouter">
        <para>the current <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="currentRoot">
        <para>the root node handled by this <see cref="T:yWorks.Layout.Tree.INodePlacer" /></para>
      </param>
      <returns>
        <para>
          <c>null</c>
        </para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.GetSourcePointAbs(yWorks.Algorithms.Edge)">
      <summary>
        <para>Returns the absolute source point of the given edge depending on the rotation of this <see cref="T:yWorks.Layout.Tree.INodePlacer" />.</para>
      </summary>
      <remarks>
        <para>This method translates the source point according to the rotation described by the <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">modification matrix</see>. It should be used instead of <see cref="M:yWorks.Layout.LayoutGraph.GetSourcePointAbs(yWorks.Algorithms.Edge)" />.</para>
        <para>It can be used in an implementation of <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />.</para>
      </remarks>
      <param name="edge">
        <para>the edge whose absolute source point should be calculated</para>
      </param>
      <returns>
        <para>the translated absolute source point for the given edge and current modification matrix</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Arranges the local root relative to the rotated subtree shapes of its children.</para>
      </summary>
      <remarks>
        <para>This is the main method that must be implemented by subclasses. For calculations and locations subclasses should use the corresponding methods of <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /> which already consider the <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">modification matrix</see>.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged subtree shape that contains the local root node and all its children</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.GetNodeShape(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the rotated subtree shape for the given node.</para>
      </summary>
      <remarks>
        <para>This is a convenience method that retrieves a rotated subtree shape for a single node from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" />. This shape may be modified and returned by <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />.</para>
      </remarks>
      <param name="node">
        <para>the node</para>
      </param>
      <returns>
        <para>the subtree shape for the given node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.GetSubtreeShape(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the rotated subtree shape for the subtree rooted at the given node.</para>
      </summary>
      <remarks>
        <para>This is a convenience method that retrieves a subtree shape of a complete subtree from the corresponding <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </remarks>
      <param name="node">
        <para>the local root node</para>
      </param>
      <returns>
        <para>the rotated subtree shape of the subtree rooted at the given local root node</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)">
      <summary>
        <para>Provides the direction of the connector to the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">SubtreeShape</see> for each child node.</para>
      </summary>
      <remarks>
        <para>This implementation uses <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.DetermineChildConnector(yWorks.Algorithms.Node)" /> and the <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">modification matrix</see> to retrieve the direction for the connectors.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root</para>
      </param>
      <param name="connectorMap">
        <para>the map that must be used for storing the direction specifiers of the child nodes</para>
      </param>
      <seealso cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.DetermineChildConnector(yWorks.Algorithms.Node)" />
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.GetPortConstraint(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the target <see cref="T:yWorks.Layout.PortConstraint" /> for the local root's incoming edge.</para>
      </summary>
      <remarks>
        <para>This method translates the <see cref="T:yWorks.Layout.PortConstraint" /> according to the rotation described by the <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">modification matrix</see>. It should be used instead of <see cref="M:yWorks.Layout.PortConstraint.GetTPC(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)" />.</para>
        <para>This method may be used in <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" /> to route the edges to the according port. It may be overridden to provide constant <see cref="T:yWorks.Layout.PortConstraint" />s for each node.</para>
      </remarks>
      <param name="localRoot">
        <para>the local root</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.PortConstraint" /> for the incoming edge of the local root or <see cref="F:yWorks.Layout.PortSide.Any" /> if no <see cref="T:yWorks.Layout.PortConstraint" /> is assigned for that edge</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.TranslateDirectionToReal(yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Translates the given model direction to the real direction in the resulting layout.</para>
      </summary>
      <remarks>
        <para>This method is used in <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)" /> to be able to return the real connector direction.</para>
      </remarks>
      <param name="modelDirection">
        <para>the model direction</para>
      </param>
      <returns>
        <para>the real direction</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if translation for the given model direction is not implemented</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.TranslateDirectionToModel(yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Translates the given real direction of the resulting layout to the model direction of this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" />.</para>
      </summary>
      <remarks>
        <para>This method is used in <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" /> to be able to retrieve the model direction for the connector</para>
      </remarks>
      <param name="realDirection">
        <para>the real direction</para>
      </param>
      <returns>
        <para>the model direction</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if translation for the given real direction is not implemented</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Determines a connector direction for the given child node.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.DetermineChildConnectors(yWorks.Algorithms.Node,yWorks.Algorithms.IDataMap)" /> and must be implemented by subclasses. Implementations can assume the default direction (top-to-bottom) for their arrangement.</para>
      </remarks>
      <param name="child">
        <para>the child node</para>
      </param>
      <returns>
        <para>a direction specifier as defined in the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> interface</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.IDataProvider,yWorks.Algorithms.IDataProvider,yWorks.Layout.LayoutGraph,yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Initializes the local data structures and then delegates the work to the abstract variant of this method (<see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />).</para>
      </summary>
      <param name="nodeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for obtaining an initial shape of the root node</para>
      </param>
      <param name="subtreeShapeProvider">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> for accessing the pre-calculated shapes of the subtrees</para>
      </param>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="localRoot">
        <para>the root of the subtree that should be arranged by this method</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the subtree rooted at the local root node</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)" />
    </member>
    <member name="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">
      <summary>
        <para>Gets the modification matrix that defines the direction of the subtree.</para>
      </summary>
      <value>
        <para>the modification matrix</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.CreateComparer">
      <summary>
        <para>Creates a <see cref="T:System.Collections.Generic.IComparer`1" /> for outgoing edges that takes the rotation into account.</para>
      </summary>
      <returns>
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> that considers the rotation</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.TranslatePoint(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix,yWorks.Algorithms.Geometry.YPoint)">
      <summary>
        <para>Translates a point from the real layout direction to the model direction using the given modification matrix.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the modification matrix to use for the translation</para>
      </param>
      <param name="realWorldPoint">
        <para>the point with coordinates from the real world</para>
      </param>
      <returns>
        <para>the translated point with coordinates from the model</para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Tree.RotatableNodePlacerBase.Spacing">
      <summary>
        <para>Gets or sets the spacing between subtrees.</para>
      </summary>
      <remarks>
        <para>The spacing needs to be non-negative.</para>
      </remarks>
      <exception cref="T:System.ArgumentException">
        <para>if the given spacing is negative</para>
      </exception>
      <value>
        <para>the distance between subtrees</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.CreateFromSketchComparer">
      <summary>
        <para>Delegates to <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.CreateComparer" />.</para>
      </summary>
      <returns>
        <para>the From Sketch <see cref="T:System.Collections.Generic.IComparer`1" /></para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.CreateComparer" />
    </member>
    <member name="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> describes how a local root node is arranged in relation to its children.</para>
      </summary>
      <remarks>
        <para>The actual placement depends on the orientation of the subtree rooted at the current local root node. All descriptions of the provided alignments refer to the top-to-bottom orientation described by <see cref="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.Default" />. In this case, the subtrees are placed below the local root and the local root is aligned horizontally above them.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.Center">
      <summary>
        <para>Horizontal <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> at the center of the subtrees.</para>
      </summary>
      <remarks>
        <para>The root node is placed centered above its whole subgraph. To determine the alignment, only <see cref="T:yWorks.Layout.INodeLayout" />s are considered. Node labels are not included although they are also contained in <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.Median">
      <summary>
        <para>Horizontal <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> at the median child node.</para>
      </summary>
      <remarks>
        <para>The root node is placed above the median of its children. To determine the alignment, only <see cref="T:yWorks.Layout.INodeLayout" />s are considered. Node labels are not included although they are also contained in <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.Leading">
      <summary>
        <para>Horizontal <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> left of the children.</para>
      </summary>
      <remarks>
        <para>The local root node leaves a distance specified by the given spacing to the leftmost child. To determine the alignment, only <see cref="T:yWorks.Layout.INodeLayout" />s are considered. Node labels are not included although they are also contained in <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.Trailing">
      <summary>
        <para>Horizontal <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> right of the children.</para>
      </summary>
      <remarks>
        <para>The root node leaves a distance specified by the given spacing to the rightmost child. To determine the alignment, only <see cref="T:yWorks.Layout.INodeLayout" />s are considered. Node labels are not included although they are also contained in <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.Left">
      <summary>
        <para>Horizontal <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> at the left side.</para>
      </summary>
      <remarks>
        <para>The root node is placed left aligned with its leftmost child. To determine the alignment, only <see cref="T:yWorks.Layout.INodeLayout" />s are considered. Node labels are not included although they are also contained in <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.Right">
      <summary>
        <para>Horizontal <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> at the right side.</para>
      </summary>
      <remarks>
        <para>The root node is placed right aligned with its rightmost child. To determine the alignment, only <see cref="T:yWorks.Layout.INodeLayout" />s are considered. Node labels are not included although they are also contained in <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.CenterOverChildren">
      <summary>
        <para>Horizontal alignment at the center of the children.</para>
      </summary>
      <remarks>
        <para>The root node is placed centered over its direct children. To determine the alignment, only <see cref="T:yWorks.Layout.INodeLayout" />s are considered. Node labels are not included although they are also contained in <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.All">
      <summary>
        <para>An array containing all supported <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" />s.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.PlaceParentHorizontal(yWorks.Layout.Tree.RotatedSubtreeShape,System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.Rectangle2D,System.Double)">
      <summary>
        <para>Moves the shape of the local root to a suitable position relative to the children's shapes.</para>
      </summary>
      <remarks>
        <para>The movement should only be done on the x-axis (horizontally).</para>
        <para>This method is called by <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" />s when they <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">place the subtrees</see>.</para>
      </remarks>
      <param name="rootShape">
        <para>the shape of the local root node that will be moved</para>
      </param>
      <param name="shapes">
        <para>a list of rotated subtree shapes, representing the shapes of the child nodes</para>
      </param>
      <param name="shapeBounds">
        <para>accumulated bounds of the shapes of all child nodes</para>
      </param>
      <param name="spacing">
        <para>the spacing value that should be used</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.GetBounds(System.Collections.Generic.IList{System.Object})">
      <summary>
        <para>Calculates the common bounds of the given subtree shapes.</para>
      </summary>
      <remarks>
        <para>This method can be used when placing the local root above its subtrees in method <see cref="M:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment.PlaceParentHorizontal(yWorks.Layout.Tree.RotatedSubtreeShape,System.Collections.Generic.IList{System.Object},yWorks.Algorithms.Geometry.Rectangle2D,System.Double)" />.</para>
      </remarks>
      <param name="shapes">
        <para>a list of rotated subtree shapes</para>
      </param>
      <returns>
        <para>the rectangle describing the bounds containing all given shapes</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix">
      <summary>
        <para>A matrix describes the rotation of the subtree handled by <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" />.</para>
      </summary>
      <remarks>
        <para>Subtrees may be rotated or mirrored. Also, matrices offering a combination of rotation and mirroring are provided.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.Default">
      <summary>
        <para>The identity matrix which does not apply any rotation or mirroring.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.Rot90">
      <summary>
        <para>A matrix which applies a counter-clockwise rotation by 90 degrees.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.Rot180">
      <summary>
        <para>A matrix which applies a rotation by 180 degrees.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.Rot270">
      <summary>
        <para>A matrix which applies a counter-clockwise rotation by 270 degrees.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.MirHor">
      <summary>
        <para>A matrix which applies a horizontal mirroring.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.MirVert">
      <summary>
        <para>A matrix which applies a vertical mirroring.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.MirHorRot90">
      <summary>
        <para>A matrix which applies a horizontal mirroring and a counter-clockwise rotation by 90 degrees.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.MirVertRot90">
      <summary>
        <para>A matrix which applies a vertical mirroring and a counter-clockwise rotation by 90 degrees.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.Multiply(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Multiplies this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix" /> with the given other <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix" />.</para>
      </summary>
      <param name="other">
        <para>the other matrix</para>
      </param>
      <returns>
        <para>the product of both matrices</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.ToString">
      <summary>
        <para>Returns a <see cref="T:System.String" /> representation of this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix" />.</para>
      </summary>
      <returns>
        <para>the <see cref="T:System.String" /> representing this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix" /></para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.EqualValues(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Compares the values of the current <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix" /> with the values of the given <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix" />.</para>
      </summary>
      <param name="other">
        <para>the matrix</para>
      </param>
      <returns>
        <para>
          <c>true</c> if this matrix and the given other matrix contain the same values, <c>false</c> otherwise</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.RotatedSubtreeShape">
      <summary>
        <para>Decorates a SubtreeShape and provides rotated access on it.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.RotatedSubtreeShape.#ctor">
      <summary>
        <para>For testing purposes only</para>
      </summary>
    </member>
    <member name="T:yWorks.Layout.Tree.SimpleNodePlacer">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.SimpleNodePlacer" /> arranges all children of a local root in a single row.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> </para>
      </remarks>
    </member>
    <member name="M:yWorks.Layout.Tree.SimpleNodePlacer.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.SimpleNodePlacer" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.SimpleNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.SimpleNodePlacer" /> instance that uses the given <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">modification matrix</see>.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix for this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /></para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.SimpleNodePlacer.#ctor(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix,yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.SimpleNodePlacer" /> instance that uses the given <see cref="P:yWorks.Layout.Tree.RotatableNodePlacerBase.ModificationMatrix">modification matrix</see> and <see cref="P:yWorks.Layout.Tree.SimpleNodePlacer.RootAlignment">root alignment</see>.</para>
      </summary>
      <param name="modificationMatrix">
        <para>the transformation matrix for this <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase" /></para>
      </param>
      <param name="rootAlignment">
        <para>the alignment for the local root in relation to its subtrees</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.SimpleNodePlacer.RootAlignment">
      <summary>
        <para>Gets or sets the <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment">RootAlignment</see> that defines how the root node is aligned with its children and their shapes.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Layout.Tree.RotatableNodePlacerBase.RootAlignment" /> instance specifying the location relative to the subtrees</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.SimpleNodePlacer.VerticalAlignment">
      <summary>
        <para>Gets or sets the relative vertical alignment of nodes with the same parent.</para>
      </summary>
      <remarks>
        <para>All values between <c>0</c> and <c>1</c> result in a valid alignment.</para>
        <list type="bullet">
          <item>
            <c>0</c> - nodes are top-aligned</item>
          <item>
            <c>0.5</c> - nodes are center-aligned</item>
          <item>
            <c>1</c> - nodes are bottom-aligned</item>
        </list>
        <para>Values outside the interval <c>[0,1]</c> may result in a more compact node placement with unaligned nodes, especially when labels are considered.</para>
      </remarks>
      <value>
        <para>the relative vertical alignment of nodes that have the same parent node</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.SimpleNodePlacer.DetermineChildConnector(yWorks.Algorithms.Node)">
      <summary>
        <para>Provides <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" /> as connector direction for the child nodes.</para>
      </summary>
      <param name="child">
        <para>the child node</para>
      </param>
      <returns>
        <para>
          <see cref="F:yWorks.Layout.Tree.ParentConnectorDirection.North" />
        </para>
      </returns>
    </member>
    <member name="P:yWorks.Layout.Tree.SimpleNodePlacer.CreateBus">
      <summary>
        <para>Gets or sets whether or not a bus is created in the space between the parent and its children.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the bus is created, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.SimpleNodePlacer.PlaceSubtree(yWorks.Algorithms.Node,yWorks.Layout.Tree.ParentConnectorDirection)">
      <summary>
        <para>Places the children of the local root node in a single row.</para>
      </summary>
      <param name="localRoot">
        <para>the local root node</para>
      </param>
      <param name="parentConnectorDirection">
        <para>the direction specifier for the connector of the local root node to its parent node</para>
      </param>
      <returns>
        <para>the merged subtree shape containing the local root node and all its children</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.TreeComponentLayout">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.TreeComponentLayout" /> arranges tree-like subgraph structures in a mixed layout style.</para>
      </summary>
      <remarks>
        <para />
        <para>The tree components are marked</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.TreeComponentLayout.DummyNodeDpKey">
      <summary>
        <para>A data provider key for identifying dummy nodes during the layout calculation.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Algorithms.IDataProvider" /> is registered and also removed in <see cref="M:yWorks.Layout.Tree.TreeComponentLayout.ApplyLayoutUsingDummies(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)" />.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Tree.TreeComponentLayout.ApplyLayoutUsingDummies(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeComponentLayout.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.TreeComponentLayout" /> instance using the specified layouter for arranging the subtrees.</para>
      </summary>
      <param name="treeCoreLayouter">
        <para>the layout algorithm used for arranging the tree components</para>
      </param>
      <exception cref="T:System.ArgumentException">
        <para>if the specified layout algorithm is <c>null</c></para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeComponentLayout.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Finds the tree components inside the given graph and applies a <see cref="P:yWorks.Layout.Tree.TreeComponentLayout.TreeComponentCoreLayout">tree layout</see> to them.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeComponentLayout.ApplyLayoutUsingDummies(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IDataProvider)">
      <summary>
        <para>Delegates the layout calculation to the <see cref="P:yWorks.Layout.Tree.TreeComponentLayout.CoreLayout">core layout algorithm</see> and handles the dummy nodes.</para>
      </summary>
      <remarks>
        <para>The dummy nodes are marked using the given <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
        <para>This implementation just registers the dummy node <see cref="T:yWorks.Algorithms.IDataProvider" /> with the graph with key <see cref="F:yWorks.Layout.Tree.TreeComponentLayout.DummyNodeDpKey" />, executes the core layout algorithm and finally removes the data provider again.</para>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.TreeComponentLayout.ApplyLayout(yWorks.Layout.LayoutGraph)" /> to invoke the core layout algorithm. It may be overridden to customize the handling of the dummy nodes.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="dummyDp">
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> which marks the dummy nodes</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeComponentLayout.TreeComponentCoreLayout">
      <summary>
        <para>Gets or sets the layout algorithm that is applied to tree components.</para>
      </summary>
      <value>
        <para>the layout algorithm for tree components</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeComponentLayout.OptimizeOrientation">
      <summary>
        <para>Gets or sets whether or not tree component arrangement is improved by changing the orientation of components.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the component arrangement is optimized, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Tree.TreeLayout">
      <summary>
        <para>This layout algorithm arranges graphs with a tree structure.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2> <see cref="T:yWorks.Layout.Tree.TreeLayout" /> provides multiple different arrangements of trees and subtrees. It is easy to customize the <see cref="F:yWorks.Layout.Tree.TreeLayout.OutEdgeComparerDpKey">order of edges</see>, the <see cref="F:yWorks.Layout.Tree.TreeLayout.PortAssignmentDpKey">port assignment</see> and the <see cref="F:yWorks.Layout.Tree.TreeLayout.NodePlacerDpKey">arrangement of the nodes</see> for each subtree.</para>
        <para>Tree layout algorithms are commonly applied to visualize relational data and produce diagrams of high quality that are able to reveal possible hierarchic properties of the graph. More precisely, they find applications in dataflow analysis, software engineering, bioinformatics and business administration.</para>
        <para> Example graph with a layout calculated by <see cref="T:yWorks.Layout.Tree.TreeLayout" /> using default settings  Tree layout using different <see cref="T:yWorks.Layout.Tree.INodePlacer" />s and rotations <h2>Concept</h2></para>
        <para>The layout algorithm starts from the leaves and continues with their parents, then with the parents of the parents and so on. When a node is processed, the algorithm will use the corresponding <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance to move its children (along with their subtrees) to a suitable position and to route the outgoing edges of this node. Then, the next local root node will be processed.</para>
        <para>To avoid moving all nodes several times and to know the area that the subtrees occupy, the layout algorithm uses <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s. These <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s are moved and merged during layout calculation.</para>
        <para>
          <h2>Features</h2>
        </para>
        <para>Each subtree can have a different style of node placement. <see cref="T:yWorks.Layout.Tree.INodePlacer" />s are responsible for arranging subtrees and their common root node. They can be specified separately for each local root with a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph using key <see cref="F:yWorks.Layout.Tree.TreeLayout.NodePlacerDpKey" />.</para>
        <para>A custom node can be defined as root of the tree using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Tree.TreeLayout.SelectedRootDpKey" />.</para>
        <para>The layout algorithm can be configured to reserve space for node labels and place the edge labels along edges such that the labels won't overlap with other graph elements. Edge labels are placed according to the information stored in a <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> instance. However, the placement along the edge will only affect the order of multiple labels at the same edge. The algorithm will always place the labels close to the target node.</para>
        <para>Grouping of nodes can also be handled by this layout algorithm. It is important that a group node contains a whole subtree. Otherwise, the group nodes may overlap with each other or with other nodes. Furthermore, the user may specify minimum size constraints for each group node using <see cref="T:yWorks.Algorithms.IDataProvider" /> key <see cref="F:yWorks.Layout.Grouping.GroupingKeys.MinimumNodeSizeDpKey" />.</para>
        <para>
          <see cref="T:yWorks.Layout.Tree.TreeLayout" /> supports custom sorting of the outgoing edges of a node. For example, a <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance that implements <see cref="T:yWorks.Layout.Tree.IFromSketchNodePlacer" /> provides a comparator that keeps the current order of siblings, allowing to extend the graph incrementally.</para>
        <para>This layout algorithm can only handle graphs with a tree structure. To apply it to a general graph, a <see cref="T:yWorks.Layout.Tree.TreeReductionStage" /> can be appended. This stage will temporarily remove some edges of the input graph until a tree is obtained. After the layout calculation, the stage will reinsert the edges that were removed and route them separately.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.TreeLayout.NodePlacerDpKey">
      <summary>
        <para>A data provider key for specifying a child node placer for each node.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.DefaultNodePlacer" />
    </member>
    <member name="F:yWorks.Layout.Tree.TreeLayout.PortAssignmentDpKey">
      <summary>
        <para>A data provider key for assigning ports to nodes.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.DefaultPortAssignment" />
    </member>
    <member name="F:yWorks.Layout.Tree.TreeLayout.OutEdgeComparerDpKey">
      <summary>
        <para>A data provider key for specifying the comparator for the outgoing edges.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.DefaultOutEdgeComparer" />
    </member>
    <member name="F:yWorks.Layout.Tree.TreeLayout.CriticalEdgeDpKey">
      <summary>
        <para>A data provider key for defining the priority of critical edges.</para>
      </summary>
      <remarks>
        <para>The layout algorithm tries to align each node pair that is connected by a critical edge (integer value &gt; <c>0</c>). This feature can, for example, be used for highlighting different edge paths that are important for a user. Conflicts between different critical edges are always resolved in favor of the higher priority.</para>
        <para>Critical edges will always align the centers of source and target node, thus replacing the current root alignment of the <see cref="T:yWorks.Layout.Tree.INodePlacer" />.</para>
        <para>The critical edge may not be straight if subtrees are rotated or port constraints are assigned.</para>
        <para>This feature is only supported by the following <see cref="T:yWorks.Layout.Tree.INodePlacer" />s:</para>
        <list type="bullet">
          <item>
            <see cref="T:yWorks.Layout.Tree.DefaultNodePlacer" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Tree.SimpleNodePlacer" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Tree.LayeredNodePlacer" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Tree.DoubleLineNodePlacer" />
          </item>
          <item>
            <see cref="T:yWorks.Layout.Tree.DendrogramNodePlacer" />
          </item>
        </list>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.TreeLayout.MultiParentDescriptorDpKey">
      <summary>
        <para>A data provider key for retrieving descriptors for nodes in multi-parent structures.</para>
      </summary>
      <remarks>
        <para>The returned descriptor affects the layout of the multi-parent structure.</para>
      </remarks>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.MultiParentAllowed" />
    </member>
    <member name="F:yWorks.Layout.Tree.TreeLayout.SelectedRootDpKey">
      <summary>
        <para>A data provider key for marking the node that will be used as root node of the tree.</para>
      </summary>
    </member>
    <member name="F:yWorks.Layout.Tree.TreeLayout.graph">
      <summary>
        <para>The input graph for which a layout is calculated.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.TreeLayout" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.GroupingSupported">
      <summary>
        <para>Gets or sets whether or not group nodes are handled by the layout algorithm.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if grouping is supported, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.ComponentLayoutEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for arranging the components of the graph is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage that arranges the graph components is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayoutEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ComponentLayout" />
      <seealso cref="T:yWorks.Layout.ComponentLayout" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.ParallelEdgeRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing parallel edges is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing parallel edges is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.ParallelEdgeRouter" />
      <seealso cref="T:yWorks.Layout.ParallelEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SelfLoopRouterEnabled">
      <summary>
        <para>Sets whether or not the <see cref="T:yWorks.Layout.ILayoutStage" /> used for routing self-loops is activated.</para>
      </summary>
      <value>
        <para>
          <c>true</c> if the stage responsible for routing self-loops is activated, <c>false</c> otherwise</para>
      </value>
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouterEnabled" />
      <seealso cref="P:yWorks.Layout.MultiStageLayout.SelfLoopRouter" />
      <seealso cref="T:yWorks.Layout.SelfLoopRouter" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.ApplyLayoutCore(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Arranges the given graph as a tree.</para>
      </summary>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.GetSubtreeShape(yWorks.Algorithms.Node)">
      <summary>
        <para>Provides access to the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the given node.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> contains information about the current extent and location of the subtree rooted at the node. It should only be modified during the layout of the parent node. Also, it won't be initialized before the layout of the corresponding subtree is calculated.</para>
        <para>This method updates the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> in <see cref="M:yWorks.Layout.Tree.TreeLayout.LayoutRoot(yWorks.Algorithms.Node)" />.</para>
      </remarks>
      <param name="localRoot">
        <para>the root of the subtree</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance if it has already been calculated, <c>null</c> otherwise</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.LayoutRoot(yWorks.Algorithms.Node)">
      <summary>
        <para>Calculates the layout for the given root node and its subtrees.</para>
      </summary>
      <remarks>
        <para>This method is invoked for each node in the tree exactly once. Thus, children are always handled before their parents. In this manner, the subtrees already have a layout and can be arranged with their parent.</para>
        <para>To retrieve the shapes of the subtrees of all children of the local root, this method uses <see cref="M:yWorks.Layout.Tree.TreeLayout.GetSubtreeShape(yWorks.Algorithms.Node)" />.</para>
        <para>The method may be overridden to add configuration code.</para>
      </remarks>
      <param name="localRoot">
        <para>the root of the subtree that whose layout is calculated</para>
      </param>
      <returns>
        <para>the combined <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of the local root node and all of its children and connecting edges</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.GetPortAssignment(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> instance that places the ports of the connecting edges of the given node.</para>
      </summary>
      <remarks>
        <para>The method may be overridden to return customized <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> instances. It is possible to return a shared instance for multiple different nodes because the instances are not used after subsequent calls to this method.</para>
        <para>The current implementation returns the <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> defined by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Tree.TreeLayout.OutEdgeComparerDpKey" />. It falls back to the default <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> if there is no specific <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> for the given node.</para>
      </remarks>
      <param name="localRoot">
        <para>the root of the local subtree</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> instance that assigns the ports of the edges at the given node</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.TreeLayout.PortAssignmentDpKey" />
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.DefaultPortAssignment" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.GetOutEdgeComparer(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the <see cref="T:System.Collections.Generic.IComparer`1" /> instance that will sort the outgoing edges connecting to the given node.</para>
      </summary>
      <remarks>
        <para>The <see cref="T:System.Collections.Generic.IComparer`1" /> can be <c>null</c> in case the initial edge order shall be used.</para>
        <para>The method may be overridden to return custom <see cref="T:System.Collections.Generic.IComparer`1" /> instances. It is possible to return a shared instance for multiple different nodes because the instances are not used after subsequent calls to this method.</para>
        <para>The current implementation returns the <see cref="T:System.Collections.Generic.IComparer`1" /> defined in the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Tree.TreeLayout.OutEdgeComparerDpKey" />. It falls back to the default <see cref="T:System.Collections.Generic.IComparer`1" /> if there is no specific <see cref="T:System.Collections.Generic.IComparer`1" /> for the given node.</para>
      </remarks>
      <param name="localRoot">
        <para>the root of the local subtree</para>
      </param>
      <returns>
        <para>the <see cref="T:System.Collections.Generic.IComparer`1" /> or <c>null</c> that sorts the outgoing edges of the given node</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.TreeLayout.OutEdgeComparerDpKey" />
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.DefaultOutEdgeComparer" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.GetNodePlacer(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance that is used for the placement of the local root node and the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s.</para>
      </summary>
      <remarks>
        <para>The method may be overridden to return custom <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instances. It is possible to return a shared instance for multiple different nodes because the instances are not used after subsequent calls to this method.</para>
        <para>The current implementation returns the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> defined by the <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.Tree.TreeLayout.NodePlacerDpKey" />. It falls back to the default <see cref="T:yWorks.Layout.Tree.INodePlacer" /> if there is no specific <see cref="T:yWorks.Layout.Tree.INodePlacer" /> for the given node.</para>
      </remarks>
      <param name="localRoot">
        <para>the root of the local subtree</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance that places the subtree below the given local root node</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.TreeLayout.NodePlacerDpKey" />
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.DefaultNodePlacer" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.CreateNodeShape(yWorks.Algorithms.Node)">
      <summary>
        <para>Creates a <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the given node that consists only of the bounds of this particular node.</para>
      </summary>
      <remarks>
        <para>It may also include node labels or <see cref="T:yWorks.Layout.NodeHalo" />s.</para>
        <para>This method may be overridden to return a custom <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> for the given node.</para>
      </remarks>
      <param name="node">
        <para>the given node</para>
      </param>
      <returns>
        <para>a <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.GetRootsArray(yWorks.Algorithms.Node)">
      <summary>
        <para>Returns an array of the nodes that will be laid out.</para>
      </summary>
      <remarks>
        <para>The given node will be considered as the root of the tree. The order of the elements ensures that no parent is processed before one of its successors.</para>
        <para>This method may be overridden to change the order in which the nodes (and their subtrees) are handled. However, it is important to keep the parents after the successors. Only siblings can change places.</para>
      </remarks>
      <param name="root">
        <para>the node to be considered as root of the tree</para>
      </param>
      <returns>
        <para>an array of nodes that will be laid out</para>
      </returns>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.DirectTree">
      <summary>
        <para>Returns a list of edges that need to be reversed in order to obtain a valid rooted and directed tree from the input graph.</para>
      </summary>
      <remarks>
        <para>The root node of the tree is either a node marked by a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with the graph with key <see cref="F:yWorks.Layout.Tree.TreeLayout.SelectedRootDpKey" /> or is defined according to <see cref="M:yWorks.Algorithms.Trees.GetRoot(yWorks.Algorithms.Graph)" />.</para>
        <para>This method is called initially to calculate a rooted tree from the input graph. It may be overridden to apply a custom algorithm that determines which edges need to be reversed.</para>
      </remarks>
      <returns>
        <para>a list of edges that need to be reversed</para>
      </returns>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.ReverseEdges(yWorks.Algorithms.EdgeList)" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SourcePortConstraintDataAcceptor">
      <summary>
        <para>Gets a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> that can overwrite the source <see cref="T:yWorks.Layout.PortConstraint">port contraint</see> temporarily used during the layout.</para>
      </summary>
      <remarks>
        <para>This method sets temporary source <see cref="T:yWorks.Layout.PortConstraint" />s, e.g., after edge reversal. It may be overridden to handle those <see cref="T:yWorks.Layout.PortConstraint" />s separately.</para>
      </remarks>
      <value>
        <para>a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> to associate source <see cref="T:yWorks.Layout.PortConstraint" />s with <see cref="T:yWorks.Algorithms.Edge" />s</para>
      </value>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourcePortConstraintDpKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.TargetPortConstraintDataAcceptor">
      <summary>
        <para>Gets a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> that can overwrite the target <see cref="T:yWorks.Layout.PortConstraint">port contraint</see> temporarily used during the layout.</para>
      </summary>
      <remarks>
        <para>This method sets temporary target <see cref="T:yWorks.Layout.PortConstraint" />s, e.g., after edge reversal. It may be overridden to handle those <see cref="T:yWorks.Layout.PortConstraint" />s separately.</para>
      </remarks>
      <value>
        <para>a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> to associate target <see cref="T:yWorks.Layout.PortConstraint" />s with <see cref="T:yWorks.Algorithms.Edge" />s</para>
      </value>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetPortConstraintDpKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SourceGroupDataAcceptor">
      <summary>
        <para>Gets a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> that can be used for temporarily overwriting the source group information used during the layout.</para>
      </summary>
      <remarks>
        <para>This method may be overridden to handle those edge groups separately.</para>
      </remarks>
      <value>
        <para>a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> to associate source edge groups with <see cref="T:yWorks.Algorithms.Edge" />s</para>
      </value>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.SourceGroupIdDpKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.TargetGroupDataAcceptor">
      <summary>
        <para>Gets a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> that can be used for temporarily overwriting the target group information used during the layout.</para>
      </summary>
      <remarks>
        <para>This method may be overridden to handle those edge groups separately.</para>
      </remarks>
      <value>
        <para>a <see cref="T:yWorks.Algorithms.IDataAcceptor" /> to associate target edge groups with <see cref="T:yWorks.Algorithms.Edge" />s</para>
      </value>
      <seealso cref="F:yWorks.Layout.PortConstraintKeys.TargetGroupIdDpKey" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.ReverseEdges(yWorks.Algorithms.EdgeList)">
      <summary>
        <para>Reverses the direction of given edges.</para>
      </summary>
      <remarks>
        <para>This method will be called initially after the <see cref="M:yWorks.Layout.Tree.TreeLayout.DirectTree" /> method and finally after the layout has been calculated. It may be overridden to additionally reverse data that depends on the direction of the edges.</para>
      </remarks>
      <param name="reversedEdges">
        <para>the edges that will be reversed</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.DefaultNodePlacer">
      <summary>
        <para>Gets or sets the default <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance that arranges all subtrees that do not have a specific <see cref="T:yWorks.Layout.Tree.INodePlacer" /> assigned using a <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the default <see cref="T:yWorks.Layout.Tree.INodePlacer" /> is set to <c>null</c></para>
      </exception>
      <value>
        <para>the default <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance</para>
      </value>
      <seealso cref="F:yWorks.Layout.Tree.TreeLayout.NodePlacerDpKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.DefaultLeafPlacer">
      <summary>
        <para>Gets or sets the default <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance that places the leaf nodes of the tree.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the default <see cref="T:yWorks.Layout.Tree.INodePlacer" /> is set to <c>null</c></para>
      </exception>
      <value>
        <para>the default <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instance</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.DefaultNodePlacer" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.DefaultPortAssignment">
      <summary>
        <para>Gets or sets the default <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> instance for all subtrees that do not have a specific <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> assigned using a <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </summary>
      <exception cref="T:System.ArgumentException">
        <para>if the default <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> is set to <c>null</c></para>
      </exception>
      <value>
        <para>the default <see cref="T:yWorks.Layout.Tree.IPortAssignment" /> instance</para>
      </value>
      <seealso cref="F:yWorks.Layout.Tree.TreeLayout.PortAssignmentDpKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.DefaultOutEdgeComparer">
      <summary>
        <para>Gets or sets the default <see cref="T:System.Collections.Generic.IComparer`1" /> instance that sorts the outgoing edges in all subtrees that do not have a specific <see cref="T:System.Collections.Generic.IComparer`1" /> assigned using a <see cref="T:yWorks.Algorithms.IDataProvider" />.</para>
      </summary>
      <value>
        <para>the new default instance or <c>null</c> if no specific sorting should be done</para>
      </value>
      <seealso cref="F:yWorks.Layout.Tree.TreeLayout.OutEdgeComparerDpKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.ConsiderNodeLabels">
      <summary>
        <para>Gets or sets whether or not the layout algorithm reserves space for node labels.</para>
      </summary>
      <remarks>
        <para>If this feature is enabled, the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> of the nodes will also hold the shapes of its labels.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if node labels are considered, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.IntegratedEdgeLabeling">
      <summary>
        <para>Gets or sets whether or not edge labels are placed by the layout algorithm.</para>
      </summary>
      <remarks>
        <para>If this is enabled, the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s of the subtrees are extended by the edge labels.</para>
        <para>The layout algorithm uses the information of <see cref="T:yWorks.Layout.PreferredPlacementDescriptor" /> for an edge label to determine the corresponding placement. However, edge labels are always placed at the target side of the edge. The placement along the edge only affects the order of the edge labels at the same edge.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if the layout algorithm places edge labels, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.MultiParentAllowed">
      <summary>
        <para>Gets or sets whether or not multi-parent structures are allowed for this tree layout.</para>
      </summary>
      <remarks>
        <para>If multi-parent structures are allowed, the directed input graph may contain structures of multiple nodes that share the same predecessors as well as the same successors. All nodes belonging to such a structure are placed side by side and the incident edges are routed in a bus-style manner.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if multi-parent structures are allowed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape">
      <summary>
        <para>A <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> represents the position and the borders of a subtree.</para>
      </summary>
      <remarks>
        <para>
          <see cref="T:yWorks.Layout.Tree.INodePlacer" />s will move <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s and use the borders to calculate distances between the subtrees. When two subtrees are placed in relation to their common root, their <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />s are merged to represent the new subtree.</para>
        <para>The borders on each side of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> are modeled with <see cref="T:yWorks.Algorithms.Geometry.BorderLine" />s. The resulting area includes the borders of each node and edge in the corresponding subtree. It can also contain the bounds of labels belonging to those nodes and edges.</para>
        <para>The <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> also describes a connector defining the location to which the edge from its parent is attached. It is possible to add some bends (target points) at the end of this edge and include them in the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" />. During layout calculation, the last target point is the connection point for the edge.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)" />
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorX" />
      <seealso cref="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorY" />
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddBoundsToShape(System.Double,System.Double,System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddTargetPoint(System.Double,System.Double)" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.CoreBounds">
      <summary>
        <para>Gets the bounds of the <see cref="T:yWorks.Layout.INodeLayout" /> of the root node of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <value>
        <para>the bounds of the root node</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.Bounds">
      <summary>
        <para>Gets the current bounds of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <value>
        <para>the bounds of the subtree</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorX">
      <summary>
        <para>Gets the current x-coordinate of the connection point to which the layout algorithm connects the ingoing edge.</para>
      </summary>
      <remarks>
        <para>The connection point can change when target points are added to the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </remarks>
      <value>
        <para>the x-coordinate of the connection point</para>
      </value>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddTargetPoint(System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AppendTargetPoints(yWorks.Layout.IEdgeLayout)" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorY">
      <summary>
        <para>Gets the current y-coordinate of the connection point to which the layout algorithm connects the ingoing edge.</para>
      </summary>
      <remarks>
        <para>The connection point can change when target points are added to the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </remarks>
      <value>
        <para>the y-coordinate of the connection point</para>
      </value>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddTargetPoint(System.Double,System.Double)" />
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AppendTargetPoints(yWorks.Layout.IEdgeLayout)" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.UpdateConnectorShape">
      <summary>
        <para>Adds the line segments of the connector to the bounds of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <remarks>
        <para>The line segments result from the target points.</para>
      </remarks>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddTargetPoint(System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddTargetPoint(System.Double,System.Double)">
      <summary>
        <para>Adds another point to the connector.</para>
      </summary>
      <remarks>
        <para>The points will appear as bend of the incoming edge. Points are added in reverse direction of the edge. Hence, the last target point is further away from the target node than the points before.</para>
      </remarks>
      <param name="x">
        <para>the current x-coordinate of the point</para>
      </param>
      <param name="y">
        <para>the current y-coordinate of the point</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddEdgeSegments(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)">
      <summary>
        <para>Adds all edge segments of the given edge to this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <remarks>
        <para>The border lines are updated.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
      <param name="edge">
        <para>the given edge</para>
      </param>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)" />
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddLineSegment(System.Double,System.Double,System.Double,System.Double)" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AppendTargetPoints(yWorks.Layout.IEdgeLayout)">
      <summary>
        <para>Appends all target points that have previously been added to this shape to the given <see cref="T:yWorks.Layout.IEdgeLayout" /> instance.</para>
      </summary>
      <remarks>
        <para>This method is used by <see cref="T:yWorks.Layout.Tree.INodePlacer" /> instances for the final edge paths.</para>
      </remarks>
      <param name="edgeLayout">
        <para>the <see cref="T:yWorks.Layout.IEdgeLayout" /> that will be modified</para>
      </param>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddTargetPoint(System.Double,System.Double)" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ConnectorDirection">
      <summary>
        <para>Gets the direction of the last connector segment.</para>
      </summary>
      <value>
        <para>one of <see cref="F:yWorks.Layout.Tree.ConnectorDirection.North" />,<see cref="F:yWorks.Layout.Tree.ConnectorDirection.East" />,<see cref="F:yWorks.Layout.Tree.ConnectorDirection.South" /> or <see cref="F:yWorks.Layout.Tree.ConnectorDirection.West" /></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddLineSegment(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Extends this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance by the given segment.</para>
      </summary>
      <remarks>
        <para>The border lines are updated with this segment.</para>
      </remarks>
      <param name="x1">
        <para>the x-coordinate of the first point of the segment</para>
      </param>
      <param name="y1">
        <para>the y-coordinate of the first point of the segment</para>
      </param>
      <param name="x2">
        <para>the x-coordinate of the second point of the segment</para>
      </param>
      <param name="y2">
        <para>the y-coordinate of the second point of the segment</para>
      </param>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)" />
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddEdgeSegments(yWorks.Layout.LayoutGraph,yWorks.Algorithms.Edge)" />
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.UpdateConnectorShape" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AddBoundsToShape(System.Double,System.Double,System.Double,System.Double)">
      <summary>
        <para>Extends this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance by the given rectangle.</para>
      </summary>
      <remarks>
        <para>The border lines are updated with this segment.</para>
      </remarks>
      <param name="x">
        <para>the x-coordinate of the upper-left corner of the rectangle</para>
      </param>
      <param name="y">
        <para>the y-coordinate of the upper-left corner of the rectangle</para>
      </param>
      <param name="width">
        <para>the width of the rectangle</para>
      </param>
      <param name="height">
        <para>the height of the rectangle</para>
      </param>
      <seealso cref="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.MergeWith(yWorks.Layout.Tree.TreeLayout.SubtreeShape)">
      <summary>
        <para>Merges the given <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance with this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <remarks>
        <para>The border lines are updated.</para>
      </remarks>
      <param name="other">
        <para>the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> to be merged with this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /></para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.MinX">
      <summary>
        <para>Gets the current minimum x-coordinate of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <value>
        <para>the minimum x-coordinate of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.MinY">
      <summary>
        <para>Gets the current minimum y-coordinate of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <value>
        <para>the minimum y-coordinate of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.MaxX">
      <summary>
        <para>Gets the current maximum x-coordinate of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <value>
        <para>the maximum x-coordinate of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /></para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.MaxY">
      <summary>
        <para>Gets the current maximum y-coordinate of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <value>
        <para>the maximum y-coordinate of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /></para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.GetBorderLine(System.Int32)">
      <summary>
        <para>Returns the <see cref="T:yWorks.Algorithms.Geometry.BorderLine" /> instance that describes the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> at the given side.</para>
      </summary>
      <param name="index">
        <para>one of the predefined borderline directions</para>
      </param>
      <returns>
        <para>the <see cref="T:yWorks.Algorithms.Geometry.BorderLine" /> instance for the given side</para>
      </returns>
      <exception cref="T:System.ArgumentException">
        <para>if the given index is invalid</para>
      </exception>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.Move(System.Double,System.Double)">
      <summary>
        <para>Moves this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance and its connector by the given offsets.</para>
      </summary>
      <remarks>
        <para>Border lines are updated.</para>
      </remarks>
      <param name="dx">
        <para>the delta x-offset by which this shape will be moved</para>
      </param>
      <param name="dy">
        <para>the delta y-offset by which this shape will be moved</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.OriginX">
      <summary>
        <para>Gets the current x-coordinate of the origin of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <remarks>
        <para>The origin is defined as the upper left corner of the <see cref="T:yWorks.Layout.INodeLayout" /> of the local root of this shape.</para>
      </remarks>
      <value>
        <para>the x-coordinate of the shape's origin</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeLayout.SubtreeShape.OriginY">
      <summary>
        <para>Gets the current y-coordinate of the origin of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <remarks>
        <para>The origin is defined as the upper left corner of the <see cref="T:yWorks.Layout.INodeLayout" /> of the local root of this shape.</para>
      </remarks>
      <value>
        <para>the y-coordinate of the shape's origin</para>
      </value>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.CreateCopy(yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Creates a clone of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance, modifying it using the provided modification matrix.</para>
      </summary>
      <param name="matrix">
        <para>the matrix that defines the modification for the new instance</para>
      </param>
      <returns>
        <para>the clone of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance</para>
      </returns>
      <seealso cref="F:yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix.Default" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.AssignValuesTo(yWorks.Layout.Tree.TreeLayout.SubtreeShape,yWorks.Layout.Tree.RotatableNodePlacerBase.Matrix)">
      <summary>
        <para>Copies the state of this <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance to the given shape applying a modification matrix.</para>
      </summary>
      <param name="toShape">
        <para>the given shape that gets the assigned values</para>
      </param>
      <param name="modificationMatrix">
        <para>the matrix that may add geometrical modifications</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeLayout.SubtreeShape.ToString">
      <summary>
        <para>Returns a string representation of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance.</para>
      </summary>
      <returns>
        <para>a string representation of the <see cref="T:yWorks.Layout.Tree.TreeLayout.SubtreeShape" /> instance</para>
      </returns>
    </member>
    <member name="T:yWorks.Layout.Tree.TreeReductionStage">
      <summary>
        <para>The <see cref="T:yWorks.Layout.Tree.TreeReductionStage" /> temporarily reduces general graphs to trees.</para>
      </summary>
      <remarks>
        <para>
          <h2>Layout Style</h2>
        </para>
        <para>This stage prepares a non-tree graph such that it can be processed by a tree layout algorithm.</para>
        <para />
        <para>The non-tree edges are marked</para>
        <para>Typical usage:</para>
        <code>TreeLayouter tl = new TreeLayout();
TreeReductionStage trs = new TreeReductionStage();
trs.NonTreeEdgeRouter = new OrganicEdgeRouter();
trs.NonTreeEdgeSelectionKey = OrganicEdgeRouter.RouteEdgeDpKey);
tl.PrependStage(trs);
graph.ApplyLayout(new BufferedLayout(tl));
tl.RemoveStage(trs);</code>
        <para>
          <h2>Concept</h2> This <see cref="T:yWorks.Layout.ILayoutStage" /> works in three steps:</para>
        <list type="number">
          <item>Remove some edges to get a tree or forest from the graph</item>
          <item>Invoke the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> which supports tree graph handling</item>
          <item>Reinsert all previously removed edges</item>
          <item>Optionally route these edges using the non-tree edge router and place their labels using the non-tree edge labeling algorithm.</item>
        </list>
        <para>
          <h2>Features</h2>
        </para>
        <para>The routing of the temporarily hidden non-tree edges can be customized by specifying an <see cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter">edge routing algorithm</see> for those edges. Similarly, the placement of edge labels of non-tree edges can be delegated to a custom <see cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeLabelingAlgorithm">edge labeling algorithm</see>. As default, both custom algorithms are not specified and, thus, non-tree edges are not routed and edge labels not placed.</para>
        <para>This stage is also able to handle multi-parent structures, i.e., structures of multiple nodes that share the same predecessors as well as the same successors. More precisely, if the specified <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> supports multi-parent structures (see <see cref="P:yWorks.Layout.Tree.TreeLayout.MultiParentAllowed" />) and option <see cref="P:yWorks.Layout.Tree.TreeReductionStage.MultiParentAllowed" /> is enabled, this stage does not hide such structures, i.e., the multi-parent structures are passed to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
        <para>Non-tree edges can also be bundled together such that their common parts are to some degree merged into a bundled part. The edge bundling can be specified by means of method <see cref="P:yWorks.Layout.Tree.TreeReductionStage.EdgeBundling" />.</para>
      </remarks>
    </member>
    <member name="F:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgesDpKey">
      <summary>
        <para>A data provider key for explicitly marking (some) edges that should not be considered for the tree.</para>
      </summary>
      <seealso cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeReductionStage.#ctor">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.TreeReductionStage" /> instance with default settings.</para>
      </summary>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeReductionStage.#ctor(yWorks.Layout.ILayoutAlgorithm)">
      <summary>
        <para>Creates a new <see cref="T:yWorks.Layout.Tree.TreeReductionStage" /> instance with the given core layout algorithm and default settings.</para>
      </summary>
      <param name="core">
        <para>the core layout algorithm</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeReductionStage.ApplyLayout(yWorks.Layout.LayoutGraph)">
      <summary>
        <para>Determines a spanning tree of the graph and passes it to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>.</para>
      </summary>
      <remarks>
        <para>This <see cref="T:yWorks.Layout.ILayoutStage" /> reduces the graph to a tree. Then, it applies the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> to that tree. After it gets the result, it reinserts the non-tree edges and routes them.</para>
      </remarks>
      <param name="graph">
        <para>the input graph</para>
      </param>
    </member>
    <member name="M:yWorks.Layout.Tree.TreeReductionStage.RouteNonTreeEdges(yWorks.Layout.LayoutGraph,yWorks.Algorithms.IEdgeMap)">
      <summary>
        <para>Routes all edges that do not belong to the chosen spanning tree.</para>
      </summary>
      <remarks>
        <para>This method is called by <see cref="M:yWorks.Layout.Tree.TreeReductionStage.ApplyLayout(yWorks.Layout.LayoutGraph)" /> after the tree was arranged by the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see>. It may be overridden to apply custom edge routes.</para>
      </remarks>
      <param name="graph">
        <para>the graph containing tree and non-tree edges</para>
      </param>
      <param name="nonTreeEdgeMap">
        <para>the <see cref="T:yWorks.Algorithms.IEdgeMap" /> that marks all non-tree edges in the graph</para>
      </param>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeReductionStage.MultiParentAllowed">
      <summary>
        <para>Gets or sets whether or not multi-parent structures (structures of multiple nodes that share the same predecessors as well as the same successors) are allowed.</para>
      </summary>
      <remarks>
        <para>More precisely, if this option is enabled and the specified <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout">core layout algorithm</see> can handle multi-parent structures (see <see cref="P:yWorks.Layout.Tree.TreeLayout.MultiParentAllowed" />), this stage does not hide such structures, but the multi-parent structures are passed on to the <see cref="P:yWorks.Layout.LayoutStageBase.CoreLayout" /> core layout algorithm}.</para>
      </remarks>
      <value>
        <para>
          <c>true</c> if multi-parent structures are allowed, <c>false</c> otherwise</para>
      </value>
    </member>
    <member name="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter">
      <summary>
        <para>Gets or sets the edge routing algorithm that is applied to all non-tree edges.</para>
      </summary>
      <value>
        <para>the edge routing algorithm used for non-tree edges</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeSelectionKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeSelectionKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> that will be used by the <see cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter">non-tree edge routing algorithm</see> to determine the edges that need to be routed.</para>
      </summary>
      <value>
        <para>the <see cref="T:yWorks.Algorithms.IDataProvider" /> key</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeLabelingAlgorithm">
      <summary>
        <para>Gets or sets the labeling algorithm that is applied to all edge labels that belong to non-tree edges.</para>
      </summary>
      <remarks>
        <para>It is required that a suitable <see cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeLabelSelectionKey">edge label selection key</see> is set. Otherwise, the edge labeling algorithm might also place labels of tree edges.</para>
      </remarks>
      <value>
        <para>the labeling algorithm used for edge labels of non-tree edges</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeLabelSelectionKey" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeLabelSelectionKey">
      <summary>
        <para>Gets or sets the key to register a <see cref="T:yWorks.Algorithms.IDataProvider" /> that is used by the <see cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeLabelingAlgorithm">non-tree edge labeling algorithm</see> to determine which edge labels it should place.</para>
      </summary>
      <value>
        <para>the non-tree edge label selection <see cref="T:yWorks.Algorithms.IDataProvider" /> key</para>
      </value>
      <seealso cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeLabelingAlgorithm" />
    </member>
    <member name="M:yWorks.Layout.Tree.TreeReductionStage.CreateStraightLineRouter">
      <summary>
        <para>Creates a routing algorithm that routes edges as a single straight segment.</para>
      </summary>
      <remarks>
        <para>The created instance can be used for <see cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter">routing non-tree edges</see>.</para>
      </remarks>
      <returns>
        <para>an edge routing algorithm that produces straight-line edges</para>
      </returns>
      <seealso cref="P:yWorks.Layout.Tree.TreeReductionStage.NonTreeEdgeRouter" />
    </member>
    <member name="P:yWorks.Layout.Tree.TreeReductionStage.EdgeBundling">
      <summary>
        <para>Gets the <see cref="T:yWorks.Layout.EdgeBundling" /> instance that defines the settings of the edge bundling feature.</para>
      </summary>
      <remarks>
        <para>The specified <see cref="T:yWorks.Layout.EdgeBundling" /> defines global bundling properties. Settings for individual edges can be defined by assigning an <see cref="T:yWorks.Layout.EdgeBundleDescriptor" /> to an edge using a <see cref="T:yWorks.Algorithms.IDataProvider" /> registered with key <see cref="F:yWorks.Layout.EdgeBundling.EdgeBundleDescriptorDpKey" />. To enable bundling for all non-tree edges, set a <see cref="P:yWorks.Layout.EdgeBundling.DefaultBundleDescriptor">default bundle descriptor</see> which has <see cref="P:yWorks.Layout.EdgeBundleDescriptor.Bundled">bundling</see> enabled.</para>
        <para>If the graph contains self-loops that belong to the set of non-tree edges, the stage will invoke the router defined for the non-tree edges in order to route them. In the case where this is not desired, the user has to hide them from the stage and route them afterwards as desired.</para>
      </remarks>
      <value>
        <para>the <see cref="T:yWorks.Layout.EdgeBundling" /> instance defining the edge bundling setup</para>
      </value>
    </member>
  </members>
</doc>